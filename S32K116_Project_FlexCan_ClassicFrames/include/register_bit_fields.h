/*
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * o Redistributions of source code must retain the above copyright notice, this list
 * of conditions and the following disclaimer.
 * o Redistributions in binary form must reproduce the above copyright notice, this
 * list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 * o Neither the name of Freescale Semiconductor, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * @file     S32K116.h
 * @brief    CMSIS HeaderFile
 * @version  1.6
 * @date     18. August 2020
 * @note     Generated by SVDConv V3.3.35 on Tuesday, 18.08.2020 14:23:19
 *           from File 'S32K116.svd',
 *           last modified on Thursday, 16.01.2020 17:09:20
 */

/*
 * Copyright (c) 2014 - 2016, Freescale Semiconductor, Inc.
 * Copyright (c) 2016 - 2018, NXP.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY NXP "AS IS" AND ANY EXPRESSED OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL NXP OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */


/** @addtogroup NXP
  * @{
  */


/** @addtogroup S32K116
  * @{
  */


#ifndef S32K116_H
#define S32K116_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M0+ Specific Interrupt Numbers  ======================================= */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* ==========================================  S32K116 Specific Interrupt Numbers  =========================================== */
  DMA0_IRQn                 =   0,              /*!< 0  DMA0                                                                   */
  DMA1_IRQn                 =   1,              /*!< 1  DMA1                                                                   */
  DMA2_IRQn                 =   2,              /*!< 2  DMA2                                                                   */
  DMA3_IRQn                 =   3,              /*!< 3  DMA3                                                                   */
  DMA_Error_IRQn            =   4,              /*!< 4  DMA_Error                                                              */
  ERM_fault_IRQn            =   5,              /*!< 5  ERM_fault                                                              */
  RTC_IRQn                  =   6,              /*!< 6  RTC                                                                    */
  RTC_Seconds_IRQn          =   7,              /*!< 7  RTC_Seconds                                                            */
  LPTMR0_IRQn               =   8,              /*!< 8  LPTMR0                                                                 */
  PORT_IRQn                 =   9,              /*!< 9  PORT                                                                   */
  CAN0_ORed_Err_Wakeup_IRQn =  10,              /*!< 10 CAN0_ORed_Err_Wakeup                                                   */
  CAN0_ORed_0_31_MB_IRQn    =  11,              /*!< 11 CAN0_ORed_0_31_MB                                                      */
  FTM0_Ch0_7_IRQn           =  12,              /*!< 12 FTM0_Ch0_7                                                             */
  FTM0_Fault_IRQn           =  13,              /*!< 13 FTM0_Fault                                                             */
  FTM0_Ovf_Reload_IRQn      =  14,              /*!< 14 FTM0_Ovf_Reload                                                        */
  FTM1_Ch0_7_IRQn           =  15,              /*!< 15 FTM1_Ch0_7                                                             */
  FTM1_Fault_IRQn           =  16,              /*!< 16 FTM1_Fault                                                             */
  FTM1_Ovf_Reload_IRQn      =  17,              /*!< 17 FTM1_Ovf_Reload                                                        */
  FTFC_IRQn                 =  18,              /*!< 18 FTFC                                                                   */
  PDB0_IRQn                 =  19,              /*!< 19 PDB0                                                                   */
  LPIT0_IRQn                =  20,              /*!< 20 LPIT0                                                                  */
  SCG_CMU_LVD_LVWSCG_IRQn   =  21,              /*!< 21 SCG_CMU_LVD_LVWSCG                                                     */
  WDOG_IRQn                 =  22,              /*!< 22 WDOG                                                                   */
  RCM_IRQn                  =  23,              /*!< 23 RCM                                                                    */
  LPI2C0_Master_Slave_IRQn  =  24,              /*!< 24 LPI2C0_Master_Slave                                                    */
  FLEXIO_IRQn               =  25,              /*!< 25 FLEXIO                                                                 */
  LPSPI0_IRQn               =  26,              /*!< 26 LPSPI0                                                                 */
  ADC0_IRQn                 =  28,              /*!< 28 ADC0                                                                   */
  CMP0_IRQn                 =  29,              /*!< 29 CMP0                                                                   */
  LPUART1_RxTx_IRQn         =  30,              /*!< 30 LPUART1_RxTx                                                           */
  LPUART0_RxTx_IRQn         =  31               /*!< 31 LPUART0_RxTx                                                           */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ==========================  Configuration of the ARM Cortex-M0+ Processor and Core Peripherals  =========================== */
#define __CM0PLUS_REV                 0x0000U   /*!< CM0PLUS Core Revision                                                     */
#define __NVIC_PRIO_BITS               2        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __VTOR_PRESENT                 0        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __MPU_PRESENT                  1        /*!< MPU present                                                               */
#define __FPU_PRESENT                  1        /*!< FPU present                                                               */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "s32_core_cm0.h"                       /*!< ARM Cortex-M0+ processor and core peripherals                             */
#include "system_S32K116.h"                     /*!< S32K116 System                                                            */

#ifndef __IM                       /*!< Read-only register */
  #define __IM   volatile const
#endif
#ifndef __OM                       /*!< Output register */
  #define __OM   volatile
#endif
#ifndef __IOM                      /*!< Input and output register */
  #define __IOM  volatile
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                         CSE_PRAM                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CSE_PRAM (CSE_PRAM)
  */

typedef struct {                                /*!< (@ 0x14000800) CSE_PRAM Structure                                         */

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM0_CSE_PRAM;/*!< (@ 0x00000000) CSE PRAM 0 Register                                    */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM0_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM0LL_CSE_PRAM;/*!< (@ 0x00000000) CSE PRAM0LL register.                               */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM0LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM0LU;  /*!< (@ 0x00000001) CSE PRAM0LU register.                                      */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM0LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM0HL;  /*!< (@ 0x00000002) CSE PRAM0HL register.                                      */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM0HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM0HU;  /*!< (@ 0x00000003) CSE PRAM0HU register.                                      */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM0HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM1_CSE_PRAM;/*!< (@ 0x00000004) CSE PRAM 1 Register                                    */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM1_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM1LL_CSE_PRAM;/*!< (@ 0x00000004) CSE PRAM1LL register.                               */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM1LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM1LU;  /*!< (@ 0x00000005) CSE PRAM1LU register.                                      */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM1LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM1HL;  /*!< (@ 0x00000006) CSE PRAM1HL register.                                      */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM1HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM1HU;  /*!< (@ 0x00000007) CSE PRAM1HU register.                                      */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM1HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM2_CSE_PRAM;/*!< (@ 0x00000008) CSE PRAM 2 Register                                    */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM2_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM2LL_CSE_PRAM;/*!< (@ 0x00000008) CSE PRAM2LL register.                               */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM2LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM2LU;  /*!< (@ 0x00000009) CSE PRAM2LU register.                                      */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM2LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM2HL;  /*!< (@ 0x0000000A) CSE PRAM2HL register.                                      */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM2HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM2HU;  /*!< (@ 0x0000000B) CSE PRAM2HU register.                                      */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM2HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM3_CSE_PRAM;/*!< (@ 0x0000000C) CSE PRAM 3 Register                                    */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM3_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM3LL_CSE_PRAM;/*!< (@ 0x0000000C) CSE PRAM3LL register.                               */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM3LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM3LU;  /*!< (@ 0x0000000D) CSE PRAM3LU register.                                      */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM3LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM3HL;  /*!< (@ 0x0000000E) CSE PRAM3HL register.                                      */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM3HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM3HU;  /*!< (@ 0x0000000F) CSE PRAM3HU register.                                      */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM3HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM4_CSE_PRAM;/*!< (@ 0x00000010) CSE PRAM 4 Register                                    */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM4_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM4LL_CSE_PRAM;/*!< (@ 0x00000010) CSE PRAM4LL register.                               */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM4LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM4LU;  /*!< (@ 0x00000011) CSE PRAM4LU register.                                      */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM4LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM4HL;  /*!< (@ 0x00000012) CSE PRAM4HL register.                                      */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM4HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM4HU;  /*!< (@ 0x00000013) CSE PRAM4HU register.                                      */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM4HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM5_CSE_PRAM;/*!< (@ 0x00000014) CSE PRAM 5 Register                                    */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM5_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM5LL_CSE_PRAM;/*!< (@ 0x00000014) CSE PRAM5LL register.                               */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM5LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM5LU;  /*!< (@ 0x00000015) CSE PRAM5LU register.                                      */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM5LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM5HL;  /*!< (@ 0x00000016) CSE PRAM5HL register.                                      */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM5HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM5HU;  /*!< (@ 0x00000017) CSE PRAM5HU register.                                      */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM5HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM6_CSE_PRAM;/*!< (@ 0x00000018) CSE PRAM 6 Register                                    */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM6_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM6LL_CSE_PRAM;/*!< (@ 0x00000018) CSE PRAM6LL register.                               */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM6LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM6LU;  /*!< (@ 0x00000019) CSE PRAM6LU register.                                      */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM6LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM6HL;  /*!< (@ 0x0000001A) CSE PRAM6HL register.                                      */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM6HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM6HU;  /*!< (@ 0x0000001B) CSE PRAM6HU register.                                      */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM6HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM7_CSE_PRAM;/*!< (@ 0x0000001C) CSE PRAM 7 Register                                    */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM7_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM7LL_CSE_PRAM;/*!< (@ 0x0000001C) CSE PRAM7LL register.                               */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM7LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM7LU;  /*!< (@ 0x0000001D) CSE PRAM7LU register.                                      */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM7LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM7HL;  /*!< (@ 0x0000001E) CSE PRAM7HL register.                                      */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM7HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM7HU;  /*!< (@ 0x0000001F) CSE PRAM7HU register.                                      */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM7HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM8_CSE_PRAM;/*!< (@ 0x00000020) CSE PRAM 8 Register                                    */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM8_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM8LL_CSE_PRAM;/*!< (@ 0x00000020) CSE PRAM8LL register.                               */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM8LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM8LU;  /*!< (@ 0x00000021) CSE PRAM8LU register.                                      */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM8LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM8HL;  /*!< (@ 0x00000022) CSE PRAM8HL register.                                      */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM8HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM8HU;  /*!< (@ 0x00000023) CSE PRAM8HU register.                                      */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM8HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM9_CSE_PRAM;/*!< (@ 0x00000024) CSE PRAM 9 Register                                    */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM9_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM9LL_CSE_PRAM;/*!< (@ 0x00000024) CSE PRAM9LL register.                               */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM9LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM9LU;  /*!< (@ 0x00000025) CSE PRAM9LU register.                                      */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM9LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM9HL;  /*!< (@ 0x00000026) CSE PRAM9HL register.                                      */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM9HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM9HU;  /*!< (@ 0x00000027) CSE PRAM9HU register.                                      */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM9HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM10_CSE_PRAM;/*!< (@ 0x00000028) CSE PRAM 10 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM10_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM10LL_CSE_PRAM;/*!< (@ 0x00000028) CSE PRAM10LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM10LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM10LU; /*!< (@ 0x00000029) CSE PRAM10LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM10LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM10HL; /*!< (@ 0x0000002A) CSE PRAM10HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM10HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM10HU; /*!< (@ 0x0000002B) CSE PRAM10HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM10HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM11_CSE_PRAM;/*!< (@ 0x0000002C) CSE PRAM 11 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM11_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM11LL_CSE_PRAM;/*!< (@ 0x0000002C) CSE PRAM11LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM11LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM11LU; /*!< (@ 0x0000002D) CSE PRAM11LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM11LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM11HL; /*!< (@ 0x0000002E) CSE PRAM11HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM11HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM11HU; /*!< (@ 0x0000002F) CSE PRAM11HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM11HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM12_CSE_PRAM;/*!< (@ 0x00000030) CSE PRAM 12 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM12_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM12LL_CSE_PRAM;/*!< (@ 0x00000030) CSE PRAM12LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM12LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM12LU; /*!< (@ 0x00000031) CSE PRAM12LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM12LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM12HL; /*!< (@ 0x00000032) CSE PRAM12HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM12HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM12HU; /*!< (@ 0x00000033) CSE PRAM12HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM12HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM13_CSE_PRAM;/*!< (@ 0x00000034) CSE PRAM 13 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM13_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM13LL_CSE_PRAM;/*!< (@ 0x00000034) CSE PRAM13LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM13LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM13LU; /*!< (@ 0x00000035) CSE PRAM13LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM13LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM13HL; /*!< (@ 0x00000036) CSE PRAM13HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM13HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM13HU; /*!< (@ 0x00000037) CSE PRAM13HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM13HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM14_CSE_PRAM;/*!< (@ 0x00000038) CSE PRAM 14 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM14_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM14LL_CSE_PRAM;/*!< (@ 0x00000038) CSE PRAM14LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM14LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM14LU; /*!< (@ 0x00000039) CSE PRAM14LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM14LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM14HL; /*!< (@ 0x0000003A) CSE PRAM14HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM14HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM14HU; /*!< (@ 0x0000003B) CSE PRAM14HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM14HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM15_CSE_PRAM;/*!< (@ 0x0000003C) CSE PRAM 15 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM15_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM15LL_CSE_PRAM;/*!< (@ 0x0000003C) CSE PRAM15LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM15LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM15LU; /*!< (@ 0x0000003D) CSE PRAM15LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM15LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM15HL; /*!< (@ 0x0000003E) CSE PRAM15HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM15HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM15HU; /*!< (@ 0x0000003F) CSE PRAM15HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM15HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM16_CSE_PRAM;/*!< (@ 0x00000040) CSE PRAM 16 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM16_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM16LL_CSE_PRAM;/*!< (@ 0x00000040) CSE PRAM16LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM16LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM16LU; /*!< (@ 0x00000041) CSE PRAM16LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM16LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM16HL; /*!< (@ 0x00000042) CSE PRAM16HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM16HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM16HU; /*!< (@ 0x00000043) CSE PRAM16HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM16HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM17_CSE_PRAM;/*!< (@ 0x00000044) CSE PRAM 17 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM17_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM17LL_CSE_PRAM;/*!< (@ 0x00000044) CSE PRAM17LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM17LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM17LU; /*!< (@ 0x00000045) CSE PRAM17LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM17LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM17HL; /*!< (@ 0x00000046) CSE PRAM17HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM17HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM17HU; /*!< (@ 0x00000047) CSE PRAM17HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM17HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM18_CSE_PRAM;/*!< (@ 0x00000048) CSE PRAM 18 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM18_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM18LL_CSE_PRAM;/*!< (@ 0x00000048) CSE PRAM18LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM18LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM18LU; /*!< (@ 0x00000049) CSE PRAM18LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM18LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM18HL; /*!< (@ 0x0000004A) CSE PRAM18HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM18HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM18HU; /*!< (@ 0x0000004B) CSE PRAM18HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM18HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM19_CSE_PRAM;/*!< (@ 0x0000004C) CSE PRAM 19 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM19_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM19LL_CSE_PRAM;/*!< (@ 0x0000004C) CSE PRAM19LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM19LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM19LU; /*!< (@ 0x0000004D) CSE PRAM19LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM19LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM19HL; /*!< (@ 0x0000004E) CSE PRAM19HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM19HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM19HU; /*!< (@ 0x0000004F) CSE PRAM19HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM19HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM20_CSE_PRAM;/*!< (@ 0x00000050) CSE PRAM 20 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM20_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM20LL_CSE_PRAM;/*!< (@ 0x00000050) CSE PRAM20LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM20LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM20LU; /*!< (@ 0x00000051) CSE PRAM20LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM20LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM20HL; /*!< (@ 0x00000052) CSE PRAM20HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM20HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM20HU; /*!< (@ 0x00000053) CSE PRAM20HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM20HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM21_CSE_PRAM;/*!< (@ 0x00000054) CSE PRAM 21 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM21_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM21LL_CSE_PRAM;/*!< (@ 0x00000054) CSE PRAM21LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM21LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM21LU; /*!< (@ 0x00000055) CSE PRAM21LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM21LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM21HL; /*!< (@ 0x00000056) CSE PRAM21HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM21HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM21HU; /*!< (@ 0x00000057) CSE PRAM21HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM21HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM22_CSE_PRAM;/*!< (@ 0x00000058) CSE PRAM 22 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM22_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM22LL_CSE_PRAM;/*!< (@ 0x00000058) CSE PRAM22LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM22LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM22LU; /*!< (@ 0x00000059) CSE PRAM22LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM22LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM22HL; /*!< (@ 0x0000005A) CSE PRAM22HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM22HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM22HU; /*!< (@ 0x0000005B) CSE PRAM22HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM22HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM23_CSE_PRAM;/*!< (@ 0x0000005C) CSE PRAM 23 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM23_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM23LL_CSE_PRAM;/*!< (@ 0x0000005C) CSE PRAM23LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM23LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM23LU; /*!< (@ 0x0000005D) CSE PRAM23LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM23LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM23HL; /*!< (@ 0x0000005E) CSE PRAM23HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM23HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM23HU; /*!< (@ 0x0000005F) CSE PRAM23HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM23HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM24_CSE_PRAM;/*!< (@ 0x00000060) CSE PRAM 24 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM24_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM24LL_CSE_PRAM;/*!< (@ 0x00000060) CSE PRAM24LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM24LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM24LU; /*!< (@ 0x00000061) CSE PRAM24LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM24LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM24HL; /*!< (@ 0x00000062) CSE PRAM24HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM24HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM24HU; /*!< (@ 0x00000063) CSE PRAM24HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM24HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM25_CSE_PRAM;/*!< (@ 0x00000064) CSE PRAM 25 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM25_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM25LL_CSE_PRAM;/*!< (@ 0x00000064) CSE PRAM25LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM25LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM25LU; /*!< (@ 0x00000065) CSE PRAM25LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM25LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM25HL; /*!< (@ 0x00000066) CSE PRAM25HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM25HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM25HU; /*!< (@ 0x00000067) CSE PRAM25HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM25HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM26_CSE_PRAM;/*!< (@ 0x00000068) CSE PRAM 26 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM26_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM26LL_CSE_PRAM;/*!< (@ 0x00000068) CSE PRAM26LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM26LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM26LU; /*!< (@ 0x00000069) CSE PRAM26LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM26LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM26HL; /*!< (@ 0x0000006A) CSE PRAM26HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM26HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM26HU; /*!< (@ 0x0000006B) CSE PRAM26HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM26HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM27_CSE_PRAM;/*!< (@ 0x0000006C) CSE PRAM 27 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM27_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM27LL_CSE_PRAM;/*!< (@ 0x0000006C) CSE PRAM27LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM27LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM27LU; /*!< (@ 0x0000006D) CSE PRAM27LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM27LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM27HL; /*!< (@ 0x0000006E) CSE PRAM27HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM27HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM27HU; /*!< (@ 0x0000006F) CSE PRAM27HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM27HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM28_CSE_PRAM;/*!< (@ 0x00000070) CSE PRAM 28 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM28_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM28LL_CSE_PRAM;/*!< (@ 0x00000070) CSE PRAM28LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM28LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM28LU; /*!< (@ 0x00000071) CSE PRAM28LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM28LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM28HL; /*!< (@ 0x00000072) CSE PRAM28HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM28HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM28HU; /*!< (@ 0x00000073) CSE PRAM28HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM28HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM29_CSE_PRAM;/*!< (@ 0x00000074) CSE PRAM 29 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM29_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM29LL_CSE_PRAM;/*!< (@ 0x00000074) CSE PRAM29LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM29LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM29LU; /*!< (@ 0x00000075) CSE PRAM29LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM29LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM29HL; /*!< (@ 0x00000076) CSE PRAM29HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM29HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM29HU; /*!< (@ 0x00000077) CSE PRAM29HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM29HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM30_CSE_PRAM;/*!< (@ 0x00000078) CSE PRAM 30 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM30_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM30LL_CSE_PRAM;/*!< (@ 0x00000078) CSE PRAM30LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM30LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM30LU; /*!< (@ 0x00000079) CSE PRAM30LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM30LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM30HL; /*!< (@ 0x0000007A) CSE PRAM30HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM30HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM30HU; /*!< (@ 0x0000007B) CSE PRAM30HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM30HU_b;
      } ;
    };
  };

  union {
    union {
      __IOM uint32_t CSE_PRAM_EmbeddedRAM31_CSE_PRAM;/*!< (@ 0x0000007C) CSE PRAM 31 Register                                  */

      struct {
        __IOM uint32_t BYTE_3   : 8;            /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
        __IOM uint32_t BYTE_2   : 8;            /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
        __IOM uint32_t BYTE_1   : 8;            /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
        __IOM uint32_t BYTE_0   : 8;            /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
      } CSE_PRAM_EmbeddedRAM31_CSE_PRAM_b;
    } ;

    struct {
      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM31LL_CSE_PRAM;/*!< (@ 0x0000007C) CSE PRAM31LL register.                             */

        struct {
          __IOM uint8_t RAM_LL  : 8;            /*!< [7..0] RAM_LL stores the first 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM31LL_CSE_PRAM_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM31LU; /*!< (@ 0x0000007D) CSE PRAM31LU register.                                     */

        struct {
          __IOM uint8_t RAM_LU  : 8;            /*!< [7..0] RAM_LU stores the second 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM31LU_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM31HL; /*!< (@ 0x0000007E) CSE PRAM31HL register.                                     */

        struct {
          __IOM uint8_t RAM_HL  : 8;            /*!< [7..0] RAM_HL stores the third 8 bits of the 32 bit CRC                   */
        } CSE_PRAM_EmbeddedRAM31HL_b;
      } ;

      union {
        __IOM uint8_t CSE_PRAM_EmbeddedRAM31HU; /*!< (@ 0x0000007F) CSE PRAM31HU register.                                     */

        struct {
          __IOM uint8_t RAM_HU  : 8;            /*!< [7..0] RAM_HU stores the fourth 8 bits of the 32 bit CRC                  */
        } CSE_PRAM_EmbeddedRAM31HU_b;
      } ;
    };
  };
} CSE_PRAM_Type;                                /*!< Size = 128 (0x80)                                                         */



/* =========================================================================================================================== */
/* ================                                           AIPS                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AIPS-Lite Bridge (AIPS)
  */

typedef struct {                                /*!< (@ 0x40000000) AIPS Structure                                             */

  union {
    __IOM uint32_t AIPS_MPRA;                   /*!< (@ 0x00000000) Master Privilege Register A                                */

    struct {
            uint32_t            : 20;
      __IOM uint32_t MPL2       : 1;            /*!< [20..20] Master 2 Privilege Level                                         */
      __IOM uint32_t MTW2       : 1;            /*!< [21..21] Master 2 Trusted For Writes                                      */
      __IOM uint32_t MTR2       : 1;            /*!< [22..22] Master 2 Trusted For Read                                        */
            uint32_t            : 1;
      __IOM uint32_t MPL1       : 1;            /*!< [24..24] Master 1 Privilege Level                                         */
      __IOM uint32_t MTW1       : 1;            /*!< [25..25] Master 1 Trusted for Writes                                      */
      __IOM uint32_t MTR1       : 1;            /*!< [26..26] Master 1 Trusted for Read                                        */
            uint32_t            : 1;
      __IOM uint32_t MPL0       : 1;            /*!< [28..28] Master 0 Privilege Level                                         */
      __IOM uint32_t MTW0       : 1;            /*!< [29..29] Master 0 Trusted For Writes                                      */
      __IOM uint32_t MTR0       : 1;            /*!< [30..30] Master 0 Trusted For Read                                        */
            uint32_t            : 1;
    } AIPS_MPRA_b;
  } ;
  __IM  uint32_t  RESERVED[7];

  union {
    __IOM uint32_t AIPS_PACRA;                  /*!< (@ 0x00000020) Peripheral Access Control Register                         */

    struct {
            uint32_t            : 24;
      __IOM uint32_t TP1        : 1;            /*!< [24..24] Trusted Protect                                                  */
      __IOM uint32_t WP1        : 1;            /*!< [25..25] Write Protect                                                    */
      __IOM uint32_t SP1        : 1;            /*!< [26..26] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP0        : 1;            /*!< [28..28] Trusted Protect                                                  */
      __IOM uint32_t WP0        : 1;            /*!< [29..29] Write Protect                                                    */
      __IOM uint32_t SP0        : 1;            /*!< [30..30] Supervisor Protect                                               */
            uint32_t            : 1;
    } AIPS_PACRA_b;
  } ;

  union {
    __IOM uint32_t AIPS_PACRB;                  /*!< (@ 0x00000024) Peripheral Access Control Register                         */

    struct {
            uint32_t            : 8;
      __IOM uint32_t TP5        : 1;            /*!< [8..8] Trusted Protect                                                    */
      __IOM uint32_t WP5        : 1;            /*!< [9..9] Write Protect                                                      */
      __IOM uint32_t SP5        : 1;            /*!< [10..10] Supervisor Protect                                               */
            uint32_t            : 13;
      __IOM uint32_t TP1        : 1;            /*!< [24..24] Trusted Protect                                                  */
      __IOM uint32_t WP1        : 1;            /*!< [25..25] Write Protect                                                    */
      __IOM uint32_t SP1        : 1;            /*!< [26..26] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP0        : 1;            /*!< [28..28] Trusted Protect                                                  */
      __IOM uint32_t WP0        : 1;            /*!< [29..29] Write Protect                                                    */
      __IOM uint32_t SP0        : 1;            /*!< [30..30] Supervisor Protect                                               */
            uint32_t            : 1;
    } AIPS_PACRB_b;
  } ;
  __IM  uint32_t  AIPS_PACRC;                   /*!< (@ 0x00000028) Peripheral Access Control Register                         */

  union {
    __IOM uint32_t AIPS_PACRD;                  /*!< (@ 0x0000002C) Peripheral Access Control Register                         */

    struct {
            uint32_t            : 24;
      __IOM uint32_t TP1        : 1;            /*!< [24..24] Trusted Protect                                                  */
      __IOM uint32_t WP1        : 1;            /*!< [25..25] Write Protect                                                    */
      __IOM uint32_t SP1        : 1;            /*!< [26..26] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP0        : 1;            /*!< [28..28] Trusted Protect                                                  */
      __IOM uint32_t WP0        : 1;            /*!< [29..29] Write Protect                                                    */
      __IOM uint32_t SP0        : 1;            /*!< [30..30] Supervisor Protect                                               */
            uint32_t            : 1;
    } AIPS_PACRD_b;
  } ;
  __IM  uint32_t  RESERVED1[4];

  union {
    __IOM uint32_t AIPS_OPACRA;                 /*!< (@ 0x00000040) Off-Platform Peripheral Access Control Register            */

    struct {
      __IOM uint32_t TP7        : 1;            /*!< [0..0] Trusted Protect                                                    */
      __IOM uint32_t WP7        : 1;            /*!< [1..1] Write Protect                                                      */
      __IOM uint32_t SP7        : 1;            /*!< [2..2] Supervisor Protect                                                 */
            uint32_t            : 1;
      __IOM uint32_t TP6        : 1;            /*!< [4..4] Trusted Protect                                                    */
      __IOM uint32_t WP6        : 1;            /*!< [5..5] Write Protect                                                      */
      __IOM uint32_t SP6        : 1;            /*!< [6..6] Supervisor Protect                                                 */
            uint32_t            : 1;
      __IOM uint32_t TP5        : 1;            /*!< [8..8] Trusted Protect                                                    */
      __IOM uint32_t WP5        : 1;            /*!< [9..9] Write Protect                                                      */
      __IOM uint32_t SP5        : 1;            /*!< [10..10] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP4        : 1;            /*!< [12..12] Trusted Protect                                                  */
      __IOM uint32_t WP4        : 1;            /*!< [13..13] Write Protect                                                    */
      __IOM uint32_t SP4        : 1;            /*!< [14..14] Supervisor Protect                                               */
            uint32_t            : 9;
      __IOM uint32_t TP1        : 1;            /*!< [24..24] Trusted Protect                                                  */
      __IOM uint32_t WP1        : 1;            /*!< [25..25] Write Protect                                                    */
      __IOM uint32_t SP1        : 1;            /*!< [26..26] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP0        : 1;            /*!< [28..28] Trusted Protect                                                  */
      __IOM uint32_t WP0        : 1;            /*!< [29..29] Write Protect                                                    */
      __IOM uint32_t SP0        : 1;            /*!< [30..30] Supervisor Protect                                               */
            uint32_t            : 1;
    } AIPS_OPACRA_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRB;                 /*!< (@ 0x00000044) Off-Platform Peripheral Access Control Register            */

    struct {
            uint32_t            : 4;
      __IOM uint32_t TP6        : 1;            /*!< [4..4] Trusted Protect                                                    */
      __IOM uint32_t WP6        : 1;            /*!< [5..5] Write Protect                                                      */
      __IOM uint32_t SP6        : 1;            /*!< [6..6] Supervisor Protect                                                 */
            uint32_t            : 1;
      __IOM uint32_t TP5        : 1;            /*!< [8..8] Trusted Protect                                                    */
      __IOM uint32_t WP5        : 1;            /*!< [9..9] Write Protect                                                      */
      __IOM uint32_t SP5        : 1;            /*!< [10..10] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP4        : 1;            /*!< [12..12] Trusted Protect                                                  */
      __IOM uint32_t WP4        : 1;            /*!< [13..13] Write Protect                                                    */
      __IOM uint32_t SP4        : 1;            /*!< [14..14] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP3        : 1;            /*!< [16..16] Trusted Protect                                                  */
      __IOM uint32_t WP3        : 1;            /*!< [17..17] Write Protect                                                    */
      __IOM uint32_t SP3        : 1;            /*!< [18..18] Supervisor Protect                                               */
            uint32_t            : 13;
    } AIPS_OPACRB_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRC;                 /*!< (@ 0x00000048) Off-Platform Peripheral Access Control Register            */

    struct {
      __IOM uint32_t TP7        : 1;            /*!< [0..0] Trusted Protect                                                    */
      __IOM uint32_t WP7        : 1;            /*!< [1..1] Write Protect                                                      */
      __IOM uint32_t SP7        : 1;            /*!< [2..2] Supervisor Protect                                                 */
            uint32_t            : 1;
      __IOM uint32_t TP6        : 1;            /*!< [4..4] Trusted Protect                                                    */
      __IOM uint32_t WP6        : 1;            /*!< [5..5] Write Protect                                                      */
      __IOM uint32_t SP6        : 1;            /*!< [6..6] Supervisor Protect                                                 */
            uint32_t            : 13;
      __IOM uint32_t TP2        : 1;            /*!< [20..20] Trusted Protect                                                  */
      __IOM uint32_t WP2        : 1;            /*!< [21..21] Write Protect                                                    */
      __IOM uint32_t SP2        : 1;            /*!< [22..22] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP1        : 1;            /*!< [24..24] Trusted Protect                                                  */
      __IOM uint32_t WP1        : 1;            /*!< [25..25] Write Protect                                                    */
      __IOM uint32_t SP1        : 1;            /*!< [26..26] Supervisor Protect                                               */
            uint32_t            : 5;
    } AIPS_OPACRC_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRD;                 /*!< (@ 0x0000004C) Off-Platform Peripheral Access Control Register            */

    struct {
            uint32_t            : 8;
      __IOM uint32_t TP5        : 1;            /*!< [8..8] Trusted Protect                                                    */
      __IOM uint32_t WP5        : 1;            /*!< [9..9] Write Protect                                                      */
      __IOM uint32_t SP5        : 1;            /*!< [10..10] Supervisor Protect                                               */
            uint32_t            : 5;
      __IOM uint32_t TP3        : 1;            /*!< [16..16] Trusted Protect                                                  */
      __IOM uint32_t WP3        : 1;            /*!< [17..17] Write Protect                                                    */
      __IOM uint32_t SP3        : 1;            /*!< [18..18] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP2        : 1;            /*!< [20..20] Trusted Protect                                                  */
      __IOM uint32_t WP2        : 1;            /*!< [21..21] Write Protect                                                    */
      __IOM uint32_t SP2        : 1;            /*!< [22..22] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP1        : 1;            /*!< [24..24] Trusted Protect                                                  */
      __IOM uint32_t WP1        : 1;            /*!< [25..25] Write Protect                                                    */
      __IOM uint32_t SP1        : 1;            /*!< [26..26] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP0        : 1;            /*!< [28..28] Trusted Protect                                                  */
      __IOM uint32_t WP0        : 1;            /*!< [29..29] Write Protect                                                    */
      __IOM uint32_t SP0        : 1;            /*!< [30..30] Supervisor Protect                                               */
            uint32_t            : 1;
    } AIPS_OPACRD_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRE;                 /*!< (@ 0x00000050) Off-Platform Peripheral Access Control Register            */

    struct {
            uint32_t            : 4;
      __IOM uint32_t TP6        : 1;            /*!< [4..4] Trusted Protect                                                    */
      __IOM uint32_t WP6        : 1;            /*!< [5..5] Write Protect                                                      */
      __IOM uint32_t SP6        : 1;            /*!< [6..6] Supervisor Protect                                                 */
            uint32_t            : 21;
      __IOM uint32_t TP0        : 1;            /*!< [28..28] Trusted Protect                                                  */
      __IOM uint32_t WP0        : 1;            /*!< [29..29] Write Protect                                                    */
      __IOM uint32_t SP0        : 1;            /*!< [30..30] Supervisor Protect                                               */
            uint32_t            : 1;
    } AIPS_OPACRE_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRF;                 /*!< (@ 0x00000054) Off-Platform Peripheral Access Control Register            */

    struct {
            uint32_t            : 8;
      __IOM uint32_t TP5        : 1;            /*!< [8..8] Trusted Protect                                                    */
      __IOM uint32_t WP5        : 1;            /*!< [9..9] Write Protect                                                      */
      __IOM uint32_t SP5        : 1;            /*!< [10..10] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP4        : 1;            /*!< [12..12] Trusted Protect                                                  */
      __IOM uint32_t WP4        : 1;            /*!< [13..13] Write Protect                                                    */
      __IOM uint32_t SP4        : 1;            /*!< [14..14] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP3        : 1;            /*!< [16..16] Trusted Protect                                                  */
      __IOM uint32_t WP3        : 1;            /*!< [17..17] Write Protect                                                    */
      __IOM uint32_t SP3        : 1;            /*!< [18..18] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP2        : 1;            /*!< [20..20] Trusted Protect                                                  */
      __IOM uint32_t WP2        : 1;            /*!< [21..21] Write Protect                                                    */
      __IOM uint32_t SP2        : 1;            /*!< [22..22] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP1        : 1;            /*!< [24..24] Trusted Protect                                                  */
      __IOM uint32_t WP1        : 1;            /*!< [25..25] Write Protect                                                    */
      __IOM uint32_t SP1        : 1;            /*!< [26..26] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP0        : 1;            /*!< [28..28] Trusted Protect                                                  */
      __IOM uint32_t WP0        : 1;            /*!< [29..29] Write Protect                                                    */
      __IOM uint32_t SP0        : 1;            /*!< [30..30] Supervisor Protect                                               */
            uint32_t            : 1;
    } AIPS_OPACRF_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRG;                 /*!< (@ 0x00000058) Off-Platform Peripheral Access Control Register            */

    struct {
            uint32_t            : 20;
      __IOM uint32_t TP2        : 1;            /*!< [20..20] Trusted Protect                                                  */
      __IOM uint32_t WP2        : 1;            /*!< [21..21] Write Protect                                                    */
      __IOM uint32_t SP2        : 1;            /*!< [22..22] Supervisor Protect                                               */
            uint32_t            : 9;
    } AIPS_OPACRG_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRH;                 /*!< (@ 0x0000005C) Off-Platform Peripheral Access Control Register            */

    struct {
            uint32_t            : 20;
      __IOM uint32_t TP2        : 1;            /*!< [20..20] Trusted Protect                                                  */
      __IOM uint32_t WP2        : 1;            /*!< [21..21] Write Protect                                                    */
      __IOM uint32_t SP2        : 1;            /*!< [22..22] Supervisor Protect                                               */
            uint32_t            : 9;
    } AIPS_OPACRH_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRI;                 /*!< (@ 0x00000060) Off-Platform Peripheral Access Control Register            */

    struct {
            uint32_t            : 4;
      __IOM uint32_t TP6        : 1;            /*!< [4..4] Trusted Protect                                                    */
      __IOM uint32_t WP6        : 1;            /*!< [5..5] Write Protect                                                      */
      __IOM uint32_t SP6        : 1;            /*!< [6..6] Supervisor Protect                                                 */
            uint32_t            : 1;
      __IOM uint32_t TP5        : 1;            /*!< [8..8] Trusted Protect                                                    */
      __IOM uint32_t WP5        : 1;            /*!< [9..9] Write Protect                                                      */
      __IOM uint32_t SP5        : 1;            /*!< [10..10] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP4        : 1;            /*!< [12..12] Trusted Protect                                                  */
      __IOM uint32_t WP4        : 1;            /*!< [13..13] Write Protect                                                    */
      __IOM uint32_t SP4        : 1;            /*!< [14..14] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP3        : 1;            /*!< [16..16] Trusted Protect                                                  */
      __IOM uint32_t WP3        : 1;            /*!< [17..17] Write Protect                                                    */
      __IOM uint32_t SP3        : 1;            /*!< [18..18] Supervisor Protect                                               */
            uint32_t            : 5;
      __IOM uint32_t TP1        : 1;            /*!< [24..24] Trusted Protect                                                  */
      __IOM uint32_t WP1        : 1;            /*!< [25..25] Write Protect                                                    */
      __IOM uint32_t SP1        : 1;            /*!< [26..26] Supervisor Protect                                               */
            uint32_t            : 5;
    } AIPS_OPACRI_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRJ;                 /*!< (@ 0x00000064) Off-Platform Peripheral Access Control Register            */

    struct {
            uint32_t            : 12;
      __IOM uint32_t TP4        : 1;            /*!< [12..12] Trusted Protect                                                  */
      __IOM uint32_t WP4        : 1;            /*!< [13..13] Write Protect                                                    */
      __IOM uint32_t SP4        : 1;            /*!< [14..14] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP3        : 1;            /*!< [16..16] Trusted Protect                                                  */
      __IOM uint32_t WP3        : 1;            /*!< [17..17] Write Protect                                                    */
      __IOM uint32_t SP3        : 1;            /*!< [18..18] Supervisor Protect                                               */
            uint32_t            : 1;
      __IOM uint32_t TP2        : 1;            /*!< [20..20] Trusted Protect                                                  */
      __IOM uint32_t WP2        : 1;            /*!< [21..21] Write Protect                                                    */
      __IOM uint32_t SP2        : 1;            /*!< [22..22] Supervisor Protect                                               */
            uint32_t            : 9;
    } AIPS_OPACRJ_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRK;                 /*!< (@ 0x00000068) Off-Platform Peripheral Access Control Register            */

    struct {
            uint32_t            : 16;
      __IOM uint32_t TP3        : 1;            /*!< [16..16] Trusted Protect                                                  */
      __IOM uint32_t WP3        : 1;            /*!< [17..17] Write Protect                                                    */
      __IOM uint32_t SP3        : 1;            /*!< [18..18] Supervisor Protect                                               */
            uint32_t            : 13;
    } AIPS_OPACRK_b;
  } ;

  union {
    __IOM uint32_t AIPS_OPACRL;                 /*!< (@ 0x0000006C) Off-Platform Peripheral Access Control Register            */

    struct {
      __IOM uint32_t TP7        : 1;            /*!< [0..0] Trusted Protect                                                    */
      __IOM uint32_t WP7        : 1;            /*!< [1..1] Write Protect                                                      */
      __IOM uint32_t SP7        : 1;            /*!< [2..2] Supervisor Protect                                                 */
            uint32_t            : 1;
      __IOM uint32_t TP6        : 1;            /*!< [4..4] Trusted Protect                                                    */
      __IOM uint32_t WP6        : 1;            /*!< [5..5] Write Protect                                                      */
      __IOM uint32_t SP6        : 1;            /*!< [6..6] Supervisor Protect                                                 */
            uint32_t            : 1;
      __IOM uint32_t TP5        : 1;            /*!< [8..8] Trusted Protect                                                    */
      __IOM uint32_t WP5        : 1;            /*!< [9..9] Write Protect                                                      */
      __IOM uint32_t SP5        : 1;            /*!< [10..10] Supervisor Protect                                               */
            uint32_t            : 21;
    } AIPS_OPACRL_b;
  } ;
} AIPS_Type;                                    /*!< Size = 112 (0x70)                                                         */



/* =========================================================================================================================== */
/* ================                                           MSCM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief MSCM (MSCM)
  */

typedef struct {                                /*!< (@ 0x40001000) MSCM Structure                                             */

  union {
    __IM  uint32_t MSCM_CPxTYPE;                /*!< (@ 0x00000000) Processor X Type Register                                  */

    struct {
      __IM  uint32_t RYPZ       : 8;            /*!< [7..0] Processor x Revision                                               */
      __IM  uint32_t PERSONALITY : 24;          /*!< [31..8] Processor x Personality                                           */
    } MSCM_CPxTYPE_b;
  } ;

  union {
    __IM  uint32_t MSCM_CPxNUM;                 /*!< (@ 0x00000004) Processor X Number Register                                */

    struct {
      __IM  uint32_t CPN        : 1;            /*!< [0..0] Processor x Number                                                 */
            uint32_t            : 31;
    } MSCM_CPxNUM_b;
  } ;

  union {
    __IM  uint32_t MSCM_CPxMASTER;              /*!< (@ 0x00000008) Processor X Master Register                                */

    struct {
      __IM  uint32_t PPMN       : 6;            /*!< [5..0] Processor x Physical Master Number                                 */
            uint32_t            : 26;
    } MSCM_CPxMASTER_b;
  } ;

  union {
    __IM  uint32_t MSCM_CPxCOUNT;               /*!< (@ 0x0000000C) Processor X Count Register                                 */

    struct {
      __IM  uint32_t PCNT       : 2;            /*!< [1..0] Processor Count                                                    */
            uint32_t            : 30;
    } MSCM_CPxCOUNT_b;
  } ;

  union {
    __IM  uint32_t MSCM_CPxCFG0;                /*!< (@ 0x00000010) Processor X Configuration Register 0                       */

    struct {
      __IM  uint32_t DCWY       : 8;            /*!< [7..0] Level 1 Data Cache Ways                                            */
      __IM  uint32_t DCSZ       : 8;            /*!< [15..8] Level 1 Data Cache Size                                           */
      __IM  uint32_t ICWY       : 8;            /*!< [23..16] Level 1 Instruction Cache Ways                                   */
      __IM  uint32_t ICSZ       : 8;            /*!< [31..24] Level 1 Instruction Cache Size                                   */
    } MSCM_CPxCFG0_b;
  } ;

  union {
    __IM  uint32_t MSCM_CPxCFG1;                /*!< (@ 0x00000014) Processor X Configuration Register 1                       */

    struct {
            uint32_t            : 16;
      __IM  uint32_t L2WY       : 8;            /*!< [23..16] Level 2 Instruction Cache Ways                                   */
      __IM  uint32_t L2SZ       : 8;            /*!< [31..24] Level 2 Instruction Cache Size                                   */
    } MSCM_CPxCFG1_b;
  } ;

  union {
    __IM  uint32_t MSCM_CPxCFG2;                /*!< (@ 0x00000018) Processor X Configuration Register 2                       */

    struct {
            uint32_t            : 8;
      __IM  uint32_t TMUSZ      : 8;            /*!< [15..8] Tightly-coupled Memory Upper Size                                 */
            uint32_t            : 8;
      __IM  uint32_t TMLSZ      : 8;            /*!< [31..24] Tightly-coupled Memory Lower Size                                */
    } MSCM_CPxCFG2_b;
  } ;

  union {
    __IM  uint32_t MSCM_CPxCFG3;                /*!< (@ 0x0000001C) Processor X Configuration Register 3                       */

    struct {
      __IM  uint32_t FPU        : 1;            /*!< [0..0] Floating Point Unit                                                */
      __IM  uint32_t SIMD       : 1;            /*!< [1..1] SIMD/NEON instruction support                                      */
      __IM  uint32_t JAZ        : 1;            /*!< [2..2] Jazelle support                                                    */
      __IM  uint32_t MMU        : 1;            /*!< [3..3] Memory Management Unit                                             */
      __IM  uint32_t TZ         : 1;            /*!< [4..4] Trust Zone                                                         */
      __IM  uint32_t CMP        : 1;            /*!< [5..5] Core Memory Protection unit                                        */
      __IM  uint32_t BB         : 1;            /*!< [6..6] Bit Banding                                                        */
            uint32_t            : 1;
      __IM  uint32_t SBP        : 2;            /*!< [9..8] System Bus Ports                                                   */
            uint32_t            : 22;
    } MSCM_CPxCFG3_b;
  } ;

  union {
    __IM  uint32_t MSCM_CP0TYPE;                /*!< (@ 0x00000020) Processor 0 Type Register                                  */

    struct {
      __IM  uint32_t RYPZ       : 8;            /*!< [7..0] Processor 0 Revision                                               */
      __IM  uint32_t PERSONALITY : 24;          /*!< [31..8] Processor 0 Personality                                           */
    } MSCM_CP0TYPE_b;
  } ;

  union {
    __IM  uint32_t MSCM_CP0NUM;                 /*!< (@ 0x00000024) Processor 0 Number Register                                */

    struct {
      __IM  uint32_t CPN        : 1;            /*!< [0..0] Processor 0 Number                                                 */
            uint32_t            : 31;
    } MSCM_CP0NUM_b;
  } ;

  union {
    __IM  uint32_t MSCM_CP0MASTER;              /*!< (@ 0x00000028) Processor 0 Master Register                                */

    struct {
      __IM  uint32_t PPMN       : 6;            /*!< [5..0] Processor 0 Physical Master Number                                 */
            uint32_t            : 26;
    } MSCM_CP0MASTER_b;
  } ;

  union {
    __IM  uint32_t MSCM_CP0COUNT;               /*!< (@ 0x0000002C) Processor 0 Count Register                                 */

    struct {
      __IM  uint32_t PCNT       : 2;            /*!< [1..0] Processor Count                                                    */
            uint32_t            : 30;
    } MSCM_CP0COUNT_b;
  } ;

  union {
    __IM  uint32_t MSCM_CP0CFG0;                /*!< (@ 0x00000030) Processor 0 Configuration Register 0                       */

    struct {
      __IM  uint32_t DCWY       : 8;            /*!< [7..0] Level 1 Data Cache Ways                                            */
      __IM  uint32_t DCSZ       : 8;            /*!< [15..8] Level 1 Data Cache Size                                           */
      __IM  uint32_t ICWY       : 8;            /*!< [23..16] Level 1 Instruction Cache Ways                                   */
      __IM  uint32_t ICSZ       : 8;            /*!< [31..24] Level 1 Instruction Cache Size                                   */
    } MSCM_CP0CFG0_b;
  } ;

  union {
    __IM  uint32_t MSCM_CP0CFG1;                /*!< (@ 0x00000034) Processor 0 Configuration Register 1                       */

    struct {
            uint32_t            : 16;
      __IM  uint32_t L2WY       : 8;            /*!< [23..16] Level 2 Instruction Cache Ways                                   */
      __IM  uint32_t L2SZ       : 8;            /*!< [31..24] Level 2 Instruction Cache Size                                   */
    } MSCM_CP0CFG1_b;
  } ;

  union {
    __IM  uint32_t MSCM_CP0CFG2;                /*!< (@ 0x00000038) Processor 0 Configuration Register 2                       */

    struct {
            uint32_t            : 8;
      __IM  uint32_t TMUSZ      : 8;            /*!< [15..8] Tightly-coupled Memory Upper Size                                 */
            uint32_t            : 8;
      __IM  uint32_t TMLSZ      : 8;            /*!< [31..24] Tightly-coupled Memory Lower Size                                */
    } MSCM_CP0CFG2_b;
  } ;

  union {
    __IM  uint32_t MSCM_CP0CFG3;                /*!< (@ 0x0000003C) Processor 0 Configuration Register 3                       */

    struct {
      __IM  uint32_t FPU        : 1;            /*!< [0..0] Floating Point Unit                                                */
      __IM  uint32_t SIMD       : 1;            /*!< [1..1] SIMD/NEON instruction support                                      */
      __IM  uint32_t JAZ        : 1;            /*!< [2..2] Jazelle support                                                    */
      __IM  uint32_t MMU        : 1;            /*!< [3..3] Memory Management Unit                                             */
      __IM  uint32_t TZ         : 1;            /*!< [4..4] Trust Zone                                                         */
      __IM  uint32_t CMP        : 1;            /*!< [5..5] Core Memory Protection unit                                        */
      __IM  uint32_t BB         : 1;            /*!< [6..6] Bit Banding                                                        */
            uint32_t            : 1;
      __IM  uint32_t SBP        : 2;            /*!< [9..8] System Bus Ports                                                   */
            uint32_t            : 22;
    } MSCM_CP0CFG3_b;
  } ;
  __IM  uint32_t  RESERVED[240];

  union {
    __IOM uint32_t MSCM_OCMDR0;                 /*!< (@ 0x00000400) On-Chip Memory Descriptor Register                         */

    struct {
            uint32_t            : 4;
      __IOM uint32_t OCM1       : 2;            /*!< [5..4] OCMEM Control Field 1                                              */
            uint32_t            : 6;
      __IM  uint32_t OCMPU      : 1;            /*!< [12..12] OCMPU                                                            */
      __IM  uint32_t OCMT       : 3;            /*!< [15..13] OCMT                                                             */
      __IOM uint32_t RO         : 1;            /*!< [16..16] RO                                                               */
      __IM  uint32_t OCMW       : 3;            /*!< [19..17] OCMW                                                             */
            uint32_t            : 4;
      __IM  uint32_t OCMSZ      : 4;            /*!< [27..24] OCMSZ                                                            */
      __IM  uint32_t OCMSZH     : 1;            /*!< [28..28] OCMSZH                                                           */
            uint32_t            : 2;
      __IM  uint32_t V          : 1;            /*!< [31..31] V                                                                */
    } MSCM_OCMDR0_b;
  } ;

  union {
    __IOM uint32_t MSCM_OCMDR1;                 /*!< (@ 0x00000404) On-Chip Memory Descriptor Register                         */

    struct {
            uint32_t            : 4;
      __IOM uint32_t OCM1       : 2;            /*!< [5..4] OCMEM Control Field 1                                              */
            uint32_t            : 6;
      __IM  uint32_t OCMPU      : 1;            /*!< [12..12] OCMPU                                                            */
      __IM  uint32_t OCMT       : 3;            /*!< [15..13] OCMT                                                             */
      __IOM uint32_t RO         : 1;            /*!< [16..16] RO                                                               */
      __IM  uint32_t OCMW       : 3;            /*!< [19..17] OCMW                                                             */
            uint32_t            : 4;
      __IM  uint32_t OCMSZ      : 4;            /*!< [27..24] OCMSZ                                                            */
      __IM  uint32_t OCMSZH     : 1;            /*!< [28..28] OCMSZH                                                           */
            uint32_t            : 2;
      __IM  uint32_t V          : 1;            /*!< [31..31] V                                                                */
    } MSCM_OCMDR1_b;
  } ;

  union {
    __IOM uint32_t MSCM_OCMDR2;                 /*!< (@ 0x00000408) On-Chip Memory Descriptor Register                         */

    struct {
            uint32_t            : 12;
      __IM  uint32_t OCMPU      : 1;            /*!< [12..12] OCMPU                                                            */
      __IM  uint32_t OCMT       : 3;            /*!< [15..13] OCMT                                                             */
      __IOM uint32_t RO         : 1;            /*!< [16..16] RO                                                               */
      __IM  uint32_t OCMW       : 3;            /*!< [19..17] OCMW                                                             */
            uint32_t            : 4;
      __IM  uint32_t OCMSZ      : 4;            /*!< [27..24] OCMSZ                                                            */
      __IM  uint32_t OCMSZH     : 1;            /*!< [28..28] OCMSZH                                                           */
            uint32_t            : 2;
      __IM  uint32_t V          : 1;            /*!< [31..31] V                                                                */
    } MSCM_OCMDR2_b;
  } ;
} MSCM_Type;                                    /*!< Size = 1036 (0x40c)                                                       */



/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Enhanced Direct Memory Access (DMA)
  */

typedef struct {                                /*!< (@ 0x40008000) DMA Structure                                              */

  union {
    __IOM uint32_t DMA_CR;                      /*!< (@ 0x00000000) Control Register                                           */

    struct {
            uint32_t            : 1;
      __IOM uint32_t EDBG       : 1;            /*!< [1..1] Enable Debug                                                       */
      __IOM uint32_t ERCA       : 1;            /*!< [2..2] Enable Round Robin Channel Arbitration                             */
            uint32_t            : 1;
      __IOM uint32_t HOE        : 1;            /*!< [4..4] Halt On Error                                                      */
      __IOM uint32_t HALT       : 1;            /*!< [5..5] Halt DMA Operations                                                */
      __IOM uint32_t CLM        : 1;            /*!< [6..6] Continuous Link Mode                                               */
      __IOM uint32_t EMLM       : 1;            /*!< [7..7] Enable Minor Loop Mapping                                          */
            uint32_t            : 8;
      __IOM uint32_t ECX        : 1;            /*!< [16..16] Error Cancel Transfer                                            */
      __IOM uint32_t CX         : 1;            /*!< [17..17] Cancel Transfer                                                  */
            uint32_t            : 13;
      __IM  uint32_t ACTIVE     : 1;            /*!< [31..31] DMA Active Status                                                */
    } DMA_CR_b;
  } ;

  union {
    __IM  uint32_t DMA_ES;                      /*!< (@ 0x00000004) Error Status Register                                      */

    struct {
      __IM  uint32_t DBE        : 1;            /*!< [0..0] Destination Bus Error                                              */
      __IM  uint32_t SBE        : 1;            /*!< [1..1] Source Bus Error                                                   */
      __IM  uint32_t SGE        : 1;            /*!< [2..2] Scatter/Gather Configuration Error                                 */
      __IM  uint32_t NCE        : 1;            /*!< [3..3] NBYTES/CITER Configuration Error                                   */
      __IM  uint32_t DOE        : 1;            /*!< [4..4] Destination Offset Error                                           */
      __IM  uint32_t DAE        : 1;            /*!< [5..5] Destination Address Error                                          */
      __IM  uint32_t SOE        : 1;            /*!< [6..6] Source Offset Error                                                */
      __IM  uint32_t SAE        : 1;            /*!< [7..7] Source Address Error                                               */
      __IM  uint32_t ERRCHN     : 4;            /*!< [11..8] Error Channel Number or Canceled Channel Number                   */
            uint32_t            : 2;
      __IM  uint32_t CPE        : 1;            /*!< [14..14] Channel Priority Error                                           */
            uint32_t            : 1;
      __IM  uint32_t ECX        : 1;            /*!< [16..16] Transfer Canceled                                                */
            uint32_t            : 14;
      __IM  uint32_t VLD        : 1;            /*!< [31..31] VLD                                                              */
    } DMA_ES_b;
  } ;
  __IM  uint32_t  RESERVED;

  union {
    __IOM uint32_t DMA_ERQ;                     /*!< (@ 0x0000000C) Enable Request Register                                    */

    struct {
      __IOM uint32_t ERQ0       : 1;            /*!< [0..0] Enable DMA Request 0                                               */
      __IOM uint32_t ERQ1       : 1;            /*!< [1..1] Enable DMA Request 1                                               */
      __IOM uint32_t ERQ2       : 1;            /*!< [2..2] Enable DMA Request 2                                               */
      __IOM uint32_t ERQ3       : 1;            /*!< [3..3] Enable DMA Request 3                                               */
      __IOM uint32_t ERQ4       : 1;            /*!< [4..4] Enable DMA Request 4                                               */
      __IOM uint32_t ERQ5       : 1;            /*!< [5..5] Enable DMA Request 5                                               */
      __IOM uint32_t ERQ6       : 1;            /*!< [6..6] Enable DMA Request 6                                               */
      __IOM uint32_t ERQ7       : 1;            /*!< [7..7] Enable DMA Request 7                                               */
      __IOM uint32_t ERQ8       : 1;            /*!< [8..8] Enable DMA Request 8                                               */
      __IOM uint32_t ERQ9       : 1;            /*!< [9..9] Enable DMA Request 9                                               */
      __IOM uint32_t ERQ10      : 1;            /*!< [10..10] Enable DMA Request 10                                            */
      __IOM uint32_t ERQ11      : 1;            /*!< [11..11] Enable DMA Request 11                                            */
      __IOM uint32_t ERQ12      : 1;            /*!< [12..12] Enable DMA Request 12                                            */
      __IOM uint32_t ERQ13      : 1;            /*!< [13..13] Enable DMA Request 13                                            */
      __IOM uint32_t ERQ14      : 1;            /*!< [14..14] Enable DMA Request 14                                            */
      __IOM uint32_t ERQ15      : 1;            /*!< [15..15] Enable DMA Request 15                                            */
            uint32_t            : 16;
    } DMA_ERQ_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t DMA_EEI;                     /*!< (@ 0x00000014) Enable Error Interrupt Register                            */

    struct {
      __IOM uint32_t EEI0       : 1;            /*!< [0..0] Enable Error Interrupt 0                                           */
      __IOM uint32_t EEI1       : 1;            /*!< [1..1] Enable Error Interrupt 1                                           */
      __IOM uint32_t EEI2       : 1;            /*!< [2..2] Enable Error Interrupt 2                                           */
      __IOM uint32_t EEI3       : 1;            /*!< [3..3] Enable Error Interrupt 3                                           */
      __IOM uint32_t EEI4       : 1;            /*!< [4..4] Enable Error Interrupt 4                                           */
      __IOM uint32_t EEI5       : 1;            /*!< [5..5] Enable Error Interrupt 5                                           */
      __IOM uint32_t EEI6       : 1;            /*!< [6..6] Enable Error Interrupt 6                                           */
      __IOM uint32_t EEI7       : 1;            /*!< [7..7] Enable Error Interrupt 7                                           */
      __IOM uint32_t EEI8       : 1;            /*!< [8..8] Enable Error Interrupt 8                                           */
      __IOM uint32_t EEI9       : 1;            /*!< [9..9] Enable Error Interrupt 9                                           */
      __IOM uint32_t EEI10      : 1;            /*!< [10..10] Enable Error Interrupt 10                                        */
      __IOM uint32_t EEI11      : 1;            /*!< [11..11] Enable Error Interrupt 11                                        */
      __IOM uint32_t EEI12      : 1;            /*!< [12..12] Enable Error Interrupt 12                                        */
      __IOM uint32_t EEI13      : 1;            /*!< [13..13] Enable Error Interrupt 13                                        */
      __IOM uint32_t EEI14      : 1;            /*!< [14..14] Enable Error Interrupt 14                                        */
      __IOM uint32_t EEI15      : 1;            /*!< [15..15] Enable Error Interrupt 15                                        */
            uint32_t            : 16;
    } DMA_EEI_b;
  } ;

  union {
    __OM  uint8_t DMA_CEEI;                     /*!< (@ 0x00000018) Clear Enable Error Interrupt Register                      */

    struct {
      __OM  uint8_t CEEI        : 4;            /*!< [3..0] Clear Enable Error Interrupt                                       */
            uint8_t             : 2;
      __OM  uint8_t CAEE        : 1;            /*!< [6..6] Clear All Enable Error Interrupts                                  */
      __OM  uint8_t NOP         : 1;            /*!< [7..7] No Op enable                                                       */
    } DMA_CEEI_b;
  } ;

  union {
    __OM  uint8_t DMA_SEEI;                     /*!< (@ 0x00000019) Set Enable Error Interrupt Register                        */

    struct {
      __OM  uint8_t SEEI        : 4;            /*!< [3..0] Set Enable Error Interrupt                                         */
            uint8_t             : 2;
      __OM  uint8_t SAEE        : 1;            /*!< [6..6] Sets All Enable Error Interrupts                                   */
      __OM  uint8_t NOP         : 1;            /*!< [7..7] No Op enable                                                       */
    } DMA_SEEI_b;
  } ;

  union {
    __OM  uint8_t DMA_CERQ;                     /*!< (@ 0x0000001A) Clear Enable Request Register                              */

    struct {
      __OM  uint8_t CERQ        : 4;            /*!< [3..0] Clear Enable Request                                               */
            uint8_t             : 2;
      __OM  uint8_t CAER        : 1;            /*!< [6..6] Clear All Enable Requests                                          */
      __OM  uint8_t NOP         : 1;            /*!< [7..7] No Op enable                                                       */
    } DMA_CERQ_b;
  } ;

  union {
    __OM  uint8_t DMA_SERQ;                     /*!< (@ 0x0000001B) Set Enable Request Register                                */

    struct {
      __OM  uint8_t SERQ        : 4;            /*!< [3..0] Set Enable Request                                                 */
            uint8_t             : 2;
      __OM  uint8_t SAER        : 1;            /*!< [6..6] Set All Enable Requests                                            */
      __OM  uint8_t NOP         : 1;            /*!< [7..7] No Op enable                                                       */
    } DMA_SERQ_b;
  } ;

  union {
    __OM  uint8_t DMA_CDNE;                     /*!< (@ 0x0000001C) Clear DONE Status Bit Register                             */

    struct {
      __OM  uint8_t CDNE        : 4;            /*!< [3..0] Clear DONE Bit                                                     */
            uint8_t             : 2;
      __OM  uint8_t CADN        : 1;            /*!< [6..6] Clears All DONE Bits                                               */
      __OM  uint8_t NOP         : 1;            /*!< [7..7] No Op enable                                                       */
    } DMA_CDNE_b;
  } ;

  union {
    __OM  uint8_t DMA_SSRT;                     /*!< (@ 0x0000001D) Set START Bit Register                                     */

    struct {
      __OM  uint8_t SSRT        : 4;            /*!< [3..0] Set START Bit                                                      */
            uint8_t             : 2;
      __OM  uint8_t SAST        : 1;            /*!< [6..6] Set All START Bits (activates all channels)                        */
      __OM  uint8_t NOP         : 1;            /*!< [7..7] No Op enable                                                       */
    } DMA_SSRT_b;
  } ;

  union {
    __OM  uint8_t DMA_CERR;                     /*!< (@ 0x0000001E) Clear Error Register                                       */

    struct {
      __OM  uint8_t CERR        : 4;            /*!< [3..0] Clear Error Indicator                                              */
            uint8_t             : 2;
      __OM  uint8_t CAEI        : 1;            /*!< [6..6] Clear All Error Indicators                                         */
      __OM  uint8_t NOP         : 1;            /*!< [7..7] No Op enable                                                       */
    } DMA_CERR_b;
  } ;

  union {
    __OM  uint8_t DMA_CINT;                     /*!< (@ 0x0000001F) Clear Interrupt Request Register                           */

    struct {
      __OM  uint8_t CINT        : 4;            /*!< [3..0] Clear Interrupt Request                                            */
            uint8_t             : 2;
      __OM  uint8_t CAIR        : 1;            /*!< [6..6] Clear All Interrupt Requests                                       */
      __OM  uint8_t NOP         : 1;            /*!< [7..7] No Op enable                                                       */
    } DMA_CINT_b;
  } ;
  __IM  uint32_t  RESERVED2;

  union {
    __IOM uint32_t DMA_INT;                     /*!< (@ 0x00000024) Interrupt Request Register                                 */

    struct {
      __IOM uint32_t INT0       : 1;            /*!< [0..0] Interrupt Request 0                                                */
      __IOM uint32_t INT1       : 1;            /*!< [1..1] Interrupt Request 1                                                */
      __IOM uint32_t INT2       : 1;            /*!< [2..2] Interrupt Request 2                                                */
      __IOM uint32_t INT3       : 1;            /*!< [3..3] Interrupt Request 3                                                */
      __IOM uint32_t INT4       : 1;            /*!< [4..4] Interrupt Request 4                                                */
      __IOM uint32_t INT5       : 1;            /*!< [5..5] Interrupt Request 5                                                */
      __IOM uint32_t INT6       : 1;            /*!< [6..6] Interrupt Request 6                                                */
      __IOM uint32_t INT7       : 1;            /*!< [7..7] Interrupt Request 7                                                */
      __IOM uint32_t INT8       : 1;            /*!< [8..8] Interrupt Request 8                                                */
      __IOM uint32_t INT9       : 1;            /*!< [9..9] Interrupt Request 9                                                */
      __IOM uint32_t INT10      : 1;            /*!< [10..10] Interrupt Request 10                                             */
      __IOM uint32_t INT11      : 1;            /*!< [11..11] Interrupt Request 11                                             */
      __IOM uint32_t INT12      : 1;            /*!< [12..12] Interrupt Request 12                                             */
      __IOM uint32_t INT13      : 1;            /*!< [13..13] Interrupt Request 13                                             */
      __IOM uint32_t INT14      : 1;            /*!< [14..14] Interrupt Request 14                                             */
      __IOM uint32_t INT15      : 1;            /*!< [15..15] Interrupt Request 15                                             */
            uint32_t            : 16;
    } DMA_INT_b;
  } ;
  __IM  uint32_t  RESERVED3;

  union {
    __IOM uint32_t DMA_ERR;                     /*!< (@ 0x0000002C) Error Register                                             */

    struct {
      __IOM uint32_t ERR0       : 1;            /*!< [0..0] Error In Channel 0                                                 */
      __IOM uint32_t ERR1       : 1;            /*!< [1..1] Error In Channel 1                                                 */
      __IOM uint32_t ERR2       : 1;            /*!< [2..2] Error In Channel 2                                                 */
      __IOM uint32_t ERR3       : 1;            /*!< [3..3] Error In Channel 3                                                 */
      __IOM uint32_t ERR4       : 1;            /*!< [4..4] Error In Channel 4                                                 */
      __IOM uint32_t ERR5       : 1;            /*!< [5..5] Error In Channel 5                                                 */
      __IOM uint32_t ERR6       : 1;            /*!< [6..6] Error In Channel 6                                                 */
      __IOM uint32_t ERR7       : 1;            /*!< [7..7] Error In Channel 7                                                 */
      __IOM uint32_t ERR8       : 1;            /*!< [8..8] Error In Channel 8                                                 */
      __IOM uint32_t ERR9       : 1;            /*!< [9..9] Error In Channel 9                                                 */
      __IOM uint32_t ERR10      : 1;            /*!< [10..10] Error In Channel 10                                              */
      __IOM uint32_t ERR11      : 1;            /*!< [11..11] Error In Channel 11                                              */
      __IOM uint32_t ERR12      : 1;            /*!< [12..12] Error In Channel 12                                              */
      __IOM uint32_t ERR13      : 1;            /*!< [13..13] Error In Channel 13                                              */
      __IOM uint32_t ERR14      : 1;            /*!< [14..14] Error In Channel 14                                              */
      __IOM uint32_t ERR15      : 1;            /*!< [15..15] Error In Channel 15                                              */
            uint32_t            : 16;
    } DMA_ERR_b;
  } ;
  __IM  uint32_t  RESERVED4;

  union {
    __IM  uint32_t DMA_HRS;                     /*!< (@ 0x00000034) Hardware Request Status Register                           */

    struct {
      __IM  uint32_t HRS0       : 1;            /*!< [0..0] Hardware Request Status Channel 0                                  */
      __IM  uint32_t HRS1       : 1;            /*!< [1..1] Hardware Request Status Channel 1                                  */
      __IM  uint32_t HRS2       : 1;            /*!< [2..2] Hardware Request Status Channel 2                                  */
      __IM  uint32_t HRS3       : 1;            /*!< [3..3] Hardware Request Status Channel 3                                  */
      __IM  uint32_t HRS4       : 1;            /*!< [4..4] Hardware Request Status Channel 4                                  */
      __IM  uint32_t HRS5       : 1;            /*!< [5..5] Hardware Request Status Channel 5                                  */
      __IM  uint32_t HRS6       : 1;            /*!< [6..6] Hardware Request Status Channel 6                                  */
      __IM  uint32_t HRS7       : 1;            /*!< [7..7] Hardware Request Status Channel 7                                  */
      __IM  uint32_t HRS8       : 1;            /*!< [8..8] Hardware Request Status Channel 8                                  */
      __IM  uint32_t HRS9       : 1;            /*!< [9..9] Hardware Request Status Channel 9                                  */
      __IM  uint32_t HRS10      : 1;            /*!< [10..10] Hardware Request Status Channel 10                               */
      __IM  uint32_t HRS11      : 1;            /*!< [11..11] Hardware Request Status Channel 11                               */
      __IM  uint32_t HRS12      : 1;            /*!< [12..12] Hardware Request Status Channel 12                               */
      __IM  uint32_t HRS13      : 1;            /*!< [13..13] Hardware Request Status Channel 13                               */
      __IM  uint32_t HRS14      : 1;            /*!< [14..14] Hardware Request Status Channel 14                               */
      __IM  uint32_t HRS15      : 1;            /*!< [15..15] Hardware Request Status Channel 15                               */
            uint32_t            : 16;
    } DMA_HRS_b;
  } ;
  __IM  uint32_t  RESERVED5[3];

  union {
    __IOM uint32_t DMA_EARS;                    /*!< (@ 0x00000044) Enable Asynchronous Request in Stop Register               */

    struct {
      __IOM uint32_t EDREQ_0    : 1;            /*!< [0..0] Enable asynchronous DMA request in stop mode for channel
                                                     0.                                                                        */
      __IOM uint32_t EDREQ_1    : 1;            /*!< [1..1] Enable asynchronous DMA request in stop mode for channel
                                                     1.                                                                        */
      __IOM uint32_t EDREQ_2    : 1;            /*!< [2..2] Enable asynchronous DMA request in stop mode for channel
                                                     2.                                                                        */
      __IOM uint32_t EDREQ_3    : 1;            /*!< [3..3] Enable asynchronous DMA request in stop mode for channel
                                                     3.                                                                        */
      __IOM uint32_t EDREQ_4    : 1;            /*!< [4..4] Enable asynchronous DMA request in stop mode for channel
                                                     4                                                                         */
      __IOM uint32_t EDREQ_5    : 1;            /*!< [5..5] Enable asynchronous DMA request in stop mode for channel
                                                     5                                                                         */
      __IOM uint32_t EDREQ_6    : 1;            /*!< [6..6] Enable asynchronous DMA request in stop mode for channel
                                                     6                                                                         */
      __IOM uint32_t EDREQ_7    : 1;            /*!< [7..7] Enable asynchronous DMA request in stop mode for channel
                                                     7                                                                         */
      __IOM uint32_t EDREQ_8    : 1;            /*!< [8..8] Enable asynchronous DMA request in stop mode for channel
                                                     8                                                                         */
      __IOM uint32_t EDREQ_9    : 1;            /*!< [9..9] Enable asynchronous DMA request in stop mode for channel
                                                     9                                                                         */
      __IOM uint32_t EDREQ_10   : 1;            /*!< [10..10] Enable asynchronous DMA request in stop mode for channel
                                                     10                                                                        */
      __IOM uint32_t EDREQ_11   : 1;            /*!< [11..11] Enable asynchronous DMA request in stop mode for channel
                                                     11                                                                        */
      __IOM uint32_t EDREQ_12   : 1;            /*!< [12..12] Enable asynchronous DMA request in stop mode for channel
                                                     12                                                                        */
      __IOM uint32_t EDREQ_13   : 1;            /*!< [13..13] Enable asynchronous DMA request in stop mode for channel
                                                     13                                                                        */
      __IOM uint32_t EDREQ_14   : 1;            /*!< [14..14] Enable asynchronous DMA request in stop mode for channel
                                                     14                                                                        */
      __IOM uint32_t EDREQ_15   : 1;            /*!< [15..15] Enable asynchronous DMA request in stop mode for channel
                                                     15                                                                        */
            uint32_t            : 16;
    } DMA_EARS_b;
  } ;
  __IM  uint32_t  RESERVED6[46];

  union {
    __IOM uint8_t DMA_DCHPRI3;                  /*!< (@ 0x00000100) Channel n Priority Register                                */

    struct {
      __IOM uint8_t CHPRI       : 4;            /*!< [3..0] Channel n Arbitration Priority                                     */
            uint8_t             : 2;
      __IOM uint8_t DPA         : 1;            /*!< [6..6] Disable Preempt Ability. This field resets to 0.                   */
      __IOM uint8_t ECP         : 1;            /*!< [7..7] Enable Channel Preemption. This field resets to 0.                 */
    } DMA_DCHPRI3_b;
  } ;

  union {
    __IOM uint8_t DMA_DCHPRI2;                  /*!< (@ 0x00000101) Channel n Priority Register                                */

    struct {
      __IOM uint8_t CHPRI       : 4;            /*!< [3..0] Channel n Arbitration Priority                                     */
            uint8_t             : 2;
      __IOM uint8_t DPA         : 1;            /*!< [6..6] Disable Preempt Ability. This field resets to 0.                   */
      __IOM uint8_t ECP         : 1;            /*!< [7..7] Enable Channel Preemption. This field resets to 0.                 */
    } DMA_DCHPRI2_b;
  } ;

  union {
    __IOM uint8_t DMA_DCHPRI1;                  /*!< (@ 0x00000102) Channel n Priority Register                                */

    struct {
      __IOM uint8_t CHPRI       : 4;            /*!< [3..0] Channel n Arbitration Priority                                     */
            uint8_t             : 2;
      __IOM uint8_t DPA         : 1;            /*!< [6..6] Disable Preempt Ability. This field resets to 0.                   */
      __IOM uint8_t ECP         : 1;            /*!< [7..7] Enable Channel Preemption. This field resets to 0.                 */
    } DMA_DCHPRI1_b;
  } ;

  union {
    __IOM uint8_t DMA_DCHPRI0;                  /*!< (@ 0x00000103) Channel n Priority Register                                */

    struct {
      __IOM uint8_t CHPRI       : 4;            /*!< [3..0] Channel n Arbitration Priority                                     */
            uint8_t             : 2;
      __IOM uint8_t DPA         : 1;            /*!< [6..6] Disable Preempt Ability. This field resets to 0.                   */
      __IOM uint8_t ECP         : 1;            /*!< [7..7] Enable Channel Preemption. This field resets to 0.                 */
    } DMA_DCHPRI0_b;
  } ;
  __IM  uint32_t  RESERVED7[959];

  union {
    __IOM uint32_t DMA_TCD0_SADDR;              /*!< (@ 0x00001000) TCD Source Address                                         */

    struct {
      __IOM uint32_t SADDR      : 32;           /*!< [31..0] Source Address                                                    */
    } DMA_TCD0_SADDR_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD0_SOFF;               /*!< (@ 0x00001004) TCD Signed Source Address Offset                           */

    struct {
      __IOM uint16_t SOFF       : 16;           /*!< [15..0] Source address signed offset                                      */
    } DMA_TCD0_SOFF_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD0_ATTR;               /*!< (@ 0x00001006) TCD Transfer Attributes                                    */

    struct {
      __IOM uint16_t DSIZE      : 3;            /*!< [2..0] Destination data transfer size                                     */
      __IOM uint16_t DMOD       : 5;            /*!< [7..3] Destination Address Modulo                                         */
      __IOM uint16_t SSIZE      : 3;            /*!< [10..8] Source data transfer size                                         */
      __IOM uint16_t SMOD       : 5;            /*!< [15..11] Source Address Modulo                                            */
    } DMA_TCD0_ATTR_b;
  } ;

  union {
    union {
      __IOM uint32_t DMA_TCD0_NBYTES_MLNO_DMA;  /*!< (@ 0x00001008) TCD Minor Byte Count (Minor Loop Mapping Disabled)         */

      struct {
        __IOM uint32_t NBYTES   : 32;           /*!< [31..0] Minor Byte Transfer Count                                         */
      } DMA_TCD0_NBYTES_MLNO_DMA_b;
    } ;

    union {
      __IOM uint32_t DMA_TCD0_NBYTES_MLOFFNO_DMA;/*!< (@ 0x00001008) TCD Signed Minor Loop Offset (Minor Loop Mapping
                                                                    Enabled and Offset Disabled)                               */

      struct {
        __IOM uint32_t NBYTES   : 30;           /*!< [29..0] Minor Byte Transfer Count                                         */
        __IOM uint32_t DMLOE    : 1;            /*!< [30..30] Destination Minor Loop Offset enable                             */
        __IOM uint32_t SMLOE    : 1;            /*!< [31..31] Source Minor Loop Offset Enable                                  */
      } DMA_TCD0_NBYTES_MLOFFNO_DMA_b;
    } ;

    union {
      __IOM uint32_t DMA_TCD0_NBYTES_MLOFFYES_DMA;/*!< (@ 0x00001008) TCD Signed Minor Loop Offset (Minor Loop Mapping
                                                                    and Offset Enabled)                                        */

      struct {
        __IOM uint32_t NBYTES   : 10;           /*!< [9..0] Minor Byte Transfer Count                                          */
        __IOM uint32_t MLOFF    : 20;           /*!< [29..10] If SMLOE or DMLOE is set, this field represents a sign-extended
                                                     offset applied to the source or destination address to
                                                     form the next-state value after the minor loop completes.                 */
        __IOM uint32_t DMLOE    : 1;            /*!< [30..30] Destination Minor Loop Offset enable                             */
        __IOM uint32_t SMLOE    : 1;            /*!< [31..31] Source Minor Loop Offset Enable                                  */
      } DMA_TCD0_NBYTES_MLOFFYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD0_SLAST;              /*!< (@ 0x0000100C) TCD Last Source Address Adjustment                         */

    struct {
      __IOM uint32_t SLAST      : 32;           /*!< [31..0] Last Source Address Adjustment                                    */
    } DMA_TCD0_SLAST_b;
  } ;

  union {
    __IOM uint32_t DMA_TCD0_DADDR;              /*!< (@ 0x00001010) TCD Destination Address                                    */

    struct {
      __IOM uint32_t DADDR      : 32;           /*!< [31..0] Destination Address                                               */
    } DMA_TCD0_DADDR_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD0_DOFF;               /*!< (@ 0x00001014) TCD Signed Destination Address Offset                      */

    struct {
      __IOM uint16_t DOFF       : 16;           /*!< [15..0] Destination Address Signed Offset                                 */
    } DMA_TCD0_DOFF_b;
  } ;

  union {
    union {
      __IOM uint16_t DMA_TCD0_CITER_ELINKNO_DMA;/*!< (@ 0x00001016) TCD Current Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Disabled)                                 */

      struct {
        __IOM uint16_t CITER    : 15;           /*!< [14..0] Current Major Iteration Count                                     */
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enable channel-to-channel linking on minor-loop complete         */
      } DMA_TCD0_CITER_ELINKNO_DMA_b;
    } ;

    union {
      __IOM uint16_t DMA_TCD0_CITER_ELINKYES_DMA;/*!< (@ 0x00001016) TCD Current Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Enabled)                                  */

      struct {
        __IOM uint16_t CITER_LE : 9;            /*!< [8..0] Current Major Iteration Count                                      */
        __IOM uint16_t LINKCH   : 4;            /*!< [12..9] Minor Loop Link Channel Number                                    */
              uint16_t          : 2;
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enable channel-to-channel linking on minor-loop complete         */
      } DMA_TCD0_CITER_ELINKYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD0_DLASTSGA;           /*!< (@ 0x00001018) TCD Last Destination Address Adjustment/Scatter
                                                                    Gather Address                                             */

    struct {
      __IOM uint32_t DLASTSGA   : 32;           /*!< [31..0] DLASTSGA                                                          */
    } DMA_TCD0_DLASTSGA_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD0_CSR;                /*!< (@ 0x0000101C) TCD Control and Status                                     */

    struct {
      __IOM uint16_t START      : 1;            /*!< [0..0] Channel Start                                                      */
      __IOM uint16_t INTMAJOR   : 1;            /*!< [1..1] Enable an interrupt when major iteration count completes.          */
      __IOM uint16_t INTHALF    : 1;            /*!< [2..2] Enable an interrupt when major counter is half complete.           */
      __IOM uint16_t DREQ       : 1;            /*!< [3..3] Disable Request                                                    */
      __IOM uint16_t ESG        : 1;            /*!< [4..4] Enable Scatter/Gather Processing                                   */
      __IOM uint16_t MAJORELINK : 1;            /*!< [5..5] Enable channel-to-channel linking on major loop complete           */
      __IOM uint16_t ACTIVE     : 1;            /*!< [6..6] Channel Active                                                     */
      __IOM uint16_t DONE       : 1;            /*!< [7..7] Channel Done                                                       */
      __IOM uint16_t MAJORLINKCH : 4;           /*!< [11..8] Major Loop Link Channel Number                                    */
            uint16_t            : 2;
      __IOM uint16_t BWC        : 2;            /*!< [15..14] Bandwidth Control                                                */
    } DMA_TCD0_CSR_b;
  } ;

  union {
    union {
      __IOM uint16_t DMA_TCD0_BITER_ELINKNO_DMA;/*!< (@ 0x0000101E) TCD Beginning Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Disabled)                                 */

      struct {
        __IOM uint16_t BITER    : 15;           /*!< [14..0] Starting Major Iteration Count                                    */
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enables channel-to-channel linking on minor loop complete        */
      } DMA_TCD0_BITER_ELINKNO_DMA_b;
    } ;

    union {
      __IOM uint16_t DMA_TCD0_BITER_ELINKYES_DMA;/*!< (@ 0x0000101E) TCD Beginning Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Enabled)                                  */

      struct {
        __IOM uint16_t BITER    : 9;            /*!< [8..0] Starting major iteration count                                     */
        __IOM uint16_t LINKCH   : 4;            /*!< [12..9] Link Channel Number                                               */
              uint16_t          : 2;
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enables channel-to-channel linking on minor loop complete        */
      } DMA_TCD0_BITER_ELINKYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD1_SADDR;              /*!< (@ 0x00001020) TCD Source Address                                         */

    struct {
      __IOM uint32_t SADDR      : 32;           /*!< [31..0] Source Address                                                    */
    } DMA_TCD1_SADDR_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD1_SOFF;               /*!< (@ 0x00001024) TCD Signed Source Address Offset                           */

    struct {
      __IOM uint16_t SOFF       : 16;           /*!< [15..0] Source address signed offset                                      */
    } DMA_TCD1_SOFF_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD1_ATTR;               /*!< (@ 0x00001026) TCD Transfer Attributes                                    */

    struct {
      __IOM uint16_t DSIZE      : 3;            /*!< [2..0] Destination data transfer size                                     */
      __IOM uint16_t DMOD       : 5;            /*!< [7..3] Destination Address Modulo                                         */
      __IOM uint16_t SSIZE      : 3;            /*!< [10..8] Source data transfer size                                         */
      __IOM uint16_t SMOD       : 5;            /*!< [15..11] Source Address Modulo                                            */
    } DMA_TCD1_ATTR_b;
  } ;

  union {
    union {
      __IOM uint32_t DMA_TCD1_NBYTES_MLNO_DMA;  /*!< (@ 0x00001028) TCD Minor Byte Count (Minor Loop Mapping Disabled)         */

      struct {
        __IOM uint32_t NBYTES   : 32;           /*!< [31..0] Minor Byte Transfer Count                                         */
      } DMA_TCD1_NBYTES_MLNO_DMA_b;
    } ;

    union {
      __IOM uint32_t DMA_TCD1_NBYTES_MLOFFNO_DMA;/*!< (@ 0x00001028) TCD Signed Minor Loop Offset (Minor Loop Mapping
                                                                    Enabled and Offset Disabled)                               */

      struct {
        __IOM uint32_t NBYTES   : 30;           /*!< [29..0] Minor Byte Transfer Count                                         */
        __IOM uint32_t DMLOE    : 1;            /*!< [30..30] Destination Minor Loop Offset enable                             */
        __IOM uint32_t SMLOE    : 1;            /*!< [31..31] Source Minor Loop Offset Enable                                  */
      } DMA_TCD1_NBYTES_MLOFFNO_DMA_b;
    } ;

    union {
      __IOM uint32_t DMA_TCD1_NBYTES_MLOFFYES_DMA;/*!< (@ 0x00001028) TCD Signed Minor Loop Offset (Minor Loop Mapping
                                                                    and Offset Enabled)                                        */

      struct {
        __IOM uint32_t NBYTES   : 10;           /*!< [9..0] Minor Byte Transfer Count                                          */
        __IOM uint32_t MLOFF    : 20;           /*!< [29..10] If SMLOE or DMLOE is set, this field represents a sign-extended
                                                     offset applied to the source or destination address to
                                                     form the next-state value after the minor loop completes.                 */
        __IOM uint32_t DMLOE    : 1;            /*!< [30..30] Destination Minor Loop Offset enable                             */
        __IOM uint32_t SMLOE    : 1;            /*!< [31..31] Source Minor Loop Offset Enable                                  */
      } DMA_TCD1_NBYTES_MLOFFYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD1_SLAST;              /*!< (@ 0x0000102C) TCD Last Source Address Adjustment                         */

    struct {
      __IOM uint32_t SLAST      : 32;           /*!< [31..0] Last Source Address Adjustment                                    */
    } DMA_TCD1_SLAST_b;
  } ;

  union {
    __IOM uint32_t DMA_TCD1_DADDR;              /*!< (@ 0x00001030) TCD Destination Address                                    */

    struct {
      __IOM uint32_t DADDR      : 32;           /*!< [31..0] Destination Address                                               */
    } DMA_TCD1_DADDR_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD1_DOFF;               /*!< (@ 0x00001034) TCD Signed Destination Address Offset                      */

    struct {
      __IOM uint16_t DOFF       : 16;           /*!< [15..0] Destination Address Signed Offset                                 */
    } DMA_TCD1_DOFF_b;
  } ;

  union {
    union {
      __IOM uint16_t DMA_TCD1_CITER_ELINKNO_DMA;/*!< (@ 0x00001036) TCD Current Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Disabled)                                 */

      struct {
        __IOM uint16_t CITER    : 15;           /*!< [14..0] Current Major Iteration Count                                     */
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enable channel-to-channel linking on minor-loop complete         */
      } DMA_TCD1_CITER_ELINKNO_DMA_b;
    } ;

    union {
      __IOM uint16_t DMA_TCD1_CITER_ELINKYES_DMA;/*!< (@ 0x00001036) TCD Current Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Enabled)                                  */

      struct {
        __IOM uint16_t CITER_LE : 9;            /*!< [8..0] Current Major Iteration Count                                      */
        __IOM uint16_t LINKCH   : 4;            /*!< [12..9] Minor Loop Link Channel Number                                    */
              uint16_t          : 2;
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enable channel-to-channel linking on minor-loop complete         */
      } DMA_TCD1_CITER_ELINKYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD1_DLASTSGA;           /*!< (@ 0x00001038) TCD Last Destination Address Adjustment/Scatter
                                                                    Gather Address                                             */

    struct {
      __IOM uint32_t DLASTSGA   : 32;           /*!< [31..0] DLASTSGA                                                          */
    } DMA_TCD1_DLASTSGA_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD1_CSR;                /*!< (@ 0x0000103C) TCD Control and Status                                     */

    struct {
      __IOM uint16_t START      : 1;            /*!< [0..0] Channel Start                                                      */
      __IOM uint16_t INTMAJOR   : 1;            /*!< [1..1] Enable an interrupt when major iteration count completes.          */
      __IOM uint16_t INTHALF    : 1;            /*!< [2..2] Enable an interrupt when major counter is half complete.           */
      __IOM uint16_t DREQ       : 1;            /*!< [3..3] Disable Request                                                    */
      __IOM uint16_t ESG        : 1;            /*!< [4..4] Enable Scatter/Gather Processing                                   */
      __IOM uint16_t MAJORELINK : 1;            /*!< [5..5] Enable channel-to-channel linking on major loop complete           */
      __IOM uint16_t ACTIVE     : 1;            /*!< [6..6] Channel Active                                                     */
      __IOM uint16_t DONE       : 1;            /*!< [7..7] Channel Done                                                       */
      __IOM uint16_t MAJORLINKCH : 4;           /*!< [11..8] Major Loop Link Channel Number                                    */
            uint16_t            : 2;
      __IOM uint16_t BWC        : 2;            /*!< [15..14] Bandwidth Control                                                */
    } DMA_TCD1_CSR_b;
  } ;

  union {
    union {
      __IOM uint16_t DMA_TCD1_BITER_ELINKNO_DMA;/*!< (@ 0x0000103E) TCD Beginning Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Disabled)                                 */

      struct {
        __IOM uint16_t BITER    : 15;           /*!< [14..0] Starting Major Iteration Count                                    */
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enables channel-to-channel linking on minor loop complete        */
      } DMA_TCD1_BITER_ELINKNO_DMA_b;
    } ;

    union {
      __IOM uint16_t DMA_TCD1_BITER_ELINKYES_DMA;/*!< (@ 0x0000103E) TCD Beginning Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Enabled)                                  */

      struct {
        __IOM uint16_t BITER    : 9;            /*!< [8..0] Starting major iteration count                                     */
        __IOM uint16_t LINKCH   : 4;            /*!< [12..9] Link Channel Number                                               */
              uint16_t          : 2;
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enables channel-to-channel linking on minor loop complete        */
      } DMA_TCD1_BITER_ELINKYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD2_SADDR;              /*!< (@ 0x00001040) TCD Source Address                                         */

    struct {
      __IOM uint32_t SADDR      : 32;           /*!< [31..0] Source Address                                                    */
    } DMA_TCD2_SADDR_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD2_SOFF;               /*!< (@ 0x00001044) TCD Signed Source Address Offset                           */

    struct {
      __IOM uint16_t SOFF       : 16;           /*!< [15..0] Source address signed offset                                      */
    } DMA_TCD2_SOFF_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD2_ATTR;               /*!< (@ 0x00001046) TCD Transfer Attributes                                    */

    struct {
      __IOM uint16_t DSIZE      : 3;            /*!< [2..0] Destination data transfer size                                     */
      __IOM uint16_t DMOD       : 5;            /*!< [7..3] Destination Address Modulo                                         */
      __IOM uint16_t SSIZE      : 3;            /*!< [10..8] Source data transfer size                                         */
      __IOM uint16_t SMOD       : 5;            /*!< [15..11] Source Address Modulo                                            */
    } DMA_TCD2_ATTR_b;
  } ;

  union {
    union {
      __IOM uint32_t DMA_TCD2_NBYTES_MLNO_DMA;  /*!< (@ 0x00001048) TCD Minor Byte Count (Minor Loop Mapping Disabled)         */

      struct {
        __IOM uint32_t NBYTES   : 32;           /*!< [31..0] Minor Byte Transfer Count                                         */
      } DMA_TCD2_NBYTES_MLNO_DMA_b;
    } ;

    union {
      __IOM uint32_t DMA_TCD2_NBYTES_MLOFFNO_DMA;/*!< (@ 0x00001048) TCD Signed Minor Loop Offset (Minor Loop Mapping
                                                                    Enabled and Offset Disabled)                               */

      struct {
        __IOM uint32_t NBYTES   : 30;           /*!< [29..0] Minor Byte Transfer Count                                         */
        __IOM uint32_t DMLOE    : 1;            /*!< [30..30] Destination Minor Loop Offset enable                             */
        __IOM uint32_t SMLOE    : 1;            /*!< [31..31] Source Minor Loop Offset Enable                                  */
      } DMA_TCD2_NBYTES_MLOFFNO_DMA_b;
    } ;

    union {
      __IOM uint32_t DMA_TCD2_NBYTES_MLOFFYES_DMA;/*!< (@ 0x00001048) TCD Signed Minor Loop Offset (Minor Loop Mapping
                                                                    and Offset Enabled)                                        */

      struct {
        __IOM uint32_t NBYTES   : 10;           /*!< [9..0] Minor Byte Transfer Count                                          */
        __IOM uint32_t MLOFF    : 20;           /*!< [29..10] If SMLOE or DMLOE is set, this field represents a sign-extended
                                                     offset applied to the source or destination address to
                                                     form the next-state value after the minor loop completes.                 */
        __IOM uint32_t DMLOE    : 1;            /*!< [30..30] Destination Minor Loop Offset enable                             */
        __IOM uint32_t SMLOE    : 1;            /*!< [31..31] Source Minor Loop Offset Enable                                  */
      } DMA_TCD2_NBYTES_MLOFFYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD2_SLAST;              /*!< (@ 0x0000104C) TCD Last Source Address Adjustment                         */

    struct {
      __IOM uint32_t SLAST      : 32;           /*!< [31..0] Last Source Address Adjustment                                    */
    } DMA_TCD2_SLAST_b;
  } ;

  union {
    __IOM uint32_t DMA_TCD2_DADDR;              /*!< (@ 0x00001050) TCD Destination Address                                    */

    struct {
      __IOM uint32_t DADDR      : 32;           /*!< [31..0] Destination Address                                               */
    } DMA_TCD2_DADDR_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD2_DOFF;               /*!< (@ 0x00001054) TCD Signed Destination Address Offset                      */

    struct {
      __IOM uint16_t DOFF       : 16;           /*!< [15..0] Destination Address Signed Offset                                 */
    } DMA_TCD2_DOFF_b;
  } ;

  union {
    union {
      __IOM uint16_t DMA_TCD2_CITER_ELINKNO_DMA;/*!< (@ 0x00001056) TCD Current Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Disabled)                                 */

      struct {
        __IOM uint16_t CITER    : 15;           /*!< [14..0] Current Major Iteration Count                                     */
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enable channel-to-channel linking on minor-loop complete         */
      } DMA_TCD2_CITER_ELINKNO_DMA_b;
    } ;

    union {
      __IOM uint16_t DMA_TCD2_CITER_ELINKYES_DMA;/*!< (@ 0x00001056) TCD Current Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Enabled)                                  */

      struct {
        __IOM uint16_t CITER_LE : 9;            /*!< [8..0] Current Major Iteration Count                                      */
        __IOM uint16_t LINKCH   : 4;            /*!< [12..9] Minor Loop Link Channel Number                                    */
              uint16_t          : 2;
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enable channel-to-channel linking on minor-loop complete         */
      } DMA_TCD2_CITER_ELINKYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD2_DLASTSGA;           /*!< (@ 0x00001058) TCD Last Destination Address Adjustment/Scatter
                                                                    Gather Address                                             */

    struct {
      __IOM uint32_t DLASTSGA   : 32;           /*!< [31..0] DLASTSGA                                                          */
    } DMA_TCD2_DLASTSGA_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD2_CSR;                /*!< (@ 0x0000105C) TCD Control and Status                                     */

    struct {
      __IOM uint16_t START      : 1;            /*!< [0..0] Channel Start                                                      */
      __IOM uint16_t INTMAJOR   : 1;            /*!< [1..1] Enable an interrupt when major iteration count completes.          */
      __IOM uint16_t INTHALF    : 1;            /*!< [2..2] Enable an interrupt when major counter is half complete.           */
      __IOM uint16_t DREQ       : 1;            /*!< [3..3] Disable Request                                                    */
      __IOM uint16_t ESG        : 1;            /*!< [4..4] Enable Scatter/Gather Processing                                   */
      __IOM uint16_t MAJORELINK : 1;            /*!< [5..5] Enable channel-to-channel linking on major loop complete           */
      __IOM uint16_t ACTIVE     : 1;            /*!< [6..6] Channel Active                                                     */
      __IOM uint16_t DONE       : 1;            /*!< [7..7] Channel Done                                                       */
      __IOM uint16_t MAJORLINKCH : 4;           /*!< [11..8] Major Loop Link Channel Number                                    */
            uint16_t            : 2;
      __IOM uint16_t BWC        : 2;            /*!< [15..14] Bandwidth Control                                                */
    } DMA_TCD2_CSR_b;
  } ;

  union {
    union {
      __IOM uint16_t DMA_TCD2_BITER_ELINKNO_DMA;/*!< (@ 0x0000105E) TCD Beginning Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Disabled)                                 */

      struct {
        __IOM uint16_t BITER    : 15;           /*!< [14..0] Starting Major Iteration Count                                    */
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enables channel-to-channel linking on minor loop complete        */
      } DMA_TCD2_BITER_ELINKNO_DMA_b;
    } ;

    union {
      __IOM uint16_t DMA_TCD2_BITER_ELINKYES_DMA;/*!< (@ 0x0000105E) TCD Beginning Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Enabled)                                  */

      struct {
        __IOM uint16_t BITER    : 9;            /*!< [8..0] Starting major iteration count                                     */
        __IOM uint16_t LINKCH   : 4;            /*!< [12..9] Link Channel Number                                               */
              uint16_t          : 2;
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enables channel-to-channel linking on minor loop complete        */
      } DMA_TCD2_BITER_ELINKYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD3_SADDR;              /*!< (@ 0x00001060) TCD Source Address                                         */

    struct {
      __IOM uint32_t SADDR      : 32;           /*!< [31..0] Source Address                                                    */
    } DMA_TCD3_SADDR_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD3_SOFF;               /*!< (@ 0x00001064) TCD Signed Source Address Offset                           */

    struct {
      __IOM uint16_t SOFF       : 16;           /*!< [15..0] Source address signed offset                                      */
    } DMA_TCD3_SOFF_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD3_ATTR;               /*!< (@ 0x00001066) TCD Transfer Attributes                                    */

    struct {
      __IOM uint16_t DSIZE      : 3;            /*!< [2..0] Destination data transfer size                                     */
      __IOM uint16_t DMOD       : 5;            /*!< [7..3] Destination Address Modulo                                         */
      __IOM uint16_t SSIZE      : 3;            /*!< [10..8] Source data transfer size                                         */
      __IOM uint16_t SMOD       : 5;            /*!< [15..11] Source Address Modulo                                            */
    } DMA_TCD3_ATTR_b;
  } ;

  union {
    union {
      __IOM uint32_t DMA_TCD3_NBYTES_MLNO_DMA;  /*!< (@ 0x00001068) TCD Minor Byte Count (Minor Loop Mapping Disabled)         */

      struct {
        __IOM uint32_t NBYTES   : 32;           /*!< [31..0] Minor Byte Transfer Count                                         */
      } DMA_TCD3_NBYTES_MLNO_DMA_b;
    } ;

    union {
      __IOM uint32_t DMA_TCD3_NBYTES_MLOFFNO_DMA;/*!< (@ 0x00001068) TCD Signed Minor Loop Offset (Minor Loop Mapping
                                                                    Enabled and Offset Disabled)                               */

      struct {
        __IOM uint32_t NBYTES   : 30;           /*!< [29..0] Minor Byte Transfer Count                                         */
        __IOM uint32_t DMLOE    : 1;            /*!< [30..30] Destination Minor Loop Offset enable                             */
        __IOM uint32_t SMLOE    : 1;            /*!< [31..31] Source Minor Loop Offset Enable                                  */
      } DMA_TCD3_NBYTES_MLOFFNO_DMA_b;
    } ;

    union {
      __IOM uint32_t DMA_TCD3_NBYTES_MLOFFYES_DMA;/*!< (@ 0x00001068) TCD Signed Minor Loop Offset (Minor Loop Mapping
                                                                    and Offset Enabled)                                        */

      struct {
        __IOM uint32_t NBYTES   : 10;           /*!< [9..0] Minor Byte Transfer Count                                          */
        __IOM uint32_t MLOFF    : 20;           /*!< [29..10] If SMLOE or DMLOE is set, this field represents a sign-extended
                                                     offset applied to the source or destination address to
                                                     form the next-state value after the minor loop completes.                 */
        __IOM uint32_t DMLOE    : 1;            /*!< [30..30] Destination Minor Loop Offset enable                             */
        __IOM uint32_t SMLOE    : 1;            /*!< [31..31] Source Minor Loop Offset Enable                                  */
      } DMA_TCD3_NBYTES_MLOFFYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD3_SLAST;              /*!< (@ 0x0000106C) TCD Last Source Address Adjustment                         */

    struct {
      __IOM uint32_t SLAST      : 32;           /*!< [31..0] Last Source Address Adjustment                                    */
    } DMA_TCD3_SLAST_b;
  } ;

  union {
    __IOM uint32_t DMA_TCD3_DADDR;              /*!< (@ 0x00001070) TCD Destination Address                                    */

    struct {
      __IOM uint32_t DADDR      : 32;           /*!< [31..0] Destination Address                                               */
    } DMA_TCD3_DADDR_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD3_DOFF;               /*!< (@ 0x00001074) TCD Signed Destination Address Offset                      */

    struct {
      __IOM uint16_t DOFF       : 16;           /*!< [15..0] Destination Address Signed Offset                                 */
    } DMA_TCD3_DOFF_b;
  } ;

  union {
    union {
      __IOM uint16_t DMA_TCD3_CITER_ELINKNO_DMA;/*!< (@ 0x00001076) TCD Current Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Disabled)                                 */

      struct {
        __IOM uint16_t CITER    : 15;           /*!< [14..0] Current Major Iteration Count                                     */
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enable channel-to-channel linking on minor-loop complete         */
      } DMA_TCD3_CITER_ELINKNO_DMA_b;
    } ;

    union {
      __IOM uint16_t DMA_TCD3_CITER_ELINKYES_DMA;/*!< (@ 0x00001076) TCD Current Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Enabled)                                  */

      struct {
        __IOM uint16_t CITER_LE : 9;            /*!< [8..0] Current Major Iteration Count                                      */
        __IOM uint16_t LINKCH   : 4;            /*!< [12..9] Minor Loop Link Channel Number                                    */
              uint16_t          : 2;
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enable channel-to-channel linking on minor-loop complete         */
      } DMA_TCD3_CITER_ELINKYES_DMA_b;
    } ;
  };

  union {
    __IOM uint32_t DMA_TCD3_DLASTSGA;           /*!< (@ 0x00001078) TCD Last Destination Address Adjustment/Scatter
                                                                    Gather Address                                             */

    struct {
      __IOM uint32_t DLASTSGA   : 32;           /*!< [31..0] DLASTSGA                                                          */
    } DMA_TCD3_DLASTSGA_b;
  } ;

  union {
    __IOM uint16_t DMA_TCD3_CSR;                /*!< (@ 0x0000107C) TCD Control and Status                                     */

    struct {
      __IOM uint16_t START      : 1;            /*!< [0..0] Channel Start                                                      */
      __IOM uint16_t INTMAJOR   : 1;            /*!< [1..1] Enable an interrupt when major iteration count completes.          */
      __IOM uint16_t INTHALF    : 1;            /*!< [2..2] Enable an interrupt when major counter is half complete.           */
      __IOM uint16_t DREQ       : 1;            /*!< [3..3] Disable Request                                                    */
      __IOM uint16_t ESG        : 1;            /*!< [4..4] Enable Scatter/Gather Processing                                   */
      __IOM uint16_t MAJORELINK : 1;            /*!< [5..5] Enable channel-to-channel linking on major loop complete           */
      __IOM uint16_t ACTIVE     : 1;            /*!< [6..6] Channel Active                                                     */
      __IOM uint16_t DONE       : 1;            /*!< [7..7] Channel Done                                                       */
      __IOM uint16_t MAJORLINKCH : 4;           /*!< [11..8] Major Loop Link Channel Number                                    */
            uint16_t            : 2;
      __IOM uint16_t BWC        : 2;            /*!< [15..14] Bandwidth Control                                                */
    } DMA_TCD3_CSR_b;
  } ;

  union {
    union {
      __IOM uint16_t DMA_TCD3_BITER_ELINKNO_DMA;/*!< (@ 0x0000107E) TCD Beginning Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Disabled)                                 */

      struct {
        __IOM uint16_t BITER    : 15;           /*!< [14..0] Starting Major Iteration Count                                    */
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enables channel-to-channel linking on minor loop complete        */
      } DMA_TCD3_BITER_ELINKNO_DMA_b;
    } ;

    union {
      __IOM uint16_t DMA_TCD3_BITER_ELINKYES_DMA;/*!< (@ 0x0000107E) TCD Beginning Minor Loop Link, Major Loop Count
                                                                    (Channel Linking Enabled)                                  */

      struct {
        __IOM uint16_t BITER    : 9;            /*!< [8..0] Starting major iteration count                                     */
        __IOM uint16_t LINKCH   : 4;            /*!< [12..9] Link Channel Number                                               */
              uint16_t          : 2;
        __IOM uint16_t ELINK    : 1;            /*!< [15..15] Enables channel-to-channel linking on minor loop complete        */
      } DMA_TCD3_BITER_ELINKYES_DMA_b;
    } ;
  };
} DMA_Type;                                     /*!< Size = 4224 (0x1080)                                                      */



/* =========================================================================================================================== */
/* ================                                            MPU                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Memory protection unit (MPU)
  */

typedef struct {                                /*!< (@ 0x4000D000) MPU Structure                                              */

  union {
    __IOM uint32_t MPU_CESR;                    /*!< (@ 0x00000000) Control/Error Status Register                              */

    struct {
      __IOM uint32_t VLD        : 1;            /*!< [0..0] Valid                                                              */
            uint32_t            : 7;
      __IM  uint32_t NRGD       : 4;            /*!< [11..8] Number Of Region Descriptors                                      */
      __IM  uint32_t NSP        : 4;            /*!< [15..12] Number Of Slave Ports                                            */
      __IM  uint32_t HRL        : 4;            /*!< [19..16] Hardware Revision Level                                          */
            uint32_t            : 10;
      __IOM uint32_t SPERR1     : 1;            /*!< [30..30] Slave Port 1 Error                                               */
      __IOM uint32_t SPERR0     : 1;            /*!< [31..31] Slave Port 0 Error                                               */
    } MPU_CESR_b;
  } ;
  __IM  uint32_t  RESERVED[3];

  union {
    __IM  uint32_t MPU_EAR0;                    /*!< (@ 0x00000010) Error Address Register, slave port 0                       */

    struct {
      __IM  uint32_t EADDR      : 32;           /*!< [31..0] Error Address                                                     */
    } MPU_EAR0_b;
  } ;

  union {
    __IM  uint32_t MPU_EDR0;                    /*!< (@ 0x00000014) Error Detail Register, slave port 0                        */

    struct {
      __IM  uint32_t ERW        : 1;            /*!< [0..0] Error Read/Write                                                   */
      __IM  uint32_t EATTR      : 3;            /*!< [3..1] Error Attributes                                                   */
      __IM  uint32_t EMN        : 4;            /*!< [7..4] Error Master Number                                                */
      __IM  uint32_t EPID       : 8;            /*!< [15..8] Error Process Identification                                      */
      __IM  uint32_t EACD       : 16;           /*!< [31..16] Error Access Control Detail                                      */
    } MPU_EDR0_b;
  } ;

  union {
    __IM  uint32_t MPU_EAR1;                    /*!< (@ 0x00000018) Error Address Register, slave port 1                       */

    struct {
      __IM  uint32_t EADDR      : 32;           /*!< [31..0] Error Address                                                     */
    } MPU_EAR1_b;
  } ;

  union {
    __IM  uint32_t MPU_EDR1;                    /*!< (@ 0x0000001C) Error Detail Register, slave port 1                        */

    struct {
      __IM  uint32_t ERW        : 1;            /*!< [0..0] Error Read/Write                                                   */
      __IM  uint32_t EATTR      : 3;            /*!< [3..1] Error Attributes                                                   */
      __IM  uint32_t EMN        : 4;            /*!< [7..4] Error Master Number                                                */
      __IM  uint32_t EPID       : 8;            /*!< [15..8] Error Process Identification                                      */
      __IM  uint32_t EACD       : 16;           /*!< [31..16] Error Access Control Detail                                      */
    } MPU_EDR1_b;
  } ;
  __IM  uint32_t  RESERVED1[248];

  union {
    __IOM uint32_t MPU_RGD0_WORD0;              /*!< (@ 0x00000400) Region Descriptor 0, Word 0                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t SRTADDR    : 27;           /*!< [31..5] Start Address                                                     */
    } MPU_RGD0_WORD0_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD0_WORD1;              /*!< (@ 0x00000404) Region Descriptor 0, Word 1                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t ENDADDR    : 27;           /*!< [31..5] End Address                                                       */
    } MPU_RGD0_WORD1_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD0_WORD2;              /*!< (@ 0x00000408) Region Descriptor 0, Word 2                                */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGD0_WORD2_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD0_WORD3;              /*!< (@ 0x0000040C) Region Descriptor 0, Word 3                                */

    struct {
      __IOM uint32_t VLD        : 1;            /*!< [0..0] Valid                                                              */
            uint32_t            : 15;
      __IOM uint32_t PIDMASK    : 8;            /*!< [23..16] Process Identifier Mask                                          */
      __IOM uint32_t PID        : 8;            /*!< [31..24] Process Identifier                                               */
    } MPU_RGD0_WORD3_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD1_WORD0;              /*!< (@ 0x00000410) Region Descriptor 1, Word 0                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t SRTADDR    : 27;           /*!< [31..5] Start Address                                                     */
    } MPU_RGD1_WORD0_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD1_WORD1;              /*!< (@ 0x00000414) Region Descriptor 1, Word 1                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t ENDADDR    : 27;           /*!< [31..5] End Address                                                       */
    } MPU_RGD1_WORD1_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD1_WORD2;              /*!< (@ 0x00000418) Region Descriptor 1, Word 2                                */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGD1_WORD2_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD1_WORD3;              /*!< (@ 0x0000041C) Region Descriptor 1, Word 3                                */

    struct {
      __IOM uint32_t VLD        : 1;            /*!< [0..0] Valid                                                              */
            uint32_t            : 15;
      __IOM uint32_t PIDMASK    : 8;            /*!< [23..16] Process Identifier Mask                                          */
      __IOM uint32_t PID        : 8;            /*!< [31..24] Process Identifier                                               */
    } MPU_RGD1_WORD3_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD2_WORD0;              /*!< (@ 0x00000420) Region Descriptor 2, Word 0                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t SRTADDR    : 27;           /*!< [31..5] Start Address                                                     */
    } MPU_RGD2_WORD0_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD2_WORD1;              /*!< (@ 0x00000424) Region Descriptor 2, Word 1                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t ENDADDR    : 27;           /*!< [31..5] End Address                                                       */
    } MPU_RGD2_WORD1_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD2_WORD2;              /*!< (@ 0x00000428) Region Descriptor 2, Word 2                                */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGD2_WORD2_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD2_WORD3;              /*!< (@ 0x0000042C) Region Descriptor 2, Word 3                                */

    struct {
      __IOM uint32_t VLD        : 1;            /*!< [0..0] Valid                                                              */
            uint32_t            : 15;
      __IOM uint32_t PIDMASK    : 8;            /*!< [23..16] Process Identifier Mask                                          */
      __IOM uint32_t PID        : 8;            /*!< [31..24] Process Identifier                                               */
    } MPU_RGD2_WORD3_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD3_WORD0;              /*!< (@ 0x00000430) Region Descriptor 3, Word 0                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t SRTADDR    : 27;           /*!< [31..5] Start Address                                                     */
    } MPU_RGD3_WORD0_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD3_WORD1;              /*!< (@ 0x00000434) Region Descriptor 3, Word 1                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t ENDADDR    : 27;           /*!< [31..5] End Address                                                       */
    } MPU_RGD3_WORD1_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD3_WORD2;              /*!< (@ 0x00000438) Region Descriptor 3, Word 2                                */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGD3_WORD2_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD3_WORD3;              /*!< (@ 0x0000043C) Region Descriptor 3, Word 3                                */

    struct {
      __IOM uint32_t VLD        : 1;            /*!< [0..0] Valid                                                              */
            uint32_t            : 15;
      __IOM uint32_t PIDMASK    : 8;            /*!< [23..16] Process Identifier Mask                                          */
      __IOM uint32_t PID        : 8;            /*!< [31..24] Process Identifier                                               */
    } MPU_RGD3_WORD3_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD4_WORD0;              /*!< (@ 0x00000440) Region Descriptor 4, Word 0                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t SRTADDR    : 27;           /*!< [31..5] Start Address                                                     */
    } MPU_RGD4_WORD0_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD4_WORD1;              /*!< (@ 0x00000444) Region Descriptor 4, Word 1                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t ENDADDR    : 27;           /*!< [31..5] End Address                                                       */
    } MPU_RGD4_WORD1_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD4_WORD2;              /*!< (@ 0x00000448) Region Descriptor 4, Word 2                                */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGD4_WORD2_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD4_WORD3;              /*!< (@ 0x0000044C) Region Descriptor 4, Word 3                                */

    struct {
      __IOM uint32_t VLD        : 1;            /*!< [0..0] Valid                                                              */
            uint32_t            : 15;
      __IOM uint32_t PIDMASK    : 8;            /*!< [23..16] Process Identifier Mask                                          */
      __IOM uint32_t PID        : 8;            /*!< [31..24] Process Identifier                                               */
    } MPU_RGD4_WORD3_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD5_WORD0;              /*!< (@ 0x00000450) Region Descriptor 5, Word 0                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t SRTADDR    : 27;           /*!< [31..5] Start Address                                                     */
    } MPU_RGD5_WORD0_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD5_WORD1;              /*!< (@ 0x00000454) Region Descriptor 5, Word 1                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t ENDADDR    : 27;           /*!< [31..5] End Address                                                       */
    } MPU_RGD5_WORD1_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD5_WORD2;              /*!< (@ 0x00000458) Region Descriptor 5, Word 2                                */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGD5_WORD2_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD5_WORD3;              /*!< (@ 0x0000045C) Region Descriptor 5, Word 3                                */

    struct {
      __IOM uint32_t VLD        : 1;            /*!< [0..0] Valid                                                              */
            uint32_t            : 15;
      __IOM uint32_t PIDMASK    : 8;            /*!< [23..16] Process Identifier Mask                                          */
      __IOM uint32_t PID        : 8;            /*!< [31..24] Process Identifier                                               */
    } MPU_RGD5_WORD3_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD6_WORD0;              /*!< (@ 0x00000460) Region Descriptor 6, Word 0                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t SRTADDR    : 27;           /*!< [31..5] Start Address                                                     */
    } MPU_RGD6_WORD0_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD6_WORD1;              /*!< (@ 0x00000464) Region Descriptor 6, Word 1                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t ENDADDR    : 27;           /*!< [31..5] End Address                                                       */
    } MPU_RGD6_WORD1_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD6_WORD2;              /*!< (@ 0x00000468) Region Descriptor 6, Word 2                                */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGD6_WORD2_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD6_WORD3;              /*!< (@ 0x0000046C) Region Descriptor 6, Word 3                                */

    struct {
      __IOM uint32_t VLD        : 1;            /*!< [0..0] Valid                                                              */
            uint32_t            : 15;
      __IOM uint32_t PIDMASK    : 8;            /*!< [23..16] Process Identifier Mask                                          */
      __IOM uint32_t PID        : 8;            /*!< [31..24] Process Identifier                                               */
    } MPU_RGD6_WORD3_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD7_WORD0;              /*!< (@ 0x00000470) Region Descriptor 7, Word 0                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t SRTADDR    : 27;           /*!< [31..5] Start Address                                                     */
    } MPU_RGD7_WORD0_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD7_WORD1;              /*!< (@ 0x00000474) Region Descriptor 7, Word 1                                */

    struct {
            uint32_t            : 5;
      __IOM uint32_t ENDADDR    : 27;           /*!< [31..5] End Address                                                       */
    } MPU_RGD7_WORD1_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD7_WORD2;              /*!< (@ 0x00000478) Region Descriptor 7, Word 2                                */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGD7_WORD2_b;
  } ;

  union {
    __IOM uint32_t MPU_RGD7_WORD3;              /*!< (@ 0x0000047C) Region Descriptor 7, Word 3                                */

    struct {
      __IOM uint32_t VLD        : 1;            /*!< [0..0] Valid                                                              */
            uint32_t            : 15;
      __IOM uint32_t PIDMASK    : 8;            /*!< [23..16] Process Identifier Mask                                          */
      __IOM uint32_t PID        : 8;            /*!< [31..24] Process Identifier                                               */
    } MPU_RGD7_WORD3_b;
  } ;
  __IM  uint32_t  RESERVED2[224];

  union {
    __IOM uint32_t MPU_RGDAAC0;                 /*!< (@ 0x00000800) Region Descriptor Alternate Access Control 0               */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier Enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access Control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGDAAC0_b;
  } ;

  union {
    __IOM uint32_t MPU_RGDAAC1;                 /*!< (@ 0x00000804) Region Descriptor Alternate Access Control 1               */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier Enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access Control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGDAAC1_b;
  } ;

  union {
    __IOM uint32_t MPU_RGDAAC2;                 /*!< (@ 0x00000808) Region Descriptor Alternate Access Control 2               */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier Enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access Control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGDAAC2_b;
  } ;

  union {
    __IOM uint32_t MPU_RGDAAC3;                 /*!< (@ 0x0000080C) Region Descriptor Alternate Access Control 3               */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier Enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access Control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGDAAC3_b;
  } ;

  union {
    __IOM uint32_t MPU_RGDAAC4;                 /*!< (@ 0x00000810) Region Descriptor Alternate Access Control 4               */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier Enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access Control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGDAAC4_b;
  } ;

  union {
    __IOM uint32_t MPU_RGDAAC5;                 /*!< (@ 0x00000814) Region Descriptor Alternate Access Control 5               */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier Enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access Control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGDAAC5_b;
  } ;

  union {
    __IOM uint32_t MPU_RGDAAC6;                 /*!< (@ 0x00000818) Region Descriptor Alternate Access Control 6               */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier Enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access Control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGDAAC6_b;
  } ;

  union {
    __IOM uint32_t MPU_RGDAAC7;                 /*!< (@ 0x0000081C) Region Descriptor Alternate Access Control 7               */

    struct {
      __IOM uint32_t M0UM       : 3;            /*!< [2..0] Bus Master 0 User Mode Access Control                              */
      __IOM uint32_t M0SM       : 2;            /*!< [4..3] Bus Master 0 Supervisor Mode Access Control                        */
      __IOM uint32_t M0PE       : 1;            /*!< [5..5] Bus Master 0 Process Identifier Enable                             */
      __IOM uint32_t M1UM       : 3;            /*!< [8..6] Bus Master 1 User Mode Access Control                              */
      __IOM uint32_t M1SM       : 2;            /*!< [10..9] Bus Master 1 Supervisor Mode Access Control                       */
            uint32_t            : 1;
      __IOM uint32_t M2UM       : 3;            /*!< [14..12] Bus Master 2 User Mode Access Control                            */
      __IOM uint32_t M2SM       : 2;            /*!< [16..15] Bus Master 2 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M3UM       : 3;            /*!< [20..18] Bus Master 3 User Mode Access Control                            */
      __IOM uint32_t M3SM       : 2;            /*!< [22..21] Bus Master 3 Supervisor Mode Access Control                      */
            uint32_t            : 1;
      __IOM uint32_t M4WE       : 1;            /*!< [24..24] Bus Master 4 Write Enable                                        */
      __IOM uint32_t M4RE       : 1;            /*!< [25..25] Bus Master 4 Read Enable                                         */
      __IOM uint32_t M5WE       : 1;            /*!< [26..26] Bus Master 5 Write Enable                                        */
      __IOM uint32_t M5RE       : 1;            /*!< [27..27] Bus Master 5 Read Enable                                         */
      __IOM uint32_t M6WE       : 1;            /*!< [28..28] Bus Master 6 Write Enable                                        */
      __IOM uint32_t M6RE       : 1;            /*!< [29..29] Bus Master 6 Read Enable                                         */
      __IOM uint32_t M7WE       : 1;            /*!< [30..30] Bus Master 7 Write Enable                                        */
      __IOM uint32_t M7RE       : 1;            /*!< [31..31] Bus Master 7 Read Enable                                         */
    } MPU_RGDAAC7_b;
  } ;
} MPU_Type;                                     /*!< Size = 2080 (0x820)                                                       */



/* =========================================================================================================================== */
/* ================                                            ERM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief ERM (ERM)
  */

typedef struct {                                /*!< (@ 0x40018000) ERM Structure                                              */

  union {
    __IOM uint32_t ERM_CR0;                     /*!< (@ 0x00000000) ERM Configuration Register 0                               */

    struct {
            uint32_t            : 30;
      __IOM uint32_t ENCIE0     : 1;            /*!< [30..30] ENCIE0                                                           */
      __IOM uint32_t ESCIE0     : 1;            /*!< [31..31] ESCIE0                                                           */
    } ERM_CR0_b;
  } ;
  __IM  uint32_t  RESERVED[3];

  union {
    __IOM uint32_t ERM_SR0;                     /*!< (@ 0x00000010) ERM Status Register 0                                      */

    struct {
            uint32_t            : 30;
      __IOM uint32_t NCE0       : 1;            /*!< [30..30] NCE0                                                             */
      __IOM uint32_t SBC0       : 1;            /*!< [31..31] SBC0                                                             */
    } ERM_SR0_b;
  } ;
  __IM  uint32_t  RESERVED1[59];

  union {
    __IM  uint32_t ERM_EAR0;                    /*!< (@ 0x00000100) ERM Memory n Error Address Register                        */

    struct {
      __IM  uint32_t EAR        : 32;           /*!< [31..0] EAR                                                               */
    } ERM_EAR0_b;
  } ;
} ERM_Type;                                     /*!< Size = 260 (0x104)                                                        */



/* =========================================================================================================================== */
/* ================                                            EIM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Error Injection Module (EIM)
  */

typedef struct {                                /*!< (@ 0x40019000) EIM Structure                                              */

  union {
    __IOM uint32_t EIM_EIMCR;                   /*!< (@ 0x00000000) Error Injection Module Configuration Register              */

    struct {
      __IOM uint32_t GEIEN      : 1;            /*!< [0..0] Global Error Injection Enable                                      */
            uint32_t            : 31;
    } EIM_EIMCR_b;
  } ;

  union {
    __IOM uint32_t EIM_EICHEN;                  /*!< (@ 0x00000004) Error Injection Channel Enable register                    */

    struct {
            uint32_t            : 31;
      __IOM uint32_t EICH0EN    : 1;            /*!< [31..31] Error Injection Channel 0 Enable                                 */
    } EIM_EICHEN_b;
  } ;
  __IM  uint32_t  RESERVED[62];

  union {
    __IOM uint32_t EIM_EICHD0_WORD0;            /*!< (@ 0x00000100) Error Injection Channel Descriptor n, Word0                */

    struct {
            uint32_t            : 25;
      __IOM uint32_t CHKBIT_MASK : 7;           /*!< [31..25] Checkbit Mask                                                    */
    } EIM_EICHD0_WORD0_b;
  } ;

  union {
    __IOM uint32_t EIM_EICHD0_WORD1;            /*!< (@ 0x00000104) Error Injection Channel Descriptor n, Word1                */

    struct {
      __IOM uint32_t B0_3DATA_MASK : 32;        /*!< [31..0] Data Mask Bytes 0-3                                               */
    } EIM_EICHD0_WORD1_b;
  } ;
} EIM_Type;                                     /*!< Size = 264 (0x108)                                                        */



/* =========================================================================================================================== */
/* ================                                           FTFC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief FTFC (FTFC)
  */

typedef struct {                                /*!< (@ 0x40020000) FTFC Structure                                             */

  union {
    __IOM uint8_t FTFC_FSTAT;                   /*!< (@ 0x00000000) Flash Status Register                                      */

    struct {
      __IM  uint8_t MGSTAT0     : 1;            /*!< [0..0] Memory Controller Command Completion Status Flag                   */
            uint8_t             : 3;
      __IOM uint8_t FPVIOL      : 1;            /*!< [4..4] Flash Protection Violation Flag                                    */
      __IOM uint8_t ACCERR      : 1;            /*!< [5..5] Flash Access Error Flag                                            */
      __IOM uint8_t RDCOLERR    : 1;            /*!< [6..6] FTFC Read Collision Error Flag                                     */
      __IOM uint8_t CCIF        : 1;            /*!< [7..7] Command Complete Interrupt Flag                                    */
    } FTFC_FSTAT_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCNFG;                   /*!< (@ 0x00000001) Flash Configuration Register                               */

    struct {
      __IM  uint8_t EEERDY      : 1;            /*!< [0..0] EEERDY                                                             */
      __IM  uint8_t RAMRDY      : 1;            /*!< [1..1] RAM Ready                                                          */
            uint8_t             : 2;
      __IOM uint8_t ERSSUSP     : 1;            /*!< [4..4] Erase Suspend                                                      */
      __IM  uint8_t ERSAREQ     : 1;            /*!< [5..5] Erase All Request                                                  */
      __IOM uint8_t RDCOLLIE    : 1;            /*!< [6..6] Read Collision Error Interrupt Enable                              */
      __IOM uint8_t CCIE        : 1;            /*!< [7..7] Command Complete Interrupt Enable                                  */
    } FTFC_FCNFG_b;
  } ;

  union {
    __IM  uint8_t FTFC_FSEC;                    /*!< (@ 0x00000002) Flash Security Register                                    */

    struct {
      __IM  uint8_t SEC         : 2;            /*!< [1..0] Flash Security                                                     */
      __IM  uint8_t FSLACC      : 2;            /*!< [3..2] Factory Failure Analysis Access Code                               */
      __IM  uint8_t MEEN        : 2;            /*!< [5..4] Mass Erase Enable Bits                                             */
      __IM  uint8_t KEYEN       : 2;            /*!< [7..6] Backdoor Key Security Enable                                       */
    } FTFC_FSEC_b;
  } ;

  union {
    __IM  uint8_t FTFC_FOPT;                    /*!< (@ 0x00000003) Flash Option Register                                      */

    struct {
      __IM  uint8_t OPT         : 8;            /*!< [7..0] Nonvolatile Option                                                 */
    } FTFC_FOPT_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOB3;                  /*!< (@ 0x00000004) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOB3_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOB2;                  /*!< (@ 0x00000005) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOB2_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOB1;                  /*!< (@ 0x00000006) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOB1_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOB0;                  /*!< (@ 0x00000007) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOB0_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOB7;                  /*!< (@ 0x00000008) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOB7_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOB6;                  /*!< (@ 0x00000009) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOB6_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOB5;                  /*!< (@ 0x0000000A) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOB5_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOB4;                  /*!< (@ 0x0000000B) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOB4_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOBB;                  /*!< (@ 0x0000000C) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOBB_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOBA;                  /*!< (@ 0x0000000D) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOBA_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOB9;                  /*!< (@ 0x0000000E) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOB9_b;
  } ;

  union {
    __IOM uint8_t FTFC_FCCOB8;                  /*!< (@ 0x0000000F) Flash Common Command Object Registers                      */

    struct {
      __IOM uint8_t CCOBn       : 8;            /*!< [7..0] CCOBn                                                              */
    } FTFC_FCCOB8_b;
  } ;

  union {
    __IOM uint8_t FTFC_FPROT3;                  /*!< (@ 0x00000010) Program Flash Protection Registers                         */

    struct {
      __IOM uint8_t PROT        : 8;            /*!< [7..0] Program Flash Region Protect                                       */
    } FTFC_FPROT3_b;
  } ;

  union {
    __IOM uint8_t FTFC_FPROT2;                  /*!< (@ 0x00000011) Program Flash Protection Registers                         */

    struct {
      __IOM uint8_t PROT        : 8;            /*!< [7..0] Program Flash Region Protect                                       */
    } FTFC_FPROT2_b;
  } ;

  union {
    __IOM uint8_t FTFC_FPROT1;                  /*!< (@ 0x00000012) Program Flash Protection Registers                         */

    struct {
      __IOM uint8_t PROT        : 8;            /*!< [7..0] Program Flash Region Protect                                       */
    } FTFC_FPROT1_b;
  } ;

  union {
    __IOM uint8_t FTFC_FPROT0;                  /*!< (@ 0x00000013) Program Flash Protection Registers                         */

    struct {
      __IOM uint8_t PROT        : 8;            /*!< [7..0] Program Flash Region Protect                                       */
    } FTFC_FPROT0_b;
  } ;
  __IM  uint8_t   RESERVED[2];

  union {
    __IOM uint8_t FTFC_FEPROT;                  /*!< (@ 0x00000016) EEPROM Protection Register                                 */

    struct {
      __IOM uint8_t EPROT       : 8;            /*!< [7..0] EEPROM Region Protect                                              */
    } FTFC_FEPROT_b;
  } ;

  union {
    __IOM uint8_t FTFC_FDPROT;                  /*!< (@ 0x00000017) Data Flash Protection Register                             */

    struct {
      __IOM uint8_t DPROT       : 8;            /*!< [7..0] Data Flash Region Protect                                          */
    } FTFC_FDPROT_b;
  } ;
  __IM  uint8_t   RESERVED1[20];

  union {
    __IM  uint8_t FTFC_FCSESTAT;                /*!< (@ 0x0000002C) Flash CSEc Status Register                                 */

    struct {
      __IM  uint8_t BSY         : 1;            /*!< [0..0] Busy                                                               */
      __IM  uint8_t SB          : 1;            /*!< [1..1] Secure Boot                                                        */
      __IM  uint8_t BIN         : 1;            /*!< [2..2] Secure Boot Initialization                                         */
      __IM  uint8_t BFN         : 1;            /*!< [3..3] Secure Boot Finished                                               */
      __IM  uint8_t BOK         : 1;            /*!< [4..4] Secure Boot OK                                                     */
      __IM  uint8_t RIN         : 1;            /*!< [5..5] Random Number Generator Initialized                                */
      __IM  uint8_t EDB         : 1;            /*!< [6..6] External Debug                                                     */
      __IM  uint8_t IDB         : 1;            /*!< [7..7] Internal Debug                                                     */
    } FTFC_FCSESTAT_b;
  } ;
  __IM  uint8_t   RESERVED2;

  union {
    __IOM uint8_t FTFC_FERSTAT;                 /*!< (@ 0x0000002E) Flash Error Status Register                                */

    struct {
            uint8_t             : 1;
      __IOM uint8_t DFDIF       : 1;            /*!< [1..1] Double Bit Fault Detect Interrupt Flag                             */
            uint8_t             : 6;
    } FTFC_FERSTAT_b;
  } ;

  union {
    __IOM uint8_t FTFC_FERCNFG;                 /*!< (@ 0x0000002F) Flash Error Configuration Register                         */

    struct {
            uint8_t             : 1;
      __IOM uint8_t DFDIE       : 1;            /*!< [1..1] Double Bit Fault Detect Interrupt Enable                           */
            uint8_t             : 3;
      __IOM uint8_t FDFD        : 1;            /*!< [5..5] Force Double Bit Fault Detect                                      */
            uint8_t             : 2;
    } FTFC_FERCNFG_b;
  } ;
} FTFC_Type;                                    /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                          DMAMUX                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief DMA channel multiplexor (DMAMUX)
  */

typedef struct {                                /*!< (@ 0x40021000) DMAMUX Structure                                           */

  union {
    __IOM uint8_t DMAMUX_CHCFG0;                /*!< (@ 0x00000000) Channel Configuration register                             */

    struct {
      __IOM uint8_t SOURCE      : 6;            /*!< [5..0] DMA Channel Source (Slot)                                          */
      __IOM uint8_t TRIG        : 1;            /*!< [6..6] DMA Channel Trigger Enable                                         */
      __IOM uint8_t ENBL        : 1;            /*!< [7..7] DMA Channel Enable                                                 */
    } DMAMUX_CHCFG0_b;
  } ;

  union {
    __IOM uint8_t DMAMUX_CHCFG1;                /*!< (@ 0x00000001) Channel Configuration register                             */

    struct {
      __IOM uint8_t SOURCE      : 6;            /*!< [5..0] DMA Channel Source (Slot)                                          */
      __IOM uint8_t TRIG        : 1;            /*!< [6..6] DMA Channel Trigger Enable                                         */
      __IOM uint8_t ENBL        : 1;            /*!< [7..7] DMA Channel Enable                                                 */
    } DMAMUX_CHCFG1_b;
  } ;

  union {
    __IOM uint8_t DMAMUX_CHCFG2;                /*!< (@ 0x00000002) Channel Configuration register                             */

    struct {
      __IOM uint8_t SOURCE      : 6;            /*!< [5..0] DMA Channel Source (Slot)                                          */
      __IOM uint8_t TRIG        : 1;            /*!< [6..6] DMA Channel Trigger Enable                                         */
      __IOM uint8_t ENBL        : 1;            /*!< [7..7] DMA Channel Enable                                                 */
    } DMAMUX_CHCFG2_b;
  } ;

  union {
    __IOM uint8_t DMAMUX_CHCFG3;                /*!< (@ 0x00000003) Channel Configuration register                             */

    struct {
      __IOM uint8_t SOURCE      : 6;            /*!< [5..0] DMA Channel Source (Slot)                                          */
      __IOM uint8_t TRIG        : 1;            /*!< [6..6] DMA Channel Trigger Enable                                         */
      __IOM uint8_t ENBL        : 1;            /*!< [7..7] DMA Channel Enable                                                 */
    } DMAMUX_CHCFG3_b;
  } ;
} DMAMUX_Type;                                  /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                           CAN0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Flex Controller Area Network module (CAN0)
  */

typedef struct {                                /*!< (@ 0x40024000) CAN0 Structure                                             */

  union {
    __IOM uint32_t CAN0_MCR;                    /*!< (@ 0x00000000) Module Configuration Register                              */

    struct {
      __IOM uint32_t MAXMB      : 7;            /*!< [6..0] Number Of The Last Message Buffer                                  */
            uint32_t            : 1;
      __IOM uint32_t IDAM       : 2;            /*!< [9..8] ID Acceptance Mode                                                 */
            uint32_t            : 1;
      __IOM uint32_t FDEN       : 1;            /*!< [11..11] CAN FD operation enable                                          */
      __IOM uint32_t AEN        : 1;            /*!< [12..12] Abort Enable                                                     */
      __IOM uint32_t LPRIOEN    : 1;            /*!< [13..13] Local Priority Enable                                            */
      __IOM uint32_t PNET_EN    : 1;            /*!< [14..14] Pretended Networking Enable                                      */
      __IOM uint32_t DMA        : 1;            /*!< [15..15] DMA Enable                                                       */
      __IOM uint32_t IRMQ       : 1;            /*!< [16..16] Individual Rx Masking And Queue Enable                           */
      __IOM uint32_t SRXDIS     : 1;            /*!< [17..17] Self Reception Disable                                           */
            uint32_t            : 2;
      __IM  uint32_t LPMACK     : 1;            /*!< [20..20] Low-Power Mode Acknowledge                                       */
      __IOM uint32_t WRNEN      : 1;            /*!< [21..21] Warning Interrupt Enable                                         */
            uint32_t            : 1;
      __IOM uint32_t SUPV       : 1;            /*!< [23..23] Supervisor Mode                                                  */
      __IM  uint32_t FRZACK     : 1;            /*!< [24..24] Freeze Mode Acknowledge                                          */
      __IOM uint32_t SOFTRST    : 1;            /*!< [25..25] Soft Reset                                                       */
            uint32_t            : 1;
      __IM  uint32_t NOTRDY     : 1;            /*!< [27..27] FlexCAN Not Ready                                                */
      __IOM uint32_t HALT       : 1;            /*!< [28..28] Halt FlexCAN                                                     */
      __IOM uint32_t RFEN       : 1;            /*!< [29..29] Rx FIFO Enable                                                   */
      __IOM uint32_t FRZ        : 1;            /*!< [30..30] Freeze Enable                                                    */
      __IOM uint32_t MDIS       : 1;            /*!< [31..31] Module Disable                                                   */
    } CAN0_MCR_b;
  } ;

  union {
    __IOM uint32_t CAN0_CTRL1;                  /*!< (@ 0x00000004) Control 1 register                                         */

    struct {
      __IOM uint32_t PROPSEG    : 3;            /*!< [2..0] Propagation Segment                                                */
      __IOM uint32_t LOM        : 1;            /*!< [3..3] Listen-Only Mode                                                   */
      __IOM uint32_t LBUF       : 1;            /*!< [4..4] Lowest Buffer Transmitted First                                    */
      __IOM uint32_t TSYN       : 1;            /*!< [5..5] Timer Sync                                                         */
      __IOM uint32_t BOFFREC    : 1;            /*!< [6..6] Bus Off Recovery                                                   */
      __IOM uint32_t SMP        : 1;            /*!< [7..7] CAN Bit Sampling                                                   */
            uint32_t            : 2;
      __IOM uint32_t RWRNMSK    : 1;            /*!< [10..10] Rx Warning Interrupt Mask                                        */
      __IOM uint32_t TWRNMSK    : 1;            /*!< [11..11] Tx Warning Interrupt Mask                                        */
      __IOM uint32_t LPB        : 1;            /*!< [12..12] Loop Back Mode                                                   */
      __IOM uint32_t CLKSRC     : 1;            /*!< [13..13] CAN Engine Clock Source                                          */
      __IOM uint32_t ERRMSK     : 1;            /*!< [14..14] Error Interrupt Mask                                             */
      __IOM uint32_t BOFFMSK    : 1;            /*!< [15..15] Bus Off Interrupt Mask                                           */
      __IOM uint32_t PSEG2      : 3;            /*!< [18..16] Phase Segment 2                                                  */
      __IOM uint32_t PSEG1      : 3;            /*!< [21..19] Phase Segment 1                                                  */
      __IOM uint32_t RJW        : 2;            /*!< [23..22] Resync Jump Width                                                */
      __IOM uint32_t PRESDIV    : 8;            /*!< [31..24] Prescaler Division Factor                                        */
    } CAN0_CTRL1_b;
  } ;

  union {
    __IOM uint32_t CAN0_TIMER;                  /*!< (@ 0x00000008) Free Running Timer                                         */

    struct {
      __IOM uint32_t TIMER      : 16;           /*!< [15..0] Timer Value                                                       */
            uint32_t            : 16;
    } CAN0_TIMER_b;
  } ;
  __IM  uint32_t  RESERVED;

  union {
    __IOM uint32_t CAN0_RXMGMASK;               /*!< (@ 0x00000010) Rx Mailboxes Global Mask Register                          */

    struct {
      __IOM uint32_t MG         : 32;           /*!< [31..0] Rx Mailboxes Global Mask Bits                                     */
    } CAN0_RXMGMASK_b;
  } ;

  union {
    __IOM uint32_t CAN0_RX14MASK;               /*!< (@ 0x00000014) Rx 14 Mask register                                        */

    struct {
      __IOM uint32_t RX14M      : 32;           /*!< [31..0] Rx Buffer 14 Mask Bits                                            */
    } CAN0_RX14MASK_b;
  } ;

  union {
    __IOM uint32_t CAN0_RX15MASK;               /*!< (@ 0x00000018) Rx 15 Mask register                                        */

    struct {
      __IOM uint32_t RX15M      : 32;           /*!< [31..0] Rx Buffer 15 Mask Bits                                            */
    } CAN0_RX15MASK_b;
  } ;

  union {
    __IOM uint32_t CAN0_ECR;                    /*!< (@ 0x0000001C) Error Counter                                              */

    struct {
      __IOM uint32_t TXERRCNT   : 8;            /*!< [7..0] Transmit Error Counter                                             */
      __IOM uint32_t RXERRCNT   : 8;            /*!< [15..8] Receive Error Counter                                             */
      __IOM uint32_t TXERRCNT_FAST : 8;         /*!< [23..16] Transmit Error Counter for fast bits                             */
      __IOM uint32_t RXERRCNT_FAST : 8;         /*!< [31..24] Receive Error Counter for fast bits                              */
    } CAN0_ECR_b;
  } ;

  union {
    __IOM uint32_t CAN0_ESR1;                   /*!< (@ 0x00000020) Error and Status 1 register                                */

    struct {
            uint32_t            : 1;
      __IOM uint32_t ERRINT     : 1;            /*!< [1..1] Error Interrupt                                                    */
      __IOM uint32_t BOFFINT    : 1;            /*!< [2..2] Bus Off Interrupt                                                  */
      __IM  uint32_t RX         : 1;            /*!< [3..3] FlexCAN In Reception                                               */
      __IM  uint32_t FLTCONF    : 2;            /*!< [5..4] Fault Confinement State                                            */
      __IM  uint32_t TX         : 1;            /*!< [6..6] FlexCAN In Transmission                                            */
      __IM  uint32_t IDLE       : 1;            /*!< [7..7] IDLE                                                               */
      __IM  uint32_t RXWRN      : 1;            /*!< [8..8] Rx Error Warning                                                   */
      __IM  uint32_t TXWRN      : 1;            /*!< [9..9] TX Error Warning                                                   */
      __IM  uint32_t STFERR     : 1;            /*!< [10..10] Stuffing Error                                                   */
      __IM  uint32_t FRMERR     : 1;            /*!< [11..11] Form Error                                                       */
      __IM  uint32_t CRCERR     : 1;            /*!< [12..12] Cyclic Redundancy Check Error                                    */
      __IM  uint32_t ACKERR     : 1;            /*!< [13..13] Acknowledge Error                                                */
      __IM  uint32_t BIT0ERR    : 1;            /*!< [14..14] Bit0 Error                                                       */
      __IM  uint32_t BIT1ERR    : 1;            /*!< [15..15] Bit1 Error                                                       */
      __IOM uint32_t RWRNINT    : 1;            /*!< [16..16] Rx Warning Interrupt Flag                                        */
      __IOM uint32_t TWRNINT    : 1;            /*!< [17..17] Tx Warning Interrupt Flag                                        */
      __IM  uint32_t SYNCH      : 1;            /*!< [18..18] CAN Synchronization Status                                       */
      __IOM uint32_t BOFFDONEINT : 1;           /*!< [19..19] Bus Off Done Interrupt                                           */
      __IOM uint32_t ERRINT_FAST : 1;           /*!< [20..20] Error Interrupt for errors detected in the Data Phase
                                                     of CAN FD frames with the BRS bit set                                     */
      __IOM uint32_t ERROVR     : 1;            /*!< [21..21] Error Overrun bit                                                */
            uint32_t            : 4;
      __IM  uint32_t STFERR_FAST : 1;           /*!< [26..26] Stuffing Error in the Data Phase of CAN FD frames with
                                                     the BRS bit set                                                           */
      __IM  uint32_t FRMERR_FAST : 1;           /*!< [27..27] Form Error in the Data Phase of CAN FD frames with
                                                     the BRS bit set                                                           */
      __IM  uint32_t CRCERR_FAST : 1;           /*!< [28..28] Cyclic Redundancy Check Error in the CRC field of CAN
                                                     FD frames with the BRS bit set                                            */
            uint32_t            : 1;
      __IM  uint32_t BIT0ERR_FAST : 1;          /*!< [30..30] Bit0 Error in the Data Phase of CAN FD frames with
                                                     the BRS bit set                                                           */
      __IM  uint32_t BIT1ERR_FAST : 1;          /*!< [31..31] Bit1 Error in the Data Phase of CAN FD frames with
                                                     the BRS bit set                                                           */
    } CAN0_ESR1_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t CAN0_IMASK1;                 /*!< (@ 0x00000028) Interrupt Masks 1 register                                 */

    struct {
      __IOM uint32_t BUF31TO0M  : 32;           /*!< [31..0] Buffer MB i Mask                                                  */
    } CAN0_IMASK1_b;
  } ;
  __IM  uint32_t  RESERVED2;

  union {
    __IOM uint32_t CAN0_IFLAG1;                 /*!< (@ 0x00000030) Interrupt Flags 1 register                                 */

    struct {
      __IOM uint32_t BUF0I      : 1;            /*!< [0..0] Buffer MB0 Interrupt Or Clear FIFO bit                             */
      __IOM uint32_t BUF4TO1I   : 4;            /*!< [4..1] Buffer MB i Interrupt Or 'reserved'                                */
      __IOM uint32_t BUF5I      : 1;            /*!< [5..5] Buffer MB5 Interrupt Or 'Frames available in Rx FIFO'              */
      __IOM uint32_t BUF6I      : 1;            /*!< [6..6] Buffer MB6 Interrupt Or 'Rx FIFO Warning'                          */
      __IOM uint32_t BUF7I      : 1;            /*!< [7..7] Buffer MB7 Interrupt Or 'Rx FIFO Overflow'                         */
      __IOM uint32_t BUF31TO8I  : 24;           /*!< [31..8] Buffer MBi Interrupt                                              */
    } CAN0_IFLAG1_b;
  } ;

  union {
    __IOM uint32_t CAN0_CTRL2;                  /*!< (@ 0x00000034) Control 2 register                                         */

    struct {
            uint32_t            : 11;
      __IOM uint32_t EDFLTDIS   : 1;            /*!< [11..11] Edge Filter Disable                                              */
      __IOM uint32_t ISOCANFDEN : 1;            /*!< [12..12] ISO CAN FD Enable                                                */
            uint32_t            : 1;
      __IOM uint32_t PREXCEN    : 1;            /*!< [14..14] Protocol Exception Enable                                        */
      __IOM uint32_t TIMER_SRC  : 1;            /*!< [15..15] Timer Source                                                     */
      __IOM uint32_t EACEN      : 1;            /*!< [16..16] Entire Frame Arbitration Field Comparison Enable For
                                                     Rx Mailboxes                                                              */
      __IOM uint32_t RRS        : 1;            /*!< [17..17] Remote Request Storing                                           */
      __IOM uint32_t MRP        : 1;            /*!< [18..18] Mailboxes Reception Priority                                     */
      __IOM uint32_t TASD       : 5;            /*!< [23..19] Tx Arbitration Start Delay                                       */
      __IOM uint32_t RFFN       : 4;            /*!< [27..24] Number Of Rx FIFO Filters                                        */
            uint32_t            : 2;
      __IOM uint32_t BOFFDONEMSK : 1;           /*!< [30..30] Bus Off Done Interrupt Mask                                      */
      __IOM uint32_t ERRMSK_FAST : 1;           /*!< [31..31] Error Interrupt Mask for errors detected in the Data
                                                     Phase of fast CAN FD frames                                               */
    } CAN0_CTRL2_b;
  } ;

  union {
    __IM  uint32_t CAN0_ESR2;                   /*!< (@ 0x00000038) Error and Status 2 register                                */

    struct {
            uint32_t            : 13;
      __IM  uint32_t IMB        : 1;            /*!< [13..13] Inactive Mailbox                                                 */
      __IM  uint32_t VPS        : 1;            /*!< [14..14] Valid Priority Status                                            */
            uint32_t            : 1;
      __IM  uint32_t LPTM       : 7;            /*!< [22..16] Lowest Priority Tx Mailbox                                       */
            uint32_t            : 9;
    } CAN0_ESR2_b;
  } ;
  __IM  uint32_t  RESERVED3[2];

  union {
    __IM  uint32_t CAN0_CRCR;                   /*!< (@ 0x00000044) CRC Register                                               */

    struct {
      __IM  uint32_t TXCRC      : 15;           /*!< [14..0] Transmitted CRC value                                             */
            uint32_t            : 1;
      __IM  uint32_t MBCRC      : 7;            /*!< [22..16] CRC Mailbox                                                      */
            uint32_t            : 9;
    } CAN0_CRCR_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXFGMASK;               /*!< (@ 0x00000048) Rx FIFO Global Mask register                               */

    struct {
      __IOM uint32_t FGM        : 32;           /*!< [31..0] Rx FIFO Global Mask Bits                                          */
    } CAN0_RXFGMASK_b;
  } ;

  union {
    __IM  uint32_t CAN0_RXFIR;                  /*!< (@ 0x0000004C) Rx FIFO Information Register                               */

    struct {
      __IM  uint32_t IDHIT      : 9;            /*!< [8..0] Identifier Acceptance Filter Hit Indicator                         */
            uint32_t            : 23;
    } CAN0_RXFIR_b;
  } ;

  union {
    __IOM uint32_t CAN0_CBT;                    /*!< (@ 0x00000050) CAN Bit Timing Register                                    */

    struct {
      __IOM uint32_t EPSEG2     : 5;            /*!< [4..0] Extended Phase Segment 2                                           */
      __IOM uint32_t EPSEG1     : 5;            /*!< [9..5] Extended Phase Segment 1                                           */
      __IOM uint32_t EPROPSEG   : 6;            /*!< [15..10] Extended Propagation Segment                                     */
      __IOM uint32_t ERJW       : 5;            /*!< [20..16] Extended Resync Jump Width                                       */
      __IOM uint32_t EPRESDIV   : 10;           /*!< [30..21] Extended Prescaler Division Factor                               */
      __IOM uint32_t BTF        : 1;            /*!< [31..31] Bit Timing Format Enable                                         */
    } CAN0_CBT_b;
  } ;
  __IM  uint32_t  RESERVED4[11];

  union {
    __IOM uint32_t CAN0_RAMn0;                  /*!< (@ 0x00000080) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn0_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn1;                  /*!< (@ 0x00000084) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn1_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn2;                  /*!< (@ 0x00000088) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn2_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn3;                  /*!< (@ 0x0000008C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn3_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn4;                  /*!< (@ 0x00000090) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn4_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn5;                  /*!< (@ 0x00000094) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn5_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn6;                  /*!< (@ 0x00000098) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn6_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn7;                  /*!< (@ 0x0000009C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn7_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn8;                  /*!< (@ 0x000000A0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn8_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn9;                  /*!< (@ 0x000000A4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn9_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn10;                 /*!< (@ 0x000000A8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn10_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn11;                 /*!< (@ 0x000000AC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn11_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn12;                 /*!< (@ 0x000000B0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn12_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn13;                 /*!< (@ 0x000000B4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn13_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn14;                 /*!< (@ 0x000000B8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn14_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn15;                 /*!< (@ 0x000000BC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn15_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn16;                 /*!< (@ 0x000000C0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn16_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn17;                 /*!< (@ 0x000000C4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn17_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn18;                 /*!< (@ 0x000000C8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn18_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn19;                 /*!< (@ 0x000000CC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn19_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn20;                 /*!< (@ 0x000000D0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn20_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn21;                 /*!< (@ 0x000000D4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn21_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn22;                 /*!< (@ 0x000000D8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn22_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn23;                 /*!< (@ 0x000000DC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn23_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn24;                 /*!< (@ 0x000000E0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn24_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn25;                 /*!< (@ 0x000000E4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn25_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn26;                 /*!< (@ 0x000000E8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn26_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn27;                 /*!< (@ 0x000000EC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn27_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn28;                 /*!< (@ 0x000000F0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn28_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn29;                 /*!< (@ 0x000000F4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn29_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn30;                 /*!< (@ 0x000000F8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn30_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn31;                 /*!< (@ 0x000000FC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn31_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn32;                 /*!< (@ 0x00000100) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn32_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn33;                 /*!< (@ 0x00000104) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn33_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn34;                 /*!< (@ 0x00000108) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn34_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn35;                 /*!< (@ 0x0000010C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn35_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn36;                 /*!< (@ 0x00000110) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn36_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn37;                 /*!< (@ 0x00000114) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn37_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn38;                 /*!< (@ 0x00000118) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn38_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn39;                 /*!< (@ 0x0000011C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn39_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn40;                 /*!< (@ 0x00000120) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn40_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn41;                 /*!< (@ 0x00000124) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn41_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn42;                 /*!< (@ 0x00000128) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn42_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn43;                 /*!< (@ 0x0000012C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn43_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn44;                 /*!< (@ 0x00000130) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn44_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn45;                 /*!< (@ 0x00000134) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn45_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn46;                 /*!< (@ 0x00000138) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn46_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn47;                 /*!< (@ 0x0000013C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn47_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn48;                 /*!< (@ 0x00000140) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn48_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn49;                 /*!< (@ 0x00000144) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn49_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn50;                 /*!< (@ 0x00000148) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn50_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn51;                 /*!< (@ 0x0000014C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn51_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn52;                 /*!< (@ 0x00000150) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn52_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn53;                 /*!< (@ 0x00000154) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn53_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn54;                 /*!< (@ 0x00000158) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn54_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn55;                 /*!< (@ 0x0000015C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn55_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn56;                 /*!< (@ 0x00000160) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn56_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn57;                 /*!< (@ 0x00000164) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn57_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn58;                 /*!< (@ 0x00000168) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn58_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn59;                 /*!< (@ 0x0000016C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn59_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn60;                 /*!< (@ 0x00000170) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn60_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn61;                 /*!< (@ 0x00000174) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn61_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn62;                 /*!< (@ 0x00000178) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn62_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn63;                 /*!< (@ 0x0000017C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn63_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn64;                 /*!< (@ 0x00000180) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn64_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn65;                 /*!< (@ 0x00000184) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn65_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn66;                 /*!< (@ 0x00000188) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn66_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn67;                 /*!< (@ 0x0000018C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn67_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn68;                 /*!< (@ 0x00000190) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn68_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn69;                 /*!< (@ 0x00000194) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn69_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn70;                 /*!< (@ 0x00000198) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn70_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn71;                 /*!< (@ 0x0000019C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn71_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn72;                 /*!< (@ 0x000001A0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn72_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn73;                 /*!< (@ 0x000001A4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn73_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn74;                 /*!< (@ 0x000001A8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn74_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn75;                 /*!< (@ 0x000001AC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn75_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn76;                 /*!< (@ 0x000001B0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn76_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn77;                 /*!< (@ 0x000001B4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn77_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn78;                 /*!< (@ 0x000001B8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn78_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn79;                 /*!< (@ 0x000001BC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn79_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn80;                 /*!< (@ 0x000001C0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn80_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn81;                 /*!< (@ 0x000001C4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn81_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn82;                 /*!< (@ 0x000001C8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn82_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn83;                 /*!< (@ 0x000001CC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn83_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn84;                 /*!< (@ 0x000001D0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn84_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn85;                 /*!< (@ 0x000001D4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn85_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn86;                 /*!< (@ 0x000001D8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn86_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn87;                 /*!< (@ 0x000001DC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn87_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn88;                 /*!< (@ 0x000001E0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn88_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn89;                 /*!< (@ 0x000001E4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn89_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn90;                 /*!< (@ 0x000001E8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn90_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn91;                 /*!< (@ 0x000001EC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn91_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn92;                 /*!< (@ 0x000001F0) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn92_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn93;                 /*!< (@ 0x000001F4) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn93_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn94;                 /*!< (@ 0x000001F8) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn94_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn95;                 /*!< (@ 0x000001FC) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn95_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn96;                 /*!< (@ 0x00000200) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn96_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn97;                 /*!< (@ 0x00000204) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn97_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn98;                 /*!< (@ 0x00000208) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn98_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn99;                 /*!< (@ 0x0000020C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn99_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn100;                /*!< (@ 0x00000210) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn100_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn101;                /*!< (@ 0x00000214) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn101_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn102;                /*!< (@ 0x00000218) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn102_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn103;                /*!< (@ 0x0000021C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn103_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn104;                /*!< (@ 0x00000220) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn104_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn105;                /*!< (@ 0x00000224) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn105_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn106;                /*!< (@ 0x00000228) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn106_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn107;                /*!< (@ 0x0000022C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn107_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn108;                /*!< (@ 0x00000230) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn108_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn109;                /*!< (@ 0x00000234) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn109_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn110;                /*!< (@ 0x00000238) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn110_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn111;                /*!< (@ 0x0000023C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn111_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn112;                /*!< (@ 0x00000240) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn112_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn113;                /*!< (@ 0x00000244) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn113_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn114;                /*!< (@ 0x00000248) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn114_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn115;                /*!< (@ 0x0000024C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn115_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn116;                /*!< (@ 0x00000250) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn116_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn117;                /*!< (@ 0x00000254) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn117_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn118;                /*!< (@ 0x00000258) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn118_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn119;                /*!< (@ 0x0000025C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn119_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn120;                /*!< (@ 0x00000260) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn120_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn121;                /*!< (@ 0x00000264) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn121_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn122;                /*!< (@ 0x00000268) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn122_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn123;                /*!< (@ 0x0000026C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn123_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn124;                /*!< (@ 0x00000270) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn124_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn125;                /*!< (@ 0x00000274) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn125_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn126;                /*!< (@ 0x00000278) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn126_b;
  } ;

  union {
    __IOM uint32_t CAN0_RAMn127;                /*!< (@ 0x0000027C) Embedded RAM                                               */

    struct {
      __IOM uint32_t DATA_BYTE_3 : 8;           /*!< [7..0] Data byte 3 of Rx/Tx frame.                                        */
      __IOM uint32_t DATA_BYTE_2 : 8;           /*!< [15..8] Data byte 2 of Rx/Tx frame.                                       */
      __IOM uint32_t DATA_BYTE_1 : 8;           /*!< [23..16] Data byte 1 of Rx/Tx frame.                                      */
      __IOM uint32_t DATA_BYTE_0 : 8;           /*!< [31..24] Data byte 0 of Rx/Tx frame.                                      */
    } CAN0_RAMn127_b;
  } ;
  __IM  uint32_t  RESERVED5[384];

  union {
    __IOM uint32_t CAN0_RXIMR0;                 /*!< (@ 0x00000880) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR0_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR1;                 /*!< (@ 0x00000884) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR1_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR2;                 /*!< (@ 0x00000888) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR2_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR3;                 /*!< (@ 0x0000088C) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR3_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR4;                 /*!< (@ 0x00000890) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR4_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR5;                 /*!< (@ 0x00000894) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR5_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR6;                 /*!< (@ 0x00000898) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR6_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR7;                 /*!< (@ 0x0000089C) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR7_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR8;                 /*!< (@ 0x000008A0) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR8_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR9;                 /*!< (@ 0x000008A4) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR9_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR10;                /*!< (@ 0x000008A8) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR10_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR11;                /*!< (@ 0x000008AC) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR11_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR12;                /*!< (@ 0x000008B0) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR12_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR13;                /*!< (@ 0x000008B4) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR13_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR14;                /*!< (@ 0x000008B8) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR14_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR15;                /*!< (@ 0x000008BC) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR15_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR16;                /*!< (@ 0x000008C0) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR16_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR17;                /*!< (@ 0x000008C4) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR17_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR18;                /*!< (@ 0x000008C8) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR18_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR19;                /*!< (@ 0x000008CC) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR19_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR20;                /*!< (@ 0x000008D0) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR20_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR21;                /*!< (@ 0x000008D4) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR21_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR22;                /*!< (@ 0x000008D8) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR22_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR23;                /*!< (@ 0x000008DC) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR23_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR24;                /*!< (@ 0x000008E0) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR24_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR25;                /*!< (@ 0x000008E4) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR25_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR26;                /*!< (@ 0x000008E8) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR26_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR27;                /*!< (@ 0x000008EC) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR27_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR28;                /*!< (@ 0x000008F0) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR28_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR29;                /*!< (@ 0x000008F4) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR29_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR30;                /*!< (@ 0x000008F8) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR30_b;
  } ;

  union {
    __IOM uint32_t CAN0_RXIMR31;                /*!< (@ 0x000008FC) Rx Individual Mask Registers                               */

    struct {
      __IOM uint32_t MI         : 32;           /*!< [31..0] Individual Mask Bits                                              */
    } CAN0_RXIMR31_b;
  } ;
  __IM  uint32_t  RESERVED6[128];

  union {
    __IOM uint32_t CAN0_CTRL1_PN;               /*!< (@ 0x00000B00) Pretended Networking Control 1 Register                    */

    struct {
      __IOM uint32_t FCS        : 2;            /*!< [1..0] Filtering Combination Selection                                    */
      __IOM uint32_t IDFS       : 2;            /*!< [3..2] ID Filtering Selection                                             */
      __IOM uint32_t PLFS       : 2;            /*!< [5..4] Payload Filtering Selection                                        */
            uint32_t            : 2;
      __IOM uint32_t NMATCH     : 8;            /*!< [15..8] Number of Messages Matching the Same Filtering Criteria           */
      __IOM uint32_t WUMF_MSK   : 1;            /*!< [16..16] Wake Up by Match Flag Mask Bit                                   */
      __IOM uint32_t WTOF_MSK   : 1;            /*!< [17..17] Wake Up by Timeout Flag Mask Bit                                 */
            uint32_t            : 14;
    } CAN0_CTRL1_PN_b;
  } ;

  union {
    __IOM uint32_t CAN0_CTRL2_PN;               /*!< (@ 0x00000B04) Pretended Networking Control 2 Register                    */

    struct {
      __IOM uint32_t MATCHTO    : 16;           /*!< [15..0] Timeout for No Message Matching the Filtering Criteria            */
            uint32_t            : 16;
    } CAN0_CTRL2_PN_b;
  } ;

  union {
    __IOM uint32_t CAN0_WU_MTC;                 /*!< (@ 0x00000B08) Pretended Networking Wake Up Match Register                */

    struct {
            uint32_t            : 8;
      __IM  uint32_t MCOUNTER   : 8;            /*!< [15..8] Number of Matches while in Pretended Networking                   */
      __IOM uint32_t WUMF       : 1;            /*!< [16..16] Wake Up by Match Flag Bit                                        */
      __IOM uint32_t WTOF       : 1;            /*!< [17..17] Wake Up by Timeout Flag Bit                                      */
            uint32_t            : 14;
    } CAN0_WU_MTC_b;
  } ;

  union {
    __IOM uint32_t CAN0_FLT_ID1;                /*!< (@ 0x00000B0C) Pretended Networking ID Filter 1 Register                  */

    struct {
      __IOM uint32_t FLT_ID1    : 29;           /*!< [28..0] ID Filter 1 for Pretended Networking filtering                    */
      __IOM uint32_t FLT_RTR    : 1;            /*!< [29..29] Remote Transmission Request Filter                               */
      __IOM uint32_t FLT_IDE    : 1;            /*!< [30..30] ID Extended Filter                                               */
            uint32_t            : 1;
    } CAN0_FLT_ID1_b;
  } ;

  union {
    __IOM uint32_t CAN0_FLT_DLC;                /*!< (@ 0x00000B10) Pretended Networking DLC Filter Register                   */

    struct {
      __IOM uint32_t FLT_DLC_HI : 4;            /*!< [3..0] Upper Limit for Length of Data Bytes Filter                        */
            uint32_t            : 12;
      __IOM uint32_t FLT_DLC_LO : 4;            /*!< [19..16] Lower Limit for Length of Data Bytes Filter                      */
            uint32_t            : 12;
    } CAN0_FLT_DLC_b;
  } ;

  union {
    __IOM uint32_t CAN0_PL1_LO;                 /*!< (@ 0x00000B14) Pretended Networking Payload Low Filter 1 Register         */

    struct {
      __IOM uint32_t Data_byte_3 : 8;           /*!< [7..0] Payload Filter 1 low order bits for Pretended Networking
                                                     payload filtering corresponding to the data byte 3.                       */
      __IOM uint32_t Data_byte_2 : 8;           /*!< [15..8] Payload Filter 1 low order bits for Pretended Networking
                                                     payload filtering corresponding to the data byte 2.                       */
      __IOM uint32_t Data_byte_1 : 8;           /*!< [23..16] Payload Filter 1 low order bits for Pretended Networking
                                                     payload filtering corresponding to the data byte 1.                       */
      __IOM uint32_t Data_byte_0 : 8;           /*!< [31..24] Payload Filter 1 low order bits for Pretended Networking
                                                     payload filtering corresponding to the data byte 0.                       */
    } CAN0_PL1_LO_b;
  } ;

  union {
    __IOM uint32_t CAN0_PL1_HI;                 /*!< (@ 0x00000B18) Pretended Networking Payload High Filter 1 Register        */

    struct {
      __IOM uint32_t Data_byte_7 : 8;           /*!< [7..0] Payload Filter 1 high order bits for Pretended Networking
                                                     payload filtering corresponding to the data byte 7.                       */
      __IOM uint32_t Data_byte_6 : 8;           /*!< [15..8] Payload Filter 1 high order bits for Pretended Networking
                                                     payload filtering corresponding to the data byte 6.                       */
      __IOM uint32_t Data_byte_5 : 8;           /*!< [23..16] Payload Filter 1 high order bits for Pretended Networking
                                                     payload filtering corresponding to the data byte 5.                       */
      __IOM uint32_t Data_byte_4 : 8;           /*!< [31..24] Payload Filter 1 high order bits for Pretended Networking
                                                     payload filtering corresponding to the data byte 4.                       */
    } CAN0_PL1_HI_b;
  } ;

  union {
    __IOM uint32_t CAN0_FLT_ID2_IDMASK;         /*!< (@ 0x00000B1C) Pretended Networking ID Filter 2 Register / ID
                                                                    Mask Register                                              */

    struct {
      __IOM uint32_t FLT_ID2_IDMASK : 29;       /*!< [28..0] ID Filter 2 for Pretended Networking Filtering / ID
                                                     Mask Bits for Pretended Networking ID Filtering                           */
      __IOM uint32_t RTR_MSK    : 1;            /*!< [29..29] Remote Transmission Request Mask Bit                             */
      __IOM uint32_t IDE_MSK    : 1;            /*!< [30..30] ID Extended Mask Bit                                             */
            uint32_t            : 1;
    } CAN0_FLT_ID2_IDMASK_b;
  } ;

  union {
    __IOM uint32_t CAN0_PL2_PLMASK_LO;          /*!< (@ 0x00000B20) Pretended Networking Payload Low Filter 2 Register
                                                                    / Payload Low Mask Register                                */

    struct {
      __IOM uint32_t Data_byte_3 : 8;           /*!< [7..0] Payload Filter 2 low order bits / Payload Mask low order
                                                     bits for Pretended Networking payload filtering corresponding
                                                     to the data byte 3.                                                       */
      __IOM uint32_t Data_byte_2 : 8;           /*!< [15..8] Payload Filter 2 low order bits / Payload Mask low order
                                                     bits for Pretended Networking payload filtering corresponding
                                                     to the data byte 2.                                                       */
      __IOM uint32_t Data_byte_1 : 8;           /*!< [23..16] Payload Filter 2 low order bits / Payload Mask low
                                                     order bits for Pretended Networking payload filtering corresponding
                                                     to the data byte 1.                                                       */
      __IOM uint32_t Data_byte_0 : 8;           /*!< [31..24] Payload Filter 2 low order bits / Payload Mask low
                                                     order bits for Pretended Networking payload filtering corresponding
                                                     to the data byte 0.                                                       */
    } CAN0_PL2_PLMASK_LO_b;
  } ;

  union {
    __IOM uint32_t CAN0_PL2_PLMASK_HI;          /*!< (@ 0x00000B24) Pretended Networking Payload High Filter 2 low
                                                                    order bits / Payload High Mask Register                    */

    struct {
      __IOM uint32_t Data_byte_7 : 8;           /*!< [7..0] Payload Filter 2 high order bits / Payload Mask high
                                                     order bits for Pretended Networking payload filtering corresponding
                                                     to the data byte 7.                                                       */
      __IOM uint32_t Data_byte_6 : 8;           /*!< [15..8] Payload Filter 2 high order bits / Payload Mask high
                                                     order bits for Pretended Networking payload filtering corresponding
                                                     to the data byte 6.                                                       */
      __IOM uint32_t Data_byte_5 : 8;           /*!< [23..16] Payload Filter 2 high order bits / Payload Mask high
                                                     order bits for Pretended Networking payload filtering corresponding
                                                     to the data byte 5.                                                       */
      __IOM uint32_t Data_byte_4 : 8;           /*!< [31..24] Payload Filter 2 high order bits / Payload Mask high
                                                     order bits for Pretended Networking payload filtering corresponding
                                                     to the data byte 4.                                                       */
    } CAN0_PL2_PLMASK_HI_b;
  } ;
  __IM  uint32_t  RESERVED7[6];

  union {
    __IM  uint32_t CAN0_WMB0_CS;                /*!< (@ 0x00000B40) Wake Up Message Buffer Register for C/S                    */

    struct {
            uint32_t            : 16;
      __IM  uint32_t DLC        : 4;            /*!< [19..16] Length of Data in Bytes                                          */
      __IM  uint32_t RTR        : 1;            /*!< [20..20] Remote Transmission Request Bit                                  */
      __IM  uint32_t IDE        : 1;            /*!< [21..21] ID Extended Bit                                                  */
      __IM  uint32_t SRR        : 1;            /*!< [22..22] Substitute Remote Request                                        */
            uint32_t            : 9;
    } CAN0_WMB0_CS_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB0_ID;                /*!< (@ 0x00000B44) Wake Up Message Buffer Register for ID                     */

    struct {
      __IM  uint32_t ID         : 29;           /*!< [28..0] Received ID under Pretended Networking mode                       */
            uint32_t            : 3;
    } CAN0_WMB0_ID_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB0_D03;               /*!< (@ 0x00000B48) Wake Up Message Buffer Register for Data 0-3               */

    struct {
      __IM  uint32_t Data_byte_3 : 8;           /*!< [7..0] Received payload corresponding to the data byte 3 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_2 : 8;           /*!< [15..8] Received payload corresponding to the data byte 2 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_1 : 8;           /*!< [23..16] Received payload corresponding to the data byte 1 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_0 : 8;           /*!< [31..24] Received payload corresponding to the data byte 0 under
                                                     Pretended Networking mode                                                 */
    } CAN0_WMB0_D03_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB0_D47;               /*!< (@ 0x00000B4C) Wake Up Message Buffer Register Data 4-7                   */

    struct {
      __IM  uint32_t Data_byte_7 : 8;           /*!< [7..0] Received payload corresponding to the data byte 7 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_6 : 8;           /*!< [15..8] Received payload corresponding to the data byte 6 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_5 : 8;           /*!< [23..16] Received payload corresponding to the data byte 5 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_4 : 8;           /*!< [31..24] Received payload corresponding to the data byte 4 under
                                                     Pretended Networking mode                                                 */
    } CAN0_WMB0_D47_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB1_CS;                /*!< (@ 0x00000B50) Wake Up Message Buffer Register for C/S                    */

    struct {
            uint32_t            : 16;
      __IM  uint32_t DLC        : 4;            /*!< [19..16] Length of Data in Bytes                                          */
      __IM  uint32_t RTR        : 1;            /*!< [20..20] Remote Transmission Request Bit                                  */
      __IM  uint32_t IDE        : 1;            /*!< [21..21] ID Extended Bit                                                  */
      __IM  uint32_t SRR        : 1;            /*!< [22..22] Substitute Remote Request                                        */
            uint32_t            : 9;
    } CAN0_WMB1_CS_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB1_ID;                /*!< (@ 0x00000B54) Wake Up Message Buffer Register for ID                     */

    struct {
      __IM  uint32_t ID         : 29;           /*!< [28..0] Received ID under Pretended Networking mode                       */
            uint32_t            : 3;
    } CAN0_WMB1_ID_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB1_D03;               /*!< (@ 0x00000B58) Wake Up Message Buffer Register for Data 0-3               */

    struct {
      __IM  uint32_t Data_byte_3 : 8;           /*!< [7..0] Received payload corresponding to the data byte 3 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_2 : 8;           /*!< [15..8] Received payload corresponding to the data byte 2 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_1 : 8;           /*!< [23..16] Received payload corresponding to the data byte 1 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_0 : 8;           /*!< [31..24] Received payload corresponding to the data byte 0 under
                                                     Pretended Networking mode                                                 */
    } CAN0_WMB1_D03_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB1_D47;               /*!< (@ 0x00000B5C) Wake Up Message Buffer Register Data 4-7                   */

    struct {
      __IM  uint32_t Data_byte_7 : 8;           /*!< [7..0] Received payload corresponding to the data byte 7 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_6 : 8;           /*!< [15..8] Received payload corresponding to the data byte 6 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_5 : 8;           /*!< [23..16] Received payload corresponding to the data byte 5 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_4 : 8;           /*!< [31..24] Received payload corresponding to the data byte 4 under
                                                     Pretended Networking mode                                                 */
    } CAN0_WMB1_D47_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB2_CS;                /*!< (@ 0x00000B60) Wake Up Message Buffer Register for C/S                    */

    struct {
            uint32_t            : 16;
      __IM  uint32_t DLC        : 4;            /*!< [19..16] Length of Data in Bytes                                          */
      __IM  uint32_t RTR        : 1;            /*!< [20..20] Remote Transmission Request Bit                                  */
      __IM  uint32_t IDE        : 1;            /*!< [21..21] ID Extended Bit                                                  */
      __IM  uint32_t SRR        : 1;            /*!< [22..22] Substitute Remote Request                                        */
            uint32_t            : 9;
    } CAN0_WMB2_CS_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB2_ID;                /*!< (@ 0x00000B64) Wake Up Message Buffer Register for ID                     */

    struct {
      __IM  uint32_t ID         : 29;           /*!< [28..0] Received ID under Pretended Networking mode                       */
            uint32_t            : 3;
    } CAN0_WMB2_ID_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB2_D03;               /*!< (@ 0x00000B68) Wake Up Message Buffer Register for Data 0-3               */

    struct {
      __IM  uint32_t Data_byte_3 : 8;           /*!< [7..0] Received payload corresponding to the data byte 3 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_2 : 8;           /*!< [15..8] Received payload corresponding to the data byte 2 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_1 : 8;           /*!< [23..16] Received payload corresponding to the data byte 1 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_0 : 8;           /*!< [31..24] Received payload corresponding to the data byte 0 under
                                                     Pretended Networking mode                                                 */
    } CAN0_WMB2_D03_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB2_D47;               /*!< (@ 0x00000B6C) Wake Up Message Buffer Register Data 4-7                   */

    struct {
      __IM  uint32_t Data_byte_7 : 8;           /*!< [7..0] Received payload corresponding to the data byte 7 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_6 : 8;           /*!< [15..8] Received payload corresponding to the data byte 6 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_5 : 8;           /*!< [23..16] Received payload corresponding to the data byte 5 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_4 : 8;           /*!< [31..24] Received payload corresponding to the data byte 4 under
                                                     Pretended Networking mode                                                 */
    } CAN0_WMB2_D47_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB3_CS;                /*!< (@ 0x00000B70) Wake Up Message Buffer Register for C/S                    */

    struct {
            uint32_t            : 16;
      __IM  uint32_t DLC        : 4;            /*!< [19..16] Length of Data in Bytes                                          */
      __IM  uint32_t RTR        : 1;            /*!< [20..20] Remote Transmission Request Bit                                  */
      __IM  uint32_t IDE        : 1;            /*!< [21..21] ID Extended Bit                                                  */
      __IM  uint32_t SRR        : 1;            /*!< [22..22] Substitute Remote Request                                        */
            uint32_t            : 9;
    } CAN0_WMB3_CS_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB3_ID;                /*!< (@ 0x00000B74) Wake Up Message Buffer Register for ID                     */

    struct {
      __IM  uint32_t ID         : 29;           /*!< [28..0] Received ID under Pretended Networking mode                       */
            uint32_t            : 3;
    } CAN0_WMB3_ID_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB3_D03;               /*!< (@ 0x00000B78) Wake Up Message Buffer Register for Data 0-3               */

    struct {
      __IM  uint32_t Data_byte_3 : 8;           /*!< [7..0] Received payload corresponding to the data byte 3 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_2 : 8;           /*!< [15..8] Received payload corresponding to the data byte 2 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_1 : 8;           /*!< [23..16] Received payload corresponding to the data byte 1 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_0 : 8;           /*!< [31..24] Received payload corresponding to the data byte 0 under
                                                     Pretended Networking mode                                                 */
    } CAN0_WMB3_D03_b;
  } ;

  union {
    __IM  uint32_t CAN0_WMB3_D47;               /*!< (@ 0x00000B7C) Wake Up Message Buffer Register Data 4-7                   */

    struct {
      __IM  uint32_t Data_byte_7 : 8;           /*!< [7..0] Received payload corresponding to the data byte 7 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_6 : 8;           /*!< [15..8] Received payload corresponding to the data byte 6 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_5 : 8;           /*!< [23..16] Received payload corresponding to the data byte 5 under
                                                     Pretended Networking mode                                                 */
      __IM  uint32_t Data_byte_4 : 8;           /*!< [31..24] Received payload corresponding to the data byte 4 under
                                                     Pretended Networking mode                                                 */
    } CAN0_WMB3_D47_b;
  } ;
  __IM  uint32_t  RESERVED8[32];

  union {
    __IOM uint32_t CAN0_FDCTRL;                 /*!< (@ 0x00000C00) CAN FD Control Register                                    */

    struct {
      __IM  uint32_t TDCVAL     : 6;            /*!< [5..0] Transceiver Delay Compensation Value                               */
            uint32_t            : 2;
      __IOM uint32_t TDCOFF     : 5;            /*!< [12..8] Transceiver Delay Compensation Offset                             */
            uint32_t            : 1;
      __IOM uint32_t TDCFAIL    : 1;            /*!< [14..14] Transceiver Delay Compensation Fail                              */
      __IOM uint32_t TDCEN      : 1;            /*!< [15..15] Transceiver Delay Compensation Enable                            */
      __IOM uint32_t MBDSR0     : 2;            /*!< [17..16] Message Buffer Data Size for Region 0                            */
            uint32_t            : 13;
      __IOM uint32_t FDRATE     : 1;            /*!< [31..31] Bit Rate Switch Enable                                           */
    } CAN0_FDCTRL_b;
  } ;

  union {
    __IOM uint32_t CAN0_FDCBT;                  /*!< (@ 0x00000C04) CAN FD Bit Timing Register                                 */

    struct {
      __IOM uint32_t FPSEG2     : 3;            /*!< [2..0] Fast Phase Segment 2                                               */
            uint32_t            : 2;
      __IOM uint32_t FPSEG1     : 3;            /*!< [7..5] Fast Phase Segment 1                                               */
            uint32_t            : 2;
      __IOM uint32_t FPROPSEG   : 5;            /*!< [14..10] Fast Propagation Segment                                         */
            uint32_t            : 1;
      __IOM uint32_t FRJW       : 3;            /*!< [18..16] Fast Resync Jump Width                                           */
            uint32_t            : 1;
      __IOM uint32_t FPRESDIV   : 10;           /*!< [29..20] Fast Prescaler Division Factor                                   */
            uint32_t            : 2;
    } CAN0_FDCBT_b;
  } ;

  union {
    __IM  uint32_t CAN0_FDCRC;                  /*!< (@ 0x00000C08) CAN FD CRC Register                                        */

    struct {
      __IM  uint32_t FD_TXCRC   : 21;           /*!< [20..0] Extended Transmitted CRC value                                    */
            uint32_t            : 3;
      __IM  uint32_t FD_MBCRC   : 7;            /*!< [30..24] CRC Mailbox Number for FD_TXCRC                                  */
            uint32_t            : 1;
    } CAN0_FDCRC_b;
  } ;
} CAN0_Type;                                    /*!< Size = 3084 (0xc0c)                                                       */



/* =========================================================================================================================== */
/* ================                                          LPSPI0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief The LPSPI Memory Map/Register Definition can be found here. (LPSPI0)
  */

typedef struct {                                /*!< (@ 0x4002C000) LPSPI0 Structure                                           */

  union {
    __IM  uint32_t LPSPI0_VERID;                /*!< (@ 0x00000000) Version ID Register                                        */

    struct {
      __IM  uint32_t FEATURE    : 16;           /*!< [15..0] Module Identification Number                                      */
      __IM  uint32_t MINOR      : 8;            /*!< [23..16] Minor Version Number                                             */
      __IM  uint32_t MAJOR      : 8;            /*!< [31..24] Major Version Number                                             */
    } LPSPI0_VERID_b;
  } ;

  union {
    __IM  uint32_t LPSPI0_PARAM;                /*!< (@ 0x00000004) Parameter Register                                         */

    struct {
      __IM  uint32_t TXFIFO     : 8;            /*!< [7..0] Transmit FIFO Size                                                 */
      __IM  uint32_t RXFIFO     : 8;            /*!< [15..8] Receive FIFO Size                                                 */
            uint32_t            : 16;
    } LPSPI0_PARAM_b;
  } ;
  __IM  uint32_t  RESERVED[2];

  union {
    __IOM uint32_t LPSPI0_CR;                   /*!< (@ 0x00000010) Control Register                                           */

    struct {
      __IOM uint32_t MEN        : 1;            /*!< [0..0] Module Enable                                                      */
      __IOM uint32_t RST        : 1;            /*!< [1..1] Software Reset                                                     */
      __IOM uint32_t DOZEN      : 1;            /*!< [2..2] Doze mode enable                                                   */
      __IOM uint32_t DBGEN      : 1;            /*!< [3..3] Debug Enable                                                       */
            uint32_t            : 4;
      __OM  uint32_t RTF        : 1;            /*!< [8..8] Reset Transmit FIFO                                                */
      __OM  uint32_t RRF        : 1;            /*!< [9..9] Reset Receive FIFO                                                 */
            uint32_t            : 22;
    } LPSPI0_CR_b;
  } ;

  union {
    __IOM uint32_t LPSPI0_SR;                   /*!< (@ 0x00000014) Status Register                                            */

    struct {
      __IM  uint32_t TDF        : 1;            /*!< [0..0] Transmit Data Flag                                                 */
      __IM  uint32_t RDF        : 1;            /*!< [1..1] Receive Data Flag                                                  */
            uint32_t            : 6;
      __IOM uint32_t WCF        : 1;            /*!< [8..8] Word Complete Flag                                                 */
      __IOM uint32_t FCF        : 1;            /*!< [9..9] Frame Complete Flag                                                */
      __IOM uint32_t TCF        : 1;            /*!< [10..10] Transfer Complete Flag                                           */
      __IOM uint32_t TEF        : 1;            /*!< [11..11] Transmit Error Flag                                              */
      __IOM uint32_t REF        : 1;            /*!< [12..12] Receive Error Flag                                               */
      __IOM uint32_t DMF        : 1;            /*!< [13..13] Data Match Flag                                                  */
            uint32_t            : 10;
      __IM  uint32_t MBF        : 1;            /*!< [24..24] Module Busy Flag                                                 */
            uint32_t            : 7;
    } LPSPI0_SR_b;
  } ;

  union {
    __IOM uint32_t LPSPI0_IER;                  /*!< (@ 0x00000018) Interrupt Enable Register                                  */

    struct {
      __IOM uint32_t TDIE       : 1;            /*!< [0..0] Transmit Data Interrupt Enable                                     */
      __IOM uint32_t RDIE       : 1;            /*!< [1..1] Receive Data Interrupt Enable                                      */
            uint32_t            : 6;
      __IOM uint32_t WCIE       : 1;            /*!< [8..8] Word Complete Interrupt Enable                                     */
      __IOM uint32_t FCIE       : 1;            /*!< [9..9] Frame Complete Interrupt Enable                                    */
      __IOM uint32_t TCIE       : 1;            /*!< [10..10] Transfer Complete Interrupt Enable                               */
      __IOM uint32_t TEIE       : 1;            /*!< [11..11] Transmit Error Interrupt Enable                                  */
      __IOM uint32_t REIE       : 1;            /*!< [12..12] Receive Error Interrupt Enable                                   */
      __IOM uint32_t DMIE       : 1;            /*!< [13..13] Data Match Interrupt Enable                                      */
            uint32_t            : 18;
    } LPSPI0_IER_b;
  } ;

  union {
    __IOM uint32_t LPSPI0_DER;                  /*!< (@ 0x0000001C) DMA Enable Register                                        */

    struct {
      __IOM uint32_t TDDE       : 1;            /*!< [0..0] Transmit Data DMA Enable                                           */
      __IOM uint32_t RDDE       : 1;            /*!< [1..1] Receive Data DMA Enable                                            */
            uint32_t            : 30;
    } LPSPI0_DER_b;
  } ;

  union {
    __IOM uint32_t LPSPI0_CFGR0;                /*!< (@ 0x00000020) Configuration Register 0                                   */

    struct {
      __IOM uint32_t HREN       : 1;            /*!< [0..0] Host Request Enable                                                */
      __IOM uint32_t HRPOL      : 1;            /*!< [1..1] Host Request Polarity                                              */
      __IOM uint32_t HRSEL      : 1;            /*!< [2..2] Host Request Select                                                */
            uint32_t            : 5;
      __IOM uint32_t CIRFIFO    : 1;            /*!< [8..8] Circular FIFO Enable                                               */
      __IOM uint32_t RDMO       : 1;            /*!< [9..9] Receive Data Match Only                                            */
            uint32_t            : 22;
    } LPSPI0_CFGR0_b;
  } ;

  union {
    __IOM uint32_t LPSPI0_CFGR1;                /*!< (@ 0x00000024) Configuration Register 1                                   */

    struct {
      __IOM uint32_t MASTER     : 1;            /*!< [0..0] Master Mode                                                        */
      __IOM uint32_t SAMPLE     : 1;            /*!< [1..1] Sample Point                                                       */
      __IOM uint32_t AUTOPCS    : 1;            /*!< [2..2] Automatic PCS                                                      */
      __IOM uint32_t NOSTALL    : 1;            /*!< [3..3] No Stall                                                           */
            uint32_t            : 4;
      __IOM uint32_t PCSPOL     : 4;            /*!< [11..8] Peripheral Chip Select Polarity                                   */
            uint32_t            : 4;
      __IOM uint32_t MATCFG     : 3;            /*!< [18..16] Match Configuration                                              */
            uint32_t            : 5;
      __IOM uint32_t PINCFG     : 2;            /*!< [25..24] Pin Configuration                                                */
      __IOM uint32_t OUTCFG     : 1;            /*!< [26..26] Output Config                                                    */
      __IOM uint32_t PCSCFG     : 1;            /*!< [27..27] Peripheral Chip Select Configuration                             */
            uint32_t            : 4;
    } LPSPI0_CFGR1_b;
  } ;
  __IM  uint32_t  RESERVED1[2];

  union {
    __IOM uint32_t LPSPI0_DMR0;                 /*!< (@ 0x00000030) Data Match Register 0                                      */

    struct {
      __IOM uint32_t MATCH0     : 32;           /*!< [31..0] Match 0 Value                                                     */
    } LPSPI0_DMR0_b;
  } ;

  union {
    __IOM uint32_t LPSPI0_DMR1;                 /*!< (@ 0x00000034) Data Match Register 1                                      */

    struct {
      __IOM uint32_t MATCH1     : 32;           /*!< [31..0] Match 1 Value                                                     */
    } LPSPI0_DMR1_b;
  } ;
  __IM  uint32_t  RESERVED2[2];

  union {
    __IOM uint32_t LPSPI0_CCR;                  /*!< (@ 0x00000040) Clock Configuration Register                               */

    struct {
      __IOM uint32_t SCKDIV     : 8;            /*!< [7..0] SCK Divider                                                        */
      __IOM uint32_t DBT        : 8;            /*!< [15..8] Delay Between Transfers                                           */
      __IOM uint32_t PCSSCK     : 8;            /*!< [23..16] PCS to SCK Delay                                                 */
      __IOM uint32_t SCKPCS     : 8;            /*!< [31..24] SCK to PCS Delay                                                 */
    } LPSPI0_CCR_b;
  } ;
  __IM  uint32_t  RESERVED3[5];

  union {
    __IOM uint32_t LPSPI0_FCR;                  /*!< (@ 0x00000058) FIFO Control Register                                      */

    struct {
      __IOM uint32_t TXWATER    : 2;            /*!< [1..0] Transmit FIFO Watermark                                            */
            uint32_t            : 14;
      __IOM uint32_t RXWATER    : 2;            /*!< [17..16] Receive FIFO Watermark                                           */
            uint32_t            : 14;
    } LPSPI0_FCR_b;
  } ;

  union {
    __IM  uint32_t LPSPI0_FSR;                  /*!< (@ 0x0000005C) FIFO Status Register                                       */

    struct {
      __IM  uint32_t TXCOUNT    : 3;            /*!< [2..0] Transmit FIFO Count                                                */
            uint32_t            : 13;
      __IM  uint32_t RXCOUNT    : 3;            /*!< [18..16] Receive FIFO Count                                               */
            uint32_t            : 13;
    } LPSPI0_FSR_b;
  } ;

  union {
    __IOM uint32_t LPSPI0_TCR;                  /*!< (@ 0x00000060) Transmit Command Register                                  */

    struct {
      __IOM uint32_t FRAMESZ    : 12;           /*!< [11..0] Frame Size                                                        */
            uint32_t            : 4;
      __IOM uint32_t WIDTH      : 2;            /*!< [17..16] Transfer Width                                                   */
      __IOM uint32_t TXMSK      : 1;            /*!< [18..18] Transmit Data Mask                                               */
      __IOM uint32_t RXMSK      : 1;            /*!< [19..19] Receive Data Mask                                                */
      __IOM uint32_t CONTC      : 1;            /*!< [20..20] Continuing Command                                               */
      __IOM uint32_t CONT       : 1;            /*!< [21..21] Continuous Transfer                                              */
      __IOM uint32_t BYSW       : 1;            /*!< [22..22] Byte Swap                                                        */
      __IOM uint32_t LSBF       : 1;            /*!< [23..23] LSB First                                                        */
      __IOM uint32_t PCS        : 2;            /*!< [25..24] Peripheral Chip Select                                           */
            uint32_t            : 1;
      __IOM uint32_t PRESCALE   : 3;            /*!< [29..27] Prescaler Value                                                  */
      __IOM uint32_t CPHA       : 1;            /*!< [30..30] Clock Phase                                                      */
      __IOM uint32_t CPOL       : 1;            /*!< [31..31] Clock Polarity                                                   */
    } LPSPI0_TCR_b;
  } ;

  union {
    __OM  uint32_t LPSPI0_TDR;                  /*!< (@ 0x00000064) Transmit Data Register                                     */

    struct {
      __OM  uint32_t DATA       : 32;           /*!< [31..0] Transmit Data                                                     */
    } LPSPI0_TDR_b;
  } ;
  __IM  uint32_t  RESERVED4[2];

  union {
    __IM  uint32_t LPSPI0_RSR;                  /*!< (@ 0x00000070) Receive Status Register                                    */

    struct {
      __IM  uint32_t SOF        : 1;            /*!< [0..0] Start Of Frame                                                     */
      __IM  uint32_t RXEMPTY    : 1;            /*!< [1..1] RX FIFO Empty                                                      */
            uint32_t            : 30;
    } LPSPI0_RSR_b;
  } ;

  union {
    __IM  uint32_t LPSPI0_RDR;                  /*!< (@ 0x00000074) Receive Data Register                                      */

    struct {
      __IM  uint32_t DATA       : 32;           /*!< [31..0] Receive Data                                                      */
    } LPSPI0_RDR_b;
  } ;
} LPSPI0_Type;                                  /*!< Size = 120 (0x78)                                                         */



/* =========================================================================================================================== */
/* ================                                            CRC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Cyclic Redundancy Check (CRC)
  */

typedef struct {                                /*!< (@ 0x40032000) CRC Structure                                              */

  union {
    union {
      __IOM uint32_t CRC_DATA_CRC;              /*!< (@ 0x00000000) CRC Data register                                          */

      struct {
        __IOM uint32_t LL       : 8;            /*!< [7..0] CRC Low Lower Byte                                                 */
        __IOM uint32_t LU       : 8;            /*!< [15..8] CRC Low Upper Byte                                                */
        __IOM uint32_t HL       : 8;            /*!< [23..16] CRC High Lower Byte                                              */
        __IOM uint32_t HU       : 8;            /*!< [31..24] CRC High Upper Byte                                              */
      } CRC_DATA_CRC_b;
    } ;

    struct {
      union {
        union {
          __IOM uint16_t CRC_DATAL_CRC;         /*!< (@ 0x00000000) CRC_DATAL register.                                        */

          struct {
            __IOM uint16_t DATAL : 16;          /*!< [15..0] DATAL stores the lower 16 bits of the 16/32 bit CRC               */
          } CRC_DATAL_CRC_b;
        } ;

        struct {
          union {
            __IOM uint8_t CRC_DATALL_CRC;       /*!< (@ 0x00000000) CRC_DATALL register.                                       */

            struct {
              __IOM uint8_t DATALL : 8;         /*!< [7..0] CRCLL stores the first 8 bits of the 32 bit DATA                   */
            } CRC_DATALL_CRC_b;
          } ;

          union {
            __IOM uint8_t CRC_DATALU;           /*!< (@ 0x00000001) CRC_DATALU register.                                       */

            struct {
              __IOM uint8_t DATALU : 8;         /*!< [7..0] DATALL stores the second 8 bits of the 32 bit CRC                  */
            } CRC_DATALU_b;
          } ;
        };
      };

      union {
        union {
          __IOM uint16_t CRC_DATAH_CRC;         /*!< (@ 0x00000002) CRC_DATAH register.                                        */

          struct {
            __IOM uint16_t DATAH : 16;          /*!< [15..0] DATAH stores the high 16 bits of the 16/32 bit CRC                */
          } CRC_DATAH_CRC_b;
        } ;

        struct {
          union {
            __IOM uint8_t CRC_DATAHL_CRC;       /*!< (@ 0x00000002) CRC_DATAHL register.                                       */

            struct {
              __IOM uint8_t DATAHL : 8;         /*!< [7..0] DATAHL stores the third 8 bits of the 32 bit CRC                   */
            } CRC_DATAHL_CRC_b;
          } ;

          union {
            __IOM uint8_t CRC_DATAHU;           /*!< (@ 0x00000003) CRC_DATAHU register.                                       */

            struct {
              __IOM uint8_t DATAHU : 8;         /*!< [7..0] DATAHU stores the fourth 8 bits of the 32 bit CRC                  */
            } CRC_DATAHU_b;
          } ;
        };
      };
    };
  };

  union {
    __IOM uint32_t CRC_GPOLY;                   /*!< (@ 0x00000004) CRC Polynomial register                                    */

    struct {
      __IOM uint32_t LOW        : 16;           /*!< [15..0] Low Polynominal Half-word                                         */
      __IOM uint32_t HIGH       : 16;           /*!< [31..16] High Polynominal Half-word                                       */
    } CRC_GPOLY_b;
  } ;

  union {
    __IOM uint32_t CRC_CTRL;                    /*!< (@ 0x00000008) CRC Control register                                       */

    struct {
            uint32_t            : 24;
      __IOM uint32_t TCRC       : 1;            /*!< [24..24] TCRC                                                             */
      __IOM uint32_t WAS        : 1;            /*!< [25..25] Write CRC Data Register As Seed                                  */
      __IOM uint32_t FXOR       : 1;            /*!< [26..26] Complement Read Of CRC Data Register                             */
            uint32_t            : 1;
      __IOM uint32_t TOTR       : 2;            /*!< [29..28] Type Of Transpose For Read                                       */
      __IOM uint32_t TOT        : 2;            /*!< [31..30] Type Of Transpose For Writes                                     */
    } CRC_CTRL_b;
  } ;
} CRC_Type;                                     /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                           PDB0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Programmable Delay Block (PDB0)
  */

typedef struct {                                /*!< (@ 0x40036000) PDB0 Structure                                             */

  union {
    __IOM uint32_t PDB0_SC;                     /*!< (@ 0x00000000) Status and Control register                                */

    struct {
      __IOM uint32_t LDOK       : 1;            /*!< [0..0] Load OK                                                            */
      __IOM uint32_t CONT       : 1;            /*!< [1..1] Continuous Mode Enable                                             */
      __IOM uint32_t MULT       : 2;            /*!< [3..2] Multiplication Factor Select for Prescaler                         */
            uint32_t            : 1;
      __IOM uint32_t PDBIE      : 1;            /*!< [5..5] PDB Interrupt Enable                                               */
      __IOM uint32_t PDBIF      : 1;            /*!< [6..6] PDB Interrupt Flag                                                 */
      __IOM uint32_t PDBEN      : 1;            /*!< [7..7] PDB Enable                                                         */
      __IOM uint32_t TRGSEL     : 4;            /*!< [11..8] Trigger Input Source Select                                       */
      __IOM uint32_t PRESCALER  : 3;            /*!< [14..12] Prescaler Divider Select                                         */
      __IOM uint32_t DMAEN      : 1;            /*!< [15..15] DMA Enable                                                       */
      __OM  uint32_t SWTRIG     : 1;            /*!< [16..16] Software Trigger                                                 */
      __IOM uint32_t PDBEIE     : 1;            /*!< [17..17] PDB Sequence Error Interrupt Enable                              */
      __IOM uint32_t LDMOD      : 2;            /*!< [19..18] Load Mode Select                                                 */
            uint32_t            : 12;
    } PDB0_SC_b;
  } ;

  union {
    __IOM uint32_t PDB0_MOD;                    /*!< (@ 0x00000004) Modulus register                                           */

    struct {
      __IOM uint32_t MOD        : 16;           /*!< [15..0] PDB Modulus                                                       */
            uint32_t            : 16;
    } PDB0_MOD_b;
  } ;

  union {
    __IM  uint32_t PDB0_CNT;                    /*!< (@ 0x00000008) Counter register                                           */

    struct {
      __IM  uint32_t CNT        : 16;           /*!< [15..0] PDB Counter                                                       */
            uint32_t            : 16;
    } PDB0_CNT_b;
  } ;

  union {
    __IOM uint32_t PDB0_IDLY;                   /*!< (@ 0x0000000C) Interrupt Delay register                                   */

    struct {
      __IOM uint32_t IDLY       : 16;           /*!< [15..0] PDB Interrupt Delay                                               */
            uint32_t            : 16;
    } PDB0_IDLY_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH0C1;                  /*!< (@ 0x00000010) Channel n Control register 1                               */

    struct {
      __IOM uint32_t EN         : 8;            /*!< [7..0] PDB Channel Pre-Trigger Enable                                     */
      __IOM uint32_t TOS        : 8;            /*!< [15..8] PDB Channel Pre-Trigger Output Select                             */
      __IOM uint32_t BB         : 8;            /*!< [23..16] PDB Channel Pre-Trigger Back-to-Back Operation Enable            */
            uint32_t            : 8;
    } PDB0_CH0C1_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH0S;                   /*!< (@ 0x00000014) Channel n Status register                                  */

    struct {
      __IOM uint32_t ERR        : 8;            /*!< [7..0] PDB Channel Sequence Error Flags                                   */
            uint32_t            : 8;
      __IOM uint32_t CF         : 8;            /*!< [23..16] PDB Channel Flags                                                */
            uint32_t            : 8;
    } PDB0_CH0S_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH0DLY0;                /*!< (@ 0x00000018) Channel n Delay 0 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH0DLY0_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH0DLY1;                /*!< (@ 0x0000001C) Channel n Delay 1 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH0DLY1_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH0DLY2;                /*!< (@ 0x00000020) Channel n Delay 2 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH0DLY2_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH0DLY3;                /*!< (@ 0x00000024) Channel n Delay 3 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH0DLY3_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH0DLY4;                /*!< (@ 0x00000028) Channel n Delay 4 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH0DLY4_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH0DLY5;                /*!< (@ 0x0000002C) Channel n Delay 5 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH0DLY5_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH0DLY6;                /*!< (@ 0x00000030) Channel n Delay 6 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH0DLY6_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH0DLY7;                /*!< (@ 0x00000034) Channel n Delay 7 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH0DLY7_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH1C1;                  /*!< (@ 0x00000038) Channel n Control register 1                               */

    struct {
      __IOM uint32_t EN         : 8;            /*!< [7..0] PDB Channel Pre-Trigger Enable                                     */
      __IOM uint32_t TOS        : 8;            /*!< [15..8] PDB Channel Pre-Trigger Output Select                             */
      __IOM uint32_t BB         : 8;            /*!< [23..16] PDB Channel Pre-Trigger Back-to-Back Operation Enable            */
            uint32_t            : 8;
    } PDB0_CH1C1_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH1S;                   /*!< (@ 0x0000003C) Channel n Status register                                  */

    struct {
      __IOM uint32_t ERR        : 8;            /*!< [7..0] PDB Channel Sequence Error Flags                                   */
            uint32_t            : 8;
      __IOM uint32_t CF         : 8;            /*!< [23..16] PDB Channel Flags                                                */
            uint32_t            : 8;
    } PDB0_CH1S_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH1DLY0;                /*!< (@ 0x00000040) Channel n Delay 0 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH1DLY0_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH1DLY1;                /*!< (@ 0x00000044) Channel n Delay 1 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH1DLY1_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH1DLY2;                /*!< (@ 0x00000048) Channel n Delay 2 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH1DLY2_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH1DLY3;                /*!< (@ 0x0000004C) Channel n Delay 3 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH1DLY3_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH1DLY4;                /*!< (@ 0x00000050) Channel n Delay 4 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH1DLY4_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH1DLY5;                /*!< (@ 0x00000054) Channel n Delay 5 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH1DLY5_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH1DLY6;                /*!< (@ 0x00000058) Channel n Delay 6 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH1DLY6_b;
  } ;

  union {
    __IOM uint32_t PDB0_CH1DLY7;                /*!< (@ 0x0000005C) Channel n Delay 7 register                                 */

    struct {
      __IOM uint32_t DLY        : 16;           /*!< [15..0] PDB Channel Delay                                                 */
            uint32_t            : 16;
    } PDB0_CH1DLY7_b;
  } ;
  __IM  uint32_t  RESERVED[76];

  union {
    __IOM uint32_t PDB0_POEN;                   /*!< (@ 0x00000190) Pulse-Out n Enable register                                */

    struct {
      __IOM uint32_t POEN       : 8;            /*!< [7..0] PDB Pulse-Out Enable                                               */
            uint32_t            : 24;
    } PDB0_POEN_b;
  } ;

  union {
    union {
      __IOM uint32_t PDB0_PODLY_PDB0;           /*!< (@ 0x00000194) Pulse-Out n Delay register                                 */

      struct {
        __IOM uint32_t DLY2     : 16;           /*!< [15..0] PDB Pulse-Out Delay 2                                             */
        __IOM uint32_t DLY1     : 16;           /*!< [31..16] PDB Pulse-Out Delay 1                                            */
      } PDB0_PODLY_PDB0_b;
    } ;

    struct {
      union {
        __IOM uint16_t PDB0_DLY2_PDB0;          /*!< (@ 0x00000194) PDB0_DLY2 register.                                        */

        struct {
          __IOM uint16_t DLY2   : 16;           /*!< [15..0] DLY2                                                              */
        } PDB0_DLY2_PDB0_b;
      } ;

      union {
        __IOM uint16_t PDB0_DLY1;               /*!< (@ 0x00000196) PDB0_DLY1 register.                                        */

        struct {
          __IOM uint16_t DLY1   : 16;           /*!< [15..0] DLY1                                                              */
        } PDB0_DLY1_b;
      } ;
    };
  };
} PDB0_Type;                                    /*!< Size = 408 (0x198)                                                        */



/* =========================================================================================================================== */
/* ================                                           LPIT0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low Power Periodic Interrupt Timer (LPIT) (LPIT0)
  */

typedef struct {                                /*!< (@ 0x40037000) LPIT0 Structure                                            */

  union {
    __IM  uint32_t LPIT0_VERID;                 /*!< (@ 0x00000000) Version ID Register                                        */

    struct {
      __IM  uint32_t FEATURE    : 16;           /*!< [15..0] Feature Number                                                    */
      __IM  uint32_t MINOR      : 8;            /*!< [23..16] Minor Version Number                                             */
      __IM  uint32_t MAJOR      : 8;            /*!< [31..24] Major Version Number                                             */
    } LPIT0_VERID_b;
  } ;

  union {
    __IM  uint32_t LPIT0_PARAM;                 /*!< (@ 0x00000004) Parameter Register                                         */

    struct {
      __IM  uint32_t CHANNEL    : 8;            /*!< [7..0] Number of Timer Channels                                           */
      __IM  uint32_t EXT_TRIG   : 8;            /*!< [15..8] Number of External Trigger Inputs                                 */
            uint32_t            : 16;
    } LPIT0_PARAM_b;
  } ;

  union {
    __IOM uint32_t LPIT0_MCR;                   /*!< (@ 0x00000008) Module Control Register                                    */

    struct {
      __IOM uint32_t M_CEN      : 1;            /*!< [0..0] Module Clock Enable                                                */
      __IOM uint32_t SW_RST     : 1;            /*!< [1..1] Software Reset Bit                                                 */
      __IOM uint32_t DOZE_EN    : 1;            /*!< [2..2] DOZE Mode Enable Bit                                               */
      __IOM uint32_t DBG_EN     : 1;            /*!< [3..3] Debug Enable Bit                                                   */
            uint32_t            : 28;
    } LPIT0_MCR_b;
  } ;

  union {
    __IOM uint32_t LPIT0_MSR;                   /*!< (@ 0x0000000C) Module Status Register                                     */

    struct {
      __IOM uint32_t TIF0       : 1;            /*!< [0..0] Channel 0 Timer Interrupt Flag                                     */
      __IOM uint32_t TIF1       : 1;            /*!< [1..1] Channel 1 Timer Interrupt Flag                                     */
      __IOM uint32_t TIF2       : 1;            /*!< [2..2] Channel 2 Timer Interrupt Flag                                     */
      __IOM uint32_t TIF3       : 1;            /*!< [3..3] Channel 3 Timer Interrupt Flag                                     */
            uint32_t            : 28;
    } LPIT0_MSR_b;
  } ;

  union {
    __IOM uint32_t LPIT0_MIER;                  /*!< (@ 0x00000010) Module Interrupt Enable Register                           */

    struct {
      __IOM uint32_t TIE0       : 1;            /*!< [0..0] Channel 0 Timer Interrupt Enable                                   */
      __IOM uint32_t TIE1       : 1;            /*!< [1..1] Channel 1 Timer Interrupt Enable                                   */
      __IOM uint32_t TIE2       : 1;            /*!< [2..2] Channel 2 Timer Interrupt Enable                                   */
      __IOM uint32_t TIE3       : 1;            /*!< [3..3] Channel 3 Timer Interrupt Enable                                   */
            uint32_t            : 28;
    } LPIT0_MIER_b;
  } ;

  union {
    __IOM uint32_t LPIT0_SETTEN;                /*!< (@ 0x00000014) Set Timer Enable Register                                  */

    struct {
      __IOM uint32_t SET_T_EN_0 : 1;            /*!< [0..0] Set Timer 0 Enable                                                 */
      __IOM uint32_t SET_T_EN_1 : 1;            /*!< [1..1] Set Timer 1 Enable                                                 */
      __IOM uint32_t SET_T_EN_2 : 1;            /*!< [2..2] Set Timer 2 Enable                                                 */
      __IOM uint32_t SET_T_EN_3 : 1;            /*!< [3..3] Set Timer 3 Enable                                                 */
            uint32_t            : 28;
    } LPIT0_SETTEN_b;
  } ;

  union {
    __IOM uint32_t LPIT0_CLRTEN;                /*!< (@ 0x00000018) Clear Timer Enable Register                                */

    struct {
      __OM  uint32_t CLR_T_EN_0 : 1;            /*!< [0..0] Clear Timer 0 Enable                                               */
      __OM  uint32_t CLR_T_EN_1 : 1;            /*!< [1..1] Clear Timer 1 Enable                                               */
      __OM  uint32_t CLR_T_EN_2 : 1;            /*!< [2..2] Clear Timer 2 Enable                                               */
      __OM  uint32_t CLR_T_EN_3 : 1;            /*!< [3..3] Clear Timer 3 Enable                                               */
            uint32_t            : 28;
    } LPIT0_CLRTEN_b;
  } ;
  __IM  uint32_t  RESERVED;

  union {
    __IOM uint32_t LPIT0_TVAL0;                 /*!< (@ 0x00000020) Timer Value Register                                       */

    struct {
      __IOM uint32_t TMR_VAL    : 32;           /*!< [31..0] Timer Value                                                       */
    } LPIT0_TVAL0_b;
  } ;

  union {
    __IM  uint32_t LPIT0_CVAL0;                 /*!< (@ 0x00000024) Current Timer Value                                        */

    struct {
      __IM  uint32_t TMR_CUR_VAL : 32;          /*!< [31..0] Current Timer Value                                               */
    } LPIT0_CVAL0_b;
  } ;

  union {
    __IOM uint32_t LPIT0_TCTRL0;                /*!< (@ 0x00000028) Timer Control Register                                     */

    struct {
      __IOM uint32_t T_EN       : 1;            /*!< [0..0] Timer Enable                                                       */
      __IOM uint32_t CHAIN      : 1;            /*!< [1..1] Chain Channel                                                      */
      __IOM uint32_t MODE       : 2;            /*!< [3..2] Timer Operation Mode                                               */
            uint32_t            : 12;
      __IOM uint32_t TSOT       : 1;            /*!< [16..16] Timer Start On Trigger                                           */
      __IOM uint32_t TSOI       : 1;            /*!< [17..17] Timer Stop On Interrupt                                          */
      __IOM uint32_t TROT       : 1;            /*!< [18..18] Timer Reload On Trigger                                          */
            uint32_t            : 4;
      __IOM uint32_t TRG_SRC    : 1;            /*!< [23..23] Trigger Source                                                   */
      __IOM uint32_t TRG_SEL    : 4;            /*!< [27..24] Trigger Select                                                   */
            uint32_t            : 4;
    } LPIT0_TCTRL0_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t LPIT0_TVAL1;                 /*!< (@ 0x00000030) Timer Value Register                                       */

    struct {
      __IOM uint32_t TMR_VAL    : 32;           /*!< [31..0] Timer Value                                                       */
    } LPIT0_TVAL1_b;
  } ;

  union {
    __IM  uint32_t LPIT0_CVAL1;                 /*!< (@ 0x00000034) Current Timer Value                                        */

    struct {
      __IM  uint32_t TMR_CUR_VAL : 32;          /*!< [31..0] Current Timer Value                                               */
    } LPIT0_CVAL1_b;
  } ;

  union {
    __IOM uint32_t LPIT0_TCTRL1;                /*!< (@ 0x00000038) Timer Control Register                                     */

    struct {
      __IOM uint32_t T_EN       : 1;            /*!< [0..0] Timer Enable                                                       */
      __IOM uint32_t CHAIN      : 1;            /*!< [1..1] Chain Channel                                                      */
      __IOM uint32_t MODE       : 2;            /*!< [3..2] Timer Operation Mode                                               */
            uint32_t            : 12;
      __IOM uint32_t TSOT       : 1;            /*!< [16..16] Timer Start On Trigger                                           */
      __IOM uint32_t TSOI       : 1;            /*!< [17..17] Timer Stop On Interrupt                                          */
      __IOM uint32_t TROT       : 1;            /*!< [18..18] Timer Reload On Trigger                                          */
            uint32_t            : 4;
      __IOM uint32_t TRG_SRC    : 1;            /*!< [23..23] Trigger Source                                                   */
      __IOM uint32_t TRG_SEL    : 4;            /*!< [27..24] Trigger Select                                                   */
            uint32_t            : 4;
    } LPIT0_TCTRL1_b;
  } ;
  __IM  uint32_t  RESERVED2;

  union {
    __IOM uint32_t LPIT0_TVAL2;                 /*!< (@ 0x00000040) Timer Value Register                                       */

    struct {
      __IOM uint32_t TMR_VAL    : 32;           /*!< [31..0] Timer Value                                                       */
    } LPIT0_TVAL2_b;
  } ;

  union {
    __IM  uint32_t LPIT0_CVAL2;                 /*!< (@ 0x00000044) Current Timer Value                                        */

    struct {
      __IM  uint32_t TMR_CUR_VAL : 32;          /*!< [31..0] Current Timer Value                                               */
    } LPIT0_CVAL2_b;
  } ;

  union {
    __IOM uint32_t LPIT0_TCTRL2;                /*!< (@ 0x00000048) Timer Control Register                                     */

    struct {
      __IOM uint32_t T_EN       : 1;            /*!< [0..0] Timer Enable                                                       */
      __IOM uint32_t CHAIN      : 1;            /*!< [1..1] Chain Channel                                                      */
      __IOM uint32_t MODE       : 2;            /*!< [3..2] Timer Operation Mode                                               */
            uint32_t            : 12;
      __IOM uint32_t TSOT       : 1;            /*!< [16..16] Timer Start On Trigger                                           */
      __IOM uint32_t TSOI       : 1;            /*!< [17..17] Timer Stop On Interrupt                                          */
      __IOM uint32_t TROT       : 1;            /*!< [18..18] Timer Reload On Trigger                                          */
            uint32_t            : 4;
      __IOM uint32_t TRG_SRC    : 1;            /*!< [23..23] Trigger Source                                                   */
      __IOM uint32_t TRG_SEL    : 4;            /*!< [27..24] Trigger Select                                                   */
            uint32_t            : 4;
    } LPIT0_TCTRL2_b;
  } ;
  __IM  uint32_t  RESERVED3;

  union {
    __IOM uint32_t LPIT0_TVAL3;                 /*!< (@ 0x00000050) Timer Value Register                                       */

    struct {
      __IOM uint32_t TMR_VAL    : 32;           /*!< [31..0] Timer Value                                                       */
    } LPIT0_TVAL3_b;
  } ;

  union {
    __IM  uint32_t LPIT0_CVAL3;                 /*!< (@ 0x00000054) Current Timer Value                                        */

    struct {
      __IM  uint32_t TMR_CUR_VAL : 32;          /*!< [31..0] Current Timer Value                                               */
    } LPIT0_CVAL3_b;
  } ;

  union {
    __IOM uint32_t LPIT0_TCTRL3;                /*!< (@ 0x00000058) Timer Control Register                                     */

    struct {
      __IOM uint32_t T_EN       : 1;            /*!< [0..0] Timer Enable                                                       */
      __IOM uint32_t CHAIN      : 1;            /*!< [1..1] Chain Channel                                                      */
      __IOM uint32_t MODE       : 2;            /*!< [3..2] Timer Operation Mode                                               */
            uint32_t            : 12;
      __IOM uint32_t TSOT       : 1;            /*!< [16..16] Timer Start On Trigger                                           */
      __IOM uint32_t TSOI       : 1;            /*!< [17..17] Timer Stop On Interrupt                                          */
      __IOM uint32_t TROT       : 1;            /*!< [18..18] Timer Reload On Trigger                                          */
            uint32_t            : 4;
      __IOM uint32_t TRG_SRC    : 1;            /*!< [23..23] Trigger Source                                                   */
      __IOM uint32_t TRG_SEL    : 4;            /*!< [27..24] Trigger Select                                                   */
            uint32_t            : 4;
    } LPIT0_TCTRL3_b;
  } ;
} LPIT0_Type;                                   /*!< Size = 92 (0x5c)                                                          */



/* =========================================================================================================================== */
/* ================                                           FTM0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief FlexTimer Module (FTM0)
  */

typedef struct {                                /*!< (@ 0x40038000) FTM0 Structure                                             */

  union {
    __IOM uint32_t FTM0_SC;                     /*!< (@ 0x00000000) Status And Control                                         */

    struct {
      __IOM uint32_t PS         : 3;            /*!< [2..0] Prescale Factor Selection                                          */
      __IOM uint32_t CLKS       : 2;            /*!< [4..3] Clock Source Selection                                             */
      __IOM uint32_t CPWMS      : 1;            /*!< [5..5] Center-Aligned PWM Select                                          */
      __IOM uint32_t RIE        : 1;            /*!< [6..6] Reload Point Interrupt Enable                                      */
      __IM  uint32_t RF         : 1;            /*!< [7..7] Reload Flag                                                        */
      __IOM uint32_t TOIE       : 1;            /*!< [8..8] Timer Overflow Interrupt Enable                                    */
      __IM  uint32_t TOF        : 1;            /*!< [9..9] Timer Overflow Flag                                                */
            uint32_t            : 6;
      __IOM uint32_t PWMEN0     : 1;            /*!< [16..16] Channel 0 PWM enable bit                                         */
      __IOM uint32_t PWMEN1     : 1;            /*!< [17..17] Channel 1 PWM enable bit                                         */
      __IOM uint32_t PWMEN2     : 1;            /*!< [18..18] Channel 2 PWM enable bit                                         */
      __IOM uint32_t PWMEN3     : 1;            /*!< [19..19] Channel 3 PWM enable bit                                         */
      __IOM uint32_t PWMEN4     : 1;            /*!< [20..20] Channel 4 PWM enable bit                                         */
      __IOM uint32_t PWMEN5     : 1;            /*!< [21..21] Channel 5 PWM enable bit                                         */
      __IOM uint32_t PWMEN6     : 1;            /*!< [22..22] Channel 6 PWM enable bit                                         */
      __IOM uint32_t PWMEN7     : 1;            /*!< [23..23] Channel 7 PWM enable bit                                         */
      __IOM uint32_t FLTPS      : 4;            /*!< [27..24] Filter Prescaler                                                 */
            uint32_t            : 4;
    } FTM0_SC_b;
  } ;

  union {
    __IOM uint32_t FTM0_CNT;                    /*!< (@ 0x00000004) Counter                                                    */

    struct {
      __IOM uint32_t COUNT      : 16;           /*!< [15..0] Counter Value                                                     */
            uint32_t            : 16;
    } FTM0_CNT_b;
  } ;

  union {
    __IOM uint32_t FTM0_MOD;                    /*!< (@ 0x00000008) Modulo                                                     */

    struct {
      __IOM uint32_t MOD        : 16;           /*!< [15..0] MOD                                                               */
            uint32_t            : 16;
    } FTM0_MOD_b;
  } ;

  union {
    __IOM uint32_t FTM0_C0SC;                   /*!< (@ 0x0000000C) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM0_C0SC_b;
  } ;

  union {
    __IOM uint32_t FTM0_C0V;                    /*!< (@ 0x00000010) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM0_C0V_b;
  } ;

  union {
    __IOM uint32_t FTM0_C1SC;                   /*!< (@ 0x00000014) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM0_C1SC_b;
  } ;

  union {
    __IOM uint32_t FTM0_C1V;                    /*!< (@ 0x00000018) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM0_C1V_b;
  } ;

  union {
    __IOM uint32_t FTM0_C2SC;                   /*!< (@ 0x0000001C) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM0_C2SC_b;
  } ;

  union {
    __IOM uint32_t FTM0_C2V;                    /*!< (@ 0x00000020) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM0_C2V_b;
  } ;

  union {
    __IOM uint32_t FTM0_C3SC;                   /*!< (@ 0x00000024) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM0_C3SC_b;
  } ;

  union {
    __IOM uint32_t FTM0_C3V;                    /*!< (@ 0x00000028) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM0_C3V_b;
  } ;

  union {
    __IOM uint32_t FTM0_C4SC;                   /*!< (@ 0x0000002C) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM0_C4SC_b;
  } ;

  union {
    __IOM uint32_t FTM0_C4V;                    /*!< (@ 0x00000030) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM0_C4V_b;
  } ;

  union {
    __IOM uint32_t FTM0_C5SC;                   /*!< (@ 0x00000034) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM0_C5SC_b;
  } ;

  union {
    __IOM uint32_t FTM0_C5V;                    /*!< (@ 0x00000038) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM0_C5V_b;
  } ;

  union {
    __IOM uint32_t FTM0_C6SC;                   /*!< (@ 0x0000003C) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM0_C6SC_b;
  } ;

  union {
    __IOM uint32_t FTM0_C6V;                    /*!< (@ 0x00000040) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM0_C6V_b;
  } ;

  union {
    __IOM uint32_t FTM0_C7SC;                   /*!< (@ 0x00000044) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM0_C7SC_b;
  } ;

  union {
    __IOM uint32_t FTM0_C7V;                    /*!< (@ 0x00000048) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM0_C7V_b;
  } ;

  union {
    __IOM uint32_t FTM0_CNTIN;                  /*!< (@ 0x0000004C) Counter Initial Value                                      */

    struct {
      __IOM uint32_t INIT       : 16;           /*!< [15..0] INIT                                                              */
            uint32_t            : 16;
    } FTM0_CNTIN_b;
  } ;

  union {
    __IM  uint32_t FTM0_STATUS;                 /*!< (@ 0x00000050) Capture And Compare Status                                 */

    struct {
      __IM  uint32_t CH0F       : 1;            /*!< [0..0] Channel 0 Flag                                                     */
      __IM  uint32_t CH1F       : 1;            /*!< [1..1] Channel 1 Flag                                                     */
      __IM  uint32_t CH2F       : 1;            /*!< [2..2] Channel 2 Flag                                                     */
      __IM  uint32_t CH3F       : 1;            /*!< [3..3] Channel 3 Flag                                                     */
      __IM  uint32_t CH4F       : 1;            /*!< [4..4] Channel 4 Flag                                                     */
      __IM  uint32_t CH5F       : 1;            /*!< [5..5] Channel 5 Flag                                                     */
      __IM  uint32_t CH6F       : 1;            /*!< [6..6] Channel 6 Flag                                                     */
      __IM  uint32_t CH7F       : 1;            /*!< [7..7] Channel 7 Flag                                                     */
            uint32_t            : 24;
    } FTM0_STATUS_b;
  } ;

  union {
    __IOM uint32_t FTM0_MODE;                   /*!< (@ 0x00000054) Features Mode Selection                                    */

    struct {
      __IOM uint32_t FTMEN      : 1;            /*!< [0..0] FTM Enable                                                         */
      __OM  uint32_t INIT       : 1;            /*!< [1..1] Initialize The Channels Output                                     */
      __IOM uint32_t WPDIS      : 1;            /*!< [2..2] Write Protection Disable                                           */
      __IOM uint32_t PWMSYNC    : 1;            /*!< [3..3] PWM Synchronization Mode                                           */
      __IOM uint32_t CAPTEST    : 1;            /*!< [4..4] Capture Test Mode Enable                                           */
      __IOM uint32_t FAULTM     : 2;            /*!< [6..5] Fault Control Mode                                                 */
      __IOM uint32_t FAULTIE    : 1;            /*!< [7..7] Fault Interrupt Enable                                             */
            uint32_t            : 24;
    } FTM0_MODE_b;
  } ;

  union {
    __IOM uint32_t FTM0_SYNC;                   /*!< (@ 0x00000058) Synchronization                                            */

    struct {
      __IOM uint32_t CNTMIN     : 1;            /*!< [0..0] Minimum Loading Point Enable                                       */
      __IOM uint32_t CNTMAX     : 1;            /*!< [1..1] Maximum Loading Point Enable                                       */
      __IOM uint32_t REINIT     : 1;            /*!< [2..2] FTM Counter Reinitialization by Synchronization                    */
      __IOM uint32_t SYNCHOM    : 1;            /*!< [3..3] Output Mask Synchronization                                        */
      __IOM uint32_t TRIG0      : 1;            /*!< [4..4] PWM Synchronization Hardware Trigger 0                             */
      __IOM uint32_t TRIG1      : 1;            /*!< [5..5] PWM Synchronization Hardware Trigger 1                             */
      __IOM uint32_t TRIG2      : 1;            /*!< [6..6] PWM Synchronization Hardware Trigger 2                             */
      __IOM uint32_t SWSYNC     : 1;            /*!< [7..7] PWM Synchronization Software Trigger                               */
            uint32_t            : 24;
    } FTM0_SYNC_b;
  } ;

  union {
    __IOM uint32_t FTM0_OUTINIT;                /*!< (@ 0x0000005C) Initial State For Channels Output                          */

    struct {
      __IOM uint32_t CH0OI      : 1;            /*!< [0..0] Channel 0 Output Initialization Value                              */
      __IOM uint32_t CH1OI      : 1;            /*!< [1..1] Channel 1 Output Initialization Value                              */
      __IOM uint32_t CH2OI      : 1;            /*!< [2..2] Channel 2 Output Initialization Value                              */
      __IOM uint32_t CH3OI      : 1;            /*!< [3..3] Channel 3 Output Initialization Value                              */
      __IOM uint32_t CH4OI      : 1;            /*!< [4..4] Channel 4 Output Initialization Value                              */
      __IOM uint32_t CH5OI      : 1;            /*!< [5..5] Channel 5 Output Initialization Value                              */
      __IOM uint32_t CH6OI      : 1;            /*!< [6..6] Channel 6 Output Initialization Value                              */
      __IOM uint32_t CH7OI      : 1;            /*!< [7..7] Channel 7 Output Initialization Value                              */
            uint32_t            : 24;
    } FTM0_OUTINIT_b;
  } ;

  union {
    __IOM uint32_t FTM0_OUTMASK;                /*!< (@ 0x00000060) Output Mask                                                */

    struct {
      __IOM uint32_t CH0OM      : 1;            /*!< [0..0] Channel 0 Output Mask                                              */
      __IOM uint32_t CH1OM      : 1;            /*!< [1..1] Channel 1 Output Mask                                              */
      __IOM uint32_t CH2OM      : 1;            /*!< [2..2] Channel 2 Output Mask                                              */
      __IOM uint32_t CH3OM      : 1;            /*!< [3..3] Channel 3 Output Mask                                              */
      __IOM uint32_t CH4OM      : 1;            /*!< [4..4] Channel 4 Output Mask                                              */
      __IOM uint32_t CH5OM      : 1;            /*!< [5..5] Channel 5 Output Mask                                              */
      __IOM uint32_t CH6OM      : 1;            /*!< [6..6] Channel 6 Output Mask                                              */
      __IOM uint32_t CH7OM      : 1;            /*!< [7..7] Channel 7 Output Mask                                              */
            uint32_t            : 24;
    } FTM0_OUTMASK_b;
  } ;

  union {
    __IOM uint32_t FTM0_COMBINE;                /*!< (@ 0x00000064) Function For Linked Channels                               */

    struct {
      __IOM uint32_t COMBINE0   : 1;            /*!< [0..0] Combine Channels For n = 0                                         */
      __IOM uint32_t COMP0      : 1;            /*!< [1..1] Complement Of Channel (n) For n = 0                                */
      __IOM uint32_t DECAPEN0   : 1;            /*!< [2..2] Dual Edge Capture Mode Enable For n = 0                            */
      __IOM uint32_t DECAP0     : 1;            /*!< [3..3] Dual Edge Capture Mode Captures For n = 0                          */
      __IOM uint32_t DTEN0      : 1;            /*!< [4..4] Deadtime Enable For n = 0                                          */
      __IOM uint32_t SYNCEN0    : 1;            /*!< [5..5] Synchronization Enable For n = 0                                   */
      __IOM uint32_t FAULTEN0   : 1;            /*!< [6..6] Fault Control Enable For n = 0                                     */
      __IOM uint32_t MCOMBINE0  : 1;            /*!< [7..7] Modified Combine Mode For n = 0                                    */
      __IOM uint32_t COMBINE1   : 1;            /*!< [8..8] Combine Channels For n = 2                                         */
      __IOM uint32_t COMP1      : 1;            /*!< [9..9] Complement Of Channel (n) For n = 2                                */
      __IOM uint32_t DECAPEN1   : 1;            /*!< [10..10] Dual Edge Capture Mode Enable For n = 2                          */
      __IOM uint32_t DECAP1     : 1;            /*!< [11..11] Dual Edge Capture Mode Captures For n = 2                        */
      __IOM uint32_t DTEN1      : 1;            /*!< [12..12] Deadtime Enable For n = 2                                        */
      __IOM uint32_t SYNCEN1    : 1;            /*!< [13..13] Synchronization Enable For n = 2                                 */
      __IOM uint32_t FAULTEN1   : 1;            /*!< [14..14] Fault Control Enable For n = 2                                   */
      __IOM uint32_t MCOMBINE1  : 1;            /*!< [15..15] Modified Combine Mode For n = 2                                  */
      __IOM uint32_t COMBINE2   : 1;            /*!< [16..16] Combine Channels For n = 4                                       */
      __IOM uint32_t COMP2      : 1;            /*!< [17..17] Complement Of Channel (n) For n = 4                              */
      __IOM uint32_t DECAPEN2   : 1;            /*!< [18..18] Dual Edge Capture Mode Enable For n = 4                          */
      __IOM uint32_t DECAP2     : 1;            /*!< [19..19] Dual Edge Capture Mode Captures For n = 4                        */
      __IOM uint32_t DTEN2      : 1;            /*!< [20..20] Deadtime Enable For n = 4                                        */
      __IOM uint32_t SYNCEN2    : 1;            /*!< [21..21] Synchronization Enable For n = 4                                 */
      __IOM uint32_t FAULTEN2   : 1;            /*!< [22..22] Fault Control Enable For n = 4                                   */
      __IOM uint32_t MCOMBINE2  : 1;            /*!< [23..23] Modified Combine Mode For n = 4                                  */
      __IOM uint32_t COMBINE3   : 1;            /*!< [24..24] Combine Channels For n = 6                                       */
      __IOM uint32_t COMP3      : 1;            /*!< [25..25] Complement Of Channel (n) for n = 6                              */
      __IOM uint32_t DECAPEN3   : 1;            /*!< [26..26] Dual Edge Capture Mode Enable For n = 6                          */
      __IOM uint32_t DECAP3     : 1;            /*!< [27..27] Dual Edge Capture Mode Captures For n = 6                        */
      __IOM uint32_t DTEN3      : 1;            /*!< [28..28] Deadtime Enable For n = 6                                        */
      __IOM uint32_t SYNCEN3    : 1;            /*!< [29..29] Synchronization Enable For n = 6                                 */
      __IOM uint32_t FAULTEN3   : 1;            /*!< [30..30] Fault Control Enable For n = 6                                   */
      __IOM uint32_t MCOMBINE3  : 1;            /*!< [31..31] Modified Combine Mode For n = 6                                  */
    } FTM0_COMBINE_b;
  } ;

  union {
    __IOM uint32_t FTM0_DEADTIME;               /*!< (@ 0x00000068) Deadtime Configuration                                     */

    struct {
      __IOM uint32_t DTVAL      : 6;            /*!< [5..0] Deadtime Value                                                     */
      __IOM uint32_t DTPS       : 2;            /*!< [7..6] Deadtime Prescaler Value                                           */
            uint32_t            : 8;
      __IOM uint32_t DTVALEX    : 4;            /*!< [19..16] Extended Deadtime Value                                          */
            uint32_t            : 12;
    } FTM0_DEADTIME_b;
  } ;

  union {
    __IOM uint32_t FTM0_EXTTRIG;                /*!< (@ 0x0000006C) FTM External Trigger                                       */

    struct {
      __IOM uint32_t CH2TRIG    : 1;            /*!< [0..0] Channel 2 External Trigger Enable                                  */
      __IOM uint32_t CH3TRIG    : 1;            /*!< [1..1] Channel 3 External Trigger Enable                                  */
      __IOM uint32_t CH4TRIG    : 1;            /*!< [2..2] Channel 4 External Trigger Enable                                  */
      __IOM uint32_t CH5TRIG    : 1;            /*!< [3..3] Channel 5 External Trigger Enable                                  */
      __IOM uint32_t CH0TRIG    : 1;            /*!< [4..4] Channel 0 External Trigger Enable                                  */
      __IOM uint32_t CH1TRIG    : 1;            /*!< [5..5] Channel 1 External Trigger Enable                                  */
      __IOM uint32_t INITTRIGEN : 1;            /*!< [6..6] Initialization Trigger Enable                                      */
      __IM  uint32_t TRIGF      : 1;            /*!< [7..7] Channel Trigger Flag                                               */
      __IOM uint32_t CH6TRIG    : 1;            /*!< [8..8] Channel 6 External Trigger Enable                                  */
      __IOM uint32_t CH7TRIG    : 1;            /*!< [9..9] Channel 7 External Trigger Enable                                  */
            uint32_t            : 22;
    } FTM0_EXTTRIG_b;
  } ;

  union {
    __IOM uint32_t FTM0_POL;                    /*!< (@ 0x00000070) Channels Polarity                                          */

    struct {
      __IOM uint32_t POL0       : 1;            /*!< [0..0] Channel 0 Polarity                                                 */
      __IOM uint32_t POL1       : 1;            /*!< [1..1] Channel 1 Polarity                                                 */
      __IOM uint32_t POL2       : 1;            /*!< [2..2] Channel 2 Polarity                                                 */
      __IOM uint32_t POL3       : 1;            /*!< [3..3] Channel 3 Polarity                                                 */
      __IOM uint32_t POL4       : 1;            /*!< [4..4] Channel 4 Polarity                                                 */
      __IOM uint32_t POL5       : 1;            /*!< [5..5] Channel 5 Polarity                                                 */
      __IOM uint32_t POL6       : 1;            /*!< [6..6] Channel 6 Polarity                                                 */
      __IOM uint32_t POL7       : 1;            /*!< [7..7] Channel 7 Polarity                                                 */
            uint32_t            : 24;
    } FTM0_POL_b;
  } ;

  union {
    __IOM uint32_t FTM0_FMS;                    /*!< (@ 0x00000074) Fault Mode Status                                          */

    struct {
      __IM  uint32_t FAULTF0    : 1;            /*!< [0..0] Fault Detection Flag 0                                             */
      __IM  uint32_t FAULTF1    : 1;            /*!< [1..1] Fault Detection Flag 1                                             */
      __IM  uint32_t FAULTF2    : 1;            /*!< [2..2] Fault Detection Flag 2                                             */
      __IM  uint32_t FAULTF3    : 1;            /*!< [3..3] Fault Detection Flag 3                                             */
            uint32_t            : 1;
      __IM  uint32_t FAULTIN    : 1;            /*!< [5..5] Fault Inputs                                                       */
      __IOM uint32_t WPEN       : 1;            /*!< [6..6] Write Protection Enable                                            */
      __IM  uint32_t FAULTF     : 1;            /*!< [7..7] Fault Detection Flag                                               */
            uint32_t            : 24;
    } FTM0_FMS_b;
  } ;

  union {
    __IOM uint32_t FTM0_FILTER;                 /*!< (@ 0x00000078) Input Capture Filter Control                               */

    struct {
      __IOM uint32_t CH0FVAL    : 4;            /*!< [3..0] Channel 0 Input Filter                                             */
      __IOM uint32_t CH1FVAL    : 4;            /*!< [7..4] Channel 1 Input Filter                                             */
      __IOM uint32_t CH2FVAL    : 4;            /*!< [11..8] Channel 2 Input Filter                                            */
      __IOM uint32_t CH3FVAL    : 4;            /*!< [15..12] Channel 3 Input Filter                                           */
            uint32_t            : 16;
    } FTM0_FILTER_b;
  } ;

  union {
    __IOM uint32_t FTM0_FLTCTRL;                /*!< (@ 0x0000007C) Fault Control                                              */

    struct {
      __IOM uint32_t FAULT0EN   : 1;            /*!< [0..0] Fault Input 0 Enable                                               */
      __IOM uint32_t FAULT1EN   : 1;            /*!< [1..1] Fault Input 1 Enable                                               */
      __IOM uint32_t FAULT2EN   : 1;            /*!< [2..2] Fault Input 2 Enable                                               */
      __IOM uint32_t FAULT3EN   : 1;            /*!< [3..3] Fault Input 3 Enable                                               */
      __IOM uint32_t FFLTR0EN   : 1;            /*!< [4..4] Fault Input 0 Filter Enable                                        */
      __IOM uint32_t FFLTR1EN   : 1;            /*!< [5..5] Fault Input 1 Filter Enable                                        */
      __IOM uint32_t FFLTR2EN   : 1;            /*!< [6..6] Fault Input 2 Filter Enable                                        */
      __IOM uint32_t FFLTR3EN   : 1;            /*!< [7..7] Fault Input 3 Filter Enable                                        */
      __IOM uint32_t FFVAL      : 4;            /*!< [11..8] Fault Input Filter                                                */
            uint32_t            : 3;
      __IOM uint32_t FSTATE     : 1;            /*!< [15..15] Fault output state                                               */
            uint32_t            : 16;
    } FTM0_FLTCTRL_b;
  } ;

  union {
    __IOM uint32_t FTM0_QDCTRL;                 /*!< (@ 0x00000080) Quadrature Decoder Control And Status                      */

    struct {
      __IOM uint32_t QUADEN     : 1;            /*!< [0..0] Quadrature Decoder Mode Enable                                     */
      __IM  uint32_t TOFDIR     : 1;            /*!< [1..1] Timer Overflow Direction In Quadrature Decoder Mode                */
      __IM  uint32_t QUADIR     : 1;            /*!< [2..2] FTM Counter Direction In Quadrature Decoder Mode                   */
      __IOM uint32_t QUADMODE   : 1;            /*!< [3..3] Quadrature Decoder Mode                                            */
      __IOM uint32_t PHBPOL     : 1;            /*!< [4..4] Phase B Input Polarity                                             */
      __IOM uint32_t PHAPOL     : 1;            /*!< [5..5] Phase A Input Polarity                                             */
      __IOM uint32_t PHBFLTREN  : 1;            /*!< [6..6] Phase B Input Filter Enable                                        */
      __IOM uint32_t PHAFLTREN  : 1;            /*!< [7..7] Phase A Input Filter Enable                                        */
            uint32_t            : 24;
    } FTM0_QDCTRL_b;
  } ;

  union {
    __IOM uint32_t FTM0_CONF;                   /*!< (@ 0x00000084) Configuration                                              */

    struct {
      __IOM uint32_t LDFQ       : 5;            /*!< [4..0] Frequency of the Reload Opportunities                              */
            uint32_t            : 1;
      __IOM uint32_t BDMMODE    : 2;            /*!< [7..6] Debug Mode                                                         */
            uint32_t            : 1;
      __IOM uint32_t GTBEEN     : 1;            /*!< [9..9] Global Time Base Enable                                            */
      __IOM uint32_t GTBEOUT    : 1;            /*!< [10..10] Global Time Base Output                                          */
      __IOM uint32_t ITRIGR     : 1;            /*!< [11..11] Initialization trigger on Reload Point                           */
            uint32_t            : 20;
    } FTM0_CONF_b;
  } ;

  union {
    __IOM uint32_t FTM0_FLTPOL;                 /*!< (@ 0x00000088) FTM Fault Input Polarity                                   */

    struct {
      __IOM uint32_t FLT0POL    : 1;            /*!< [0..0] Fault Input 0 Polarity                                             */
      __IOM uint32_t FLT1POL    : 1;            /*!< [1..1] Fault Input 1 Polarity                                             */
      __IOM uint32_t FLT2POL    : 1;            /*!< [2..2] Fault Input 2 Polarity                                             */
      __IOM uint32_t FLT3POL    : 1;            /*!< [3..3] Fault Input 3 Polarity                                             */
            uint32_t            : 28;
    } FTM0_FLTPOL_b;
  } ;

  union {
    __IOM uint32_t FTM0_SYNCONF;                /*!< (@ 0x0000008C) Synchronization Configuration                              */

    struct {
      __IOM uint32_t HWTRIGMODE : 1;            /*!< [0..0] Hardware Trigger Mode                                              */
            uint32_t            : 1;
      __IOM uint32_t CNTINC     : 1;            /*!< [2..2] CNTIN Register Synchronization                                     */
            uint32_t            : 1;
      __IOM uint32_t INVC       : 1;            /*!< [4..4] INVCTRL Register Synchronization                                   */
      __IOM uint32_t SWOC       : 1;            /*!< [5..5] SWOCTRL Register Synchronization                                   */
            uint32_t            : 1;
      __IOM uint32_t SYNCMODE   : 1;            /*!< [7..7] Synchronization Mode                                               */
      __IOM uint32_t SWRSTCNT   : 1;            /*!< [8..8] FTM counter synchronization is activated by the software
                                                     trigger                                                                   */
      __IOM uint32_t SWWRBUF    : 1;            /*!< [9..9] MOD, HCR, CNTIN, and CV registers synchronization is
                                                     activated by the software trigger                                         */
      __IOM uint32_t SWOM       : 1;            /*!< [10..10] Output mask synchronization is activated by the software
                                                     trigger                                                                   */
      __IOM uint32_t SWINVC     : 1;            /*!< [11..11] Inverting control synchronization is activated by the
                                                     software trigger                                                          */
      __IOM uint32_t SWSOC      : 1;            /*!< [12..12] Software output control synchronization is activated
                                                     by the software trigger                                                   */
            uint32_t            : 3;
      __IOM uint32_t HWRSTCNT   : 1;            /*!< [16..16] FTM counter synchronization is activated by a hardware
                                                     trigger                                                                   */
      __IOM uint32_t HWWRBUF    : 1;            /*!< [17..17] MOD, HCR, CNTIN, and CV registers synchronization is
                                                     activated by a hardware trigger                                           */
      __IOM uint32_t HWOM       : 1;            /*!< [18..18] Output mask synchronization is activated by a hardware
                                                     trigger                                                                   */
      __IOM uint32_t HWINVC     : 1;            /*!< [19..19] Inverting control synchronization is activated by a
                                                     hardware trigger                                                          */
      __IOM uint32_t HWSOC      : 1;            /*!< [20..20] Software output control synchronization is activated
                                                     by a hardware trigger                                                     */
            uint32_t            : 11;
    } FTM0_SYNCONF_b;
  } ;

  union {
    __IOM uint32_t FTM0_INVCTRL;                /*!< (@ 0x00000090) FTM Inverting Control                                      */

    struct {
      __IOM uint32_t INV0EN     : 1;            /*!< [0..0] Pair Channels 0 Inverting Enable                                   */
      __IOM uint32_t INV1EN     : 1;            /*!< [1..1] Pair Channels 1 Inverting Enable                                   */
      __IOM uint32_t INV2EN     : 1;            /*!< [2..2] Pair Channels 2 Inverting Enable                                   */
      __IOM uint32_t INV3EN     : 1;            /*!< [3..3] Pair Channels 3 Inverting Enable                                   */
            uint32_t            : 28;
    } FTM0_INVCTRL_b;
  } ;

  union {
    __IOM uint32_t FTM0_SWOCTRL;                /*!< (@ 0x00000094) FTM Software Output Control                                */

    struct {
      __IOM uint32_t CH0OC      : 1;            /*!< [0..0] Channel 0 Software Output Control Enable                           */
      __IOM uint32_t CH1OC      : 1;            /*!< [1..1] Channel 1 Software Output Control Enable                           */
      __IOM uint32_t CH2OC      : 1;            /*!< [2..2] Channel 2 Software Output Control Enable                           */
      __IOM uint32_t CH3OC      : 1;            /*!< [3..3] Channel 3 Software Output Control Enable                           */
      __IOM uint32_t CH4OC      : 1;            /*!< [4..4] Channel 4 Software Output Control Enable                           */
      __IOM uint32_t CH5OC      : 1;            /*!< [5..5] Channel 5 Software Output Control Enable                           */
      __IOM uint32_t CH6OC      : 1;            /*!< [6..6] Channel 6 Software Output Control Enable                           */
      __IOM uint32_t CH7OC      : 1;            /*!< [7..7] Channel 7 Software Output Control Enable                           */
      __IOM uint32_t CH0OCV     : 1;            /*!< [8..8] Channel 0 Software Output Control Value                            */
      __IOM uint32_t CH1OCV     : 1;            /*!< [9..9] Channel 1 Software Output Control Value                            */
      __IOM uint32_t CH2OCV     : 1;            /*!< [10..10] Channel 2 Software Output Control Value                          */
      __IOM uint32_t CH3OCV     : 1;            /*!< [11..11] Channel 3 Software Output Control Value                          */
      __IOM uint32_t CH4OCV     : 1;            /*!< [12..12] Channel 4 Software Output Control Value                          */
      __IOM uint32_t CH5OCV     : 1;            /*!< [13..13] Channel 5 Software Output Control Value                          */
      __IOM uint32_t CH6OCV     : 1;            /*!< [14..14] Channel 6 Software Output Control Value                          */
      __IOM uint32_t CH7OCV     : 1;            /*!< [15..15] Channel 7 Software Output Control Value                          */
            uint32_t            : 16;
    } FTM0_SWOCTRL_b;
  } ;

  union {
    __IOM uint32_t FTM0_PWMLOAD;                /*!< (@ 0x00000098) FTM PWM Load                                               */

    struct {
      __IOM uint32_t CH0SEL     : 1;            /*!< [0..0] Channel 0 Select                                                   */
      __IOM uint32_t CH1SEL     : 1;            /*!< [1..1] Channel 1 Select                                                   */
      __IOM uint32_t CH2SEL     : 1;            /*!< [2..2] Channel 2 Select                                                   */
      __IOM uint32_t CH3SEL     : 1;            /*!< [3..3] Channel 3 Select                                                   */
      __IOM uint32_t CH4SEL     : 1;            /*!< [4..4] Channel 4 Select                                                   */
      __IOM uint32_t CH5SEL     : 1;            /*!< [5..5] Channel 5 Select                                                   */
      __IOM uint32_t CH6SEL     : 1;            /*!< [6..6] Channel 6 Select                                                   */
      __IOM uint32_t CH7SEL     : 1;            /*!< [7..7] Channel 7 Select                                                   */
      __IOM uint32_t HCSEL      : 1;            /*!< [8..8] Half Cycle Select                                                  */
      __IOM uint32_t LDOK       : 1;            /*!< [9..9] Load Enable                                                        */
      __IOM uint32_t GLEN       : 1;            /*!< [10..10] Global Load Enable                                               */
      __OM  uint32_t GLDOK      : 1;            /*!< [11..11] Global Load OK                                                   */
            uint32_t            : 20;
    } FTM0_PWMLOAD_b;
  } ;

  union {
    __IOM uint32_t FTM0_HCR;                    /*!< (@ 0x0000009C) Half Cycle Register                                        */

    struct {
      __IOM uint32_t HCVAL      : 16;           /*!< [15..0] Half Cycle Value                                                  */
            uint32_t            : 16;
    } FTM0_HCR_b;
  } ;

  union {
    __IOM uint32_t FTM0_PAIR0DEADTIME;          /*!< (@ 0x000000A0) Pair 0 Deadtime Configuration                              */

    struct {
      __IOM uint32_t DTVAL      : 6;            /*!< [5..0] Deadtime Value                                                     */
      __IOM uint32_t DTPS       : 2;            /*!< [7..6] Deadtime Prescaler Value                                           */
            uint32_t            : 8;
      __IOM uint32_t DTVALEX    : 4;            /*!< [19..16] Extended Deadtime Value                                          */
            uint32_t            : 12;
    } FTM0_PAIR0DEADTIME_b;
  } ;
  __IM  uint32_t  RESERVED;

  union {
    __IOM uint32_t FTM0_PAIR1DEADTIME;          /*!< (@ 0x000000A8) Pair 1 Deadtime Configuration                              */

    struct {
      __IOM uint32_t DTVAL      : 6;            /*!< [5..0] Deadtime Value                                                     */
      __IOM uint32_t DTPS       : 2;            /*!< [7..6] Deadtime Prescaler Value                                           */
            uint32_t            : 8;
      __IOM uint32_t DTVALEX    : 4;            /*!< [19..16] Extended Deadtime Value                                          */
            uint32_t            : 12;
    } FTM0_PAIR1DEADTIME_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t FTM0_PAIR2DEADTIME;          /*!< (@ 0x000000B0) Pair 2 Deadtime Configuration                              */

    struct {
      __IOM uint32_t DTVAL      : 6;            /*!< [5..0] Deadtime Value                                                     */
      __IOM uint32_t DTPS       : 2;            /*!< [7..6] Deadtime Prescaler Value                                           */
            uint32_t            : 8;
      __IOM uint32_t DTVALEX    : 4;            /*!< [19..16] Extended Deadtime Value                                          */
            uint32_t            : 12;
    } FTM0_PAIR2DEADTIME_b;
  } ;
  __IM  uint32_t  RESERVED2;

  union {
    __IOM uint32_t FTM0_PAIR3DEADTIME;          /*!< (@ 0x000000B8) Pair 3 Deadtime Configuration                              */

    struct {
      __IOM uint32_t DTVAL      : 6;            /*!< [5..0] Deadtime Value                                                     */
      __IOM uint32_t DTPS       : 2;            /*!< [7..6] Deadtime Prescaler Value                                           */
            uint32_t            : 8;
      __IOM uint32_t DTVALEX    : 4;            /*!< [19..16] Extended Deadtime Value                                          */
            uint32_t            : 12;
    } FTM0_PAIR3DEADTIME_b;
  } ;
  __IM  uint32_t  RESERVED3[81];

  union {
    __IOM uint32_t FTM0_MOD_MIRROR;             /*!< (@ 0x00000200) Mirror of Modulo Value                                     */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACMOD    : 5;            /*!< [15..11] Modulo Fractional Value                                          */
      __IOM uint32_t MOD        : 16;           /*!< [31..16] Mirror of the Modulo Integer Value                               */
    } FTM0_MOD_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM0_C0V_MIRROR;             /*!< (@ 0x00000204) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM0_C0V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM0_C1V_MIRROR;             /*!< (@ 0x00000208) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM0_C1V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM0_C2V_MIRROR;             /*!< (@ 0x0000020C) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM0_C2V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM0_C3V_MIRROR;             /*!< (@ 0x00000210) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM0_C3V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM0_C4V_MIRROR;             /*!< (@ 0x00000214) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM0_C4V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM0_C5V_MIRROR;             /*!< (@ 0x00000218) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM0_C5V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM0_C6V_MIRROR;             /*!< (@ 0x0000021C) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM0_C6V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM0_C7V_MIRROR;             /*!< (@ 0x00000220) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM0_C7V_MIRROR_b;
  } ;
} FTM0_Type;                                    /*!< Size = 548 (0x224)                                                        */



/* =========================================================================================================================== */
/* ================                                           FTM1                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief FlexTimer Module (FTM1)
  */

typedef struct {                                /*!< (@ 0x40039000) FTM1 Structure                                             */

  union {
    __IOM uint32_t FTM1_SC;                     /*!< (@ 0x00000000) Status And Control                                         */

    struct {
      __IOM uint32_t PS         : 3;            /*!< [2..0] Prescale Factor Selection                                          */
      __IOM uint32_t CLKS       : 2;            /*!< [4..3] Clock Source Selection                                             */
      __IOM uint32_t CPWMS      : 1;            /*!< [5..5] Center-Aligned PWM Select                                          */
      __IOM uint32_t RIE        : 1;            /*!< [6..6] Reload Point Interrupt Enable                                      */
      __IM  uint32_t RF         : 1;            /*!< [7..7] Reload Flag                                                        */
      __IOM uint32_t TOIE       : 1;            /*!< [8..8] Timer Overflow Interrupt Enable                                    */
      __IM  uint32_t TOF        : 1;            /*!< [9..9] Timer Overflow Flag                                                */
            uint32_t            : 6;
      __IOM uint32_t PWMEN0     : 1;            /*!< [16..16] Channel 0 PWM enable bit                                         */
      __IOM uint32_t PWMEN1     : 1;            /*!< [17..17] Channel 1 PWM enable bit                                         */
      __IOM uint32_t PWMEN2     : 1;            /*!< [18..18] Channel 2 PWM enable bit                                         */
      __IOM uint32_t PWMEN3     : 1;            /*!< [19..19] Channel 3 PWM enable bit                                         */
      __IOM uint32_t PWMEN4     : 1;            /*!< [20..20] Channel 4 PWM enable bit                                         */
      __IOM uint32_t PWMEN5     : 1;            /*!< [21..21] Channel 5 PWM enable bit                                         */
      __IOM uint32_t PWMEN6     : 1;            /*!< [22..22] Channel 6 PWM enable bit                                         */
      __IOM uint32_t PWMEN7     : 1;            /*!< [23..23] Channel 7 PWM enable bit                                         */
      __IOM uint32_t FLTPS      : 4;            /*!< [27..24] Filter Prescaler                                                 */
            uint32_t            : 4;
    } FTM1_SC_b;
  } ;

  union {
    __IOM uint32_t FTM1_CNT;                    /*!< (@ 0x00000004) Counter                                                    */

    struct {
      __IOM uint32_t COUNT      : 16;           /*!< [15..0] Counter Value                                                     */
            uint32_t            : 16;
    } FTM1_CNT_b;
  } ;

  union {
    __IOM uint32_t FTM1_MOD;                    /*!< (@ 0x00000008) Modulo                                                     */

    struct {
      __IOM uint32_t MOD        : 16;           /*!< [15..0] MOD                                                               */
            uint32_t            : 16;
    } FTM1_MOD_b;
  } ;

  union {
    __IOM uint32_t FTM1_C0SC;                   /*!< (@ 0x0000000C) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM1_C0SC_b;
  } ;

  union {
    __IOM uint32_t FTM1_C0V;                    /*!< (@ 0x00000010) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM1_C0V_b;
  } ;

  union {
    __IOM uint32_t FTM1_C1SC;                   /*!< (@ 0x00000014) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM1_C1SC_b;
  } ;

  union {
    __IOM uint32_t FTM1_C1V;                    /*!< (@ 0x00000018) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM1_C1V_b;
  } ;

  union {
    __IOM uint32_t FTM1_C2SC;                   /*!< (@ 0x0000001C) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM1_C2SC_b;
  } ;

  union {
    __IOM uint32_t FTM1_C2V;                    /*!< (@ 0x00000020) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM1_C2V_b;
  } ;

  union {
    __IOM uint32_t FTM1_C3SC;                   /*!< (@ 0x00000024) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM1_C3SC_b;
  } ;

  union {
    __IOM uint32_t FTM1_C3V;                    /*!< (@ 0x00000028) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM1_C3V_b;
  } ;

  union {
    __IOM uint32_t FTM1_C4SC;                   /*!< (@ 0x0000002C) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM1_C4SC_b;
  } ;

  union {
    __IOM uint32_t FTM1_C4V;                    /*!< (@ 0x00000030) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM1_C4V_b;
  } ;

  union {
    __IOM uint32_t FTM1_C5SC;                   /*!< (@ 0x00000034) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM1_C5SC_b;
  } ;

  union {
    __IOM uint32_t FTM1_C5V;                    /*!< (@ 0x00000038) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM1_C5V_b;
  } ;

  union {
    __IOM uint32_t FTM1_C6SC;                   /*!< (@ 0x0000003C) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM1_C6SC_b;
  } ;

  union {
    __IOM uint32_t FTM1_C6V;                    /*!< (@ 0x00000040) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM1_C6V_b;
  } ;

  union {
    __IOM uint32_t FTM1_C7SC;                   /*!< (@ 0x00000044) Channel (n) Status And Control                             */

    struct {
      __IOM uint32_t DMA        : 1;            /*!< [0..0] DMA Enable                                                         */
      __IOM uint32_t ICRST      : 1;            /*!< [1..1] FTM counter reset by the selected input capture event.             */
      __IOM uint32_t ELSA       : 1;            /*!< [2..2] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t ELSB       : 1;            /*!< [3..3] Channel (n) Edge or Level Select                                   */
      __IOM uint32_t MSA        : 1;            /*!< [4..4] Channel (n) Mode Select                                            */
      __IOM uint32_t MSB        : 1;            /*!< [5..5] Channel (n) Mode Select                                            */
      __IOM uint32_t CHIE       : 1;            /*!< [6..6] Channel (n) Interrupt Enable                                       */
      __IM  uint32_t CHF        : 1;            /*!< [7..7] Channel (n) Flag                                                   */
      __IOM uint32_t TRIGMODE   : 1;            /*!< [8..8] Trigger mode control                                               */
      __IM  uint32_t CHIS       : 1;            /*!< [9..9] Channel (n) Input State                                            */
      __IM  uint32_t CHOV       : 1;            /*!< [10..10] Channel (n) Output Value                                         */
            uint32_t            : 21;
    } FTM1_C7SC_b;
  } ;

  union {
    __IOM uint32_t FTM1_C7V;                    /*!< (@ 0x00000048) Channel (n) Value                                          */

    struct {
      __IOM uint32_t VAL        : 16;           /*!< [15..0] Channel Value                                                     */
            uint32_t            : 16;
    } FTM1_C7V_b;
  } ;

  union {
    __IOM uint32_t FTM1_CNTIN;                  /*!< (@ 0x0000004C) Counter Initial Value                                      */

    struct {
      __IOM uint32_t INIT       : 16;           /*!< [15..0] INIT                                                              */
            uint32_t            : 16;
    } FTM1_CNTIN_b;
  } ;

  union {
    __IM  uint32_t FTM1_STATUS;                 /*!< (@ 0x00000050) Capture And Compare Status                                 */

    struct {
      __IM  uint32_t CH0F       : 1;            /*!< [0..0] Channel 0 Flag                                                     */
      __IM  uint32_t CH1F       : 1;            /*!< [1..1] Channel 1 Flag                                                     */
      __IM  uint32_t CH2F       : 1;            /*!< [2..2] Channel 2 Flag                                                     */
      __IM  uint32_t CH3F       : 1;            /*!< [3..3] Channel 3 Flag                                                     */
      __IM  uint32_t CH4F       : 1;            /*!< [4..4] Channel 4 Flag                                                     */
      __IM  uint32_t CH5F       : 1;            /*!< [5..5] Channel 5 Flag                                                     */
      __IM  uint32_t CH6F       : 1;            /*!< [6..6] Channel 6 Flag                                                     */
      __IM  uint32_t CH7F       : 1;            /*!< [7..7] Channel 7 Flag                                                     */
            uint32_t            : 24;
    } FTM1_STATUS_b;
  } ;

  union {
    __IOM uint32_t FTM1_MODE;                   /*!< (@ 0x00000054) Features Mode Selection                                    */

    struct {
      __IOM uint32_t FTMEN      : 1;            /*!< [0..0] FTM Enable                                                         */
      __OM  uint32_t INIT       : 1;            /*!< [1..1] Initialize The Channels Output                                     */
      __IOM uint32_t WPDIS      : 1;            /*!< [2..2] Write Protection Disable                                           */
      __IOM uint32_t PWMSYNC    : 1;            /*!< [3..3] PWM Synchronization Mode                                           */
      __IOM uint32_t CAPTEST    : 1;            /*!< [4..4] Capture Test Mode Enable                                           */
      __IOM uint32_t FAULTM     : 2;            /*!< [6..5] Fault Control Mode                                                 */
      __IOM uint32_t FAULTIE    : 1;            /*!< [7..7] Fault Interrupt Enable                                             */
            uint32_t            : 24;
    } FTM1_MODE_b;
  } ;

  union {
    __IOM uint32_t FTM1_SYNC;                   /*!< (@ 0x00000058) Synchronization                                            */

    struct {
      __IOM uint32_t CNTMIN     : 1;            /*!< [0..0] Minimum Loading Point Enable                                       */
      __IOM uint32_t CNTMAX     : 1;            /*!< [1..1] Maximum Loading Point Enable                                       */
      __IOM uint32_t REINIT     : 1;            /*!< [2..2] FTM Counter Reinitialization by Synchronization                    */
      __IOM uint32_t SYNCHOM    : 1;            /*!< [3..3] Output Mask Synchronization                                        */
      __IOM uint32_t TRIG0      : 1;            /*!< [4..4] PWM Synchronization Hardware Trigger 0                             */
      __IOM uint32_t TRIG1      : 1;            /*!< [5..5] PWM Synchronization Hardware Trigger 1                             */
      __IOM uint32_t TRIG2      : 1;            /*!< [6..6] PWM Synchronization Hardware Trigger 2                             */
      __IOM uint32_t SWSYNC     : 1;            /*!< [7..7] PWM Synchronization Software Trigger                               */
            uint32_t            : 24;
    } FTM1_SYNC_b;
  } ;

  union {
    __IOM uint32_t FTM1_OUTINIT;                /*!< (@ 0x0000005C) Initial State For Channels Output                          */

    struct {
      __IOM uint32_t CH0OI      : 1;            /*!< [0..0] Channel 0 Output Initialization Value                              */
      __IOM uint32_t CH1OI      : 1;            /*!< [1..1] Channel 1 Output Initialization Value                              */
      __IOM uint32_t CH2OI      : 1;            /*!< [2..2] Channel 2 Output Initialization Value                              */
      __IOM uint32_t CH3OI      : 1;            /*!< [3..3] Channel 3 Output Initialization Value                              */
      __IOM uint32_t CH4OI      : 1;            /*!< [4..4] Channel 4 Output Initialization Value                              */
      __IOM uint32_t CH5OI      : 1;            /*!< [5..5] Channel 5 Output Initialization Value                              */
      __IOM uint32_t CH6OI      : 1;            /*!< [6..6] Channel 6 Output Initialization Value                              */
      __IOM uint32_t CH7OI      : 1;            /*!< [7..7] Channel 7 Output Initialization Value                              */
            uint32_t            : 24;
    } FTM1_OUTINIT_b;
  } ;

  union {
    __IOM uint32_t FTM1_OUTMASK;                /*!< (@ 0x00000060) Output Mask                                                */

    struct {
      __IOM uint32_t CH0OM      : 1;            /*!< [0..0] Channel 0 Output Mask                                              */
      __IOM uint32_t CH1OM      : 1;            /*!< [1..1] Channel 1 Output Mask                                              */
      __IOM uint32_t CH2OM      : 1;            /*!< [2..2] Channel 2 Output Mask                                              */
      __IOM uint32_t CH3OM      : 1;            /*!< [3..3] Channel 3 Output Mask                                              */
      __IOM uint32_t CH4OM      : 1;            /*!< [4..4] Channel 4 Output Mask                                              */
      __IOM uint32_t CH5OM      : 1;            /*!< [5..5] Channel 5 Output Mask                                              */
      __IOM uint32_t CH6OM      : 1;            /*!< [6..6] Channel 6 Output Mask                                              */
      __IOM uint32_t CH7OM      : 1;            /*!< [7..7] Channel 7 Output Mask                                              */
            uint32_t            : 24;
    } FTM1_OUTMASK_b;
  } ;

  union {
    __IOM uint32_t FTM1_COMBINE;                /*!< (@ 0x00000064) Function For Linked Channels                               */

    struct {
      __IOM uint32_t COMBINE0   : 1;            /*!< [0..0] Combine Channels For n = 0                                         */
      __IOM uint32_t COMP0      : 1;            /*!< [1..1] Complement Of Channel (n) For n = 0                                */
      __IOM uint32_t DECAPEN0   : 1;            /*!< [2..2] Dual Edge Capture Mode Enable For n = 0                            */
      __IOM uint32_t DECAP0     : 1;            /*!< [3..3] Dual Edge Capture Mode Captures For n = 0                          */
      __IOM uint32_t DTEN0      : 1;            /*!< [4..4] Deadtime Enable For n = 0                                          */
      __IOM uint32_t SYNCEN0    : 1;            /*!< [5..5] Synchronization Enable For n = 0                                   */
      __IOM uint32_t FAULTEN0   : 1;            /*!< [6..6] Fault Control Enable For n = 0                                     */
      __IOM uint32_t MCOMBINE0  : 1;            /*!< [7..7] Modified Combine Mode For n = 0                                    */
      __IOM uint32_t COMBINE1   : 1;            /*!< [8..8] Combine Channels For n = 2                                         */
      __IOM uint32_t COMP1      : 1;            /*!< [9..9] Complement Of Channel (n) For n = 2                                */
      __IOM uint32_t DECAPEN1   : 1;            /*!< [10..10] Dual Edge Capture Mode Enable For n = 2                          */
      __IOM uint32_t DECAP1     : 1;            /*!< [11..11] Dual Edge Capture Mode Captures For n = 2                        */
      __IOM uint32_t DTEN1      : 1;            /*!< [12..12] Deadtime Enable For n = 2                                        */
      __IOM uint32_t SYNCEN1    : 1;            /*!< [13..13] Synchronization Enable For n = 2                                 */
      __IOM uint32_t FAULTEN1   : 1;            /*!< [14..14] Fault Control Enable For n = 2                                   */
      __IOM uint32_t MCOMBINE1  : 1;            /*!< [15..15] Modified Combine Mode For n = 2                                  */
      __IOM uint32_t COMBINE2   : 1;            /*!< [16..16] Combine Channels For n = 4                                       */
      __IOM uint32_t COMP2      : 1;            /*!< [17..17] Complement Of Channel (n) For n = 4                              */
      __IOM uint32_t DECAPEN2   : 1;            /*!< [18..18] Dual Edge Capture Mode Enable For n = 4                          */
      __IOM uint32_t DECAP2     : 1;            /*!< [19..19] Dual Edge Capture Mode Captures For n = 4                        */
      __IOM uint32_t DTEN2      : 1;            /*!< [20..20] Deadtime Enable For n = 4                                        */
      __IOM uint32_t SYNCEN2    : 1;            /*!< [21..21] Synchronization Enable For n = 4                                 */
      __IOM uint32_t FAULTEN2   : 1;            /*!< [22..22] Fault Control Enable For n = 4                                   */
      __IOM uint32_t MCOMBINE2  : 1;            /*!< [23..23] Modified Combine Mode For n = 4                                  */
      __IOM uint32_t COMBINE3   : 1;            /*!< [24..24] Combine Channels For n = 6                                       */
      __IOM uint32_t COMP3      : 1;            /*!< [25..25] Complement Of Channel (n) for n = 6                              */
      __IOM uint32_t DECAPEN3   : 1;            /*!< [26..26] Dual Edge Capture Mode Enable For n = 6                          */
      __IOM uint32_t DECAP3     : 1;            /*!< [27..27] Dual Edge Capture Mode Captures For n = 6                        */
      __IOM uint32_t DTEN3      : 1;            /*!< [28..28] Deadtime Enable For n = 6                                        */
      __IOM uint32_t SYNCEN3    : 1;            /*!< [29..29] Synchronization Enable For n = 6                                 */
      __IOM uint32_t FAULTEN3   : 1;            /*!< [30..30] Fault Control Enable For n = 6                                   */
      __IOM uint32_t MCOMBINE3  : 1;            /*!< [31..31] Modified Combine Mode For n = 6                                  */
    } FTM1_COMBINE_b;
  } ;

  union {
    __IOM uint32_t FTM1_DEADTIME;               /*!< (@ 0x00000068) Deadtime Configuration                                     */

    struct {
      __IOM uint32_t DTVAL      : 6;            /*!< [5..0] Deadtime Value                                                     */
      __IOM uint32_t DTPS       : 2;            /*!< [7..6] Deadtime Prescaler Value                                           */
            uint32_t            : 8;
      __IOM uint32_t DTVALEX    : 4;            /*!< [19..16] Extended Deadtime Value                                          */
            uint32_t            : 12;
    } FTM1_DEADTIME_b;
  } ;

  union {
    __IOM uint32_t FTM1_EXTTRIG;                /*!< (@ 0x0000006C) FTM External Trigger                                       */

    struct {
      __IOM uint32_t CH2TRIG    : 1;            /*!< [0..0] Channel 2 External Trigger Enable                                  */
      __IOM uint32_t CH3TRIG    : 1;            /*!< [1..1] Channel 3 External Trigger Enable                                  */
      __IOM uint32_t CH4TRIG    : 1;            /*!< [2..2] Channel 4 External Trigger Enable                                  */
      __IOM uint32_t CH5TRIG    : 1;            /*!< [3..3] Channel 5 External Trigger Enable                                  */
      __IOM uint32_t CH0TRIG    : 1;            /*!< [4..4] Channel 0 External Trigger Enable                                  */
      __IOM uint32_t CH1TRIG    : 1;            /*!< [5..5] Channel 1 External Trigger Enable                                  */
      __IOM uint32_t INITTRIGEN : 1;            /*!< [6..6] Initialization Trigger Enable                                      */
      __IM  uint32_t TRIGF      : 1;            /*!< [7..7] Channel Trigger Flag                                               */
      __IOM uint32_t CH6TRIG    : 1;            /*!< [8..8] Channel 6 External Trigger Enable                                  */
      __IOM uint32_t CH7TRIG    : 1;            /*!< [9..9] Channel 7 External Trigger Enable                                  */
            uint32_t            : 22;
    } FTM1_EXTTRIG_b;
  } ;

  union {
    __IOM uint32_t FTM1_POL;                    /*!< (@ 0x00000070) Channels Polarity                                          */

    struct {
      __IOM uint32_t POL0       : 1;            /*!< [0..0] Channel 0 Polarity                                                 */
      __IOM uint32_t POL1       : 1;            /*!< [1..1] Channel 1 Polarity                                                 */
      __IOM uint32_t POL2       : 1;            /*!< [2..2] Channel 2 Polarity                                                 */
      __IOM uint32_t POL3       : 1;            /*!< [3..3] Channel 3 Polarity                                                 */
      __IOM uint32_t POL4       : 1;            /*!< [4..4] Channel 4 Polarity                                                 */
      __IOM uint32_t POL5       : 1;            /*!< [5..5] Channel 5 Polarity                                                 */
      __IOM uint32_t POL6       : 1;            /*!< [6..6] Channel 6 Polarity                                                 */
      __IOM uint32_t POL7       : 1;            /*!< [7..7] Channel 7 Polarity                                                 */
            uint32_t            : 24;
    } FTM1_POL_b;
  } ;

  union {
    __IOM uint32_t FTM1_FMS;                    /*!< (@ 0x00000074) Fault Mode Status                                          */

    struct {
      __IM  uint32_t FAULTF0    : 1;            /*!< [0..0] Fault Detection Flag 0                                             */
      __IM  uint32_t FAULTF1    : 1;            /*!< [1..1] Fault Detection Flag 1                                             */
      __IM  uint32_t FAULTF2    : 1;            /*!< [2..2] Fault Detection Flag 2                                             */
      __IM  uint32_t FAULTF3    : 1;            /*!< [3..3] Fault Detection Flag 3                                             */
            uint32_t            : 1;
      __IM  uint32_t FAULTIN    : 1;            /*!< [5..5] Fault Inputs                                                       */
      __IOM uint32_t WPEN       : 1;            /*!< [6..6] Write Protection Enable                                            */
      __IM  uint32_t FAULTF     : 1;            /*!< [7..7] Fault Detection Flag                                               */
            uint32_t            : 24;
    } FTM1_FMS_b;
  } ;

  union {
    __IOM uint32_t FTM1_FILTER;                 /*!< (@ 0x00000078) Input Capture Filter Control                               */

    struct {
      __IOM uint32_t CH0FVAL    : 4;            /*!< [3..0] Channel 0 Input Filter                                             */
      __IOM uint32_t CH1FVAL    : 4;            /*!< [7..4] Channel 1 Input Filter                                             */
      __IOM uint32_t CH2FVAL    : 4;            /*!< [11..8] Channel 2 Input Filter                                            */
      __IOM uint32_t CH3FVAL    : 4;            /*!< [15..12] Channel 3 Input Filter                                           */
            uint32_t            : 16;
    } FTM1_FILTER_b;
  } ;

  union {
    __IOM uint32_t FTM1_FLTCTRL;                /*!< (@ 0x0000007C) Fault Control                                              */

    struct {
      __IOM uint32_t FAULT0EN   : 1;            /*!< [0..0] Fault Input 0 Enable                                               */
      __IOM uint32_t FAULT1EN   : 1;            /*!< [1..1] Fault Input 1 Enable                                               */
      __IOM uint32_t FAULT2EN   : 1;            /*!< [2..2] Fault Input 2 Enable                                               */
      __IOM uint32_t FAULT3EN   : 1;            /*!< [3..3] Fault Input 3 Enable                                               */
      __IOM uint32_t FFLTR0EN   : 1;            /*!< [4..4] Fault Input 0 Filter Enable                                        */
      __IOM uint32_t FFLTR1EN   : 1;            /*!< [5..5] Fault Input 1 Filter Enable                                        */
      __IOM uint32_t FFLTR2EN   : 1;            /*!< [6..6] Fault Input 2 Filter Enable                                        */
      __IOM uint32_t FFLTR3EN   : 1;            /*!< [7..7] Fault Input 3 Filter Enable                                        */
      __IOM uint32_t FFVAL      : 4;            /*!< [11..8] Fault Input Filter                                                */
            uint32_t            : 3;
      __IOM uint32_t FSTATE     : 1;            /*!< [15..15] Fault output state                                               */
            uint32_t            : 16;
    } FTM1_FLTCTRL_b;
  } ;

  union {
    __IOM uint32_t FTM1_QDCTRL;                 /*!< (@ 0x00000080) Quadrature Decoder Control And Status                      */

    struct {
      __IOM uint32_t QUADEN     : 1;            /*!< [0..0] Quadrature Decoder Mode Enable                                     */
      __IM  uint32_t TOFDIR     : 1;            /*!< [1..1] Timer Overflow Direction In Quadrature Decoder Mode                */
      __IM  uint32_t QUADIR     : 1;            /*!< [2..2] FTM Counter Direction In Quadrature Decoder Mode                   */
      __IOM uint32_t QUADMODE   : 1;            /*!< [3..3] Quadrature Decoder Mode                                            */
      __IOM uint32_t PHBPOL     : 1;            /*!< [4..4] Phase B Input Polarity                                             */
      __IOM uint32_t PHAPOL     : 1;            /*!< [5..5] Phase A Input Polarity                                             */
      __IOM uint32_t PHBFLTREN  : 1;            /*!< [6..6] Phase B Input Filter Enable                                        */
      __IOM uint32_t PHAFLTREN  : 1;            /*!< [7..7] Phase A Input Filter Enable                                        */
            uint32_t            : 24;
    } FTM1_QDCTRL_b;
  } ;

  union {
    __IOM uint32_t FTM1_CONF;                   /*!< (@ 0x00000084) Configuration                                              */

    struct {
      __IOM uint32_t LDFQ       : 5;            /*!< [4..0] Frequency of the Reload Opportunities                              */
            uint32_t            : 1;
      __IOM uint32_t BDMMODE    : 2;            /*!< [7..6] Debug Mode                                                         */
            uint32_t            : 1;
      __IOM uint32_t GTBEEN     : 1;            /*!< [9..9] Global Time Base Enable                                            */
      __IOM uint32_t GTBEOUT    : 1;            /*!< [10..10] Global Time Base Output                                          */
      __IOM uint32_t ITRIGR     : 1;            /*!< [11..11] Initialization trigger on Reload Point                           */
            uint32_t            : 20;
    } FTM1_CONF_b;
  } ;

  union {
    __IOM uint32_t FTM1_FLTPOL;                 /*!< (@ 0x00000088) FTM Fault Input Polarity                                   */

    struct {
      __IOM uint32_t FLT0POL    : 1;            /*!< [0..0] Fault Input 0 Polarity                                             */
      __IOM uint32_t FLT1POL    : 1;            /*!< [1..1] Fault Input 1 Polarity                                             */
      __IOM uint32_t FLT2POL    : 1;            /*!< [2..2] Fault Input 2 Polarity                                             */
      __IOM uint32_t FLT3POL    : 1;            /*!< [3..3] Fault Input 3 Polarity                                             */
            uint32_t            : 28;
    } FTM1_FLTPOL_b;
  } ;

  union {
    __IOM uint32_t FTM1_SYNCONF;                /*!< (@ 0x0000008C) Synchronization Configuration                              */

    struct {
      __IOM uint32_t HWTRIGMODE : 1;            /*!< [0..0] Hardware Trigger Mode                                              */
            uint32_t            : 1;
      __IOM uint32_t CNTINC     : 1;            /*!< [2..2] CNTIN Register Synchronization                                     */
            uint32_t            : 1;
      __IOM uint32_t INVC       : 1;            /*!< [4..4] INVCTRL Register Synchronization                                   */
      __IOM uint32_t SWOC       : 1;            /*!< [5..5] SWOCTRL Register Synchronization                                   */
            uint32_t            : 1;
      __IOM uint32_t SYNCMODE   : 1;            /*!< [7..7] Synchronization Mode                                               */
      __IOM uint32_t SWRSTCNT   : 1;            /*!< [8..8] FTM counter synchronization is activated by the software
                                                     trigger                                                                   */
      __IOM uint32_t SWWRBUF    : 1;            /*!< [9..9] MOD, HCR, CNTIN, and CV registers synchronization is
                                                     activated by the software trigger                                         */
      __IOM uint32_t SWOM       : 1;            /*!< [10..10] Output mask synchronization is activated by the software
                                                     trigger                                                                   */
      __IOM uint32_t SWINVC     : 1;            /*!< [11..11] Inverting control synchronization is activated by the
                                                     software trigger                                                          */
      __IOM uint32_t SWSOC      : 1;            /*!< [12..12] Software output control synchronization is activated
                                                     by the software trigger                                                   */
            uint32_t            : 3;
      __IOM uint32_t HWRSTCNT   : 1;            /*!< [16..16] FTM counter synchronization is activated by a hardware
                                                     trigger                                                                   */
      __IOM uint32_t HWWRBUF    : 1;            /*!< [17..17] MOD, HCR, CNTIN, and CV registers synchronization is
                                                     activated by a hardware trigger                                           */
      __IOM uint32_t HWOM       : 1;            /*!< [18..18] Output mask synchronization is activated by a hardware
                                                     trigger                                                                   */
      __IOM uint32_t HWINVC     : 1;            /*!< [19..19] Inverting control synchronization is activated by a
                                                     hardware trigger                                                          */
      __IOM uint32_t HWSOC      : 1;            /*!< [20..20] Software output control synchronization is activated
                                                     by a hardware trigger                                                     */
            uint32_t            : 11;
    } FTM1_SYNCONF_b;
  } ;

  union {
    __IOM uint32_t FTM1_INVCTRL;                /*!< (@ 0x00000090) FTM Inverting Control                                      */

    struct {
      __IOM uint32_t INV0EN     : 1;            /*!< [0..0] Pair Channels 0 Inverting Enable                                   */
      __IOM uint32_t INV1EN     : 1;            /*!< [1..1] Pair Channels 1 Inverting Enable                                   */
      __IOM uint32_t INV2EN     : 1;            /*!< [2..2] Pair Channels 2 Inverting Enable                                   */
      __IOM uint32_t INV3EN     : 1;            /*!< [3..3] Pair Channels 3 Inverting Enable                                   */
            uint32_t            : 28;
    } FTM1_INVCTRL_b;
  } ;

  union {
    __IOM uint32_t FTM1_SWOCTRL;                /*!< (@ 0x00000094) FTM Software Output Control                                */

    struct {
      __IOM uint32_t CH0OC      : 1;            /*!< [0..0] Channel 0 Software Output Control Enable                           */
      __IOM uint32_t CH1OC      : 1;            /*!< [1..1] Channel 1 Software Output Control Enable                           */
      __IOM uint32_t CH2OC      : 1;            /*!< [2..2] Channel 2 Software Output Control Enable                           */
      __IOM uint32_t CH3OC      : 1;            /*!< [3..3] Channel 3 Software Output Control Enable                           */
      __IOM uint32_t CH4OC      : 1;            /*!< [4..4] Channel 4 Software Output Control Enable                           */
      __IOM uint32_t CH5OC      : 1;            /*!< [5..5] Channel 5 Software Output Control Enable                           */
      __IOM uint32_t CH6OC      : 1;            /*!< [6..6] Channel 6 Software Output Control Enable                           */
      __IOM uint32_t CH7OC      : 1;            /*!< [7..7] Channel 7 Software Output Control Enable                           */
      __IOM uint32_t CH0OCV     : 1;            /*!< [8..8] Channel 0 Software Output Control Value                            */
      __IOM uint32_t CH1OCV     : 1;            /*!< [9..9] Channel 1 Software Output Control Value                            */
      __IOM uint32_t CH2OCV     : 1;            /*!< [10..10] Channel 2 Software Output Control Value                          */
      __IOM uint32_t CH3OCV     : 1;            /*!< [11..11] Channel 3 Software Output Control Value                          */
      __IOM uint32_t CH4OCV     : 1;            /*!< [12..12] Channel 4 Software Output Control Value                          */
      __IOM uint32_t CH5OCV     : 1;            /*!< [13..13] Channel 5 Software Output Control Value                          */
      __IOM uint32_t CH6OCV     : 1;            /*!< [14..14] Channel 6 Software Output Control Value                          */
      __IOM uint32_t CH7OCV     : 1;            /*!< [15..15] Channel 7 Software Output Control Value                          */
            uint32_t            : 16;
    } FTM1_SWOCTRL_b;
  } ;

  union {
    __IOM uint32_t FTM1_PWMLOAD;                /*!< (@ 0x00000098) FTM PWM Load                                               */

    struct {
      __IOM uint32_t CH0SEL     : 1;            /*!< [0..0] Channel 0 Select                                                   */
      __IOM uint32_t CH1SEL     : 1;            /*!< [1..1] Channel 1 Select                                                   */
      __IOM uint32_t CH2SEL     : 1;            /*!< [2..2] Channel 2 Select                                                   */
      __IOM uint32_t CH3SEL     : 1;            /*!< [3..3] Channel 3 Select                                                   */
      __IOM uint32_t CH4SEL     : 1;            /*!< [4..4] Channel 4 Select                                                   */
      __IOM uint32_t CH5SEL     : 1;            /*!< [5..5] Channel 5 Select                                                   */
      __IOM uint32_t CH6SEL     : 1;            /*!< [6..6] Channel 6 Select                                                   */
      __IOM uint32_t CH7SEL     : 1;            /*!< [7..7] Channel 7 Select                                                   */
      __IOM uint32_t HCSEL      : 1;            /*!< [8..8] Half Cycle Select                                                  */
      __IOM uint32_t LDOK       : 1;            /*!< [9..9] Load Enable                                                        */
      __IOM uint32_t GLEN       : 1;            /*!< [10..10] Global Load Enable                                               */
      __OM  uint32_t GLDOK      : 1;            /*!< [11..11] Global Load OK                                                   */
            uint32_t            : 20;
    } FTM1_PWMLOAD_b;
  } ;

  union {
    __IOM uint32_t FTM1_HCR;                    /*!< (@ 0x0000009C) Half Cycle Register                                        */

    struct {
      __IOM uint32_t HCVAL      : 16;           /*!< [15..0] Half Cycle Value                                                  */
            uint32_t            : 16;
    } FTM1_HCR_b;
  } ;

  union {
    __IOM uint32_t FTM1_PAIR0DEADTIME;          /*!< (@ 0x000000A0) Pair 0 Deadtime Configuration                              */

    struct {
      __IOM uint32_t DTVAL      : 6;            /*!< [5..0] Deadtime Value                                                     */
      __IOM uint32_t DTPS       : 2;            /*!< [7..6] Deadtime Prescaler Value                                           */
            uint32_t            : 8;
      __IOM uint32_t DTVALEX    : 4;            /*!< [19..16] Extended Deadtime Value                                          */
            uint32_t            : 12;
    } FTM1_PAIR0DEADTIME_b;
  } ;
  __IM  uint32_t  RESERVED;

  union {
    __IOM uint32_t FTM1_PAIR1DEADTIME;          /*!< (@ 0x000000A8) Pair 1 Deadtime Configuration                              */

    struct {
      __IOM uint32_t DTVAL      : 6;            /*!< [5..0] Deadtime Value                                                     */
      __IOM uint32_t DTPS       : 2;            /*!< [7..6] Deadtime Prescaler Value                                           */
            uint32_t            : 8;
      __IOM uint32_t DTVALEX    : 4;            /*!< [19..16] Extended Deadtime Value                                          */
            uint32_t            : 12;
    } FTM1_PAIR1DEADTIME_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t FTM1_PAIR2DEADTIME;          /*!< (@ 0x000000B0) Pair 2 Deadtime Configuration                              */

    struct {
      __IOM uint32_t DTVAL      : 6;            /*!< [5..0] Deadtime Value                                                     */
      __IOM uint32_t DTPS       : 2;            /*!< [7..6] Deadtime Prescaler Value                                           */
            uint32_t            : 8;
      __IOM uint32_t DTVALEX    : 4;            /*!< [19..16] Extended Deadtime Value                                          */
            uint32_t            : 12;
    } FTM1_PAIR2DEADTIME_b;
  } ;
  __IM  uint32_t  RESERVED2;

  union {
    __IOM uint32_t FTM1_PAIR3DEADTIME;          /*!< (@ 0x000000B8) Pair 3 Deadtime Configuration                              */

    struct {
      __IOM uint32_t DTVAL      : 6;            /*!< [5..0] Deadtime Value                                                     */
      __IOM uint32_t DTPS       : 2;            /*!< [7..6] Deadtime Prescaler Value                                           */
            uint32_t            : 8;
      __IOM uint32_t DTVALEX    : 4;            /*!< [19..16] Extended Deadtime Value                                          */
            uint32_t            : 12;
    } FTM1_PAIR3DEADTIME_b;
  } ;
  __IM  uint32_t  RESERVED3[81];

  union {
    __IOM uint32_t FTM1_MOD_MIRROR;             /*!< (@ 0x00000200) Mirror of Modulo Value                                     */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACMOD    : 5;            /*!< [15..11] Modulo Fractional Value                                          */
      __IOM uint32_t MOD        : 16;           /*!< [31..16] Mirror of the Modulo Integer Value                               */
    } FTM1_MOD_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM1_C0V_MIRROR;             /*!< (@ 0x00000204) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM1_C0V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM1_C1V_MIRROR;             /*!< (@ 0x00000208) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM1_C1V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM1_C2V_MIRROR;             /*!< (@ 0x0000020C) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM1_C2V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM1_C3V_MIRROR;             /*!< (@ 0x00000210) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM1_C3V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM1_C4V_MIRROR;             /*!< (@ 0x00000214) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM1_C4V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM1_C5V_MIRROR;             /*!< (@ 0x00000218) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM1_C5V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM1_C6V_MIRROR;             /*!< (@ 0x0000021C) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM1_C6V_MIRROR_b;
  } ;

  union {
    __IOM uint32_t FTM1_C7V_MIRROR;             /*!< (@ 0x00000220) Mirror of Channel (n) Match Value                          */

    struct {
            uint32_t            : 11;
      __IOM uint32_t FRACVAL    : 5;            /*!< [15..11] Channel (n) Match Fractional Value                               */
      __IOM uint32_t VAL        : 16;           /*!< [31..16] Mirror of the Channel (n) Match Integer Value                    */
    } FTM1_C7V_MIRROR_b;
  } ;
} FTM1_Type;                                    /*!< Size = 548 (0x224)                                                        */



/* =========================================================================================================================== */
/* ================                                           ADC0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog-to-Digital Converter (ADC0)
  */

typedef struct {                                /*!< (@ 0x4003B000) ADC0 Structure                                             */

  union {
    __IOM uint32_t ADC0_SC1A;                   /*!< (@ 0x00000000) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1A_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1B;                   /*!< (@ 0x00000004) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1B_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1C;                   /*!< (@ 0x00000008) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1C_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1D;                   /*!< (@ 0x0000000C) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1D_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1E;                   /*!< (@ 0x00000010) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1E_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1F;                   /*!< (@ 0x00000014) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1F_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1G;                   /*!< (@ 0x00000018) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1G_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1H;                   /*!< (@ 0x0000001C) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1H_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1I;                   /*!< (@ 0x00000020) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1I_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1J;                   /*!< (@ 0x00000024) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1J_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1K;                   /*!< (@ 0x00000028) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1K_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1L;                   /*!< (@ 0x0000002C) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1L_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1M;                   /*!< (@ 0x00000030) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1M_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1N;                   /*!< (@ 0x00000034) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1N_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1O;                   /*!< (@ 0x00000038) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1O_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC1P;                   /*!< (@ 0x0000003C) ADC Status and Control Register 1                          */

    struct {
      __IOM uint32_t ADCH       : 5;            /*!< [4..0] Input channel select                                               */
            uint32_t            : 1;
      __IOM uint32_t AIEN       : 1;            /*!< [6..6] Interrupt Enable                                                   */
      __IM  uint32_t COCO       : 1;            /*!< [7..7] Conversion Complete Flag                                           */
            uint32_t            : 24;
    } ADC0_SC1P_b;
  } ;

  union {
    __IOM uint32_t ADC0_CFG1;                   /*!< (@ 0x00000040) ADC Configuration Register 1                               */

    struct {
      __IOM uint32_t ADICLK     : 2;            /*!< [1..0] Input Clock Select                                                 */
      __IOM uint32_t MODE       : 2;            /*!< [3..2] Conversion mode selection                                          */
            uint32_t            : 1;
      __IOM uint32_t ADIV       : 2;            /*!< [6..5] Clock Divide Select                                                */
            uint32_t            : 1;
      __OM  uint32_t CLRLTRG    : 1;            /*!< [8..8] Clear Latch Trigger in Trigger Handler Block                       */
            uint32_t            : 23;
    } ADC0_CFG1_b;
  } ;

  union {
    __IOM uint32_t ADC0_CFG2;                   /*!< (@ 0x00000044) ADC Configuration Register 2                               */

    struct {
      __IOM uint32_t SMPLTS     : 8;            /*!< [7..0] Sample Time Select                                                 */
            uint32_t            : 24;
    } ADC0_CFG2_b;
  } ;

  union {
    __IM  uint32_t ADC0_RA;                     /*!< (@ 0x00000048) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RA_b;
  } ;

  union {
    __IM  uint32_t ADC0_RB;                     /*!< (@ 0x0000004C) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RB_b;
  } ;

  union {
    __IM  uint32_t ADC0_RC;                     /*!< (@ 0x00000050) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RC_b;
  } ;

  union {
    __IM  uint32_t ADC0_RD;                     /*!< (@ 0x00000054) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RD_b;
  } ;

  union {
    __IM  uint32_t ADC0_RE;                     /*!< (@ 0x00000058) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RE_b;
  } ;

  union {
    __IM  uint32_t ADC0_RF;                     /*!< (@ 0x0000005C) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RF_b;
  } ;

  union {
    __IM  uint32_t ADC0_RG;                     /*!< (@ 0x00000060) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RG_b;
  } ;

  union {
    __IM  uint32_t ADC0_RH;                     /*!< (@ 0x00000064) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RH_b;
  } ;

  union {
    __IM  uint32_t ADC0_RI;                     /*!< (@ 0x00000068) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RI_b;
  } ;

  union {
    __IM  uint32_t ADC0_RJ;                     /*!< (@ 0x0000006C) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RJ_b;
  } ;

  union {
    __IM  uint32_t ADC0_RK;                     /*!< (@ 0x00000070) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RK_b;
  } ;

  union {
    __IM  uint32_t ADC0_RL;                     /*!< (@ 0x00000074) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RL_b;
  } ;

  union {
    __IM  uint32_t ADC0_RM;                     /*!< (@ 0x00000078) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RM_b;
  } ;

  union {
    __IM  uint32_t ADC0_RN;                     /*!< (@ 0x0000007C) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RN_b;
  } ;

  union {
    __IM  uint32_t ADC0_RO;                     /*!< (@ 0x00000080) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RO_b;
  } ;

  union {
    __IM  uint32_t ADC0_RP;                     /*!< (@ 0x00000084) ADC Data Result Registers                                  */

    struct {
      __IM  uint32_t D          : 12;           /*!< [11..0] Data result                                                       */
            uint32_t            : 20;
    } ADC0_RP_b;
  } ;

  union {
    __IOM uint32_t ADC0_CV1;                    /*!< (@ 0x00000088) Compare Value Registers                                    */

    struct {
      __IOM uint32_t CV         : 16;           /*!< [15..0] Compare Value.                                                    */
            uint32_t            : 16;
    } ADC0_CV1_b;
  } ;

  union {
    __IOM uint32_t ADC0_CV2;                    /*!< (@ 0x0000008C) Compare Value Registers                                    */

    struct {
      __IOM uint32_t CV         : 16;           /*!< [15..0] Compare Value.                                                    */
            uint32_t            : 16;
    } ADC0_CV2_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC2;                    /*!< (@ 0x00000090) Status and Control Register 2                              */

    struct {
      __IOM uint32_t REFSEL     : 2;            /*!< [1..0] Voltage Reference Selection                                        */
      __IOM uint32_t DMAEN      : 1;            /*!< [2..2] DMA Enable                                                         */
      __IOM uint32_t ACREN      : 1;            /*!< [3..3] Compare Function Range Enable                                      */
      __IOM uint32_t ACFGT      : 1;            /*!< [4..4] Compare Function Greater Than Enable                               */
      __IOM uint32_t ACFE       : 1;            /*!< [5..5] Compare Function Enable                                            */
      __IOM uint32_t ADTRG      : 1;            /*!< [6..6] Conversion Trigger Select                                          */
      __IM  uint32_t ADACT      : 1;            /*!< [7..7] Conversion Active                                                  */
            uint32_t            : 5;
      __IM  uint32_t TRGPRNUM   : 2;            /*!< [14..13] Trigger Process Number                                           */
            uint32_t            : 1;
      __IM  uint32_t TRGSTLAT   : 4;            /*!< [19..16] Trigger Status                                                   */
            uint32_t            : 4;
      __IM  uint32_t TRGSTERR   : 4;            /*!< [27..24] Error in Multiplexed Trigger Request                             */
            uint32_t            : 4;
    } ADC0_SC2_b;
  } ;

  union {
    __IOM uint32_t ADC0_SC3;                    /*!< (@ 0x00000094) Status and Control Register 3                              */

    struct {
      __IOM uint32_t AVGS       : 2;            /*!< [1..0] Hardware Average Select                                            */
      __IOM uint32_t AVGE       : 1;            /*!< [2..2] Hardware Average Enable                                            */
      __IOM uint32_t ADCO       : 1;            /*!< [3..3] Continuous Conversion Enable                                       */
            uint32_t            : 3;
      __IOM uint32_t CAL        : 1;            /*!< [7..7] Calibration                                                        */
            uint32_t            : 24;
    } ADC0_SC3_b;
  } ;

  union {
    __IOM uint32_t ADC0_BASE_OFS;               /*!< (@ 0x00000098) BASE Offset Register                                       */

    struct {
      __IOM uint32_t BA_OFS     : 8;            /*!< [7..0] Base Offset Error Correction Value                                 */
            uint32_t            : 24;
    } ADC0_BASE_OFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_OFS;                    /*!< (@ 0x0000009C) ADC Offset Correction Register                             */

    struct {
      __IOM uint32_t OFS        : 16;           /*!< [15..0] Offset Error Correction Value                                     */
            uint32_t            : 16;
    } ADC0_OFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_USR_OFS;                /*!< (@ 0x000000A0) USER Offset Correction Register                            */

    struct {
      __IOM uint32_t USR_OFS    : 8;            /*!< [7..0] USER Offset Error Correction Value                                 */
            uint32_t            : 24;
    } ADC0_USR_OFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_XOFS;                   /*!< (@ 0x000000A4) ADC X Offset Correction Register                           */

    struct {
      __IOM uint32_t XOFS       : 6;            /*!< [5..0] X offset error correction value                                    */
            uint32_t            : 26;
    } ADC0_XOFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_YOFS;                   /*!< (@ 0x000000A8) ADC Y Offset Correction Register                           */

    struct {
      __IOM uint32_t YOFS       : 8;            /*!< [7..0] Y offset error correction value                                    */
            uint32_t            : 24;
    } ADC0_YOFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_G;                      /*!< (@ 0x000000AC) ADC Gain Register                                          */

    struct {
      __IOM uint32_t G          : 11;           /*!< [10..0] Gain error adjustment factor for the overall conversion           */
            uint32_t            : 21;
    } ADC0_G_b;
  } ;

  union {
    __IOM uint32_t ADC0_UG;                     /*!< (@ 0x000000B0) ADC User Gain Register                                     */

    struct {
      __IOM uint32_t UG         : 10;           /*!< [9..0] User gain error correction value                                   */
            uint32_t            : 22;
    } ADC0_UG_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLPS;                   /*!< (@ 0x000000B4) ADC General Calibration Value Register S                   */

    struct {
      __IOM uint32_t CLPS       : 7;            /*!< [6..0] Calibration Value                                                  */
            uint32_t            : 25;
    } ADC0_CLPS_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLP3;                   /*!< (@ 0x000000B8) ADC Plus-Side General Calibration Value Register
                                                                    3                                                          */

    struct {
      __IOM uint32_t CLP3       : 10;           /*!< [9..0] Calibration Value                                                  */
            uint32_t            : 22;
    } ADC0_CLP3_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLP2;                   /*!< (@ 0x000000BC) ADC Plus-Side General Calibration Value Register
                                                                    2                                                          */

    struct {
      __IOM uint32_t CLP2       : 10;           /*!< [9..0] Calibration Value                                                  */
            uint32_t            : 22;
    } ADC0_CLP2_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLP1;                   /*!< (@ 0x000000C0) ADC Plus-Side General Calibration Value Register
                                                                    1                                                          */

    struct {
      __IOM uint32_t CLP1       : 9;            /*!< [8..0] Calibration Value                                                  */
            uint32_t            : 23;
    } ADC0_CLP1_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLP0;                   /*!< (@ 0x000000C4) ADC Plus-Side General Calibration Value Register
                                                                    0                                                          */

    struct {
      __IOM uint32_t CLP0       : 8;            /*!< [7..0] Calibration Value                                                  */
            uint32_t            : 24;
    } ADC0_CLP0_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLPX;                   /*!< (@ 0x000000C8) ADC Plus-Side General Calibration Value Register
                                                                    X                                                          */

    struct {
      __IOM uint32_t CLPX       : 7;            /*!< [6..0] Calibration Value                                                  */
            uint32_t            : 25;
    } ADC0_CLPX_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLP9;                   /*!< (@ 0x000000CC) ADC Plus-Side General Calibration Value Register
                                                                    9                                                          */

    struct {
      __IOM uint32_t CLP9       : 7;            /*!< [6..0] Calibration Value                                                  */
            uint32_t            : 25;
    } ADC0_CLP9_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLPS_OFS;               /*!< (@ 0x000000D0) ADC General Calibration Offset Value Register
                                                                    S                                                          */

    struct {
      __IOM uint32_t CLPS_OFS   : 4;            /*!< [3..0] CLPS Offset                                                        */
            uint32_t            : 28;
    } ADC0_CLPS_OFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLP3_OFS;               /*!< (@ 0x000000D4) ADC Plus-Side General Calibration Offset Value
                                                                    Register 3                                                 */

    struct {
      __IOM uint32_t CLP3_OFS   : 4;            /*!< [3..0] CLP3 Offset                                                        */
            uint32_t            : 28;
    } ADC0_CLP3_OFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLP2_OFS;               /*!< (@ 0x000000D8) ADC Plus-Side General Calibration Offset Value
                                                                    Register 2                                                 */

    struct {
      __IOM uint32_t CLP2_OFS   : 4;            /*!< [3..0] CLP2 Offset                                                        */
            uint32_t            : 28;
    } ADC0_CLP2_OFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLP1_OFS;               /*!< (@ 0x000000DC) ADC Plus-Side General Calibration Offset Value
                                                                    Register 1                                                 */

    struct {
      __IOM uint32_t CLP1_OFS   : 4;            /*!< [3..0] CLP1 Offset                                                        */
            uint32_t            : 28;
    } ADC0_CLP1_OFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLP0_OFS;               /*!< (@ 0x000000E0) ADC Plus-Side General Calibration Offset Value
                                                                    Register 0                                                 */

    struct {
      __IOM uint32_t CLP0_OFS   : 4;            /*!< [3..0] CLP0 Offset                                                        */
            uint32_t            : 28;
    } ADC0_CLP0_OFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLPX_OFS;               /*!< (@ 0x000000E4) ADC Plus-Side General Calibration Offset Value
                                                                    Register X                                                 */

    struct {
      __IOM uint32_t CLPX_OFS   : 12;           /*!< [11..0] CLPX Offset                                                       */
            uint32_t            : 20;
    } ADC0_CLPX_OFS_b;
  } ;

  union {
    __IOM uint32_t ADC0_CLP9_OFS;               /*!< (@ 0x000000E8) ADC Plus-Side General Calibration Offset Value
                                                                    Register 9                                                 */

    struct {
      __IOM uint32_t CLP9_OFS   : 12;           /*!< [11..0] CLP9 Offset                                                       */
            uint32_t            : 20;
    } ADC0_CLP9_OFS_b;
  } ;
} ADC0_Type;                                    /*!< Size = 236 (0xec)                                                         */



/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Secure Real Time Clock (RTC)
  */

typedef struct {                                /*!< (@ 0x4003D000) RTC Structure                                              */

  union {
    __IOM uint32_t RTC_TSR;                     /*!< (@ 0x00000000) RTC Time Seconds Register                                  */

    struct {
      __IOM uint32_t TSR        : 32;           /*!< [31..0] Time Seconds Register                                             */
    } RTC_TSR_b;
  } ;

  union {
    __IOM uint32_t RTC_TPR;                     /*!< (@ 0x00000004) RTC Time Prescaler Register                                */

    struct {
      __IOM uint32_t TPR        : 16;           /*!< [15..0] Time Prescaler Register                                           */
            uint32_t            : 16;
    } RTC_TPR_b;
  } ;

  union {
    __IOM uint32_t RTC_TAR;                     /*!< (@ 0x00000008) RTC Time Alarm Register                                    */

    struct {
      __IOM uint32_t TAR        : 32;           /*!< [31..0] Time Alarm Register                                               */
    } RTC_TAR_b;
  } ;

  union {
    __IOM uint32_t RTC_TCR;                     /*!< (@ 0x0000000C) RTC Time Compensation Register                             */

    struct {
      __IOM uint32_t TCR        : 8;            /*!< [7..0] Time Compensation Register                                         */
      __IOM uint32_t CIR        : 8;            /*!< [15..8] Compensation Interval Register                                    */
      __IM  uint32_t TCV        : 8;            /*!< [23..16] Time Compensation Value                                          */
      __IM  uint32_t CIC        : 8;            /*!< [31..24] Compensation Interval Counter                                    */
    } RTC_TCR_b;
  } ;

  union {
    __IOM uint32_t RTC_CR;                      /*!< (@ 0x00000010) RTC Control Register                                       */

    struct {
      __IOM uint32_t SWR        : 1;            /*!< [0..0] Software Reset                                                     */
            uint32_t            : 1;
      __IOM uint32_t SUP        : 1;            /*!< [2..2] Supervisor Access                                                  */
      __IOM uint32_t UM         : 1;            /*!< [3..3] Update Mode                                                        */
            uint32_t            : 1;
      __IOM uint32_t CPS        : 1;            /*!< [5..5] Clock Pin Select                                                   */
            uint32_t            : 1;
      __IOM uint32_t LPOS       : 1;            /*!< [7..7] LPO Select                                                         */
            uint32_t            : 1;
      __IOM uint32_t CLKO       : 1;            /*!< [9..9] Clock Output                                                       */
            uint32_t            : 14;
      __IOM uint32_t CPE        : 1;            /*!< [24..24] Clock Pin Enable                                                 */
            uint32_t            : 7;
    } RTC_CR_b;
  } ;

  union {
    __IOM uint32_t RTC_SR;                      /*!< (@ 0x00000014) RTC Status Register                                        */

    struct {
      __IM  uint32_t TIF        : 1;            /*!< [0..0] Time Invalid Flag                                                  */
      __IM  uint32_t TOF        : 1;            /*!< [1..1] Time Overflow Flag                                                 */
      __IM  uint32_t TAF        : 1;            /*!< [2..2] Time Alarm Flag                                                    */
            uint32_t            : 1;
      __IOM uint32_t TCE        : 1;            /*!< [4..4] Time Counter Enable                                                */
            uint32_t            : 27;
    } RTC_SR_b;
  } ;

  union {
    __IOM uint32_t RTC_LR;                      /*!< (@ 0x00000018) RTC Lock Register                                          */

    struct {
            uint32_t            : 3;
      __IOM uint32_t TCL        : 1;            /*!< [3..3] Time Compensation Lock                                             */
      __IOM uint32_t CRL        : 1;            /*!< [4..4] Control Register Lock                                              */
      __IOM uint32_t SRL        : 1;            /*!< [5..5] Status Register Lock                                               */
      __IOM uint32_t LRL        : 1;            /*!< [6..6] Lock Register Lock                                                 */
            uint32_t            : 25;
    } RTC_LR_b;
  } ;

  union {
    __IOM uint32_t RTC_IER;                     /*!< (@ 0x0000001C) RTC Interrupt Enable Register                              */

    struct {
      __IOM uint32_t TIIE       : 1;            /*!< [0..0] Time Invalid Interrupt Enable                                      */
      __IOM uint32_t TOIE       : 1;            /*!< [1..1] Time Overflow Interrupt Enable                                     */
      __IOM uint32_t TAIE       : 1;            /*!< [2..2] Time Alarm Interrupt Enable                                        */
            uint32_t            : 1;
      __IOM uint32_t TSIE       : 1;            /*!< [4..4] Time Seconds Interrupt Enable                                      */
            uint32_t            : 11;
      __IOM uint32_t TSIC       : 3;            /*!< [18..16] Timer Seconds Interrupt Configuration                            */
            uint32_t            : 13;
    } RTC_IER_b;
  } ;
} RTC_Type;                                     /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                         CMU_FC_0                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CMU_FC (CMU_FC_0)
  */

typedef struct {                                /*!< (@ 0x4003E000) CMU_FC_0 Structure                                         */

  union {
    __IOM uint32_t CMU_FC_0_GCR;                /*!< (@ 0x00000000) CMU Frequency Check Global Configuration Register          */

    struct {
      __IOM uint32_t FCE        : 1;            /*!< [0..0] Frequency Check Enable                                             */
            uint32_t            : 31;
    } CMU_FC_0_GCR_b;
  } ;

  union {
    __IOM uint32_t CMU_FC_0_RCCR;               /*!< (@ 0x00000004) CMU Frequency Check Reference Count Configuration
                                                                    Register                                                   */

    struct {
      __IOM uint32_t REF_CNT    : 16;           /*!< [15..0] Reference Clock Count                                             */
            uint32_t            : 16;
    } CMU_FC_0_RCCR_b;
  } ;

  union {
    __IOM uint32_t CMU_FC_0_HTCR;               /*!< (@ 0x00000008) CMU Frequency Check High Threshold Configuration
                                                                    Register                                                   */

    struct {
      __IOM uint32_t HFREF      : 24;           /*!< [23..0] High Frequency Reference Threshold                                */
            uint32_t            : 8;
    } CMU_FC_0_HTCR_b;
  } ;

  union {
    __IOM uint32_t CMU_FC_0_LTCR;               /*!< (@ 0x0000000C) CMU Frequency Check Low Threshold Configuration
                                                                    Register                                                   */

    struct {
      __IOM uint32_t LFREF      : 24;           /*!< [23..0] Low Frequency Reference Threshold                                 */
            uint32_t            : 8;
    } CMU_FC_0_LTCR_b;
  } ;

  union {
    __IOM uint32_t CMU_FC_0_SR;                 /*!< (@ 0x00000010) CMU Frequency Check Status Register                        */

    struct {
      __IOM uint32_t FLL        : 1;            /*!< [0..0] Frequency Lower than Low Frequency Reference Threshold
                                                     Event Status                                                              */
      __IOM uint32_t FHH        : 1;            /*!< [1..1] Frequency Higher than High Frequency Reference Threshold
                                                     Event Status                                                              */
      __IM  uint32_t STATE      : 2;            /*!< [3..2] Module State                                                       */
      __IM  uint32_t RS         : 1;            /*!< [4..4] Run Status                                                         */
            uint32_t            : 27;
    } CMU_FC_0_SR_b;
  } ;

  union {
    __IOM uint32_t CMU_FC_0_IER;                /*!< (@ 0x00000014) CMU Frequency Check Interrupt/Event Enable Register        */

    struct {
      __IOM uint32_t FLLIE      : 1;            /*!< [0..0] Frequency Lower than Low Frequency Reference Threshold
                                                     Interrupt Enable                                                          */
      __IOM uint32_t FHHIE      : 1;            /*!< [1..1] Frequency Higher than High Frequency Reference Threshold
                                                     Interrupt Enable                                                          */
      __IOM uint32_t FLLAEE     : 1;            /*!< [2..2] Frequency Lower than Low Frequency Reference Threshold
                                                     Asynchronous Event Enable                                                 */
      __IOM uint32_t FHHAEE     : 1;            /*!< [3..3] Frequency Higher than High Frequency Reference Threshold
                                                     Asynchronous Event Enable                                                 */
            uint32_t            : 28;
    } CMU_FC_0_IER_b;
  } ;
} CMU_FC_0_Type;                                /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                         CMU_FC_1                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CMU_FC (CMU_FC_1)
  */

typedef struct {                                /*!< (@ 0x4003F000) CMU_FC_1 Structure                                         */

  union {
    __IOM uint32_t CMU_FC_1_GCR;                /*!< (@ 0x00000000) CMU Frequency Check Global Configuration Register          */

    struct {
      __IOM uint32_t FCE        : 1;            /*!< [0..0] Frequency Check Enable                                             */
            uint32_t            : 31;
    } CMU_FC_1_GCR_b;
  } ;

  union {
    __IOM uint32_t CMU_FC_1_RCCR;               /*!< (@ 0x00000004) CMU Frequency Check Reference Count Configuration
                                                                    Register                                                   */

    struct {
      __IOM uint32_t REF_CNT    : 16;           /*!< [15..0] Reference Clock Count                                             */
            uint32_t            : 16;
    } CMU_FC_1_RCCR_b;
  } ;

  union {
    __IOM uint32_t CMU_FC_1_HTCR;               /*!< (@ 0x00000008) CMU Frequency Check High Threshold Configuration
                                                                    Register                                                   */

    struct {
      __IOM uint32_t HFREF      : 24;           /*!< [23..0] High Frequency Reference Threshold                                */
            uint32_t            : 8;
    } CMU_FC_1_HTCR_b;
  } ;

  union {
    __IOM uint32_t CMU_FC_1_LTCR;               /*!< (@ 0x0000000C) CMU Frequency Check Low Threshold Configuration
                                                                    Register                                                   */

    struct {
      __IOM uint32_t LFREF      : 24;           /*!< [23..0] Low Frequency Reference Threshold                                 */
            uint32_t            : 8;
    } CMU_FC_1_LTCR_b;
  } ;

  union {
    __IOM uint32_t CMU_FC_1_SR;                 /*!< (@ 0x00000010) CMU Frequency Check Status Register                        */

    struct {
      __IOM uint32_t FLL        : 1;            /*!< [0..0] Frequency Lower than Low Frequency Reference Threshold
                                                     Event Status                                                              */
      __IOM uint32_t FHH        : 1;            /*!< [1..1] Frequency Higher than High Frequency Reference Threshold
                                                     Event Status                                                              */
      __IM  uint32_t STATE      : 2;            /*!< [3..2] Module State                                                       */
      __IM  uint32_t RS         : 1;            /*!< [4..4] Run Status                                                         */
            uint32_t            : 27;
    } CMU_FC_1_SR_b;
  } ;

  union {
    __IOM uint32_t CMU_FC_1_IER;                /*!< (@ 0x00000014) CMU Frequency Check Interrupt/Event Enable Register        */

    struct {
      __IOM uint32_t FLLIE      : 1;            /*!< [0..0] Frequency Lower than Low Frequency Reference Threshold
                                                     Interrupt Enable                                                          */
      __IOM uint32_t FHHIE      : 1;            /*!< [1..1] Frequency Higher than High Frequency Reference Threshold
                                                     Interrupt Enable                                                          */
      __IOM uint32_t FLLAEE     : 1;            /*!< [2..2] Frequency Lower than Low Frequency Reference Threshold
                                                     Asynchronous Event Enable                                                 */
      __IOM uint32_t FHHAEE     : 1;            /*!< [3..3] Frequency Higher than High Frequency Reference Threshold
                                                     Asynchronous Event Enable                                                 */
            uint32_t            : 28;
    } CMU_FC_1_IER_b;
  } ;
} CMU_FC_1_Type;                                /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                          LPTMR0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low Power Timer (LPTMR0)
  */

typedef struct {                                /*!< (@ 0x40040000) LPTMR0 Structure                                           */

  union {
    __IOM uint32_t LPTMR0_CSR;                  /*!< (@ 0x00000000) Low Power Timer Control Status Register                    */

    struct {
      __IOM uint32_t TEN        : 1;            /*!< [0..0] Timer Enable                                                       */
      __IOM uint32_t TMS        : 1;            /*!< [1..1] Timer Mode Select                                                  */
      __IOM uint32_t TFC        : 1;            /*!< [2..2] Timer Free-Running Counter                                         */
      __IOM uint32_t TPP        : 1;            /*!< [3..3] Timer Pin Polarity                                                 */
      __IOM uint32_t TPS        : 2;            /*!< [5..4] Timer Pin Select                                                   */
      __IOM uint32_t TIE        : 1;            /*!< [6..6] Timer Interrupt Enable                                             */
      __IOM uint32_t TCF        : 1;            /*!< [7..7] Timer Compare Flag                                                 */
      __IOM uint32_t TDRE       : 1;            /*!< [8..8] Timer DMA Request Enable                                           */
            uint32_t            : 23;
    } LPTMR0_CSR_b;
  } ;

  union {
    __IOM uint32_t LPTMR0_PSR;                  /*!< (@ 0x00000004) Low Power Timer Prescale Register                          */

    struct {
      __IOM uint32_t PCS        : 2;            /*!< [1..0] Prescaler Clock Select                                             */
      __IOM uint32_t PBYP       : 1;            /*!< [2..2] Prescaler Bypass                                                   */
      __IOM uint32_t PRESCALE   : 4;            /*!< [6..3] Prescale Value                                                     */
            uint32_t            : 25;
    } LPTMR0_PSR_b;
  } ;

  union {
    __IOM uint32_t LPTMR0_CMR;                  /*!< (@ 0x00000008) Low Power Timer Compare Register                           */

    struct {
      __IOM uint32_t COMPARE    : 16;           /*!< [15..0] Compare Value                                                     */
            uint32_t            : 16;
    } LPTMR0_CMR_b;
  } ;

  union {
    __IOM uint32_t LPTMR0_CNR;                  /*!< (@ 0x0000000C) Low Power Timer Counter Register                           */

    struct {
      __IOM uint32_t COUNTER    : 16;           /*!< [15..0] Counter Value                                                     */
            uint32_t            : 16;
    } LPTMR0_CNR_b;
  } ;
} LPTMR0_Type;                                  /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                            SIM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief System Integration Module (SIM)
  */

typedef struct {                                /*!< (@ 0x40048000) SIM Structure                                              */
  __IM  uint32_t  RESERVED;

  union {
    __IOM uint32_t SIM_CHIPCTL;                 /*!< (@ 0x00000004) Chip Control register                                      */

    struct {
      __IOM uint32_t ADC_INTERLEAVE_EN : 4;     /*!< [3..0] ADC interleave channel enable                                      */
      __IOM uint32_t CLKOUTSEL  : 4;            /*!< [7..4] CLKOUT Select                                                      */
      __IOM uint32_t CLKOUTDIV  : 3;            /*!< [10..8] CLKOUT Divide Ratio                                               */
      __IOM uint32_t CLKOUTEN   : 1;            /*!< [11..11] CLKOUT enable                                                    */
      __IOM uint32_t TRACECLK_SEL : 1;          /*!< [12..12] Debug trace clock select                                         */
      __IOM uint32_t PDB_BB_SEL : 1;            /*!< [13..13] PDB back-to-back select                                          */
            uint32_t            : 2;
      __IOM uint32_t ADC_SUPPLY : 3;            /*!< [18..16] ADC_SUPPLY                                                       */
      __IOM uint32_t ADC_SUPPLYEN : 1;          /*!< [19..19] ADC_SUPPLYEN                                                     */
      __IOM uint32_t SRAMU_RETEN : 1;           /*!< [20..20] SRAMU_RETEN                                                      */
      __IOM uint32_t SRAML_RETEN : 1;           /*!< [21..21] SRAML_RETEN                                                      */
            uint32_t            : 10;
    } SIM_CHIPCTL_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t SIM_FTMOPT0;                 /*!< (@ 0x0000000C) FTM Option Register 0                                      */

    struct {
      __IOM uint32_t FTM0FLTxSEL : 3;           /*!< [2..0] FTM0 Fault X Select                                                */
            uint32_t            : 1;
      __IOM uint32_t FTM1FLTxSEL : 3;           /*!< [6..4] FTM1 Fault X Select                                                */
            uint32_t            : 1;
      __IOM uint32_t FTM2FLTxSEL : 3;           /*!< [10..8] FTM2 Fault X Select                                               */
            uint32_t            : 1;
      __IOM uint32_t FTM3FLTxSEL : 3;           /*!< [14..12] FTM3 Fault X Select                                              */
            uint32_t            : 9;
      __IOM uint32_t FTM0CLKSEL : 2;            /*!< [25..24] FTM0 External Clock Pin Select                                   */
      __IOM uint32_t FTM1CLKSEL : 2;            /*!< [27..26] FTM1 External Clock Pin Select                                   */
      __IOM uint32_t FTM2CLKSEL : 2;            /*!< [29..28] FTM2 External Clock Pin Select                                   */
      __IOM uint32_t FTM3CLKSEL : 2;            /*!< [31..30] FTM3 External Clock Pin Select                                   */
    } SIM_FTMOPT0_b;
  } ;

  union {
    __IOM uint32_t SIM_LPOCLKS;                 /*!< (@ 0x00000010) LPO Clock Select Register                                  */

    struct {
      __IOM uint32_t LPO1KCLKEN : 1;            /*!< [0..0] 1 kHz LPO_CLK enable                                               */
      __IOM uint32_t LPO32KCLKEN : 1;           /*!< [1..1] 32 kHz LPO_CLK enable                                              */
      __IOM uint32_t LPOCLKSEL  : 2;            /*!< [3..2] LPO clock source select                                            */
      __IOM uint32_t RTCCLKSEL  : 2;            /*!< [5..4] 32 kHz clock source select                                         */
            uint32_t            : 26;
    } SIM_LPOCLKS_b;
  } ;
  __IM  uint32_t  RESERVED2;

  union {
    __IOM uint32_t SIM_ADCOPT;                  /*!< (@ 0x00000018) ADC Options Register                                       */

    struct {
      __IOM uint32_t ADC0TRGSEL : 1;            /*!< [0..0] ADC0 trigger source select                                         */
      __IOM uint32_t ADC0SWPRETRG : 3;          /*!< [3..1] ADC0 software pretrigger sources                                   */
      __IOM uint32_t ADC0PRETRGSEL : 2;         /*!< [5..4] ADC0 pretrigger source select                                      */
            uint32_t            : 2;
      __IOM uint32_t ADC1TRGSEL : 1;            /*!< [8..8] ADC1 trigger source select                                         */
      __IOM uint32_t ADC1SWPRETRG : 3;          /*!< [11..9] ADC1 software pretrigger sources                                  */
      __IOM uint32_t ADC1PRETRGSEL : 2;         /*!< [13..12] ADC1 pretrigger source select                                    */
            uint32_t            : 18;
    } SIM_ADCOPT_b;
  } ;

  union {
    __IOM uint32_t SIM_FTMOPT1;                 /*!< (@ 0x0000001C) FTM Option Register 1                                      */

    struct {
      __IOM uint32_t FTM0SYNCBIT : 1;           /*!< [0..0] FTM0 Sync Bit                                                      */
      __IOM uint32_t FTM1SYNCBIT : 1;           /*!< [1..1] FTM1 Sync Bit                                                      */
      __IOM uint32_t FTM2SYNCBIT : 1;           /*!< [2..2] FTM2 Sync Bit                                                      */
      __IOM uint32_t FTM3SYNCBIT : 1;           /*!< [3..3] FTM3 Sync Bit                                                      */
      __IOM uint32_t FTM1CH0SEL : 2;            /*!< [5..4] FTM1 CH0 Select                                                    */
      __IOM uint32_t FTM2CH0SEL : 2;            /*!< [7..6] FTM2 CH0 Select                                                    */
      __IOM uint32_t FTM2CH1SEL : 1;            /*!< [8..8] FTM2 CH1 Select                                                    */
            uint32_t            : 6;
      __IOM uint32_t FTMGLDOK   : 1;            /*!< [15..15] FTM global load enable                                           */
      __IOM uint32_t FTM0_OUTSEL : 8;           /*!< [23..16] FTM0 channel modulation select with FTM1_CH1                     */
      __IOM uint32_t FTM3_OUTSEL : 8;           /*!< [31..24] FTM3 channel modulation select with FTM2_CH1                     */
    } SIM_FTMOPT1_b;
  } ;

  union {
    __IOM uint32_t SIM_MISCTRL0;                /*!< (@ 0x00000020) Miscellaneous control register 0                           */

    struct {
            uint32_t            : 9;
      __IOM uint32_t STOP1_MONITOR : 1;         /*!< [9..9] STOP1 monitor bit                                                  */
      __IOM uint32_t STOP2_MONITOR : 1;         /*!< [10..10] STOP2 monitor bit                                                */
            uint32_t            : 5;
      __IOM uint32_t FTM0_OBE_CTRL : 1;         /*!< [16..16] FTM0 OBE CTRL bit                                                */
      __IOM uint32_t FTM1_OBE_CTRL : 1;         /*!< [17..17] FTM1 OBE CTRL bit                                                */
      __IOM uint32_t FTM2_OBE_CTRL : 1;         /*!< [18..18] FTM2 OBE CTRL bit                                                */
      __IOM uint32_t FTM3_OBE_CTRL : 1;         /*!< [19..19] FTM3 OBE CTRL bit                                                */
            uint32_t            : 12;
    } SIM_MISCTRL0_b;
  } ;

  union {
    __IM  uint32_t SIM_SDID;                    /*!< (@ 0x00000024) System Device Identification Register                      */

    struct {
      __IM  uint32_t FEATURES   : 8;            /*!< [7..0] Features                                                           */
      __IM  uint32_t PACKAGE    : 4;            /*!< [11..8] Package                                                           */
      __IM  uint32_t REVID      : 4;            /*!< [15..12] Device revision number                                           */
      __IM  uint32_t RAMSIZE    : 4;            /*!< [19..16] RAM size                                                         */
      __IM  uint32_t DERIVATE   : 4;            /*!< [23..20] Derivate                                                         */
      __IM  uint32_t SUBSERIES  : 4;            /*!< [27..24] Subseries                                                        */
      __IM  uint32_t GENERATION : 4;            /*!< [31..28] S32K product series generation                                   */
    } SIM_SDID_b;
  } ;
  __IM  uint32_t  RESERVED3[6];

  union {
    __IOM uint32_t SIM_PLATCGC;                 /*!< (@ 0x00000040) Platform Clock Gating Control Register                     */

    struct {
      __IOM uint32_t CGCMSCM    : 1;            /*!< [0..0] MSCM Clock Gating Control                                          */
      __IOM uint32_t CGCMPU     : 1;            /*!< [1..1] MPU Clock Gating Control                                           */
      __IOM uint32_t CGCDMA     : 1;            /*!< [2..2] DMA Clock Gating Control                                           */
      __IOM uint32_t CGCERM     : 1;            /*!< [3..3] ERM Clock Gating Control                                           */
      __IOM uint32_t CGCEIM     : 1;            /*!< [4..4] EIM Clock Gating Control                                           */
      __IOM uint32_t CGCGPIO    : 1;            /*!< [5..5] GPIO Clock Gating Control                                          */
            uint32_t            : 26;
    } SIM_PLATCGC_b;
  } ;
  __IM  uint32_t  RESERVED4[2];

  union {
    __IOM uint32_t SIM_FCFG1;                   /*!< (@ 0x0000004C) Flash Configuration Register 1                             */

    struct {
            uint32_t            : 12;
      __IM  uint32_t DEPART     : 4;            /*!< [15..12] FlexNVM partition                                                */
      __IM  uint32_t EEERAMSIZE : 4;            /*!< [19..16] EEE SRAM SIZE                                                    */
            uint32_t            : 12;
    } SIM_FCFG1_b;
  } ;
  __IM  uint32_t  RESERVED5;

  union {
    __IM  uint32_t SIM_UIDH;                    /*!< (@ 0x00000054) Unique Identification Register High                        */

    struct {
      __IM  uint32_t UID127_96  : 32;           /*!< [31..0] Unique Identification                                             */
    } SIM_UIDH_b;
  } ;

  union {
    __IM  uint32_t SIM_UIDMH;                   /*!< (@ 0x00000058) Unique Identification Register Mid-High                    */

    struct {
      __IM  uint32_t UID95_64   : 32;           /*!< [31..0] Unique Identification                                             */
    } SIM_UIDMH_b;
  } ;

  union {
    __IM  uint32_t SIM_UIDML;                   /*!< (@ 0x0000005C) Unique Identification Register Mid Low                     */

    struct {
      __IM  uint32_t UID63_32   : 32;           /*!< [31..0] Unique Identification                                             */
    } SIM_UIDML_b;
  } ;

  union {
    __IM  uint32_t SIM_UIDL;                    /*!< (@ 0x00000060) Unique Identification Register Low                         */

    struct {
      __IM  uint32_t UID31_0    : 32;           /*!< [31..0] Unique Identification                                             */
    } SIM_UIDL_b;
  } ;
  __IM  uint32_t  RESERVED6;

  union {
    __IOM uint32_t SIM_CLKDIV4;                 /*!< (@ 0x00000068) System Clock Divider Register 4                            */

    struct {
      __IOM uint32_t TRACEFRAC  : 1;            /*!< [0..0] Trace Clock Divider fraction To configure TRACEDIV and
                                                     TRACEFRAC, you must first clear TRACEDIVEN to disable the
                                                     trace clock divide function.                                              */
      __IOM uint32_t TRACEDIV   : 3;            /*!< [3..1] Trace Clock Divider value To configure TRACEDIV, you
                                                     must first disable TRACEDIVEN, then enable it after setting
                                                     TRACEDIV.                                                                 */
            uint32_t            : 24;
      __IOM uint32_t TRACEDIVEN : 1;            /*!< [28..28] Debug Trace Divider control                                      */
            uint32_t            : 3;
    } SIM_CLKDIV4_b;
  } ;

  union {
    __IOM uint32_t SIM_MISCTRL1;                /*!< (@ 0x0000006C) Miscellaneous Control register 1                           */

    struct {
      __IOM uint32_t SW_TRG     : 1;            /*!< [0..0] Software trigger to TRGMUX. Writing to this bit generates
                                                     software trigger to peripherals through TRGMUX (Refer to
                                                     Figure: Trigger interconnectivity).                                       */
            uint32_t            : 31;
    } SIM_MISCTRL1_b;
  } ;
} SIM_Type;                                     /*!< Size = 112 (0x70)                                                         */



/* =========================================================================================================================== */
/* ================                                           PORTA                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Pin Control and Interrupts (PORTA)
  */

typedef struct {                                /*!< (@ 0x40049000) PORTA Structure                                            */

  union {
    __IOM uint32_t PORTA_PCR0;                  /*!< (@ 0x00000000) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR0_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR1;                  /*!< (@ 0x00000004) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR1_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR2;                  /*!< (@ 0x00000008) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR2_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR3;                  /*!< (@ 0x0000000C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR3_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR4;                  /*!< (@ 0x00000010) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR4_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR5;                  /*!< (@ 0x00000014) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 2;
      __IOM uint32_t PFE        : 1;            /*!< [4..4] Passive Filter Enable                                              */
            uint32_t            : 3;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR5_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR6;                  /*!< (@ 0x00000018) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR6_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR7;                  /*!< (@ 0x0000001C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR7_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR8;                  /*!< (@ 0x00000020) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR8_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR9;                  /*!< (@ 0x00000024) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR9_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR10;                 /*!< (@ 0x00000028) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR10_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR11;                 /*!< (@ 0x0000002C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR11_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR12;                 /*!< (@ 0x00000030) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR12_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR13;                 /*!< (@ 0x00000034) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR13_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR14;                 /*!< (@ 0x00000038) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR14_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR15;                 /*!< (@ 0x0000003C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR15_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR16;                 /*!< (@ 0x00000040) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR16_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR17;                 /*!< (@ 0x00000044) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR17_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR18;                 /*!< (@ 0x00000048) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR18_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR19;                 /*!< (@ 0x0000004C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR19_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR20;                 /*!< (@ 0x00000050) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR20_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR21;                 /*!< (@ 0x00000054) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR21_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR22;                 /*!< (@ 0x00000058) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR22_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR23;                 /*!< (@ 0x0000005C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR23_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR24;                 /*!< (@ 0x00000060) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR24_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR25;                 /*!< (@ 0x00000064) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR25_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR26;                 /*!< (@ 0x00000068) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR26_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR27;                 /*!< (@ 0x0000006C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR27_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR28;                 /*!< (@ 0x00000070) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR28_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR29;                 /*!< (@ 0x00000074) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR29_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR30;                 /*!< (@ 0x00000078) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR30_b;
  } ;

  union {
    __IOM uint32_t PORTA_PCR31;                 /*!< (@ 0x0000007C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTA_PCR31_b;
  } ;

  union {
    __OM  uint32_t PORTA_GPCLR;                 /*!< (@ 0x00000080) Global Pin Control Low Register                            */

    struct {
      __OM  uint32_t GPWD       : 16;           /*!< [15..0] Global Pin Write Data                                             */
      __OM  uint32_t GPWE       : 16;           /*!< [31..16] Global Pin Write Enable                                          */
    } PORTA_GPCLR_b;
  } ;

  union {
    __OM  uint32_t PORTA_GPCHR;                 /*!< (@ 0x00000084) Global Pin Control High Register                           */

    struct {
      __OM  uint32_t GPWD       : 16;           /*!< [15..0] Global Pin Write Data                                             */
      __OM  uint32_t GPWE       : 16;           /*!< [31..16] Global Pin Write Enable                                          */
    } PORTA_GPCHR_b;
  } ;

  union {
    __OM  uint32_t PORTA_GICLR;                 /*!< (@ 0x00000088) Global Interrupt Control Low Register                      */

    struct {
      __OM  uint32_t GIWE       : 16;           /*!< [15..0] Global Interrupt Write Enable                                     */
      __OM  uint32_t GIWD       : 16;           /*!< [31..16] Global Interrupt Write Data                                      */
    } PORTA_GICLR_b;
  } ;

  union {
    __OM  uint32_t PORTA_GICHR;                 /*!< (@ 0x0000008C) Global Interrupt Control High Register                     */

    struct {
      __OM  uint32_t GIWE       : 16;           /*!< [15..0] Global Interrupt Write Enable                                     */
      __OM  uint32_t GIWD       : 16;           /*!< [31..16] Global Interrupt Write Data                                      */
    } PORTA_GICHR_b;
  } ;
  __IM  uint32_t  RESERVED[4];

  union {
    __IOM uint32_t PORTA_ISFR;                  /*!< (@ 0x000000A0) Interrupt Status Flag Register                             */

    struct {
      __IOM uint32_t ISF        : 32;           /*!< [31..0] Interrupt Status Flag                                             */
    } PORTA_ISFR_b;
  } ;
  __IM  uint32_t  RESERVED1[7];

  union {
    __IOM uint32_t PORTA_DFER;                  /*!< (@ 0x000000C0) Digital Filter Enable Register                             */

    struct {
      __IOM uint32_t DFE        : 32;           /*!< [31..0] Digital Filter Enable                                             */
    } PORTA_DFER_b;
  } ;

  union {
    __IOM uint32_t PORTA_DFCR;                  /*!< (@ 0x000000C4) Digital Filter Clock Register                              */

    struct {
      __IOM uint32_t CS         : 1;            /*!< [0..0] Clock Source                                                       */
            uint32_t            : 31;
    } PORTA_DFCR_b;
  } ;

  union {
    __IOM uint32_t PORTA_DFWR;                  /*!< (@ 0x000000C8) Digital Filter Width Register                              */

    struct {
      __IOM uint32_t FILT       : 5;            /*!< [4..0] Filter Length                                                      */
            uint32_t            : 27;
    } PORTA_DFWR_b;
  } ;
} PORTA_Type;                                   /*!< Size = 204 (0xcc)                                                         */



/* =========================================================================================================================== */
/* ================                                           PORTB                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Pin Control and Interrupts (PORTB)
  */

typedef struct {                                /*!< (@ 0x4004A000) PORTB Structure                                            */

  union {
    __IOM uint32_t PORTB_PCR0;                  /*!< (@ 0x00000000) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR0_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR1;                  /*!< (@ 0x00000004) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR1_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR2;                  /*!< (@ 0x00000008) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR2_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR3;                  /*!< (@ 0x0000000C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR3_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR4;                  /*!< (@ 0x00000010) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR4_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR5;                  /*!< (@ 0x00000014) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR5_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR6;                  /*!< (@ 0x00000018) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR6_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR7;                  /*!< (@ 0x0000001C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR7_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR8;                  /*!< (@ 0x00000020) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR8_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR9;                  /*!< (@ 0x00000024) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR9_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR10;                 /*!< (@ 0x00000028) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR10_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR11;                 /*!< (@ 0x0000002C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR11_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR12;                 /*!< (@ 0x00000030) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR12_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR13;                 /*!< (@ 0x00000034) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR13_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR14;                 /*!< (@ 0x00000038) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR14_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR15;                 /*!< (@ 0x0000003C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR15_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR16;                 /*!< (@ 0x00000040) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR16_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR17;                 /*!< (@ 0x00000044) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR17_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR18;                 /*!< (@ 0x00000048) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR18_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR19;                 /*!< (@ 0x0000004C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR19_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR20;                 /*!< (@ 0x00000050) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR20_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR21;                 /*!< (@ 0x00000054) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR21_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR22;                 /*!< (@ 0x00000058) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR22_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR23;                 /*!< (@ 0x0000005C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR23_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR24;                 /*!< (@ 0x00000060) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR24_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR25;                 /*!< (@ 0x00000064) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR25_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR26;                 /*!< (@ 0x00000068) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR26_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR27;                 /*!< (@ 0x0000006C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR27_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR28;                 /*!< (@ 0x00000070) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR28_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR29;                 /*!< (@ 0x00000074) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR29_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR30;                 /*!< (@ 0x00000078) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR30_b;
  } ;

  union {
    __IOM uint32_t PORTB_PCR31;                 /*!< (@ 0x0000007C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTB_PCR31_b;
  } ;

  union {
    __OM  uint32_t PORTB_GPCLR;                 /*!< (@ 0x00000080) Global Pin Control Low Register                            */

    struct {
      __OM  uint32_t GPWD       : 16;           /*!< [15..0] Global Pin Write Data                                             */
      __OM  uint32_t GPWE       : 16;           /*!< [31..16] Global Pin Write Enable                                          */
    } PORTB_GPCLR_b;
  } ;

  union {
    __OM  uint32_t PORTB_GPCHR;                 /*!< (@ 0x00000084) Global Pin Control High Register                           */

    struct {
      __OM  uint32_t GPWD       : 16;           /*!< [15..0] Global Pin Write Data                                             */
      __OM  uint32_t GPWE       : 16;           /*!< [31..16] Global Pin Write Enable                                          */
    } PORTB_GPCHR_b;
  } ;

  union {
    __OM  uint32_t PORTB_GICLR;                 /*!< (@ 0x00000088) Global Interrupt Control Low Register                      */

    struct {
      __OM  uint32_t GIWE       : 16;           /*!< [15..0] Global Interrupt Write Enable                                     */
      __OM  uint32_t GIWD       : 16;           /*!< [31..16] Global Interrupt Write Data                                      */
    } PORTB_GICLR_b;
  } ;

  union {
    __OM  uint32_t PORTB_GICHR;                 /*!< (@ 0x0000008C) Global Interrupt Control High Register                     */

    struct {
      __OM  uint32_t GIWE       : 16;           /*!< [15..0] Global Interrupt Write Enable                                     */
      __OM  uint32_t GIWD       : 16;           /*!< [31..16] Global Interrupt Write Data                                      */
    } PORTB_GICHR_b;
  } ;
  __IM  uint32_t  RESERVED[4];

  union {
    __IOM uint32_t PORTB_ISFR;                  /*!< (@ 0x000000A0) Interrupt Status Flag Register                             */

    struct {
      __IOM uint32_t ISF        : 32;           /*!< [31..0] Interrupt Status Flag                                             */
    } PORTB_ISFR_b;
  } ;
  __IM  uint32_t  RESERVED1[7];

  union {
    __IOM uint32_t PORTB_DFER;                  /*!< (@ 0x000000C0) Digital Filter Enable Register                             */

    struct {
      __IOM uint32_t DFE        : 32;           /*!< [31..0] Digital Filter Enable                                             */
    } PORTB_DFER_b;
  } ;

  union {
    __IOM uint32_t PORTB_DFCR;                  /*!< (@ 0x000000C4) Digital Filter Clock Register                              */

    struct {
      __IOM uint32_t CS         : 1;            /*!< [0..0] Clock Source                                                       */
            uint32_t            : 31;
    } PORTB_DFCR_b;
  } ;

  union {
    __IOM uint32_t PORTB_DFWR;                  /*!< (@ 0x000000C8) Digital Filter Width Register                              */

    struct {
      __IOM uint32_t FILT       : 5;            /*!< [4..0] Filter Length                                                      */
            uint32_t            : 27;
    } PORTB_DFWR_b;
  } ;
} PORTB_Type;                                   /*!< Size = 204 (0xcc)                                                         */



/* =========================================================================================================================== */
/* ================                                           PORTC                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Pin Control and Interrupts (PORTC)
  */

typedef struct {                                /*!< (@ 0x4004B000) PORTC Structure                                            */

  union {
    __IOM uint32_t PORTC_PCR0;                  /*!< (@ 0x00000000) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR0_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR1;                  /*!< (@ 0x00000004) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR1_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR2;                  /*!< (@ 0x00000008) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR2_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR3;                  /*!< (@ 0x0000000C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR3_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR4;                  /*!< (@ 0x00000010) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR4_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR5;                  /*!< (@ 0x00000014) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR5_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR6;                  /*!< (@ 0x00000018) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR6_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR7;                  /*!< (@ 0x0000001C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR7_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR8;                  /*!< (@ 0x00000020) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR8_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR9;                  /*!< (@ 0x00000024) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR9_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR10;                 /*!< (@ 0x00000028) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR10_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR11;                 /*!< (@ 0x0000002C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR11_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR12;                 /*!< (@ 0x00000030) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR12_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR13;                 /*!< (@ 0x00000034) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR13_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR14;                 /*!< (@ 0x00000038) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR14_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR15;                 /*!< (@ 0x0000003C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR15_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR16;                 /*!< (@ 0x00000040) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR16_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR17;                 /*!< (@ 0x00000044) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR17_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR18;                 /*!< (@ 0x00000048) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR18_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR19;                 /*!< (@ 0x0000004C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR19_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR20;                 /*!< (@ 0x00000050) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR20_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR21;                 /*!< (@ 0x00000054) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR21_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR22;                 /*!< (@ 0x00000058) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR22_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR23;                 /*!< (@ 0x0000005C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR23_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR24;                 /*!< (@ 0x00000060) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR24_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR25;                 /*!< (@ 0x00000064) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR25_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR26;                 /*!< (@ 0x00000068) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR26_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR27;                 /*!< (@ 0x0000006C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR27_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR28;                 /*!< (@ 0x00000070) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR28_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR29;                 /*!< (@ 0x00000074) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR29_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR30;                 /*!< (@ 0x00000078) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR30_b;
  } ;

  union {
    __IOM uint32_t PORTC_PCR31;                 /*!< (@ 0x0000007C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTC_PCR31_b;
  } ;

  union {
    __OM  uint32_t PORTC_GPCLR;                 /*!< (@ 0x00000080) Global Pin Control Low Register                            */

    struct {
      __OM  uint32_t GPWD       : 16;           /*!< [15..0] Global Pin Write Data                                             */
      __OM  uint32_t GPWE       : 16;           /*!< [31..16] Global Pin Write Enable                                          */
    } PORTC_GPCLR_b;
  } ;

  union {
    __OM  uint32_t PORTC_GPCHR;                 /*!< (@ 0x00000084) Global Pin Control High Register                           */

    struct {
      __OM  uint32_t GPWD       : 16;           /*!< [15..0] Global Pin Write Data                                             */
      __OM  uint32_t GPWE       : 16;           /*!< [31..16] Global Pin Write Enable                                          */
    } PORTC_GPCHR_b;
  } ;

  union {
    __OM  uint32_t PORTC_GICLR;                 /*!< (@ 0x00000088) Global Interrupt Control Low Register                      */

    struct {
      __OM  uint32_t GIWE       : 16;           /*!< [15..0] Global Interrupt Write Enable                                     */
      __OM  uint32_t GIWD       : 16;           /*!< [31..16] Global Interrupt Write Data                                      */
    } PORTC_GICLR_b;
  } ;

  union {
    __OM  uint32_t PORTC_GICHR;                 /*!< (@ 0x0000008C) Global Interrupt Control High Register                     */

    struct {
      __OM  uint32_t GIWE       : 16;           /*!< [15..0] Global Interrupt Write Enable                                     */
      __OM  uint32_t GIWD       : 16;           /*!< [31..16] Global Interrupt Write Data                                      */
    } PORTC_GICHR_b;
  } ;
  __IM  uint32_t  RESERVED[4];

  union {
    __IOM uint32_t PORTC_ISFR;                  /*!< (@ 0x000000A0) Interrupt Status Flag Register                             */

    struct {
      __IOM uint32_t ISF        : 32;           /*!< [31..0] Interrupt Status Flag                                             */
    } PORTC_ISFR_b;
  } ;
  __IM  uint32_t  RESERVED1[7];

  union {
    __IOM uint32_t PORTC_DFER;                  /*!< (@ 0x000000C0) Digital Filter Enable Register                             */

    struct {
      __IOM uint32_t DFE        : 32;           /*!< [31..0] Digital Filter Enable                                             */
    } PORTC_DFER_b;
  } ;

  union {
    __IOM uint32_t PORTC_DFCR;                  /*!< (@ 0x000000C4) Digital Filter Clock Register                              */

    struct {
      __IOM uint32_t CS         : 1;            /*!< [0..0] Clock Source                                                       */
            uint32_t            : 31;
    } PORTC_DFCR_b;
  } ;

  union {
    __IOM uint32_t PORTC_DFWR;                  /*!< (@ 0x000000C8) Digital Filter Width Register                              */

    struct {
      __IOM uint32_t FILT       : 5;            /*!< [4..0] Filter Length                                                      */
            uint32_t            : 27;
    } PORTC_DFWR_b;
  } ;
} PORTC_Type;                                   /*!< Size = 204 (0xcc)                                                         */



/* =========================================================================================================================== */
/* ================                                           PORTD                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Pin Control and Interrupts (PORTD)
  */

typedef struct {                                /*!< (@ 0x4004C000) PORTD Structure                                            */

  union {
    __IOM uint32_t PORTD_PCR0;                  /*!< (@ 0x00000000) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR0_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR1;                  /*!< (@ 0x00000004) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR1_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR2;                  /*!< (@ 0x00000008) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR2_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR3;                  /*!< (@ 0x0000000C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 2;
      __IOM uint32_t PFE        : 1;            /*!< [4..4] Passive Filter Enable                                              */
            uint32_t            : 3;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR3_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR4;                  /*!< (@ 0x00000010) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR4_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR5;                  /*!< (@ 0x00000014) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR5_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR6;                  /*!< (@ 0x00000018) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR6_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR7;                  /*!< (@ 0x0000001C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR7_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR8;                  /*!< (@ 0x00000020) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR8_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR9;                  /*!< (@ 0x00000024) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR9_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR10;                 /*!< (@ 0x00000028) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR10_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR11;                 /*!< (@ 0x0000002C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR11_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR12;                 /*!< (@ 0x00000030) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR12_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR13;                 /*!< (@ 0x00000034) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR13_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR14;                 /*!< (@ 0x00000038) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR14_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR15;                 /*!< (@ 0x0000003C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR15_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR16;                 /*!< (@ 0x00000040) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR16_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR17;                 /*!< (@ 0x00000044) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR17_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR18;                 /*!< (@ 0x00000048) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR18_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR19;                 /*!< (@ 0x0000004C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR19_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR20;                 /*!< (@ 0x00000050) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR20_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR21;                 /*!< (@ 0x00000054) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR21_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR22;                 /*!< (@ 0x00000058) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR22_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR23;                 /*!< (@ 0x0000005C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR23_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR24;                 /*!< (@ 0x00000060) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR24_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR25;                 /*!< (@ 0x00000064) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR25_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR26;                 /*!< (@ 0x00000068) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR26_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR27;                 /*!< (@ 0x0000006C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR27_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR28;                 /*!< (@ 0x00000070) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR28_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR29;                 /*!< (@ 0x00000074) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR29_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR30;                 /*!< (@ 0x00000078) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR30_b;
  } ;

  union {
    __IOM uint32_t PORTD_PCR31;                 /*!< (@ 0x0000007C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTD_PCR31_b;
  } ;

  union {
    __OM  uint32_t PORTD_GPCLR;                 /*!< (@ 0x00000080) Global Pin Control Low Register                            */

    struct {
      __OM  uint32_t GPWD       : 16;           /*!< [15..0] Global Pin Write Data                                             */
      __OM  uint32_t GPWE       : 16;           /*!< [31..16] Global Pin Write Enable                                          */
    } PORTD_GPCLR_b;
  } ;

  union {
    __OM  uint32_t PORTD_GPCHR;                 /*!< (@ 0x00000084) Global Pin Control High Register                           */

    struct {
      __OM  uint32_t GPWD       : 16;           /*!< [15..0] Global Pin Write Data                                             */
      __OM  uint32_t GPWE       : 16;           /*!< [31..16] Global Pin Write Enable                                          */
    } PORTD_GPCHR_b;
  } ;

  union {
    __OM  uint32_t PORTD_GICLR;                 /*!< (@ 0x00000088) Global Interrupt Control Low Register                      */

    struct {
      __OM  uint32_t GIWE       : 16;           /*!< [15..0] Global Interrupt Write Enable                                     */
      __OM  uint32_t GIWD       : 16;           /*!< [31..16] Global Interrupt Write Data                                      */
    } PORTD_GICLR_b;
  } ;

  union {
    __OM  uint32_t PORTD_GICHR;                 /*!< (@ 0x0000008C) Global Interrupt Control High Register                     */

    struct {
      __OM  uint32_t GIWE       : 16;           /*!< [15..0] Global Interrupt Write Enable                                     */
      __OM  uint32_t GIWD       : 16;           /*!< [31..16] Global Interrupt Write Data                                      */
    } PORTD_GICHR_b;
  } ;
  __IM  uint32_t  RESERVED[4];

  union {
    __IOM uint32_t PORTD_ISFR;                  /*!< (@ 0x000000A0) Interrupt Status Flag Register                             */

    struct {
      __IOM uint32_t ISF        : 32;           /*!< [31..0] Interrupt Status Flag                                             */
    } PORTD_ISFR_b;
  } ;
  __IM  uint32_t  RESERVED1[7];

  union {
    __IOM uint32_t PORTD_DFER;                  /*!< (@ 0x000000C0) Digital Filter Enable Register                             */

    struct {
      __IOM uint32_t DFE        : 32;           /*!< [31..0] Digital Filter Enable                                             */
    } PORTD_DFER_b;
  } ;

  union {
    __IOM uint32_t PORTD_DFCR;                  /*!< (@ 0x000000C4) Digital Filter Clock Register                              */

    struct {
      __IOM uint32_t CS         : 1;            /*!< [0..0] Clock Source                                                       */
            uint32_t            : 31;
    } PORTD_DFCR_b;
  } ;

  union {
    __IOM uint32_t PORTD_DFWR;                  /*!< (@ 0x000000C8) Digital Filter Width Register                              */

    struct {
      __IOM uint32_t FILT       : 5;            /*!< [4..0] Filter Length                                                      */
            uint32_t            : 27;
    } PORTD_DFWR_b;
  } ;
} PORTD_Type;                                   /*!< Size = 204 (0xcc)                                                         */



/* =========================================================================================================================== */
/* ================                                           PORTE                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Pin Control and Interrupts (PORTE)
  */

typedef struct {                                /*!< (@ 0x4004D000) PORTE Structure                                            */

  union {
    __IOM uint32_t PORTE_PCR0;                  /*!< (@ 0x00000000) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR0_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR1;                  /*!< (@ 0x00000004) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR1_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR2;                  /*!< (@ 0x00000008) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR2_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR3;                  /*!< (@ 0x0000000C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR3_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR4;                  /*!< (@ 0x00000010) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR4_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR5;                  /*!< (@ 0x00000014) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR5_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR6;                  /*!< (@ 0x00000018) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR6_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR7;                  /*!< (@ 0x0000001C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR7_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR8;                  /*!< (@ 0x00000020) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR8_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR9;                  /*!< (@ 0x00000024) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR9_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR10;                 /*!< (@ 0x00000028) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR10_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR11;                 /*!< (@ 0x0000002C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR11_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR12;                 /*!< (@ 0x00000030) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR12_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR13;                 /*!< (@ 0x00000034) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR13_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR14;                 /*!< (@ 0x00000038) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR14_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR15;                 /*!< (@ 0x0000003C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR15_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR16;                 /*!< (@ 0x00000040) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR16_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR17;                 /*!< (@ 0x00000044) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR17_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR18;                 /*!< (@ 0x00000048) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR18_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR19;                 /*!< (@ 0x0000004C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR19_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR20;                 /*!< (@ 0x00000050) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR20_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR21;                 /*!< (@ 0x00000054) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR21_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR22;                 /*!< (@ 0x00000058) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR22_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR23;                 /*!< (@ 0x0000005C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR23_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR24;                 /*!< (@ 0x00000060) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR24_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR25;                 /*!< (@ 0x00000064) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 4;
      __IOM uint32_t DSE        : 1;            /*!< [6..6] Drive Strength Enable                                              */
            uint32_t            : 1;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR25_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR26;                 /*!< (@ 0x00000068) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR26_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR27;                 /*!< (@ 0x0000006C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR27_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR28;                 /*!< (@ 0x00000070) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR28_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR29;                 /*!< (@ 0x00000074) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR29_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR30;                 /*!< (@ 0x00000078) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR30_b;
  } ;

  union {
    __IOM uint32_t PORTE_PCR31;                 /*!< (@ 0x0000007C) Pin Control Register n                                     */

    struct {
      __IOM uint32_t PS         : 1;            /*!< [0..0] Pull Select                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Pull Enable                                                        */
            uint32_t            : 6;
      __IOM uint32_t MUX        : 3;            /*!< [10..8] Pin Mux Control                                                   */
            uint32_t            : 4;
      __IOM uint32_t LK         : 1;            /*!< [15..15] Lock Register                                                    */
      __IOM uint32_t IRQC       : 4;            /*!< [19..16] Interrupt Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t ISF        : 1;            /*!< [24..24] Interrupt Status Flag                                            */
            uint32_t            : 7;
    } PORTE_PCR31_b;
  } ;

  union {
    __OM  uint32_t PORTE_GPCLR;                 /*!< (@ 0x00000080) Global Pin Control Low Register                            */

    struct {
      __OM  uint32_t GPWD       : 16;           /*!< [15..0] Global Pin Write Data                                             */
      __OM  uint32_t GPWE       : 16;           /*!< [31..16] Global Pin Write Enable                                          */
    } PORTE_GPCLR_b;
  } ;

  union {
    __OM  uint32_t PORTE_GPCHR;                 /*!< (@ 0x00000084) Global Pin Control High Register                           */

    struct {
      __OM  uint32_t GPWD       : 16;           /*!< [15..0] Global Pin Write Data                                             */
      __OM  uint32_t GPWE       : 16;           /*!< [31..16] Global Pin Write Enable                                          */
    } PORTE_GPCHR_b;
  } ;

  union {
    __OM  uint32_t PORTE_GICLR;                 /*!< (@ 0x00000088) Global Interrupt Control Low Register                      */

    struct {
      __OM  uint32_t GIWE       : 16;           /*!< [15..0] Global Interrupt Write Enable                                     */
      __OM  uint32_t GIWD       : 16;           /*!< [31..16] Global Interrupt Write Data                                      */
    } PORTE_GICLR_b;
  } ;

  union {
    __OM  uint32_t PORTE_GICHR;                 /*!< (@ 0x0000008C) Global Interrupt Control High Register                     */

    struct {
      __OM  uint32_t GIWE       : 16;           /*!< [15..0] Global Interrupt Write Enable                                     */
      __OM  uint32_t GIWD       : 16;           /*!< [31..16] Global Interrupt Write Data                                      */
    } PORTE_GICHR_b;
  } ;
  __IM  uint32_t  RESERVED[4];

  union {
    __IOM uint32_t PORTE_ISFR;                  /*!< (@ 0x000000A0) Interrupt Status Flag Register                             */

    struct {
      __IOM uint32_t ISF        : 32;           /*!< [31..0] Interrupt Status Flag                                             */
    } PORTE_ISFR_b;
  } ;
  __IM  uint32_t  RESERVED1[7];

  union {
    __IOM uint32_t PORTE_DFER;                  /*!< (@ 0x000000C0) Digital Filter Enable Register                             */

    struct {
      __IOM uint32_t DFE        : 32;           /*!< [31..0] Digital Filter Enable                                             */
    } PORTE_DFER_b;
  } ;

  union {
    __IOM uint32_t PORTE_DFCR;                  /*!< (@ 0x000000C4) Digital Filter Clock Register                              */

    struct {
      __IOM uint32_t CS         : 1;            /*!< [0..0] Clock Source                                                       */
            uint32_t            : 31;
    } PORTE_DFCR_b;
  } ;

  union {
    __IOM uint32_t PORTE_DFWR;                  /*!< (@ 0x000000C8) Digital Filter Width Register                              */

    struct {
      __IOM uint32_t FILT       : 5;            /*!< [4..0] Filter Length                                                      */
            uint32_t            : 27;
    } PORTE_DFWR_b;
  } ;
} PORTE_Type;                                   /*!< Size = 204 (0xcc)                                                         */



/* =========================================================================================================================== */
/* ================                                           WDOG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Watchdog timer (WDOG)
  */

typedef struct {                                /*!< (@ 0x40052000) WDOG Structure                                             */

  union {
    __IOM uint32_t WDOG_CS;                     /*!< (@ 0x00000000) Watchdog Control and Status Register                       */

    struct {
      __IOM uint32_t STOP       : 1;            /*!< [0..0] Stop Enable                                                        */
      __IOM uint32_t WAIT       : 1;            /*!< [1..1] Wait Enable                                                        */
      __IOM uint32_t DBG        : 1;            /*!< [2..2] Debug Enable                                                       */
      __IOM uint32_t TST        : 2;            /*!< [4..3] Watchdog Test                                                      */
      __IOM uint32_t UPDATE     : 1;            /*!< [5..5] Allow updates                                                      */
      __IOM uint32_t INT        : 1;            /*!< [6..6] Watchdog Interrupt                                                 */
      __IOM uint32_t EN         : 1;            /*!< [7..7] Watchdog Enable                                                    */
      __IOM uint32_t CLK        : 2;            /*!< [9..8] Watchdog Clock                                                     */
      __IM  uint32_t RCS        : 1;            /*!< [10..10] Reconfiguration Success                                          */
      __IM  uint32_t ULK        : 1;            /*!< [11..11] Unlock status                                                    */
      __IOM uint32_t PRES       : 1;            /*!< [12..12] Watchdog prescaler                                               */
      __IOM uint32_t CMD32EN    : 1;            /*!< [13..13] Enables or disables WDOG support for 32-bit (otherwise
                                                     16-bit or 8-bit) refresh/unlock command write words                       */
      __IOM uint32_t FLG        : 1;            /*!< [14..14] Watchdog Interrupt Flag                                          */
      __IOM uint32_t WIN        : 1;            /*!< [15..15] Watchdog Window                                                  */
            uint32_t            : 16;
    } WDOG_CS_b;
  } ;

  union {
    __IOM uint32_t WDOG_CNT;                    /*!< (@ 0x00000004) Watchdog Counter Register                                  */

    struct {
      __IOM uint32_t CNTLOW     : 8;            /*!< [7..0] Low byte of the Watchdog Counter                                   */
      __IOM uint32_t CNTHIGH    : 8;            /*!< [15..8] High byte of the Watchdog Counter                                 */
            uint32_t            : 16;
    } WDOG_CNT_b;
  } ;

  union {
    __IOM uint32_t WDOG_TOVAL;                  /*!< (@ 0x00000008) Watchdog Timeout Value Register                            */

    struct {
      __IOM uint32_t TOVALLOW   : 8;            /*!< [7..0] Low byte of the timeout value                                      */
      __IOM uint32_t TOVALHIGH  : 8;            /*!< [15..8] High byte of the timeout value                                    */
            uint32_t            : 16;
    } WDOG_TOVAL_b;
  } ;

  union {
    __IOM uint32_t WDOG_WIN;                    /*!< (@ 0x0000000C) Watchdog Window Register                                   */

    struct {
      __IOM uint32_t WINLOW     : 8;            /*!< [7..0] Low byte of Watchdog Window                                        */
      __IOM uint32_t WINHIGH    : 8;            /*!< [15..8] High byte of Watchdog Window                                      */
            uint32_t            : 16;
    } WDOG_WIN_b;
  } ;
} WDOG_Type;                                    /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          FLEXIO                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief The FLEXIO Memory Map/Register Definition can be found here. (FLEXIO)
  */

typedef struct {                                /*!< (@ 0x4005A000) FLEXIO Structure                                           */

  union {
    __IM  uint32_t FLEXIO_VERID;                /*!< (@ 0x00000000) Version ID Register                                        */

    struct {
      __IM  uint32_t FEATURE    : 16;           /*!< [15..0] Feature Specification Number                                      */
      __IM  uint32_t MINOR      : 8;            /*!< [23..16] Minor Version Number                                             */
      __IM  uint32_t MAJOR      : 8;            /*!< [31..24] Major Version Number                                             */
    } FLEXIO_VERID_b;
  } ;

  union {
    __IM  uint32_t FLEXIO_PARAM;                /*!< (@ 0x00000004) Parameter Register                                         */

    struct {
      __IM  uint32_t SHIFTER    : 8;            /*!< [7..0] Shifter Number                                                     */
      __IM  uint32_t TIMER      : 8;            /*!< [15..8] Timer Number                                                      */
      __IM  uint32_t PIN        : 8;            /*!< [23..16] Pin Number                                                       */
      __IM  uint32_t TRIGGER    : 8;            /*!< [31..24] Trigger Number                                                   */
    } FLEXIO_PARAM_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_CTRL;                 /*!< (@ 0x00000008) FlexIO Control Register                                    */

    struct {
      __IOM uint32_t FLEXEN     : 1;            /*!< [0..0] FlexIO Enable                                                      */
      __IOM uint32_t SWRST      : 1;            /*!< [1..1] Software Reset                                                     */
      __IOM uint32_t FASTACC    : 1;            /*!< [2..2] Fast Access                                                        */
            uint32_t            : 27;
      __IOM uint32_t DBGE       : 1;            /*!< [30..30] Debug Enable                                                     */
      __IOM uint32_t DOZEN      : 1;            /*!< [31..31] Doze Enable                                                      */
    } FLEXIO_CTRL_b;
  } ;

  union {
    __IM  uint32_t FLEXIO_PIN;                  /*!< (@ 0x0000000C) Pin State Register                                         */

    struct {
      __IM  uint32_t PDI        : 8;            /*!< [7..0] Pin Data Input                                                     */
            uint32_t            : 24;
    } FLEXIO_PIN_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTSTAT;            /*!< (@ 0x00000010) Shifter Status Register                                    */

    struct {
      __IOM uint32_t SSF        : 4;            /*!< [3..0] Shifter Status Flag                                                */
            uint32_t            : 28;
    } FLEXIO_SHIFTSTAT_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTERR;             /*!< (@ 0x00000014) Shifter Error Register                                     */

    struct {
      __IOM uint32_t SEF        : 4;            /*!< [3..0] Shifter Error Flags                                                */
            uint32_t            : 28;
    } FLEXIO_SHIFTERR_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMSTAT;              /*!< (@ 0x00000018) Timer Status Register                                      */

    struct {
      __IOM uint32_t TSF        : 4;            /*!< [3..0] Timer Status Flags                                                 */
            uint32_t            : 28;
    } FLEXIO_TIMSTAT_b;
  } ;
  __IM  uint32_t  RESERVED;

  union {
    __IOM uint32_t FLEXIO_SHIFTSIEN;            /*!< (@ 0x00000020) Shifter Status Interrupt Enable                            */

    struct {
      __IOM uint32_t SSIE       : 4;            /*!< [3..0] Shifter Status Interrupt Enable                                    */
            uint32_t            : 28;
    } FLEXIO_SHIFTSIEN_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTEIEN;            /*!< (@ 0x00000024) Shifter Error Interrupt Enable                             */

    struct {
      __IOM uint32_t SEIE       : 4;            /*!< [3..0] Shifter Error Interrupt Enable                                     */
            uint32_t            : 28;
    } FLEXIO_SHIFTEIEN_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMIEN;               /*!< (@ 0x00000028) Timer Interrupt Enable Register                            */

    struct {
      __IOM uint32_t TEIE       : 4;            /*!< [3..0] Timer Status Interrupt Enable                                      */
            uint32_t            : 28;
    } FLEXIO_TIMIEN_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t FLEXIO_SHIFTSDEN;            /*!< (@ 0x00000030) Shifter Status DMA Enable                                  */

    struct {
      __IOM uint32_t SSDE       : 4;            /*!< [3..0] Shifter Status DMA Enable                                          */
            uint32_t            : 28;
    } FLEXIO_SHIFTSDEN_b;
  } ;
  __IM  uint32_t  RESERVED2[19];

  union {
    __IOM uint32_t FLEXIO_SHIFTCTL0;            /*!< (@ 0x00000080) Shifter Control N Register                                 */

    struct {
      __IOM uint32_t SMOD       : 3;            /*!< [2..0] Shifter Mode                                                       */
            uint32_t            : 4;
      __IOM uint32_t PINPOL     : 1;            /*!< [7..7] Shifter Pin Polarity                                               */
      __IOM uint32_t PINSEL     : 3;            /*!< [10..8] Shifter Pin Select                                                */
            uint32_t            : 5;
      __IOM uint32_t PINCFG     : 2;            /*!< [17..16] Shifter Pin Configuration                                        */
            uint32_t            : 5;
      __IOM uint32_t TIMPOL     : 1;            /*!< [23..23] Timer Polarity                                                   */
      __IOM uint32_t TIMSEL     : 2;            /*!< [25..24] Timer Select                                                     */
            uint32_t            : 6;
    } FLEXIO_SHIFTCTL0_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTCTL1;            /*!< (@ 0x00000084) Shifter Control N Register                                 */

    struct {
      __IOM uint32_t SMOD       : 3;            /*!< [2..0] Shifter Mode                                                       */
            uint32_t            : 4;
      __IOM uint32_t PINPOL     : 1;            /*!< [7..7] Shifter Pin Polarity                                               */
      __IOM uint32_t PINSEL     : 3;            /*!< [10..8] Shifter Pin Select                                                */
            uint32_t            : 5;
      __IOM uint32_t PINCFG     : 2;            /*!< [17..16] Shifter Pin Configuration                                        */
            uint32_t            : 5;
      __IOM uint32_t TIMPOL     : 1;            /*!< [23..23] Timer Polarity                                                   */
      __IOM uint32_t TIMSEL     : 2;            /*!< [25..24] Timer Select                                                     */
            uint32_t            : 6;
    } FLEXIO_SHIFTCTL1_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTCTL2;            /*!< (@ 0x00000088) Shifter Control N Register                                 */

    struct {
      __IOM uint32_t SMOD       : 3;            /*!< [2..0] Shifter Mode                                                       */
            uint32_t            : 4;
      __IOM uint32_t PINPOL     : 1;            /*!< [7..7] Shifter Pin Polarity                                               */
      __IOM uint32_t PINSEL     : 3;            /*!< [10..8] Shifter Pin Select                                                */
            uint32_t            : 5;
      __IOM uint32_t PINCFG     : 2;            /*!< [17..16] Shifter Pin Configuration                                        */
            uint32_t            : 5;
      __IOM uint32_t TIMPOL     : 1;            /*!< [23..23] Timer Polarity                                                   */
      __IOM uint32_t TIMSEL     : 2;            /*!< [25..24] Timer Select                                                     */
            uint32_t            : 6;
    } FLEXIO_SHIFTCTL2_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTCTL3;            /*!< (@ 0x0000008C) Shifter Control N Register                                 */

    struct {
      __IOM uint32_t SMOD       : 3;            /*!< [2..0] Shifter Mode                                                       */
            uint32_t            : 4;
      __IOM uint32_t PINPOL     : 1;            /*!< [7..7] Shifter Pin Polarity                                               */
      __IOM uint32_t PINSEL     : 3;            /*!< [10..8] Shifter Pin Select                                                */
            uint32_t            : 5;
      __IOM uint32_t PINCFG     : 2;            /*!< [17..16] Shifter Pin Configuration                                        */
            uint32_t            : 5;
      __IOM uint32_t TIMPOL     : 1;            /*!< [23..23] Timer Polarity                                                   */
      __IOM uint32_t TIMSEL     : 2;            /*!< [25..24] Timer Select                                                     */
            uint32_t            : 6;
    } FLEXIO_SHIFTCTL3_b;
  } ;
  __IM  uint32_t  RESERVED3[28];

  union {
    __IOM uint32_t FLEXIO_SHIFTCFG0;            /*!< (@ 0x00000100) Shifter Configuration N Register                           */

    struct {
      __IOM uint32_t SSTART     : 2;            /*!< [1..0] Shifter Start bit                                                  */
            uint32_t            : 2;
      __IOM uint32_t SSTOP      : 2;            /*!< [5..4] Shifter Stop bit                                                   */
            uint32_t            : 2;
      __IOM uint32_t INSRC      : 1;            /*!< [8..8] Input Source                                                       */
            uint32_t            : 23;
    } FLEXIO_SHIFTCFG0_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTCFG1;            /*!< (@ 0x00000104) Shifter Configuration N Register                           */

    struct {
      __IOM uint32_t SSTART     : 2;            /*!< [1..0] Shifter Start bit                                                  */
            uint32_t            : 2;
      __IOM uint32_t SSTOP      : 2;            /*!< [5..4] Shifter Stop bit                                                   */
            uint32_t            : 2;
      __IOM uint32_t INSRC      : 1;            /*!< [8..8] Input Source                                                       */
            uint32_t            : 23;
    } FLEXIO_SHIFTCFG1_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTCFG2;            /*!< (@ 0x00000108) Shifter Configuration N Register                           */

    struct {
      __IOM uint32_t SSTART     : 2;            /*!< [1..0] Shifter Start bit                                                  */
            uint32_t            : 2;
      __IOM uint32_t SSTOP      : 2;            /*!< [5..4] Shifter Stop bit                                                   */
            uint32_t            : 2;
      __IOM uint32_t INSRC      : 1;            /*!< [8..8] Input Source                                                       */
            uint32_t            : 23;
    } FLEXIO_SHIFTCFG2_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTCFG3;            /*!< (@ 0x0000010C) Shifter Configuration N Register                           */

    struct {
      __IOM uint32_t SSTART     : 2;            /*!< [1..0] Shifter Start bit                                                  */
            uint32_t            : 2;
      __IOM uint32_t SSTOP      : 2;            /*!< [5..4] Shifter Stop bit                                                   */
            uint32_t            : 2;
      __IOM uint32_t INSRC      : 1;            /*!< [8..8] Input Source                                                       */
            uint32_t            : 23;
    } FLEXIO_SHIFTCFG3_b;
  } ;
  __IM  uint32_t  RESERVED4[60];

  union {
    __IOM uint32_t FLEXIO_SHIFTBUF0;            /*!< (@ 0x00000200) Shifter Buffer N Register                                  */

    struct {
      __IOM uint32_t SHIFTBUF   : 32;           /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUF0_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUF1;            /*!< (@ 0x00000204) Shifter Buffer N Register                                  */

    struct {
      __IOM uint32_t SHIFTBUF   : 32;           /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUF1_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUF2;            /*!< (@ 0x00000208) Shifter Buffer N Register                                  */

    struct {
      __IOM uint32_t SHIFTBUF   : 32;           /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUF2_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUF3;            /*!< (@ 0x0000020C) Shifter Buffer N Register                                  */

    struct {
      __IOM uint32_t SHIFTBUF   : 32;           /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUF3_b;
  } ;
  __IM  uint32_t  RESERVED5[28];

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBIS0;         /*!< (@ 0x00000280) Shifter Buffer N Bit Swapped Register                      */

    struct {
      __IOM uint32_t SHIFTBUFBIS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBIS0_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBIS1;         /*!< (@ 0x00000284) Shifter Buffer N Bit Swapped Register                      */

    struct {
      __IOM uint32_t SHIFTBUFBIS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBIS1_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBIS2;         /*!< (@ 0x00000288) Shifter Buffer N Bit Swapped Register                      */

    struct {
      __IOM uint32_t SHIFTBUFBIS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBIS2_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBIS3;         /*!< (@ 0x0000028C) Shifter Buffer N Bit Swapped Register                      */

    struct {
      __IOM uint32_t SHIFTBUFBIS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBIS3_b;
  } ;
  __IM  uint32_t  RESERVED6[28];

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBYS0;         /*!< (@ 0x00000300) Shifter Buffer N Byte Swapped Register                     */

    struct {
      __IOM uint32_t SHIFTBUFBYS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBYS0_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBYS1;         /*!< (@ 0x00000304) Shifter Buffer N Byte Swapped Register                     */

    struct {
      __IOM uint32_t SHIFTBUFBYS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBYS1_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBYS2;         /*!< (@ 0x00000308) Shifter Buffer N Byte Swapped Register                     */

    struct {
      __IOM uint32_t SHIFTBUFBYS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBYS2_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBYS3;         /*!< (@ 0x0000030C) Shifter Buffer N Byte Swapped Register                     */

    struct {
      __IOM uint32_t SHIFTBUFBYS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBYS3_b;
  } ;
  __IM  uint32_t  RESERVED7[28];

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBBS0;         /*!< (@ 0x00000380) Shifter Buffer N Bit Byte Swapped Register                 */

    struct {
      __IOM uint32_t SHIFTBUFBBS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBBS0_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBBS1;         /*!< (@ 0x00000384) Shifter Buffer N Bit Byte Swapped Register                 */

    struct {
      __IOM uint32_t SHIFTBUFBBS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBBS1_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBBS2;         /*!< (@ 0x00000388) Shifter Buffer N Bit Byte Swapped Register                 */

    struct {
      __IOM uint32_t SHIFTBUFBBS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBBS2_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_SHIFTBUFBBS3;         /*!< (@ 0x0000038C) Shifter Buffer N Bit Byte Swapped Register                 */

    struct {
      __IOM uint32_t SHIFTBUFBBS : 32;          /*!< [31..0] Shift Buffer                                                      */
    } FLEXIO_SHIFTBUFBBS3_b;
  } ;
  __IM  uint32_t  RESERVED8[28];

  union {
    __IOM uint32_t FLEXIO_TIMCTL0;              /*!< (@ 0x00000400) Timer Control N Register                                   */

    struct {
      __IOM uint32_t TIMOD      : 2;            /*!< [1..0] Timer Mode                                                         */
            uint32_t            : 5;
      __IOM uint32_t PINPOL     : 1;            /*!< [7..7] Timer Pin Polarity                                                 */
      __IOM uint32_t PINSEL     : 3;            /*!< [10..8] Timer Pin Select                                                  */
            uint32_t            : 5;
      __IOM uint32_t PINCFG     : 2;            /*!< [17..16] Timer Pin Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t TRGSRC     : 1;            /*!< [22..22] Trigger Source                                                   */
      __IOM uint32_t TRGPOL     : 1;            /*!< [23..23] Trigger Polarity                                                 */
      __IOM uint32_t TRGSEL     : 4;            /*!< [27..24] Trigger Select                                                   */
            uint32_t            : 4;
    } FLEXIO_TIMCTL0_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMCTL1;              /*!< (@ 0x00000404) Timer Control N Register                                   */

    struct {
      __IOM uint32_t TIMOD      : 2;            /*!< [1..0] Timer Mode                                                         */
            uint32_t            : 5;
      __IOM uint32_t PINPOL     : 1;            /*!< [7..7] Timer Pin Polarity                                                 */
      __IOM uint32_t PINSEL     : 3;            /*!< [10..8] Timer Pin Select                                                  */
            uint32_t            : 5;
      __IOM uint32_t PINCFG     : 2;            /*!< [17..16] Timer Pin Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t TRGSRC     : 1;            /*!< [22..22] Trigger Source                                                   */
      __IOM uint32_t TRGPOL     : 1;            /*!< [23..23] Trigger Polarity                                                 */
      __IOM uint32_t TRGSEL     : 4;            /*!< [27..24] Trigger Select                                                   */
            uint32_t            : 4;
    } FLEXIO_TIMCTL1_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMCTL2;              /*!< (@ 0x00000408) Timer Control N Register                                   */

    struct {
      __IOM uint32_t TIMOD      : 2;            /*!< [1..0] Timer Mode                                                         */
            uint32_t            : 5;
      __IOM uint32_t PINPOL     : 1;            /*!< [7..7] Timer Pin Polarity                                                 */
      __IOM uint32_t PINSEL     : 3;            /*!< [10..8] Timer Pin Select                                                  */
            uint32_t            : 5;
      __IOM uint32_t PINCFG     : 2;            /*!< [17..16] Timer Pin Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t TRGSRC     : 1;            /*!< [22..22] Trigger Source                                                   */
      __IOM uint32_t TRGPOL     : 1;            /*!< [23..23] Trigger Polarity                                                 */
      __IOM uint32_t TRGSEL     : 4;            /*!< [27..24] Trigger Select                                                   */
            uint32_t            : 4;
    } FLEXIO_TIMCTL2_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMCTL3;              /*!< (@ 0x0000040C) Timer Control N Register                                   */

    struct {
      __IOM uint32_t TIMOD      : 2;            /*!< [1..0] Timer Mode                                                         */
            uint32_t            : 5;
      __IOM uint32_t PINPOL     : 1;            /*!< [7..7] Timer Pin Polarity                                                 */
      __IOM uint32_t PINSEL     : 3;            /*!< [10..8] Timer Pin Select                                                  */
            uint32_t            : 5;
      __IOM uint32_t PINCFG     : 2;            /*!< [17..16] Timer Pin Configuration                                          */
            uint32_t            : 4;
      __IOM uint32_t TRGSRC     : 1;            /*!< [22..22] Trigger Source                                                   */
      __IOM uint32_t TRGPOL     : 1;            /*!< [23..23] Trigger Polarity                                                 */
      __IOM uint32_t TRGSEL     : 4;            /*!< [27..24] Trigger Select                                                   */
            uint32_t            : 4;
    } FLEXIO_TIMCTL3_b;
  } ;
  __IM  uint32_t  RESERVED9[28];

  union {
    __IOM uint32_t FLEXIO_TIMCFG0;              /*!< (@ 0x00000480) Timer Configuration N Register                             */

    struct {
            uint32_t            : 1;
      __IOM uint32_t TSTART     : 1;            /*!< [1..1] Timer Start Bit                                                    */
            uint32_t            : 2;
      __IOM uint32_t TSTOP      : 2;            /*!< [5..4] Timer Stop Bit                                                     */
            uint32_t            : 2;
      __IOM uint32_t TIMENA     : 3;            /*!< [10..8] Timer Enable                                                      */
            uint32_t            : 1;
      __IOM uint32_t TIMDIS     : 3;            /*!< [14..12] Timer Disable                                                    */
            uint32_t            : 1;
      __IOM uint32_t TIMRST     : 3;            /*!< [18..16] Timer Reset                                                      */
            uint32_t            : 1;
      __IOM uint32_t TIMDEC     : 2;            /*!< [21..20] Timer Decrement                                                  */
            uint32_t            : 2;
      __IOM uint32_t TIMOUT     : 2;            /*!< [25..24] Timer Output                                                     */
            uint32_t            : 6;
    } FLEXIO_TIMCFG0_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMCFG1;              /*!< (@ 0x00000484) Timer Configuration N Register                             */

    struct {
            uint32_t            : 1;
      __IOM uint32_t TSTART     : 1;            /*!< [1..1] Timer Start Bit                                                    */
            uint32_t            : 2;
      __IOM uint32_t TSTOP      : 2;            /*!< [5..4] Timer Stop Bit                                                     */
            uint32_t            : 2;
      __IOM uint32_t TIMENA     : 3;            /*!< [10..8] Timer Enable                                                      */
            uint32_t            : 1;
      __IOM uint32_t TIMDIS     : 3;            /*!< [14..12] Timer Disable                                                    */
            uint32_t            : 1;
      __IOM uint32_t TIMRST     : 3;            /*!< [18..16] Timer Reset                                                      */
            uint32_t            : 1;
      __IOM uint32_t TIMDEC     : 2;            /*!< [21..20] Timer Decrement                                                  */
            uint32_t            : 2;
      __IOM uint32_t TIMOUT     : 2;            /*!< [25..24] Timer Output                                                     */
            uint32_t            : 6;
    } FLEXIO_TIMCFG1_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMCFG2;              /*!< (@ 0x00000488) Timer Configuration N Register                             */

    struct {
            uint32_t            : 1;
      __IOM uint32_t TSTART     : 1;            /*!< [1..1] Timer Start Bit                                                    */
            uint32_t            : 2;
      __IOM uint32_t TSTOP      : 2;            /*!< [5..4] Timer Stop Bit                                                     */
            uint32_t            : 2;
      __IOM uint32_t TIMENA     : 3;            /*!< [10..8] Timer Enable                                                      */
            uint32_t            : 1;
      __IOM uint32_t TIMDIS     : 3;            /*!< [14..12] Timer Disable                                                    */
            uint32_t            : 1;
      __IOM uint32_t TIMRST     : 3;            /*!< [18..16] Timer Reset                                                      */
            uint32_t            : 1;
      __IOM uint32_t TIMDEC     : 2;            /*!< [21..20] Timer Decrement                                                  */
            uint32_t            : 2;
      __IOM uint32_t TIMOUT     : 2;            /*!< [25..24] Timer Output                                                     */
            uint32_t            : 6;
    } FLEXIO_TIMCFG2_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMCFG3;              /*!< (@ 0x0000048C) Timer Configuration N Register                             */

    struct {
            uint32_t            : 1;
      __IOM uint32_t TSTART     : 1;            /*!< [1..1] Timer Start Bit                                                    */
            uint32_t            : 2;
      __IOM uint32_t TSTOP      : 2;            /*!< [5..4] Timer Stop Bit                                                     */
            uint32_t            : 2;
      __IOM uint32_t TIMENA     : 3;            /*!< [10..8] Timer Enable                                                      */
            uint32_t            : 1;
      __IOM uint32_t TIMDIS     : 3;            /*!< [14..12] Timer Disable                                                    */
            uint32_t            : 1;
      __IOM uint32_t TIMRST     : 3;            /*!< [18..16] Timer Reset                                                      */
            uint32_t            : 1;
      __IOM uint32_t TIMDEC     : 2;            /*!< [21..20] Timer Decrement                                                  */
            uint32_t            : 2;
      __IOM uint32_t TIMOUT     : 2;            /*!< [25..24] Timer Output                                                     */
            uint32_t            : 6;
    } FLEXIO_TIMCFG3_b;
  } ;
  __IM  uint32_t  RESERVED10[28];

  union {
    __IOM uint32_t FLEXIO_TIMCMP0;              /*!< (@ 0x00000500) Timer Compare N Register                                   */

    struct {
      __IOM uint32_t CMP        : 16;           /*!< [15..0] Timer Compare Value                                               */
            uint32_t            : 16;
    } FLEXIO_TIMCMP0_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMCMP1;              /*!< (@ 0x00000504) Timer Compare N Register                                   */

    struct {
      __IOM uint32_t CMP        : 16;           /*!< [15..0] Timer Compare Value                                               */
            uint32_t            : 16;
    } FLEXIO_TIMCMP1_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMCMP2;              /*!< (@ 0x00000508) Timer Compare N Register                                   */

    struct {
      __IOM uint32_t CMP        : 16;           /*!< [15..0] Timer Compare Value                                               */
            uint32_t            : 16;
    } FLEXIO_TIMCMP2_b;
  } ;

  union {
    __IOM uint32_t FLEXIO_TIMCMP3;              /*!< (@ 0x0000050C) Timer Compare N Register                                   */

    struct {
      __IOM uint32_t CMP        : 16;           /*!< [15..0] Timer Compare Value                                               */
            uint32_t            : 16;
    } FLEXIO_TIMCMP3_b;
  } ;
} FLEXIO_Type;                                  /*!< Size = 1296 (0x510)                                                       */



/* =========================================================================================================================== */
/* ================                                          TRGMUX                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief TRGMUX (TRGMUX)
  */

typedef struct {                                /*!< (@ 0x40063000) TRGMUX Structure                                           */

  union {
    __IOM uint32_t TRGMUX_DMAMUX0;              /*!< (@ 0x00000000) TRGMUX DMAMUX0 Register                                    */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 2;
      __IOM uint32_t SEL1       : 6;            /*!< [13..8] Trigger MUX Input 1 Source Select                                 */
            uint32_t            : 2;
      __IOM uint32_t SEL2       : 6;            /*!< [21..16] Trigger MUX Input 2 Source Select                                */
            uint32_t            : 2;
      __IOM uint32_t SEL3       : 6;            /*!< [29..24] Trigger MUX Input 3 Source Select                                */
            uint32_t            : 1;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_DMAMUX0_b;
  } ;

  union {
    __IOM uint32_t TRGMUX_EXTOUT0;              /*!< (@ 0x00000004) TRGMUX EXTOUT0 Register                                    */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 2;
      __IOM uint32_t SEL1       : 6;            /*!< [13..8] Trigger MUX Input 1 Source Select                                 */
            uint32_t            : 2;
      __IOM uint32_t SEL2       : 6;            /*!< [21..16] Trigger MUX Input 2 Source Select                                */
            uint32_t            : 2;
      __IOM uint32_t SEL3       : 6;            /*!< [29..24] Trigger MUX Input 3 Source Select                                */
            uint32_t            : 1;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_EXTOUT0_b;
  } ;

  union {
    __IOM uint32_t TRGMUX_EXTOUT1;              /*!< (@ 0x00000008) TRGMUX EXTOUT1 Register                                    */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 2;
      __IOM uint32_t SEL1       : 6;            /*!< [13..8] Trigger MUX Input 1 Source Select                                 */
            uint32_t            : 2;
      __IOM uint32_t SEL2       : 6;            /*!< [21..16] Trigger MUX Input 2 Source Select                                */
            uint32_t            : 2;
      __IOM uint32_t SEL3       : 6;            /*!< [29..24] Trigger MUX Input 3 Source Select                                */
            uint32_t            : 1;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_EXTOUT1_b;
  } ;

  union {
    __IOM uint32_t TRGMUX_ADC0;                 /*!< (@ 0x0000000C) TRGMUX ADC0 Register                                       */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 2;
      __IOM uint32_t SEL1       : 6;            /*!< [13..8] Trigger MUX Input 1 Source Select                                 */
            uint32_t            : 2;
      __IOM uint32_t SEL2       : 6;            /*!< [21..16] Trigger MUX Input 2 Source Select                                */
            uint32_t            : 2;
      __IOM uint32_t SEL3       : 6;            /*!< [29..24] Trigger MUX Input 3 Source Select                                */
            uint32_t            : 1;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_ADC0_b;
  } ;
  __IM  uint32_t  RESERVED[3];

  union {
    __IOM uint32_t TRGMUX_CMP0;                 /*!< (@ 0x0000001C) TRGMUX CMP0 Register                                       */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 25;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_CMP0_b;
  } ;
  __IM  uint32_t  RESERVED1[2];

  union {
    __IOM uint32_t TRGMUX_FTM0;                 /*!< (@ 0x00000028) TRGMUX FTM0 Register                                       */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 2;
      __IOM uint32_t SEL1       : 6;            /*!< [13..8] Trigger MUX Input 1 Source Select                                 */
            uint32_t            : 2;
      __IOM uint32_t SEL2       : 6;            /*!< [21..16] Trigger MUX Input 2 Source Select                                */
            uint32_t            : 2;
      __IOM uint32_t SEL3       : 6;            /*!< [29..24] Trigger MUX Input 3 Source Select                                */
            uint32_t            : 1;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_FTM0_b;
  } ;

  union {
    __IOM uint32_t TRGMUX_FTM1;                 /*!< (@ 0x0000002C) TRGMUX FTM1 Register                                       */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 2;
      __IOM uint32_t SEL1       : 6;            /*!< [13..8] Trigger MUX Input 1 Source Select                                 */
            uint32_t            : 2;
      __IOM uint32_t SEL2       : 6;            /*!< [21..16] Trigger MUX Input 2 Source Select                                */
            uint32_t            : 2;
      __IOM uint32_t SEL3       : 6;            /*!< [29..24] Trigger MUX Input 3 Source Select                                */
            uint32_t            : 1;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_FTM1_b;
  } ;
  __IM  uint32_t  RESERVED2[2];

  union {
    __IOM uint32_t TRGMUX_PDB0;                 /*!< (@ 0x00000038) TRGMUX PDB0 Register                                       */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 25;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_PDB0_b;
  } ;
  __IM  uint32_t  RESERVED3[2];

  union {
    __IOM uint32_t TRGMUX_FLEXIO;               /*!< (@ 0x00000044) TRGMUX FLEXIO Register                                     */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 2;
      __IOM uint32_t SEL1       : 6;            /*!< [13..8] Trigger MUX Input 1 Source Select                                 */
            uint32_t            : 2;
      __IOM uint32_t SEL2       : 6;            /*!< [21..16] Trigger MUX Input 2 Source Select                                */
            uint32_t            : 2;
      __IOM uint32_t SEL3       : 6;            /*!< [29..24] Trigger MUX Input 3 Source Select                                */
            uint32_t            : 1;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_FLEXIO_b;
  } ;

  union {
    __IOM uint32_t TRGMUX_LPIT0;                /*!< (@ 0x00000048) TRGMUX LPIT0 Register                                      */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 2;
      __IOM uint32_t SEL1       : 6;            /*!< [13..8] Trigger MUX Input 1 Source Select                                 */
            uint32_t            : 2;
      __IOM uint32_t SEL2       : 6;            /*!< [21..16] Trigger MUX Input 2 Source Select                                */
            uint32_t            : 2;
      __IOM uint32_t SEL3       : 6;            /*!< [29..24] Trigger MUX Input 3 Source Select                                */
            uint32_t            : 1;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_LPIT0_b;
  } ;

  union {
    __IOM uint32_t TRGMUX_LPUART0;              /*!< (@ 0x0000004C) TRGMUX LPUART0 Register                                    */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 25;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_LPUART0_b;
  } ;

  union {
    __IOM uint32_t TRGMUX_LPUART1;              /*!< (@ 0x00000050) TRGMUX LPUART1 Register                                    */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 25;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_LPUART1_b;
  } ;

  union {
    __IOM uint32_t TRGMUX_LPI2C0;               /*!< (@ 0x00000054) TRGMUX LPI2C0 Register                                     */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 25;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_LPI2C0_b;
  } ;
  __IM  uint32_t  RESERVED4;

  union {
    __IOM uint32_t TRGMUX_LPSPI0;               /*!< (@ 0x0000005C) TRGMUX LPSPI0 Register                                     */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 25;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_LPSPI0_b;
  } ;
  __IM  uint32_t  RESERVED5;

  union {
    __IOM uint32_t TRGMUX_LPTMR0;               /*!< (@ 0x00000064) TRGMUX LPTMR0 Register                                     */

    struct {
      __IOM uint32_t SEL0       : 6;            /*!< [5..0] Trigger MUX Input 0 Source Select                                  */
            uint32_t            : 25;
      __IOM uint32_t LK         : 1;            /*!< [31..31] TRGMUX register lock.                                            */
    } TRGMUX_LPTMR0_b;
  } ;
} TRGMUX_Type;                                  /*!< Size = 104 (0x68)                                                         */



/* =========================================================================================================================== */
/* ================                                            SCG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief System Clock Generator (SCG)
  */

typedef struct {                                /*!< (@ 0x40064000) SCG Structure                                              */

  union {
    __IM  uint32_t SCG_VERID;                   /*!< (@ 0x00000000) Version ID Register                                        */

    struct {
      __IM  uint32_t VERSION    : 32;           /*!< [31..0] SCG Version Number                                                */
    } SCG_VERID_b;
  } ;

  union {
    __IM  uint32_t SCG_PARAM;                   /*!< (@ 0x00000004) Parameter Register                                         */

    struct {
      __IM  uint32_t CLKPRES    : 8;            /*!< [7..0] Clock Present                                                      */
            uint32_t            : 19;
      __IM  uint32_t DIVPRES    : 5;            /*!< [31..27] Divider Present                                                  */
    } SCG_PARAM_b;
  } ;
  __IM  uint32_t  RESERVED[2];

  union {
    __IM  uint32_t SCG_CSR;                     /*!< (@ 0x00000010) Clock Status Register                                      */

    struct {
      __IM  uint32_t DIVSLOW    : 4;            /*!< [3..0] Slow Clock Divide Ratio                                            */
      __IM  uint32_t DIVBUS     : 4;            /*!< [7..4] Bus Clock Divide Ratio                                             */
            uint32_t            : 8;
      __IM  uint32_t DIVCORE    : 4;            /*!< [19..16] Core Clock Divide Ratio                                          */
            uint32_t            : 4;
      __IM  uint32_t SCS        : 4;            /*!< [27..24] System Clock Source                                              */
            uint32_t            : 4;
    } SCG_CSR_b;
  } ;

  union {
    __IOM uint32_t SCG_RCCR;                    /*!< (@ 0x00000014) Run Clock Control Register                                 */

    struct {
      __IOM uint32_t DIVSLOW    : 4;            /*!< [3..0] Slow Clock Divide Ratio                                            */
      __IOM uint32_t DIVBUS     : 4;            /*!< [7..4] Bus Clock Divide Ratio                                             */
            uint32_t            : 8;
      __IOM uint32_t DIVCORE    : 4;            /*!< [19..16] Core Clock Divide Ratio                                          */
            uint32_t            : 4;
      __IOM uint32_t SCS        : 4;            /*!< [27..24] System Clock Source                                              */
            uint32_t            : 4;
    } SCG_RCCR_b;
  } ;

  union {
    __IOM uint32_t SCG_VCCR;                    /*!< (@ 0x00000018) VLPR Clock Control Register                                */

    struct {
      __IOM uint32_t DIVSLOW    : 4;            /*!< [3..0] Slow Clock Divide Ratio                                            */
      __IOM uint32_t DIVBUS     : 4;            /*!< [7..4] Bus Clock Divide Ratio                                             */
            uint32_t            : 8;
      __IOM uint32_t DIVCORE    : 4;            /*!< [19..16] Core Clock Divide Ratio                                          */
            uint32_t            : 4;
      __IOM uint32_t SCS        : 4;            /*!< [27..24] System Clock Source                                              */
            uint32_t            : 4;
    } SCG_VCCR_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t SCG_CLKOUTCNFG;              /*!< (@ 0x00000020) SCG CLKOUT Configuration Register                          */

    struct {
            uint32_t            : 24;
      __IOM uint32_t CLKOUTSEL  : 4;            /*!< [27..24] SCG Clkout Select                                                */
            uint32_t            : 4;
    } SCG_CLKOUTCNFG_b;
  } ;
  __IM  uint32_t  RESERVED2[55];

  union {
    __IOM uint32_t SCG_SOSCCSR;                 /*!< (@ 0x00000100) System OSC Control Status Register                         */

    struct {
      __IOM uint32_t SOSCEN     : 1;            /*!< [0..0] System OSC Enable                                                  */
            uint32_t            : 15;
      __IOM uint32_t SOSCCM     : 1;            /*!< [16..16] System OSC Clock Monitor                                         */
      __IOM uint32_t SOSCCMRE   : 1;            /*!< [17..17] System OSC Clock Monitor Reset Enable                            */
            uint32_t            : 5;
      __IOM uint32_t LK         : 1;            /*!< [23..23] Lock Register                                                    */
      __IM  uint32_t SOSCVLD    : 1;            /*!< [24..24] System OSC Valid                                                 */
      __IM  uint32_t SOSCSEL    : 1;            /*!< [25..25] System OSC Selected                                              */
      __IOM uint32_t SOSCERR    : 1;            /*!< [26..26] System OSC Clock Error                                           */
            uint32_t            : 5;
    } SCG_SOSCCSR_b;
  } ;

  union {
    __IOM uint32_t SCG_SOSCDIV;                 /*!< (@ 0x00000104) System OSC Divide Register                                 */

    struct {
      __IOM uint32_t SOSCDIV1   : 3;            /*!< [2..0] System OSC Clock Divide 1                                          */
            uint32_t            : 5;
      __IOM uint32_t SOSCDIV2   : 3;            /*!< [10..8] System OSC Clock Divide 2                                         */
            uint32_t            : 21;
    } SCG_SOSCDIV_b;
  } ;

  union {
    __IOM uint32_t SCG_SOSCCFG;                 /*!< (@ 0x00000108) System Oscillator Configuration Register                   */

    struct {
            uint32_t            : 2;
      __IOM uint32_t EREFS      : 1;            /*!< [2..2] External Reference Select                                          */
      __IOM uint32_t HGO        : 1;            /*!< [3..3] High Gain Oscillator Select                                        */
      __IOM uint32_t RANGE      : 2;            /*!< [5..4] System OSC Range Select                                            */
            uint32_t            : 26;
    } SCG_SOSCCFG_b;
  } ;
  __IM  uint32_t  RESERVED3[61];

  union {
    __IOM uint32_t SCG_SIRCCSR;                 /*!< (@ 0x00000200) Slow IRC Control Status Register                           */

    struct {
      __IOM uint32_t SIRCEN     : 1;            /*!< [0..0] Slow IRC Enable                                                    */
      __IOM uint32_t SIRCSTEN   : 1;            /*!< [1..1] Slow IRC Stop Enable                                               */
      __IOM uint32_t SIRCLPEN   : 1;            /*!< [2..2] Slow IRC Low Power Enable                                          */
            uint32_t            : 20;
      __IOM uint32_t LK         : 1;            /*!< [23..23] Lock Register                                                    */
      __IM  uint32_t SIRCVLD    : 1;            /*!< [24..24] Slow IRC Valid                                                   */
      __IM  uint32_t SIRCSEL    : 1;            /*!< [25..25] Slow IRC Selected                                                */
            uint32_t            : 6;
    } SCG_SIRCCSR_b;
  } ;

  union {
    __IOM uint32_t SCG_SIRCDIV;                 /*!< (@ 0x00000204) Slow IRC Divide Register                                   */

    struct {
      __IOM uint32_t SIRCDIV1   : 3;            /*!< [2..0] Slow IRC Clock Divide 1                                            */
            uint32_t            : 5;
      __IOM uint32_t SIRCDIV2   : 3;            /*!< [10..8] Slow IRC Clock Divide 2                                           */
            uint32_t            : 21;
    } SCG_SIRCDIV_b;
  } ;

  union {
    __IOM uint32_t SCG_SIRCCFG;                 /*!< (@ 0x00000208) Slow IRC Configuration Register                            */

    struct {
      __IOM uint32_t RANGE      : 1;            /*!< [0..0] Frequency Range                                                    */
            uint32_t            : 31;
    } SCG_SIRCCFG_b;
  } ;
  __IM  uint32_t  RESERVED4[61];

  union {
    __IOM uint32_t SCG_FIRCCSR;                 /*!< (@ 0x00000300) Fast IRC Control Status Register                           */

    struct {
      __IOM uint32_t FIRCEN     : 1;            /*!< [0..0] Fast IRC Enable                                                    */
            uint32_t            : 2;
      __IOM uint32_t FIRCREGOFF : 1;            /*!< [3..3] Fast IRC Regulator Enable                                          */
            uint32_t            : 19;
      __IOM uint32_t LK         : 1;            /*!< [23..23] Lock Register                                                    */
      __IM  uint32_t FIRCVLD    : 1;            /*!< [24..24] Fast IRC Valid status                                            */
      __IM  uint32_t FIRCSEL    : 1;            /*!< [25..25] Fast IRC Selected status                                         */
      __IOM uint32_t FIRCERR    : 1;            /*!< [26..26] Fast IRC Clock Error                                             */
            uint32_t            : 5;
    } SCG_FIRCCSR_b;
  } ;

  union {
    __IOM uint32_t SCG_FIRCDIV;                 /*!< (@ 0x00000304) Fast IRC Divide Register                                   */

    struct {
      __IOM uint32_t FIRCDIV1   : 3;            /*!< [2..0] Fast IRC Clock Divide 1                                            */
            uint32_t            : 5;
      __IOM uint32_t FIRCDIV2   : 3;            /*!< [10..8] Fast IRC Clock Divide 2                                           */
            uint32_t            : 21;
    } SCG_FIRCDIV_b;
  } ;

  union {
    __IOM uint32_t SCG_FIRCCFG;                 /*!< (@ 0x00000308) Fast IRC Configuration Register                            */

    struct {
      __IOM uint32_t RANGE      : 2;            /*!< [1..0] Frequency Range                                                    */
            uint32_t            : 30;
    } SCG_FIRCCFG_b;
  } ;
} SCG_Type;                                     /*!< Size = 780 (0x30c)                                                        */



/* =========================================================================================================================== */
/* ================                                            PCC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PCC (PCC)
  */

typedef struct {                                /*!< (@ 0x40065000) PCC Structure                                              */
  __IM  uint32_t  RESERVED[32];

  union {
    __IOM uint32_t PCC_FTFC;                    /*!< (@ 0x00000080) PCC FTFC Register                                          */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_FTFC_b;
  } ;

  union {
    __IOM uint32_t PCC_DMAMUX;                  /*!< (@ 0x00000084) PCC DMAMUX Register                                        */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_DMAMUX_b;
  } ;
  __IM  uint32_t  RESERVED1[2];

  union {
    __IOM uint32_t PCC_FlexCAN0;                /*!< (@ 0x00000090) PCC FlexCAN0 Register                                      */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_FlexCAN0_b;
  } ;
  __IM  uint32_t  RESERVED2[7];

  union {
    __IOM uint32_t PCC_LPSPI0;                  /*!< (@ 0x000000B0) PCC LPSPI0 Register                                        */

    struct {
            uint32_t            : 24;
      __IOM uint32_t PCS        : 3;            /*!< [26..24] Peripheral Clock Source Select                                   */
            uint32_t            : 3;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_LPSPI0_b;
  } ;
  __IM  uint32_t  RESERVED3[5];

  union {
    __IOM uint32_t PCC_CRC;                     /*!< (@ 0x000000C8) PCC CRC Register                                           */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_CRC_b;
  } ;
  __IM  uint32_t  RESERVED4[3];

  union {
    __IOM uint32_t PCC_PDB0;                    /*!< (@ 0x000000D8) PCC PDB0 Register                                          */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_PDB0_b;
  } ;

  union {
    __IOM uint32_t PCC_LPIT;                    /*!< (@ 0x000000DC) PCC LPIT Register                                          */

    struct {
            uint32_t            : 24;
      __IOM uint32_t PCS        : 3;            /*!< [26..24] Peripheral Clock Source Select                                   */
            uint32_t            : 3;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_LPIT_b;
  } ;

  union {
    __IOM uint32_t PCC_FTM0;                    /*!< (@ 0x000000E0) PCC FTM0 Register                                          */

    struct {
            uint32_t            : 24;
      __IOM uint32_t PCS        : 3;            /*!< [26..24] Peripheral Clock Source Select                                   */
            uint32_t            : 3;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_FTM0_b;
  } ;

  union {
    __IOM uint32_t PCC_FTM1;                    /*!< (@ 0x000000E4) PCC FTM1 Register                                          */

    struct {
            uint32_t            : 24;
      __IOM uint32_t PCS        : 3;            /*!< [26..24] Peripheral Clock Source Select                                   */
            uint32_t            : 3;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_FTM1_b;
  } ;
  __IM  uint32_t  RESERVED5;

  union {
    __IOM uint32_t PCC_ADC0;                    /*!< (@ 0x000000EC) PCC ADC0 Register                                          */

    struct {
            uint32_t            : 24;
      __IOM uint32_t PCS        : 3;            /*!< [26..24] Peripheral Clock Source Select                                   */
            uint32_t            : 3;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_ADC0_b;
  } ;
  __IM  uint32_t  RESERVED6;

  union {
    __IOM uint32_t PCC_RTC;                     /*!< (@ 0x000000F4) PCC RTC Register                                           */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_RTC_b;
  } ;

  union {
    __IOM uint32_t PCC_CMU0;                    /*!< (@ 0x000000F8) PCC CMU0 Register                                          */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_CMU0_b;
  } ;

  union {
    __IOM uint32_t PCC_CMU1;                    /*!< (@ 0x000000FC) PCC CMU1 Register                                          */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_CMU1_b;
  } ;

  union {
    __IOM uint32_t PCC_LPTMR0;                  /*!< (@ 0x00000100) PCC LPTMR0 Register                                        */

    struct {
      __IOM uint32_t PCD        : 4;            /*!< [3..0] Peripheral Clock Divider Select                                    */
      __IOM uint32_t FRAC       : 1;            /*!< [4..4] Peripheral Clock Divider Fraction                                  */
            uint32_t            : 19;
      __IOM uint32_t PCS        : 3;            /*!< [26..24] Peripheral Clock Source Select                                   */
            uint32_t            : 3;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_LPTMR0_b;
  } ;
  __IM  uint32_t  RESERVED7[8];

  union {
    __IOM uint32_t PCC_PORTA;                   /*!< (@ 0x00000124) PCC PORTA Register                                         */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_PORTA_b;
  } ;

  union {
    __IOM uint32_t PCC_PORTB;                   /*!< (@ 0x00000128) PCC PORTB Register                                         */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_PORTB_b;
  } ;

  union {
    __IOM uint32_t PCC_PORTC;                   /*!< (@ 0x0000012C) PCC PORTC Register                                         */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_PORTC_b;
  } ;

  union {
    __IOM uint32_t PCC_PORTD;                   /*!< (@ 0x00000130) PCC PORTD Register                                         */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_PORTD_b;
  } ;

  union {
    __IOM uint32_t PCC_PORTE;                   /*!< (@ 0x00000134) PCC PORTE Register                                         */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_PORTE_b;
  } ;
  __IM  uint32_t  RESERVED8[12];

  union {
    __IOM uint32_t PCC_FlexIO;                  /*!< (@ 0x00000168) PCC FlexIO Register                                        */

    struct {
            uint32_t            : 24;
      __IOM uint32_t PCS        : 3;            /*!< [26..24] Peripheral Clock Source Select                                   */
            uint32_t            : 3;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_FlexIO_b;
  } ;
  __IM  uint32_t  RESERVED9[11];

  union {
    __IOM uint32_t PCC_LPI2C0;                  /*!< (@ 0x00000198) PCC LPI2C0 Register                                        */

    struct {
            uint32_t            : 24;
      __IOM uint32_t PCS        : 3;            /*!< [26..24] Peripheral Clock Source Select                                   */
            uint32_t            : 3;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_LPI2C0_b;
  } ;
  __IM  uint32_t  RESERVED10[3];

  union {
    __IOM uint32_t PCC_LPUART0;                 /*!< (@ 0x000001A8) PCC LPUART0 Register                                       */

    struct {
            uint32_t            : 24;
      __IOM uint32_t PCS        : 3;            /*!< [26..24] Peripheral Clock Source Select                                   */
            uint32_t            : 3;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_LPUART0_b;
  } ;

  union {
    __IOM uint32_t PCC_LPUART1;                 /*!< (@ 0x000001AC) PCC LPUART1 Register                                       */

    struct {
            uint32_t            : 24;
      __IOM uint32_t PCS        : 3;            /*!< [26..24] Peripheral Clock Source Select                                   */
            uint32_t            : 3;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_LPUART1_b;
  } ;
  __IM  uint32_t  RESERVED11[7];

  union {
    __IOM uint32_t PCC_CMP0;                    /*!< (@ 0x000001CC) PCC CMP0 Register                                          */

    struct {
            uint32_t            : 30;
      __IOM uint32_t CGC        : 1;            /*!< [30..30] Clock Gate Control                                               */
      __IM  uint32_t PR         : 1;            /*!< [31..31] Present                                                          */
    } PCC_CMP0_b;
  } ;
} PCC_Type;                                     /*!< Size = 464 (0x1d0)                                                        */



/* =========================================================================================================================== */
/* ================                                          LPI2C0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief The LPI2C Memory Map/Register Definition can be found here. (LPI2C0)
  */

typedef struct {                                /*!< (@ 0x40066000) LPI2C0 Structure                                           */

  union {
    __IM  uint32_t LPI2C0_VERID;                /*!< (@ 0x00000000) Version ID Register                                        */

    struct {
      __IM  uint32_t FEATURE    : 16;           /*!< [15..0] Feature Specification Number                                      */
      __IM  uint32_t MINOR      : 8;            /*!< [23..16] Minor Version Number                                             */
      __IM  uint32_t MAJOR      : 8;            /*!< [31..24] Major Version Number                                             */
    } LPI2C0_VERID_b;
  } ;

  union {
    __IM  uint32_t LPI2C0_PARAM;                /*!< (@ 0x00000004) Parameter Register                                         */

    struct {
      __IM  uint32_t MTXFIFO    : 4;            /*!< [3..0] Master Transmit FIFO Size                                          */
            uint32_t            : 4;
      __IM  uint32_t MRXFIFO    : 4;            /*!< [11..8] Master Receive FIFO Size                                          */
            uint32_t            : 20;
    } LPI2C0_PARAM_b;
  } ;
  __IM  uint32_t  RESERVED[2];

  union {
    __IOM uint32_t LPI2C0_MCR;                  /*!< (@ 0x00000010) Master Control Register                                    */

    struct {
      __IOM uint32_t MEN        : 1;            /*!< [0..0] Master Enable                                                      */
      __IOM uint32_t RST        : 1;            /*!< [1..1] Software Reset                                                     */
      __IOM uint32_t DOZEN      : 1;            /*!< [2..2] Doze mode enable                                                   */
      __IOM uint32_t DBGEN      : 1;            /*!< [3..3] Debug Enable                                                       */
            uint32_t            : 4;
      __OM  uint32_t RTF        : 1;            /*!< [8..8] Reset Transmit FIFO                                                */
      __OM  uint32_t RRF        : 1;            /*!< [9..9] Reset Receive FIFO                                                 */
            uint32_t            : 22;
    } LPI2C0_MCR_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_MSR;                  /*!< (@ 0x00000014) Master Status Register                                     */

    struct {
      __IM  uint32_t TDF        : 1;            /*!< [0..0] Transmit Data Flag                                                 */
      __IM  uint32_t RDF        : 1;            /*!< [1..1] Receive Data Flag                                                  */
            uint32_t            : 6;
      __IOM uint32_t EPF        : 1;            /*!< [8..8] End Packet Flag                                                    */
      __IOM uint32_t SDF        : 1;            /*!< [9..9] STOP Detect Flag                                                   */
      __IOM uint32_t NDF        : 1;            /*!< [10..10] NACK Detect Flag                                                 */
      __IOM uint32_t ALF        : 1;            /*!< [11..11] Arbitration Lost Flag                                            */
      __IOM uint32_t FEF        : 1;            /*!< [12..12] FIFO Error Flag                                                  */
      __IOM uint32_t PLTF       : 1;            /*!< [13..13] Pin Low Timeout Flag                                             */
      __IOM uint32_t DMF        : 1;            /*!< [14..14] Data Match Flag                                                  */
            uint32_t            : 9;
      __IM  uint32_t MBF        : 1;            /*!< [24..24] Master Busy Flag                                                 */
      __IM  uint32_t BBF        : 1;            /*!< [25..25] Bus Busy Flag                                                    */
            uint32_t            : 6;
    } LPI2C0_MSR_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_MIER;                 /*!< (@ 0x00000018) Master Interrupt Enable Register                           */

    struct {
      __IOM uint32_t TDIE       : 1;            /*!< [0..0] Transmit Data Interrupt Enable                                     */
      __IOM uint32_t RDIE       : 1;            /*!< [1..1] Receive Data Interrupt Enable                                      */
            uint32_t            : 6;
      __IOM uint32_t EPIE       : 1;            /*!< [8..8] End Packet Interrupt Enable                                        */
      __IOM uint32_t SDIE       : 1;            /*!< [9..9] STOP Detect Interrupt Enable                                       */
      __IOM uint32_t NDIE       : 1;            /*!< [10..10] NACK Detect Interrupt Enable                                     */
      __IOM uint32_t ALIE       : 1;            /*!< [11..11] Arbitration Lost Interrupt Enable                                */
      __IOM uint32_t FEIE       : 1;            /*!< [12..12] FIFO Error Interrupt Enable                                      */
      __IOM uint32_t PLTIE      : 1;            /*!< [13..13] Pin Low Timeout Interrupt Enable                                 */
      __IOM uint32_t DMIE       : 1;            /*!< [14..14] Data Match Interrupt Enable                                      */
            uint32_t            : 17;
    } LPI2C0_MIER_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_MDER;                 /*!< (@ 0x0000001C) Master DMA Enable Register                                 */

    struct {
      __IOM uint32_t TDDE       : 1;            /*!< [0..0] Transmit Data DMA Enable                                           */
      __IOM uint32_t RDDE       : 1;            /*!< [1..1] Receive Data DMA Enable                                            */
            uint32_t            : 30;
    } LPI2C0_MDER_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_MCFGR0;               /*!< (@ 0x00000020) Master Configuration Register 0                            */

    struct {
      __IOM uint32_t HREN       : 1;            /*!< [0..0] Host Request Enable                                                */
      __IOM uint32_t HRPOL      : 1;            /*!< [1..1] Host Request Polarity                                              */
      __IOM uint32_t HRSEL      : 1;            /*!< [2..2] Host Request Select                                                */
            uint32_t            : 5;
      __IOM uint32_t CIRFIFO    : 1;            /*!< [8..8] Circular FIFO Enable                                               */
      __IOM uint32_t RDMO       : 1;            /*!< [9..9] Receive Data Match Only                                            */
            uint32_t            : 22;
    } LPI2C0_MCFGR0_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_MCFGR1;               /*!< (@ 0x00000024) Master Configuration Register 1                            */

    struct {
      __IOM uint32_t PRESCALE   : 3;            /*!< [2..0] Prescaler                                                          */
            uint32_t            : 5;
      __IOM uint32_t AUTOSTOP   : 1;            /*!< [8..8] Automatic STOP Generation                                          */
      __IOM uint32_t IGNACK     : 1;            /*!< [9..9] IGNACK                                                             */
      __IOM uint32_t TIMECFG    : 1;            /*!< [10..10] Timeout Configuration                                            */
            uint32_t            : 5;
      __IOM uint32_t MATCFG     : 3;            /*!< [18..16] Match Configuration                                              */
            uint32_t            : 5;
      __IOM uint32_t PINCFG     : 3;            /*!< [26..24] Pin Configuration                                                */
            uint32_t            : 5;
    } LPI2C0_MCFGR1_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_MCFGR2;               /*!< (@ 0x00000028) Master Configuration Register 2                            */

    struct {
      __IOM uint32_t BUSIDLE    : 12;           /*!< [11..0] Bus Idle Timeout                                                  */
            uint32_t            : 4;
      __IOM uint32_t FILTSCL    : 4;            /*!< [19..16] Glitch Filter SCL                                                */
            uint32_t            : 4;
      __IOM uint32_t FILTSDA    : 4;            /*!< [27..24] Glitch Filter SDA                                                */
            uint32_t            : 4;
    } LPI2C0_MCFGR2_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_MCFGR3;               /*!< (@ 0x0000002C) Master Configuration Register 3                            */

    struct {
            uint32_t            : 8;
      __IOM uint32_t PINLOW     : 12;           /*!< [19..8] Pin Low Timeout                                                   */
            uint32_t            : 12;
    } LPI2C0_MCFGR3_b;
  } ;
  __IM  uint32_t  RESERVED1[4];

  union {
    __IOM uint32_t LPI2C0_MDMR;                 /*!< (@ 0x00000040) Master Data Match Register                                 */

    struct {
      __IOM uint32_t MATCH0     : 8;            /*!< [7..0] Match 0 Value                                                      */
            uint32_t            : 8;
      __IOM uint32_t MATCH1     : 8;            /*!< [23..16] Match 1 Value                                                    */
            uint32_t            : 8;
    } LPI2C0_MDMR_b;
  } ;
  __IM  uint32_t  RESERVED2;

  union {
    __IOM uint32_t LPI2C0_MCCR0;                /*!< (@ 0x00000048) Master Clock Configuration Register 0                      */

    struct {
      __IOM uint32_t CLKLO      : 6;            /*!< [5..0] Clock Low Period                                                   */
            uint32_t            : 2;
      __IOM uint32_t CLKHI      : 6;            /*!< [13..8] Clock High Period                                                 */
            uint32_t            : 2;
      __IOM uint32_t SETHOLD    : 6;            /*!< [21..16] Setup Hold Delay                                                 */
            uint32_t            : 2;
      __IOM uint32_t DATAVD     : 6;            /*!< [29..24] Data Valid Delay                                                 */
            uint32_t            : 2;
    } LPI2C0_MCCR0_b;
  } ;
  __IM  uint32_t  RESERVED3;

  union {
    __IOM uint32_t LPI2C0_MCCR1;                /*!< (@ 0x00000050) Master Clock Configuration Register 1                      */

    struct {
      __IOM uint32_t CLKLO      : 6;            /*!< [5..0] Clock Low Period                                                   */
            uint32_t            : 2;
      __IOM uint32_t CLKHI      : 6;            /*!< [13..8] Clock High Period                                                 */
            uint32_t            : 2;
      __IOM uint32_t SETHOLD    : 6;            /*!< [21..16] Setup Hold Delay                                                 */
            uint32_t            : 2;
      __IOM uint32_t DATAVD     : 6;            /*!< [29..24] Data Valid Delay                                                 */
            uint32_t            : 2;
    } LPI2C0_MCCR1_b;
  } ;
  __IM  uint32_t  RESERVED4;

  union {
    __IOM uint32_t LPI2C0_MFCR;                 /*!< (@ 0x00000058) Master FIFO Control Register                               */

    struct {
      __IOM uint32_t TXWATER    : 2;            /*!< [1..0] Transmit FIFO Watermark                                            */
            uint32_t            : 14;
      __IOM uint32_t RXWATER    : 2;            /*!< [17..16] Receive FIFO Watermark                                           */
            uint32_t            : 14;
    } LPI2C0_MFCR_b;
  } ;

  union {
    __IM  uint32_t LPI2C0_MFSR;                 /*!< (@ 0x0000005C) Master FIFO Status Register                                */

    struct {
      __IM  uint32_t TXCOUNT    : 3;            /*!< [2..0] Transmit FIFO Count                                                */
            uint32_t            : 13;
      __IM  uint32_t RXCOUNT    : 3;            /*!< [18..16] Receive FIFO Count                                               */
            uint32_t            : 13;
    } LPI2C0_MFSR_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_MTDR;                 /*!< (@ 0x00000060) Master Transmit Data Register                              */

    struct {
      __OM  uint32_t DATA       : 8;            /*!< [7..0] Transmit Data                                                      */
      __OM  uint32_t CMD        : 3;            /*!< [10..8] Command Data                                                      */
            uint32_t            : 21;
    } LPI2C0_MTDR_b;
  } ;
  __IM  uint32_t  RESERVED5[3];

  union {
    __IM  uint32_t LPI2C0_MRDR;                 /*!< (@ 0x00000070) Master Receive Data Register                               */

    struct {
      __IM  uint32_t DATA       : 8;            /*!< [7..0] Receive Data                                                       */
            uint32_t            : 6;
      __IM  uint32_t RXEMPTY    : 1;            /*!< [14..14] RX Empty                                                         */
            uint32_t            : 17;
    } LPI2C0_MRDR_b;
  } ;
  __IM  uint32_t  RESERVED6[39];

  union {
    __IOM uint32_t LPI2C0_SCR;                  /*!< (@ 0x00000110) Slave Control Register                                     */

    struct {
      __IOM uint32_t SEN        : 1;            /*!< [0..0] Slave Enable                                                       */
      __IOM uint32_t RST        : 1;            /*!< [1..1] Software Reset                                                     */
            uint32_t            : 2;
      __IOM uint32_t FILTEN     : 1;            /*!< [4..4] Filter Enable                                                      */
      __IOM uint32_t FILTDZ     : 1;            /*!< [5..5] Filter Doze Enable                                                 */
            uint32_t            : 2;
      __OM  uint32_t RTF        : 1;            /*!< [8..8] Reset Transmit FIFO                                                */
      __OM  uint32_t RRF        : 1;            /*!< [9..9] Reset Receive FIFO                                                 */
            uint32_t            : 22;
    } LPI2C0_SCR_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_SSR;                  /*!< (@ 0x00000114) Slave Status Register                                      */

    struct {
      __IM  uint32_t TDF        : 1;            /*!< [0..0] Transmit Data Flag                                                 */
      __IM  uint32_t RDF        : 1;            /*!< [1..1] Receive Data Flag                                                  */
      __IM  uint32_t AVF        : 1;            /*!< [2..2] Address Valid Flag                                                 */
      __IM  uint32_t TAF        : 1;            /*!< [3..3] Transmit ACK Flag                                                  */
            uint32_t            : 4;
      __IOM uint32_t RSF        : 1;            /*!< [8..8] Repeated Start Flag                                                */
      __IOM uint32_t SDF        : 1;            /*!< [9..9] STOP Detect Flag                                                   */
      __IOM uint32_t BEF        : 1;            /*!< [10..10] Bit Error Flag                                                   */
      __IOM uint32_t FEF        : 1;            /*!< [11..11] FIFO Error Flag                                                  */
      __IM  uint32_t AM0F       : 1;            /*!< [12..12] Address Match 0 Flag                                             */
      __IM  uint32_t AM1F       : 1;            /*!< [13..13] Address Match 1 Flag                                             */
      __IM  uint32_t GCF        : 1;            /*!< [14..14] General Call Flag                                                */
      __IM  uint32_t SARF       : 1;            /*!< [15..15] SMBus Alert Response Flag                                        */
            uint32_t            : 8;
      __IM  uint32_t SBF        : 1;            /*!< [24..24] Slave Busy Flag                                                  */
      __IM  uint32_t BBF        : 1;            /*!< [25..25] Bus Busy Flag                                                    */
            uint32_t            : 6;
    } LPI2C0_SSR_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_SIER;                 /*!< (@ 0x00000118) Slave Interrupt Enable Register                            */

    struct {
      __IOM uint32_t TDIE       : 1;            /*!< [0..0] Transmit Data Interrupt Enable                                     */
      __IOM uint32_t RDIE       : 1;            /*!< [1..1] Receive Data Interrupt Enable                                      */
      __IOM uint32_t AVIE       : 1;            /*!< [2..2] Address Valid Interrupt Enable                                     */
      __IOM uint32_t TAIE       : 1;            /*!< [3..3] Transmit ACK Interrupt Enable                                      */
            uint32_t            : 4;
      __IOM uint32_t RSIE       : 1;            /*!< [8..8] Repeated Start Interrupt Enable                                    */
      __IOM uint32_t SDIE       : 1;            /*!< [9..9] STOP Detect Interrupt Enable                                       */
      __IOM uint32_t BEIE       : 1;            /*!< [10..10] Bit Error Interrupt Enable                                       */
      __IOM uint32_t FEIE       : 1;            /*!< [11..11] FIFO Error Interrupt Enable                                      */
      __IOM uint32_t AM0IE      : 1;            /*!< [12..12] Address Match 0 Interrupt Enable                                 */
      __IOM uint32_t AM1F       : 1;            /*!< [13..13] Address Match 1 Interrupt Enable                                 */
      __IOM uint32_t GCIE       : 1;            /*!< [14..14] General Call Interrupt Enable                                    */
      __IOM uint32_t SARIE      : 1;            /*!< [15..15] SMBus Alert Response Interrupt Enable                            */
            uint32_t            : 16;
    } LPI2C0_SIER_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_SDER;                 /*!< (@ 0x0000011C) Slave DMA Enable Register                                  */

    struct {
      __IOM uint32_t TDDE       : 1;            /*!< [0..0] Transmit Data DMA Enable                                           */
      __IOM uint32_t RDDE       : 1;            /*!< [1..1] Receive Data DMA Enable                                            */
      __IOM uint32_t AVDE       : 1;            /*!< [2..2] Address Valid DMA Enable                                           */
            uint32_t            : 29;
    } LPI2C0_SDER_b;
  } ;
  __IM  uint32_t  RESERVED7;

  union {
    __IOM uint32_t LPI2C0_SCFGR1;               /*!< (@ 0x00000124) Slave Configuration Register 1                             */

    struct {
      __IOM uint32_t ADRSTALL   : 1;            /*!< [0..0] Address SCL Stall                                                  */
      __IOM uint32_t RXSTALL    : 1;            /*!< [1..1] RX SCL Stall                                                       */
      __IOM uint32_t TXDSTALL   : 1;            /*!< [2..2] TX Data SCL Stall                                                  */
      __IOM uint32_t ACKSTALL   : 1;            /*!< [3..3] ACK SCL Stall                                                      */
            uint32_t            : 4;
      __IOM uint32_t GCEN       : 1;            /*!< [8..8] General Call Enable                                                */
      __IOM uint32_t SAEN       : 1;            /*!< [9..9] SMBus Alert Enable                                                 */
      __IOM uint32_t TXCFG      : 1;            /*!< [10..10] Transmit Flag Configuration                                      */
      __IOM uint32_t RXCFG      : 1;            /*!< [11..11] Receive Data Configuration                                       */
      __IOM uint32_t IGNACK     : 1;            /*!< [12..12] Ignore NACK                                                      */
      __IOM uint32_t HSMEN      : 1;            /*!< [13..13] High Speed Mode Enable                                           */
            uint32_t            : 2;
      __IOM uint32_t ADDRCFG    : 3;            /*!< [18..16] Address Configuration                                            */
            uint32_t            : 13;
    } LPI2C0_SCFGR1_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_SCFGR2;               /*!< (@ 0x00000128) Slave Configuration Register 2                             */

    struct {
      __IOM uint32_t CLKHOLD    : 4;            /*!< [3..0] Clock Hold Time                                                    */
            uint32_t            : 4;
      __IOM uint32_t DATAVD     : 6;            /*!< [13..8] Data Valid Delay                                                  */
            uint32_t            : 2;
      __IOM uint32_t FILTSCL    : 4;            /*!< [19..16] Glitch Filter SCL                                                */
            uint32_t            : 4;
      __IOM uint32_t FILTSDA    : 4;            /*!< [27..24] Glitch Filter SDA                                                */
            uint32_t            : 4;
    } LPI2C0_SCFGR2_b;
  } ;
  __IM  uint32_t  RESERVED8[5];

  union {
    __IOM uint32_t LPI2C0_SAMR;                 /*!< (@ 0x00000140) Slave Address Match Register                               */

    struct {
            uint32_t            : 1;
      __IOM uint32_t ADDR0      : 10;           /*!< [10..1] Address 0 Value                                                   */
            uint32_t            : 6;
      __IOM uint32_t ADDR1      : 10;           /*!< [26..17] Address 1 Value                                                  */
            uint32_t            : 5;
    } LPI2C0_SAMR_b;
  } ;
  __IM  uint32_t  RESERVED9[3];

  union {
    __IM  uint32_t LPI2C0_SASR;                 /*!< (@ 0x00000150) Slave Address Status Register                              */

    struct {
      __IM  uint32_t RADDR      : 11;           /*!< [10..0] Received Address                                                  */
            uint32_t            : 3;
      __IM  uint32_t ANV        : 1;            /*!< [14..14] Address Not Valid                                                */
            uint32_t            : 17;
    } LPI2C0_SASR_b;
  } ;

  union {
    __IOM uint32_t LPI2C0_STAR;                 /*!< (@ 0x00000154) Slave Transmit ACK Register                                */

    struct {
      __IOM uint32_t TXNACK     : 1;            /*!< [0..0] Transmit NACK                                                      */
            uint32_t            : 31;
    } LPI2C0_STAR_b;
  } ;
  __IM  uint32_t  RESERVED10[2];

  union {
    __IOM uint32_t LPI2C0_STDR;                 /*!< (@ 0x00000160) Slave Transmit Data Register                               */

    struct {
      __OM  uint32_t DATA       : 8;            /*!< [7..0] Transmit Data                                                      */
            uint32_t            : 24;
    } LPI2C0_STDR_b;
  } ;
  __IM  uint32_t  RESERVED11[3];

  union {
    __IM  uint32_t LPI2C0_SRDR;                 /*!< (@ 0x00000170) Slave Receive Data Register                                */

    struct {
      __IM  uint32_t DATA       : 8;            /*!< [7..0] Receive Data                                                       */
            uint32_t            : 6;
      __IM  uint32_t RXEMPTY    : 1;            /*!< [14..14] RX Empty                                                         */
      __IM  uint32_t SOF        : 1;            /*!< [15..15] Start Of Frame                                                   */
            uint32_t            : 16;
    } LPI2C0_SRDR_b;
  } ;
} LPI2C0_Type;                                  /*!< Size = 372 (0x174)                                                        */



/* =========================================================================================================================== */
/* ================                                          LPUART0                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal Asynchronous Receiver/Transmitter (LPUART0)
  */

typedef struct {                                /*!< (@ 0x4006A000) LPUART0 Structure                                          */

  union {
    __IM  uint32_t LPUART0_VERID;               /*!< (@ 0x00000000) Version ID Register                                        */

    struct {
      __IM  uint32_t FEATURE    : 16;           /*!< [15..0] Feature Identification Number                                     */
      __IM  uint32_t MINOR      : 8;            /*!< [23..16] Minor Version Number                                             */
      __IM  uint32_t MAJOR      : 8;            /*!< [31..24] Major Version Number                                             */
    } LPUART0_VERID_b;
  } ;

  union {
    __IM  uint32_t LPUART0_PARAM;               /*!< (@ 0x00000004) Parameter Register                                         */

    struct {
      __IM  uint32_t TXFIFO     : 8;            /*!< [7..0] Transmit FIFO Size                                                 */
      __IM  uint32_t RXFIFO     : 8;            /*!< [15..8] Receive FIFO Size                                                 */
            uint32_t            : 16;
    } LPUART0_PARAM_b;
  } ;

  union {
    __IOM uint32_t LPUART0_GLOBAL;              /*!< (@ 0x00000008) LPUART Global Register                                     */

    struct {
            uint32_t            : 1;
      __IOM uint32_t RST        : 1;            /*!< [1..1] Software Reset                                                     */
            uint32_t            : 30;
    } LPUART0_GLOBAL_b;
  } ;

  union {
    __IOM uint32_t LPUART0_PINCFG;              /*!< (@ 0x0000000C) LPUART Pin Configuration Register                          */

    struct {
      __IOM uint32_t TRGSEL     : 2;            /*!< [1..0] Trigger Select                                                     */
            uint32_t            : 30;
    } LPUART0_PINCFG_b;
  } ;

  union {
    __IOM uint32_t LPUART0_BAUD;                /*!< (@ 0x00000010) LPUART Baud Rate Register                                  */

    struct {
      __IOM uint32_t SBR        : 13;           /*!< [12..0] Baud Rate Modulo Divisor.                                         */
      __IOM uint32_t SBNS       : 1;            /*!< [13..13] Stop Bit Number Select                                           */
      __IOM uint32_t RXEDGIE    : 1;            /*!< [14..14] RX Input Active Edge Interrupt Enable                            */
      __IOM uint32_t LBKDIE     : 1;            /*!< [15..15] LIN Break Detect Interrupt Enable                                */
      __IOM uint32_t RESYNCDIS  : 1;            /*!< [16..16] Resynchronization Disable                                        */
      __IOM uint32_t BOTHEDGE   : 1;            /*!< [17..17] Both Edge Sampling                                               */
      __IOM uint32_t MATCFG     : 2;            /*!< [19..18] Match Configuration                                              */
      __IOM uint32_t RIDMAE     : 1;            /*!< [20..20] Receiver Idle DMA Enable                                         */
      __IOM uint32_t RDMAE      : 1;            /*!< [21..21] Receiver Full DMA Enable                                         */
            uint32_t            : 1;
      __IOM uint32_t TDMAE      : 1;            /*!< [23..23] Transmitter DMA Enable                                           */
      __IOM uint32_t OSR        : 5;            /*!< [28..24] Oversampling Ratio                                               */
      __IOM uint32_t M10        : 1;            /*!< [29..29] 10-bit Mode select                                               */
      __IOM uint32_t MAEN2      : 1;            /*!< [30..30] Match Address Mode Enable 2                                      */
      __IOM uint32_t MAEN1      : 1;            /*!< [31..31] Match Address Mode Enable 1                                      */
    } LPUART0_BAUD_b;
  } ;

  union {
    __IOM uint32_t LPUART0_STAT;                /*!< (@ 0x00000014) LPUART Status Register                                     */

    struct {
            uint32_t            : 14;
      __IOM uint32_t MA2F       : 1;            /*!< [14..14] Match 2 Flag                                                     */
      __IOM uint32_t MA1F       : 1;            /*!< [15..15] Match 1 Flag                                                     */
      __IOM uint32_t PF         : 1;            /*!< [16..16] Parity Error Flag                                                */
      __IOM uint32_t FE         : 1;            /*!< [17..17] Framing Error Flag                                               */
      __IOM uint32_t NF         : 1;            /*!< [18..18] Noise Flag                                                       */
      __IOM uint32_t OR         : 1;            /*!< [19..19] Receiver Overrun Flag                                            */
      __IOM uint32_t IDLE       : 1;            /*!< [20..20] Idle Line Flag                                                   */
      __IM  uint32_t RDRF       : 1;            /*!< [21..21] Receive Data Register Full Flag                                  */
      __IM  uint32_t TC         : 1;            /*!< [22..22] Transmission Complete Flag                                       */
      __IM  uint32_t TDRE       : 1;            /*!< [23..23] Transmit Data Register Empty Flag                                */
      __IM  uint32_t RAF        : 1;            /*!< [24..24] Receiver Active Flag                                             */
      __IOM uint32_t LBKDE      : 1;            /*!< [25..25] LIN Break Detection Enable                                       */
      __IOM uint32_t BRK13      : 1;            /*!< [26..26] Break Character Generation Length                                */
      __IOM uint32_t RWUID      : 1;            /*!< [27..27] Receive Wake Up Idle Detect                                      */
      __IOM uint32_t RXINV      : 1;            /*!< [28..28] Receive Data Inversion                                           */
      __IOM uint32_t MSBF       : 1;            /*!< [29..29] MSB First                                                        */
      __IOM uint32_t RXEDGIF    : 1;            /*!< [30..30] RXD Pin Active Edge Interrupt Flag                               */
      __IOM uint32_t LBKDIF     : 1;            /*!< [31..31] LIN Break Detect Interrupt Flag                                  */
    } LPUART0_STAT_b;
  } ;

  union {
    __IOM uint32_t LPUART0_CTRL;                /*!< (@ 0x00000018) LPUART Control Register                                    */

    struct {
      __IOM uint32_t PT         : 1;            /*!< [0..0] Parity Type                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Parity Enable                                                      */
      __IOM uint32_t ILT        : 1;            /*!< [2..2] Idle Line Type Select                                              */
      __IOM uint32_t WAKE       : 1;            /*!< [3..3] Receiver Wakeup Method Select                                      */
      __IOM uint32_t M          : 1;            /*!< [4..4] 9-Bit or 8-Bit Mode Select                                         */
      __IOM uint32_t RSRC       : 1;            /*!< [5..5] Receiver Source Select                                             */
      __IOM uint32_t DOZEEN     : 1;            /*!< [6..6] Doze Enable                                                        */
      __IOM uint32_t LOOPS      : 1;            /*!< [7..7] Loop Mode Select                                                   */
      __IOM uint32_t IDLECFG    : 3;            /*!< [10..8] Idle Configuration                                                */
      __IOM uint32_t M7         : 1;            /*!< [11..11] 7-Bit Mode Select                                                */
            uint32_t            : 2;
      __IOM uint32_t MA2IE      : 1;            /*!< [14..14] Match 2 Interrupt Enable                                         */
      __IOM uint32_t MA1IE      : 1;            /*!< [15..15] Match 1 Interrupt Enable                                         */
      __IOM uint32_t SBK        : 1;            /*!< [16..16] Send Break                                                       */
      __IOM uint32_t RWU        : 1;            /*!< [17..17] Receiver Wakeup Control                                          */
      __IOM uint32_t RE         : 1;            /*!< [18..18] Receiver Enable                                                  */
      __IOM uint32_t TE         : 1;            /*!< [19..19] Transmitter Enable                                               */
      __IOM uint32_t ILIE       : 1;            /*!< [20..20] Idle Line Interrupt Enable                                       */
      __IOM uint32_t RIE        : 1;            /*!< [21..21] Receiver Interrupt Enable                                        */
      __IOM uint32_t TCIE       : 1;            /*!< [22..22] Transmission Complete Interrupt Enable for                       */
      __IOM uint32_t TIE        : 1;            /*!< [23..23] Transmit Interrupt Enable                                        */
      __IOM uint32_t PEIE       : 1;            /*!< [24..24] Parity Error Interrupt Enable                                    */
      __IOM uint32_t FEIE       : 1;            /*!< [25..25] Framing Error Interrupt Enable                                   */
      __IOM uint32_t NEIE       : 1;            /*!< [26..26] Noise Error Interrupt Enable                                     */
      __IOM uint32_t ORIE       : 1;            /*!< [27..27] Overrun Interrupt Enable                                         */
      __IOM uint32_t TXINV      : 1;            /*!< [28..28] Transmit Data Inversion                                          */
      __IOM uint32_t TXDIR      : 1;            /*!< [29..29] TXD Pin Direction in Single-Wire Mode                            */
      __IOM uint32_t R9T8       : 1;            /*!< [30..30] Receive Bit 9 / Transmit Bit 8                                   */
      __IOM uint32_t R8T9       : 1;            /*!< [31..31] Receive Bit 8 / Transmit Bit 9                                   */
    } LPUART0_CTRL_b;
  } ;

  union {
    __IOM uint32_t LPUART0_DATA;                /*!< (@ 0x0000001C) LPUART Data Register                                       */

    struct {
      __IOM uint32_t R0T0       : 1;            /*!< [0..0] R0T0                                                               */
      __IOM uint32_t R1T1       : 1;            /*!< [1..1] R1T1                                                               */
      __IOM uint32_t R2T2       : 1;            /*!< [2..2] R2T2                                                               */
      __IOM uint32_t R3T3       : 1;            /*!< [3..3] R3T3                                                               */
      __IOM uint32_t R4T4       : 1;            /*!< [4..4] R4T4                                                               */
      __IOM uint32_t R5T5       : 1;            /*!< [5..5] R5T5                                                               */
      __IOM uint32_t R6T6       : 1;            /*!< [6..6] R6T6                                                               */
      __IOM uint32_t R7T7       : 1;            /*!< [7..7] R7T7                                                               */
      __IOM uint32_t R8T8       : 1;            /*!< [8..8] R8T8                                                               */
      __IOM uint32_t R9T9       : 1;            /*!< [9..9] R9T9                                                               */
            uint32_t            : 1;
      __IM  uint32_t IDLINE     : 1;            /*!< [11..11] Idle Line                                                        */
      __IM  uint32_t RXEMPT     : 1;            /*!< [12..12] Receive Buffer Empty                                             */
      __IOM uint32_t FRETSC     : 1;            /*!< [13..13] Frame Error / Transmit Special Character                         */
      __IM  uint32_t PARITYE    : 1;            /*!< [14..14] PARITYE                                                          */
      __IM  uint32_t NOISY      : 1;            /*!< [15..15] NOISY                                                            */
            uint32_t            : 16;
    } LPUART0_DATA_b;
  } ;

  union {
    __IOM uint32_t LPUART0_MATCH;               /*!< (@ 0x00000020) LPUART Match Address Register                              */

    struct {
      __IOM uint32_t MA1        : 10;           /*!< [9..0] Match Address 1                                                    */
            uint32_t            : 6;
      __IOM uint32_t MA2        : 10;           /*!< [25..16] Match Address 2                                                  */
            uint32_t            : 6;
    } LPUART0_MATCH_b;
  } ;

  union {
    __IOM uint32_t LPUART0_MODIR;               /*!< (@ 0x00000024) LPUART Modem IrDA Register                                 */

    struct {
      __IOM uint32_t TXCTSE     : 1;            /*!< [0..0] Transmitter clear-to-send enable                                   */
      __IOM uint32_t TXRTSE     : 1;            /*!< [1..1] Transmitter request-to-send enable                                 */
      __IOM uint32_t TXRTSPOL   : 1;            /*!< [2..2] Transmitter request-to-send polarity                               */
      __IOM uint32_t RXRTSE     : 1;            /*!< [3..3] Receiver request-to-send enable                                    */
      __IOM uint32_t TXCTSC     : 1;            /*!< [4..4] Transmit CTS Configuration                                         */
      __IOM uint32_t TXCTSSRC   : 1;            /*!< [5..5] Transmit CTS Source                                                */
            uint32_t            : 2;
      __IOM uint32_t RTSWATER   : 2;            /*!< [9..8] Receive RTS Configuration                                          */
            uint32_t            : 6;
      __IOM uint32_t TNP        : 2;            /*!< [17..16] Transmitter narrow pulse                                         */
      __IOM uint32_t IREN       : 1;            /*!< [18..18] Infrared enable                                                  */
            uint32_t            : 13;
    } LPUART0_MODIR_b;
  } ;

  union {
    __IOM uint32_t LPUART0_FIFO;                /*!< (@ 0x00000028) LPUART FIFO Register                                       */

    struct {
      __IM  uint32_t RXFIFOSIZE : 3;            /*!< [2..0] Receive FIFO. Buffer Depth                                         */
      __IOM uint32_t RXFE       : 1;            /*!< [3..3] Receive FIFO Enable                                                */
      __IM  uint32_t TXFIFOSIZE : 3;            /*!< [6..4] Transmit FIFO. Buffer Depth                                        */
      __IOM uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO Enable                                               */
      __IOM uint32_t RXUFE      : 1;            /*!< [8..8] Receive FIFO Underflow Interrupt Enable                            */
      __IOM uint32_t TXOFE      : 1;            /*!< [9..9] Transmit FIFO Overflow Interrupt Enable                            */
      __IOM uint32_t RXIDEN     : 3;            /*!< [12..10] Receiver Idle Empty Enable                                       */
            uint32_t            : 1;
      __OM  uint32_t RXFLUSH    : 1;            /*!< [14..14] Receive FIFO/Buffer Flush                                        */
      __OM  uint32_t TXFLUSH    : 1;            /*!< [15..15] Transmit FIFO/Buffer Flush                                       */
      __IOM uint32_t RXUF       : 1;            /*!< [16..16] Receiver Buffer Underflow Flag                                   */
      __IOM uint32_t TXOF       : 1;            /*!< [17..17] Transmitter Buffer Overflow Flag                                 */
            uint32_t            : 4;
      __IM  uint32_t RXEMPT     : 1;            /*!< [22..22] Receive Buffer/FIFO Empty                                        */
      __IM  uint32_t TXEMPT     : 1;            /*!< [23..23] Transmit Buffer/FIFO Empty                                       */
            uint32_t            : 8;
    } LPUART0_FIFO_b;
  } ;

  union {
    __IOM uint32_t LPUART0_WATER;               /*!< (@ 0x0000002C) LPUART Watermark Register                                  */

    struct {
      __IOM uint32_t TXWATER    : 2;            /*!< [1..0] Transmit Watermark                                                 */
            uint32_t            : 6;
      __IM  uint32_t TXCOUNT    : 3;            /*!< [10..8] Transmit Counter                                                  */
            uint32_t            : 5;
      __IOM uint32_t RXWATER    : 2;            /*!< [17..16] Receive Watermark                                                */
            uint32_t            : 6;
      __IM  uint32_t RXCOUNT    : 3;            /*!< [26..24] Receive Counter                                                  */
            uint32_t            : 5;
    } LPUART0_WATER_b;
  } ;
} LPUART0_Type;                                 /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                          LPUART1                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal Asynchronous Receiver/Transmitter (LPUART1)
  */

typedef struct {                                /*!< (@ 0x4006B000) LPUART1 Structure                                          */

  union {
    __IM  uint32_t LPUART1_VERID;               /*!< (@ 0x00000000) Version ID Register                                        */

    struct {
      __IM  uint32_t FEATURE    : 16;           /*!< [15..0] Feature Identification Number                                     */
      __IM  uint32_t MINOR      : 8;            /*!< [23..16] Minor Version Number                                             */
      __IM  uint32_t MAJOR      : 8;            /*!< [31..24] Major Version Number                                             */
    } LPUART1_VERID_b;
  } ;

  union {
    __IM  uint32_t LPUART1_PARAM;               /*!< (@ 0x00000004) Parameter Register                                         */

    struct {
      __IM  uint32_t TXFIFO     : 8;            /*!< [7..0] Transmit FIFO Size                                                 */
      __IM  uint32_t RXFIFO     : 8;            /*!< [15..8] Receive FIFO Size                                                 */
            uint32_t            : 16;
    } LPUART1_PARAM_b;
  } ;

  union {
    __IOM uint32_t LPUART1_GLOBAL;              /*!< (@ 0x00000008) LPUART Global Register                                     */

    struct {
            uint32_t            : 1;
      __IOM uint32_t RST        : 1;            /*!< [1..1] Software Reset                                                     */
            uint32_t            : 30;
    } LPUART1_GLOBAL_b;
  } ;

  union {
    __IOM uint32_t LPUART1_PINCFG;              /*!< (@ 0x0000000C) LPUART Pin Configuration Register                          */

    struct {
      __IOM uint32_t TRGSEL     : 2;            /*!< [1..0] Trigger Select                                                     */
            uint32_t            : 30;
    } LPUART1_PINCFG_b;
  } ;

  union {
    __IOM uint32_t LPUART1_BAUD;                /*!< (@ 0x00000010) LPUART Baud Rate Register                                  */

    struct {
      __IOM uint32_t SBR        : 13;           /*!< [12..0] Baud Rate Modulo Divisor.                                         */
      __IOM uint32_t SBNS       : 1;            /*!< [13..13] Stop Bit Number Select                                           */
      __IOM uint32_t RXEDGIE    : 1;            /*!< [14..14] RX Input Active Edge Interrupt Enable                            */
      __IOM uint32_t LBKDIE     : 1;            /*!< [15..15] LIN Break Detect Interrupt Enable                                */
      __IOM uint32_t RESYNCDIS  : 1;            /*!< [16..16] Resynchronization Disable                                        */
      __IOM uint32_t BOTHEDGE   : 1;            /*!< [17..17] Both Edge Sampling                                               */
      __IOM uint32_t MATCFG     : 2;            /*!< [19..18] Match Configuration                                              */
      __IOM uint32_t RIDMAE     : 1;            /*!< [20..20] Receiver Idle DMA Enable                                         */
      __IOM uint32_t RDMAE      : 1;            /*!< [21..21] Receiver Full DMA Enable                                         */
            uint32_t            : 1;
      __IOM uint32_t TDMAE      : 1;            /*!< [23..23] Transmitter DMA Enable                                           */
      __IOM uint32_t OSR        : 5;            /*!< [28..24] Oversampling Ratio                                               */
      __IOM uint32_t M10        : 1;            /*!< [29..29] 10-bit Mode select                                               */
      __IOM uint32_t MAEN2      : 1;            /*!< [30..30] Match Address Mode Enable 2                                      */
      __IOM uint32_t MAEN1      : 1;            /*!< [31..31] Match Address Mode Enable 1                                      */
    } LPUART1_BAUD_b;
  } ;

  union {
    __IOM uint32_t LPUART1_STAT;                /*!< (@ 0x00000014) LPUART Status Register                                     */

    struct {
            uint32_t            : 14;
      __IOM uint32_t MA2F       : 1;            /*!< [14..14] Match 2 Flag                                                     */
      __IOM uint32_t MA1F       : 1;            /*!< [15..15] Match 1 Flag                                                     */
      __IOM uint32_t PF         : 1;            /*!< [16..16] Parity Error Flag                                                */
      __IOM uint32_t FE         : 1;            /*!< [17..17] Framing Error Flag                                               */
      __IOM uint32_t NF         : 1;            /*!< [18..18] Noise Flag                                                       */
      __IOM uint32_t OR         : 1;            /*!< [19..19] Receiver Overrun Flag                                            */
      __IOM uint32_t IDLE       : 1;            /*!< [20..20] Idle Line Flag                                                   */
      __IM  uint32_t RDRF       : 1;            /*!< [21..21] Receive Data Register Full Flag                                  */
      __IM  uint32_t TC         : 1;            /*!< [22..22] Transmission Complete Flag                                       */
      __IM  uint32_t TDRE       : 1;            /*!< [23..23] Transmit Data Register Empty Flag                                */
      __IM  uint32_t RAF        : 1;            /*!< [24..24] Receiver Active Flag                                             */
      __IOM uint32_t LBKDE      : 1;            /*!< [25..25] LIN Break Detection Enable                                       */
      __IOM uint32_t BRK13      : 1;            /*!< [26..26] Break Character Generation Length                                */
      __IOM uint32_t RWUID      : 1;            /*!< [27..27] Receive Wake Up Idle Detect                                      */
      __IOM uint32_t RXINV      : 1;            /*!< [28..28] Receive Data Inversion                                           */
      __IOM uint32_t MSBF       : 1;            /*!< [29..29] MSB First                                                        */
      __IOM uint32_t RXEDGIF    : 1;            /*!< [30..30] RXD Pin Active Edge Interrupt Flag                               */
      __IOM uint32_t LBKDIF     : 1;            /*!< [31..31] LIN Break Detect Interrupt Flag                                  */
    } LPUART1_STAT_b;
  } ;

  union {
    __IOM uint32_t LPUART1_CTRL;                /*!< (@ 0x00000018) LPUART Control Register                                    */

    struct {
      __IOM uint32_t PT         : 1;            /*!< [0..0] Parity Type                                                        */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Parity Enable                                                      */
      __IOM uint32_t ILT        : 1;            /*!< [2..2] Idle Line Type Select                                              */
      __IOM uint32_t WAKE       : 1;            /*!< [3..3] Receiver Wakeup Method Select                                      */
      __IOM uint32_t M          : 1;            /*!< [4..4] 9-Bit or 8-Bit Mode Select                                         */
      __IOM uint32_t RSRC       : 1;            /*!< [5..5] Receiver Source Select                                             */
      __IOM uint32_t DOZEEN     : 1;            /*!< [6..6] Doze Enable                                                        */
      __IOM uint32_t LOOPS      : 1;            /*!< [7..7] Loop Mode Select                                                   */
      __IOM uint32_t IDLECFG    : 3;            /*!< [10..8] Idle Configuration                                                */
      __IOM uint32_t M7         : 1;            /*!< [11..11] 7-Bit Mode Select                                                */
            uint32_t            : 2;
      __IOM uint32_t MA2IE      : 1;            /*!< [14..14] Match 2 Interrupt Enable                                         */
      __IOM uint32_t MA1IE      : 1;            /*!< [15..15] Match 1 Interrupt Enable                                         */
      __IOM uint32_t SBK        : 1;            /*!< [16..16] Send Break                                                       */
      __IOM uint32_t RWU        : 1;            /*!< [17..17] Receiver Wakeup Control                                          */
      __IOM uint32_t RE         : 1;            /*!< [18..18] Receiver Enable                                                  */
      __IOM uint32_t TE         : 1;            /*!< [19..19] Transmitter Enable                                               */
      __IOM uint32_t ILIE       : 1;            /*!< [20..20] Idle Line Interrupt Enable                                       */
      __IOM uint32_t RIE        : 1;            /*!< [21..21] Receiver Interrupt Enable                                        */
      __IOM uint32_t TCIE       : 1;            /*!< [22..22] Transmission Complete Interrupt Enable for                       */
      __IOM uint32_t TIE        : 1;            /*!< [23..23] Transmit Interrupt Enable                                        */
      __IOM uint32_t PEIE       : 1;            /*!< [24..24] Parity Error Interrupt Enable                                    */
      __IOM uint32_t FEIE       : 1;            /*!< [25..25] Framing Error Interrupt Enable                                   */
      __IOM uint32_t NEIE       : 1;            /*!< [26..26] Noise Error Interrupt Enable                                     */
      __IOM uint32_t ORIE       : 1;            /*!< [27..27] Overrun Interrupt Enable                                         */
      __IOM uint32_t TXINV      : 1;            /*!< [28..28] Transmit Data Inversion                                          */
      __IOM uint32_t TXDIR      : 1;            /*!< [29..29] TXD Pin Direction in Single-Wire Mode                            */
      __IOM uint32_t R9T8       : 1;            /*!< [30..30] Receive Bit 9 / Transmit Bit 8                                   */
      __IOM uint32_t R8T9       : 1;            /*!< [31..31] Receive Bit 8 / Transmit Bit 9                                   */
    } LPUART1_CTRL_b;
  } ;

  union {
    __IOM uint32_t LPUART1_DATA;                /*!< (@ 0x0000001C) LPUART Data Register                                       */

    struct {
      __IOM uint32_t R0T0       : 1;            /*!< [0..0] R0T0                                                               */
      __IOM uint32_t R1T1       : 1;            /*!< [1..1] R1T1                                                               */
      __IOM uint32_t R2T2       : 1;            /*!< [2..2] R2T2                                                               */
      __IOM uint32_t R3T3       : 1;            /*!< [3..3] R3T3                                                               */
      __IOM uint32_t R4T4       : 1;            /*!< [4..4] R4T4                                                               */
      __IOM uint32_t R5T5       : 1;            /*!< [5..5] R5T5                                                               */
      __IOM uint32_t R6T6       : 1;            /*!< [6..6] R6T6                                                               */
      __IOM uint32_t R7T7       : 1;            /*!< [7..7] R7T7                                                               */
      __IOM uint32_t R8T8       : 1;            /*!< [8..8] R8T8                                                               */
      __IOM uint32_t R9T9       : 1;            /*!< [9..9] R9T9                                                               */
            uint32_t            : 1;
      __IM  uint32_t IDLINE     : 1;            /*!< [11..11] Idle Line                                                        */
      __IM  uint32_t RXEMPT     : 1;            /*!< [12..12] Receive Buffer Empty                                             */
      __IOM uint32_t FRETSC     : 1;            /*!< [13..13] Frame Error / Transmit Special Character                         */
      __IM  uint32_t PARITYE    : 1;            /*!< [14..14] PARITYE                                                          */
      __IM  uint32_t NOISY      : 1;            /*!< [15..15] NOISY                                                            */
            uint32_t            : 16;
    } LPUART1_DATA_b;
  } ;

  union {
    __IOM uint32_t LPUART1_MATCH;               /*!< (@ 0x00000020) LPUART Match Address Register                              */

    struct {
      __IOM uint32_t MA1        : 10;           /*!< [9..0] Match Address 1                                                    */
            uint32_t            : 6;
      __IOM uint32_t MA2        : 10;           /*!< [25..16] Match Address 2                                                  */
            uint32_t            : 6;
    } LPUART1_MATCH_b;
  } ;

  union {
    __IOM uint32_t LPUART1_MODIR;               /*!< (@ 0x00000024) LPUART Modem IrDA Register                                 */

    struct {
      __IOM uint32_t TXCTSE     : 1;            /*!< [0..0] Transmitter clear-to-send enable                                   */
      __IOM uint32_t TXRTSE     : 1;            /*!< [1..1] Transmitter request-to-send enable                                 */
      __IOM uint32_t TXRTSPOL   : 1;            /*!< [2..2] Transmitter request-to-send polarity                               */
      __IOM uint32_t RXRTSE     : 1;            /*!< [3..3] Receiver request-to-send enable                                    */
      __IOM uint32_t TXCTSC     : 1;            /*!< [4..4] Transmit CTS Configuration                                         */
      __IOM uint32_t TXCTSSRC   : 1;            /*!< [5..5] Transmit CTS Source                                                */
            uint32_t            : 2;
      __IOM uint32_t RTSWATER   : 2;            /*!< [9..8] Receive RTS Configuration                                          */
            uint32_t            : 6;
      __IOM uint32_t TNP        : 2;            /*!< [17..16] Transmitter narrow pulse                                         */
      __IOM uint32_t IREN       : 1;            /*!< [18..18] Infrared enable                                                  */
            uint32_t            : 13;
    } LPUART1_MODIR_b;
  } ;

  union {
    __IOM uint32_t LPUART1_FIFO;                /*!< (@ 0x00000028) LPUART FIFO Register                                       */

    struct {
      __IM  uint32_t RXFIFOSIZE : 3;            /*!< [2..0] Receive FIFO. Buffer Depth                                         */
      __IOM uint32_t RXFE       : 1;            /*!< [3..3] Receive FIFO Enable                                                */
      __IM  uint32_t TXFIFOSIZE : 3;            /*!< [6..4] Transmit FIFO. Buffer Depth                                        */
      __IOM uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO Enable                                               */
      __IOM uint32_t RXUFE      : 1;            /*!< [8..8] Receive FIFO Underflow Interrupt Enable                            */
      __IOM uint32_t TXOFE      : 1;            /*!< [9..9] Transmit FIFO Overflow Interrupt Enable                            */
      __IOM uint32_t RXIDEN     : 3;            /*!< [12..10] Receiver Idle Empty Enable                                       */
            uint32_t            : 1;
      __OM  uint32_t RXFLUSH    : 1;            /*!< [14..14] Receive FIFO/Buffer Flush                                        */
      __OM  uint32_t TXFLUSH    : 1;            /*!< [15..15] Transmit FIFO/Buffer Flush                                       */
      __IOM uint32_t RXUF       : 1;            /*!< [16..16] Receiver Buffer Underflow Flag                                   */
      __IOM uint32_t TXOF       : 1;            /*!< [17..17] Transmitter Buffer Overflow Flag                                 */
            uint32_t            : 4;
      __IM  uint32_t RXEMPT     : 1;            /*!< [22..22] Receive Buffer/FIFO Empty                                        */
      __IM  uint32_t TXEMPT     : 1;            /*!< [23..23] Transmit Buffer/FIFO Empty                                       */
            uint32_t            : 8;
    } LPUART1_FIFO_b;
  } ;

  union {
    __IOM uint32_t LPUART1_WATER;               /*!< (@ 0x0000002C) LPUART Watermark Register                                  */

    struct {
      __IOM uint32_t TXWATER    : 2;            /*!< [1..0] Transmit Watermark                                                 */
            uint32_t            : 6;
      __IM  uint32_t TXCOUNT    : 3;            /*!< [10..8] Transmit Counter                                                  */
            uint32_t            : 5;
      __IOM uint32_t RXWATER    : 2;            /*!< [17..16] Receive Watermark                                                */
            uint32_t            : 6;
      __IM  uint32_t RXCOUNT    : 3;            /*!< [26..24] Receive Counter                                                  */
            uint32_t            : 5;
    } LPUART1_WATER_b;
  } ;
} LPUART1_Type;                                 /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                           CMP0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief High-Speed Comparator (CMP), Voltage Reference (VREF) Digital-to-Analog Converter (DAC), and Analog Mux (ANMUX) (CMP0)
  */

typedef struct {                                /*!< (@ 0x40073000) CMP0 Structure                                             */

  union {
    __IOM uint32_t CMP0_C0;                     /*!< (@ 0x00000000) CMP Control Register 0                                     */

    struct {
      __IOM uint32_t HYSTCTR    : 2;            /*!< [1..0] Comparator hard block hysteresis control. See chip data
                                                     sheet to get the actual hysteresis value with each level                  */
      __IOM uint32_t OFFSET     : 1;            /*!< [2..2] Comparator hard block offset control. See chip data sheet
                                                     to get the actual offset value with each level                            */
            uint32_t            : 1;
      __IOM uint32_t FILTER_CNT : 3;            /*!< [6..4] Filter Sample Count                                                */
            uint32_t            : 1;
      __IOM uint32_t EN         : 1;            /*!< [8..8] Comparator Module Enable                                           */
      __IOM uint32_t OPE        : 1;            /*!< [9..9] Comparator Output Pin Enable                                       */
      __IOM uint32_t COS        : 1;            /*!< [10..10] Comparator Output Select                                         */
      __IOM uint32_t INVT       : 1;            /*!< [11..11] Comparator invert                                                */
      __IOM uint32_t PMODE      : 1;            /*!< [12..12] Power Mode Select                                                */
            uint32_t            : 1;
      __IOM uint32_t WE         : 1;            /*!< [14..14] Windowing Enable                                                 */
      __IOM uint32_t SE         : 1;            /*!< [15..15] Sample Enable                                                    */
      __IOM uint32_t FPR        : 8;            /*!< [23..16] Filter Sample Period                                             */
      __IM  uint32_t COUT       : 1;            /*!< [24..24] Analog Comparator Output                                         */
      __IOM uint32_t CFF        : 1;            /*!< [25..25] Analog Comparator Flag Falling                                   */
      __IOM uint32_t CFR        : 1;            /*!< [26..26] Analog Comparator Flag Rising                                    */
      __IOM uint32_t IEF        : 1;            /*!< [27..27] Comparator Interrupt Enable Falling                              */
      __IOM uint32_t IER        : 1;            /*!< [28..28] Comparator Interrupt Enable Rising                               */
            uint32_t            : 1;
      __IOM uint32_t DMAEN      : 1;            /*!< [30..30] DMA Enable                                                       */
            uint32_t            : 1;
    } CMP0_C0_b;
  } ;

  union {
    __IOM uint32_t CMP0_C1;                     /*!< (@ 0x00000004) CMP Control Register 1                                     */

    struct {
      __IOM uint32_t VOSEL      : 8;            /*!< [7..0] DAC Output Voltage Select                                          */
      __IOM uint32_t MSEL       : 3;            /*!< [10..8] Minus Input MUX Control                                           */
      __IOM uint32_t PSEL       : 3;            /*!< [13..11] Plus Input MUX Control                                           */
      __IOM uint32_t VRSEL      : 1;            /*!< [14..14] Supply Voltage Reference Source Select                           */
      __IOM uint32_t DACEN      : 1;            /*!< [15..15] DAC Enable                                                       */
      __IOM uint32_t CHN0       : 1;            /*!< [16..16] Channel 0 input enable                                           */
      __IOM uint32_t CHN1       : 1;            /*!< [17..17] Channel 1 input enable                                           */
      __IOM uint32_t CHN2       : 1;            /*!< [18..18] Channel 2 input enable                                           */
      __IOM uint32_t CHN3       : 1;            /*!< [19..19] Channel 3 input enable                                           */
      __IOM uint32_t CHN4       : 1;            /*!< [20..20] Channel 4 input enable                                           */
      __IOM uint32_t CHN5       : 1;            /*!< [21..21] Channel 5 input enable                                           */
      __IOM uint32_t CHN6       : 1;            /*!< [22..22] Channel 6 input enable                                           */
      __IOM uint32_t CHN7       : 1;            /*!< [23..23] Channel 7 input enable                                           */
      __IOM uint32_t INNSEL     : 2;            /*!< [25..24] Selection of the input to the negative port of the
                                                     comparator                                                                */
            uint32_t            : 1;
      __IOM uint32_t INPSEL     : 2;            /*!< [28..27] Selection of the input to the positive port of the
                                                     comparator                                                                */
            uint32_t            : 3;
    } CMP0_C1_b;
  } ;

  union {
    __IOM uint32_t CMP0_C2;                     /*!< (@ 0x00000008) CMP Control Register 2                                     */

    struct {
      __IOM uint32_t ACOn       : 8;            /*!< [7..0] The result of the input comparison for channel n                   */
      __IOM uint32_t INITMOD    : 6;            /*!< [13..8] Comparator and DAC initialization delay modulus.                  */
      __IOM uint32_t NSAM       : 2;            /*!< [15..14] Number of sample clocks                                          */
      __IOM uint32_t CH0F       : 1;            /*!< [16..16] Channel 0 input changed flag                                     */
      __IOM uint32_t CH1F       : 1;            /*!< [17..17] Channel 1 input changed flag                                     */
      __IOM uint32_t CH2F       : 1;            /*!< [18..18] Channel 2 input changed flag                                     */
      __IOM uint32_t CH3F       : 1;            /*!< [19..19] Channel 3 input changed flag                                     */
      __IOM uint32_t CH4F       : 1;            /*!< [20..20] Channel 4 input changed flag                                     */
      __IOM uint32_t CH5F       : 1;            /*!< [21..21] Channel 5 input changed flag                                     */
      __IOM uint32_t CH6F       : 1;            /*!< [22..22] Channel 6 input changed flag                                     */
      __IOM uint32_t CH7F       : 1;            /*!< [23..23] Channel 7 input changed flag                                     */
            uint32_t            : 1;
      __IOM uint32_t FXMXCH     : 3;            /*!< [27..25] Fixed channel selection                                          */
            uint32_t            : 1;
      __IOM uint32_t FXMP       : 1;            /*!< [29..29] Fixed MUX Port                                                   */
      __IOM uint32_t RRIE       : 1;            /*!< [30..30] Round-Robin interrupt enable                                     */
      __IOM uint32_t RRE        : 1;            /*!< [31..31] Round-Robin Enable                                               */
    } CMP0_C2_b;
  } ;
} CMP0_Type;                                    /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                            PMC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PMC (PMC)
  */

typedef struct {                                /*!< (@ 0x4007D000) PMC Structure                                              */

  union {
    __IOM uint8_t PMC_LVDSC1;                   /*!< (@ 0x00000000) Low Voltage Detect Status and Control 1 Register           */

    struct {
            uint8_t             : 4;
      __IOM uint8_t LVDRE       : 1;            /*!< [4..4] Low Voltage Detect Reset Enable                                    */
      __IOM uint8_t LVDIE       : 1;            /*!< [5..5] Low Voltage Detect Interrupt Enable                                */
      __OM  uint8_t LVDACK      : 1;            /*!< [6..6] Low Voltage Detect Acknowledge                                     */
      __IM  uint8_t LVDF        : 1;            /*!< [7..7] Low Voltage Detect Flag                                            */
    } PMC_LVDSC1_b;
  } ;

  union {
    __IOM uint8_t PMC_LVDSC2;                   /*!< (@ 0x00000001) Low Voltage Detect Status and Control 2 Register           */

    struct {
            uint8_t             : 5;
      __IOM uint8_t LVWIE       : 1;            /*!< [5..5] Low-Voltage Warning Interrupt Enable                               */
      __OM  uint8_t LVWACK      : 1;            /*!< [6..6] Low-Voltage Warning Acknowledge                                    */
      __IM  uint8_t LVWF        : 1;            /*!< [7..7] Low-Voltage Warning Flag                                           */
    } PMC_LVDSC2_b;
  } ;

  union {
    __IOM uint8_t PMC_REGSC;                    /*!< (@ 0x00000002) Regulator Status and Control Register                      */

    struct {
      __IOM uint8_t BIASEN      : 1;            /*!< [0..0] Bias Enable Bit                                                    */
      __IOM uint8_t CLKBIASDIS  : 1;            /*!< [1..1] Clock Bias Disable Bit                                             */
      __IM  uint8_t REGFPM      : 1;            /*!< [2..2] Regulator in Full Performance Mode Status Bit                      */
            uint8_t             : 3;
      __IM  uint8_t LPOSTAT     : 1;            /*!< [6..6] LPO Status Bit                                                     */
      __IOM uint8_t LPODIS      : 1;            /*!< [7..7] LPO Disable Bit                                                    */
    } PMC_REGSC_b;
  } ;
  __IM  uint8_t   RESERVED;

  union {
    __IOM uint8_t PMC_LPOTRIM;                  /*!< (@ 0x00000004) Low Power Oscillator Trim Register                         */

    struct {
      __IOM uint8_t LPOTRIM     : 5;            /*!< [4..0] LPO trimming bits                                                  */
            uint8_t             : 3;
    } PMC_LPOTRIM_b;
  } ;
} PMC_Type;                                     /*!< Size = 5 (0x5)                                                            */



/* =========================================================================================================================== */
/* ================                                            SMC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief System Mode Controller (SMC)
  */

typedef struct {                                /*!< (@ 0x4007E000) SMC Structure                                              */

  union {
    __IM  uint32_t SMC_VERID;                   /*!< (@ 0x00000000) SMC Version ID Register                                    */

    struct {
      __IM  uint32_t FEATURE    : 16;           /*!< [15..0] Feature Specification Number                                      */
      __IM  uint32_t MINOR      : 8;            /*!< [23..16] Minor Version Number                                             */
      __IM  uint32_t MAJOR      : 8;            /*!< [31..24] Major Version Number                                             */
    } SMC_VERID_b;
  } ;

  union {
    __IM  uint32_t SMC_PARAM;                   /*!< (@ 0x00000004) SMC Parameter Register                                     */

    struct {
      __IM  uint32_t EHSRUN     : 1;            /*!< [0..0] Existence of HSRUN feature                                         */
            uint32_t            : 2;
      __IM  uint32_t ELLS       : 1;            /*!< [3..3] Existence of LLS feature                                           */
            uint32_t            : 1;
      __IM  uint32_t ELLS2      : 1;            /*!< [5..5] Existence of LLS2 feature                                          */
      __IM  uint32_t EVLLS0     : 1;            /*!< [6..6] Existence of VLLS0 feature                                         */
            uint32_t            : 25;
    } SMC_PARAM_b;
  } ;

  union {
    __IOM uint32_t SMC_PMPROT;                  /*!< (@ 0x00000008) Power Mode Protection register                             */

    struct {
            uint32_t            : 5;
      __IOM uint32_t AVLP       : 1;            /*!< [5..5] Allow Very-Low-Power Modes                                         */
            uint32_t            : 26;
    } SMC_PMPROT_b;
  } ;

  union {
    __IOM uint32_t SMC_PMCTRL;                  /*!< (@ 0x0000000C) Power Mode Control register                                */

    struct {
      __IOM uint32_t STOPM      : 3;            /*!< [2..0] Stop Mode Control                                                  */
      __IM  uint32_t VLPSA      : 1;            /*!< [3..3] Very Low Power Stop Aborted                                        */
            uint32_t            : 1;
      __IOM uint32_t RUNM       : 2;            /*!< [6..5] Run Mode Control                                                   */
            uint32_t            : 25;
    } SMC_PMCTRL_b;
  } ;

  union {
    __IOM uint32_t SMC_STOPCTRL;                /*!< (@ 0x00000010) Stop Control Register                                      */

    struct {
            uint32_t            : 6;
      __IOM uint32_t STOPO      : 2;            /*!< [7..6] Stop Option                                                        */
            uint32_t            : 24;
    } SMC_STOPCTRL_b;
  } ;

  union {
    __IM  uint32_t SMC_PMSTAT;                  /*!< (@ 0x00000014) Power Mode Status register                                 */

    struct {
      __IM  uint32_t PMSTAT     : 8;            /*!< [7..0] Power Mode Status                                                  */
            uint32_t            : 24;
    } SMC_PMSTAT_b;
  } ;
} SMC_Type;                                     /*!< Size = 24 (0x18)                                                          */



/* =========================================================================================================================== */
/* ================                                            RCM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Reset Control Module (RCM)
  */

typedef struct {                                /*!< (@ 0x4007F000) RCM Structure                                              */

  union {
    __IM  uint32_t RCM_VERID;                   /*!< (@ 0x00000000) Version ID Register                                        */

    struct {
      __IM  uint32_t FEATURE    : 16;           /*!< [15..0] Feature Specification Number                                      */
      __IM  uint32_t MINOR      : 8;            /*!< [23..16] Minor Version Number                                             */
      __IM  uint32_t MAJOR      : 8;            /*!< [31..24] Major Version Number                                             */
    } RCM_VERID_b;
  } ;

  union {
    __IM  uint32_t RCM_PARAM;                   /*!< (@ 0x00000004) Parameter Register                                         */

    struct {
      __IM  uint32_t EWAKEUP    : 1;            /*!< [0..0] Existence of SRS[WAKEUP] status indication feature                 */
      __IM  uint32_t ELVD       : 1;            /*!< [1..1] Existence of SRS[LVD] status indication feature                    */
      __IM  uint32_t ELOC       : 1;            /*!< [2..2] Existence of SRS[LOC] status indication feature                    */
      __IM  uint32_t ELOL       : 1;            /*!< [3..3] Existence of SRS[LOL] status indication feature                    */
      __IM  uint32_t ECMU_LOC   : 1;            /*!< [4..4] Existence of SRS[CMU_LOC] status indication feature                */
      __IM  uint32_t EWDOG      : 1;            /*!< [5..5] Existence of SRS[WDOG] status indication feature                   */
      __IM  uint32_t EPIN       : 1;            /*!< [6..6] Existence of SRS[PIN] status indication feature                    */
      __IM  uint32_t EPOR       : 1;            /*!< [7..7] Existence of SRS[POR] status indication feature                    */
      __IM  uint32_t EJTAG      : 1;            /*!< [8..8] Existence of SRS[JTAG] status indication feature                   */
      __IM  uint32_t ELOCKUP    : 1;            /*!< [9..9] Existence of SRS[LOCKUP] status indication feature                 */
      __IM  uint32_t ESW        : 1;            /*!< [10..10] Existence of SRS[SW] status indication feature                   */
      __IM  uint32_t EMDM_AP    : 1;            /*!< [11..11] Existence of SRS[MDM_AP] status indication feature               */
            uint32_t            : 1;
      __IM  uint32_t ESACKERR   : 1;            /*!< [13..13] Existence of SRS[SACKERR] status indication feature              */
            uint32_t            : 1;
      __IM  uint32_t ETAMPER    : 1;            /*!< [15..15] Existence of SRS[TAMPER] status indication feature               */
      __IM  uint32_t ECORE1     : 1;            /*!< [16..16] Existence of SRS[CORE1] status indication feature                */
            uint32_t            : 15;
    } RCM_PARAM_b;
  } ;

  union {
    __IM  uint32_t RCM_SRS;                     /*!< (@ 0x00000008) System Reset Status Register                               */

    struct {
            uint32_t            : 1;
      __IM  uint32_t LVD        : 1;            /*!< [1..1] Low-Voltage Detect Reset or High-Voltage Detect Reset              */
      __IM  uint32_t LOC        : 1;            /*!< [2..2] Loss-of-Clock Reset                                                */
      __IM  uint32_t LOL        : 1;            /*!< [3..3] Loss-of-Lock Reset                                                 */
      __IM  uint32_t CMU_LOC    : 1;            /*!< [4..4] CMU Loss-of-Clock Reset                                            */
      __IM  uint32_t WDOG       : 1;            /*!< [5..5] Watchdog                                                           */
      __IM  uint32_t PIN        : 1;            /*!< [6..6] External Reset Pin                                                 */
      __IM  uint32_t POR        : 1;            /*!< [7..7] Power-On Reset                                                     */
      __IM  uint32_t JTAG       : 1;            /*!< [8..8] JTAG generated reset                                               */
      __IM  uint32_t LOCKUP     : 1;            /*!< [9..9] Core Lockup                                                        */
      __IM  uint32_t SW         : 1;            /*!< [10..10] Software                                                         */
      __IM  uint32_t MDM_AP     : 1;            /*!< [11..11] MDM-AP System Reset Request                                      */
            uint32_t            : 1;
      __IM  uint32_t SACKERR    : 1;            /*!< [13..13] Stop Acknowledge Error                                           */
            uint32_t            : 18;
    } RCM_SRS_b;
  } ;

  union {
    __IOM uint32_t RCM_RPC;                     /*!< (@ 0x0000000C) Reset Pin Control register                                 */

    struct {
      __IOM uint32_t RSTFLTSRW  : 2;            /*!< [1..0] Reset Pin Filter Select in Run and Wait Modes                      */
      __IOM uint32_t RSTFLTSS   : 1;            /*!< [2..2] Reset Pin Filter Select in Stop Mode                               */
            uint32_t            : 5;
      __IOM uint32_t RSTFLTSEL  : 5;            /*!< [12..8] Reset Pin Filter Bus Clock Select                                 */
            uint32_t            : 19;
    } RCM_RPC_b;
  } ;
  __IM  uint32_t  RESERVED[2];

  union {
    __IOM uint32_t RCM_SSRS;                    /*!< (@ 0x00000018) Sticky System Reset Status Register                        */

    struct {
            uint32_t            : 1;
      __IOM uint32_t SLVD       : 1;            /*!< [1..1] Sticky Low-Voltage Detect Reset                                    */
      __IOM uint32_t SLOC       : 1;            /*!< [2..2] Sticky Loss-of-Clock Reset                                         */
      __IOM uint32_t SLOL       : 1;            /*!< [3..3] Sticky Loss-of-Lock Reset                                          */
      __IOM uint32_t SCMU_LOC   : 1;            /*!< [4..4] Sticky CMU Loss-of-Clock Reset                                     */
      __IOM uint32_t SWDOG      : 1;            /*!< [5..5] Sticky Watchdog                                                    */
      __IOM uint32_t SPIN       : 1;            /*!< [6..6] Sticky External Reset Pin                                          */
      __IOM uint32_t SPOR       : 1;            /*!< [7..7] Sticky Power-On Reset                                              */
      __IOM uint32_t SJTAG      : 1;            /*!< [8..8] Sticky JTAG generated reset                                        */
      __IOM uint32_t SLOCKUP    : 1;            /*!< [9..9] Sticky Core Lockup                                                 */
      __IOM uint32_t SSW        : 1;            /*!< [10..10] Sticky Software                                                  */
      __IOM uint32_t SMDM_AP    : 1;            /*!< [11..11] Sticky MDM-AP System Reset Request                               */
            uint32_t            : 1;
      __IOM uint32_t SSACKERR   : 1;            /*!< [13..13] Sticky Stop Acknowledge Error                                    */
            uint32_t            : 18;
    } RCM_SSRS_b;
  } ;

  union {
    __IOM uint32_t RCM_SRIE;                    /*!< (@ 0x0000001C) System Reset Interrupt Enable Register                     */

    struct {
      __IOM uint32_t DELAY      : 2;            /*!< [1..0] Reset Delay Time                                                   */
      __IOM uint32_t LOC        : 1;            /*!< [2..2] Loss-of-Clock Interrupt                                            */
      __IOM uint32_t LOL        : 1;            /*!< [3..3] Loss-of-Lock Interrupt                                             */
      __IOM uint32_t CMU_LOC    : 1;            /*!< [4..4] CMU Loss-of-Clock Interrupt                                        */
      __IOM uint32_t WDOG       : 1;            /*!< [5..5] Watchdog Interrupt                                                 */
      __IOM uint32_t PIN        : 1;            /*!< [6..6] External Reset Pin Interrupt                                       */
      __IOM uint32_t GIE        : 1;            /*!< [7..7] Global Interrupt Enable                                            */
      __IOM uint32_t JTAG       : 1;            /*!< [8..8] JTAG generated reset                                               */
      __IOM uint32_t LOCKUP     : 1;            /*!< [9..9] Core Lockup Interrupt                                              */
      __IOM uint32_t SW         : 1;            /*!< [10..10] Software Interrupt                                               */
      __IOM uint32_t MDM_AP     : 1;            /*!< [11..11] MDM-AP System Reset Request                                      */
            uint32_t            : 1;
      __IOM uint32_t SACKERR    : 1;            /*!< [13..13] Stop Acknowledge Error Interrupt                                 */
            uint32_t            : 18;
    } RCM_SRIE_b;
  } ;
} RCM_Type;                                     /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                            PTA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Input/Output (PTA)
  */

typedef struct {                                /*!< (@ 0x400FF000) PTA Structure                                              */

  union {
    __IOM uint32_t GPIOA_PDOR;                  /*!< (@ 0x00000000) Port Data Output Register                                  */

    struct {
      __IOM uint32_t PDO        : 32;           /*!< [31..0] Port Data Output                                                  */
    } GPIOA_PDOR_b;
  } ;

  union {
    __OM  uint32_t GPIOA_PSOR;                  /*!< (@ 0x00000004) Port Set Output Register                                   */

    struct {
      __OM  uint32_t PTSO       : 32;           /*!< [31..0] Port Set Output                                                   */
    } GPIOA_PSOR_b;
  } ;

  union {
    __OM  uint32_t GPIOA_PCOR;                  /*!< (@ 0x00000008) Port Clear Output Register                                 */

    struct {
      __OM  uint32_t PTCO       : 32;           /*!< [31..0] Port Clear Output                                                 */
    } GPIOA_PCOR_b;
  } ;

  union {
    __OM  uint32_t GPIOA_PTOR;                  /*!< (@ 0x0000000C) Port Toggle Output Register                                */

    struct {
      __OM  uint32_t PTTO       : 32;           /*!< [31..0] Port Toggle Output                                                */
    } GPIOA_PTOR_b;
  } ;

  union {
    __IM  uint32_t GPIOA_PDIR;                  /*!< (@ 0x00000010) Port Data Input Register                                   */

    struct {
      __IM  uint32_t PDI        : 32;           /*!< [31..0] Port Data Input                                                   */
    } GPIOA_PDIR_b;
  } ;

  union {
    __IOM uint32_t GPIOA_PDDR;                  /*!< (@ 0x00000014) Port Data Direction Register                               */

    struct {
      __IOM uint32_t PDD        : 32;           /*!< [31..0] Port Data Direction                                               */
    } GPIOA_PDDR_b;
  } ;

  union {
    __IOM uint32_t GPIOA_PIDR;                  /*!< (@ 0x00000018) Port Input Disable Register                                */

    struct {
      __IOM uint32_t PID        : 32;           /*!< [31..0] Port Input Disable                                                */
    } GPIOA_PIDR_b;
  } ;
} PTA_Type;                                     /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                            PTB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Input/Output (PTB)
  */

typedef struct {                                /*!< (@ 0x400FF040) PTB Structure                                              */

  union {
    __IOM uint32_t GPIOB_PDOR;                  /*!< (@ 0x00000000) Port Data Output Register                                  */

    struct {
      __IOM uint32_t PDO        : 32;           /*!< [31..0] Port Data Output                                                  */
    } GPIOB_PDOR_b;
  } ;

  union {
    __OM  uint32_t GPIOB_PSOR;                  /*!< (@ 0x00000004) Port Set Output Register                                   */

    struct {
      __OM  uint32_t PTSO       : 32;           /*!< [31..0] Port Set Output                                                   */
    } GPIOB_PSOR_b;
  } ;

  union {
    __OM  uint32_t GPIOB_PCOR;                  /*!< (@ 0x00000008) Port Clear Output Register                                 */

    struct {
      __OM  uint32_t PTCO       : 32;           /*!< [31..0] Port Clear Output                                                 */
    } GPIOB_PCOR_b;
  } ;

  union {
    __OM  uint32_t GPIOB_PTOR;                  /*!< (@ 0x0000000C) Port Toggle Output Register                                */

    struct {
      __OM  uint32_t PTTO       : 32;           /*!< [31..0] Port Toggle Output                                                */
    } GPIOB_PTOR_b;
  } ;

  union {
    __IM  uint32_t GPIOB_PDIR;                  /*!< (@ 0x00000010) Port Data Input Register                                   */

    struct {
      __IM  uint32_t PDI        : 32;           /*!< [31..0] Port Data Input                                                   */
    } GPIOB_PDIR_b;
  } ;

  union {
    __IOM uint32_t GPIOB_PDDR;                  /*!< (@ 0x00000014) Port Data Direction Register                               */

    struct {
      __IOM uint32_t PDD        : 32;           /*!< [31..0] Port Data Direction                                               */
    } GPIOB_PDDR_b;
  } ;

  union {
    __IOM uint32_t GPIOB_PIDR;                  /*!< (@ 0x00000018) Port Input Disable Register                                */

    struct {
      __IOM uint32_t PID        : 32;           /*!< [31..0] Port Input Disable                                                */
    } GPIOB_PIDR_b;
  } ;
} PTB_Type;                                     /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                            PTC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Input/Output (PTC)
  */

typedef struct {                                /*!< (@ 0x400FF080) PTC Structure                                              */

  union {
    __IOM uint32_t GPIOC_PDOR;                  /*!< (@ 0x00000000) Port Data Output Register                                  */

    struct {
      __IOM uint32_t PDO        : 32;           /*!< [31..0] Port Data Output                                                  */
    } GPIOC_PDOR_b;
  } ;

  union {
    __OM  uint32_t GPIOC_PSOR;                  /*!< (@ 0x00000004) Port Set Output Register                                   */

    struct {
      __OM  uint32_t PTSO       : 32;           /*!< [31..0] Port Set Output                                                   */
    } GPIOC_PSOR_b;
  } ;

  union {
    __OM  uint32_t GPIOC_PCOR;                  /*!< (@ 0x00000008) Port Clear Output Register                                 */

    struct {
      __OM  uint32_t PTCO       : 32;           /*!< [31..0] Port Clear Output                                                 */
    } GPIOC_PCOR_b;
  } ;

  union {
    __OM  uint32_t GPIOC_PTOR;                  /*!< (@ 0x0000000C) Port Toggle Output Register                                */

    struct {
      __OM  uint32_t PTTO       : 32;           /*!< [31..0] Port Toggle Output                                                */
    } GPIOC_PTOR_b;
  } ;

  union {
    __IM  uint32_t GPIOC_PDIR;                  /*!< (@ 0x00000010) Port Data Input Register                                   */

    struct {
      __IM  uint32_t PDI        : 32;           /*!< [31..0] Port Data Input                                                   */
    } GPIOC_PDIR_b;
  } ;

  union {
    __IOM uint32_t GPIOC_PDDR;                  /*!< (@ 0x00000014) Port Data Direction Register                               */

    struct {
      __IOM uint32_t PDD        : 32;           /*!< [31..0] Port Data Direction                                               */
    } GPIOC_PDDR_b;
  } ;

  union {
    __IOM uint32_t GPIOC_PIDR;                  /*!< (@ 0x00000018) Port Input Disable Register                                */

    struct {
      __IOM uint32_t PID        : 32;           /*!< [31..0] Port Input Disable                                                */
    } GPIOC_PIDR_b;
  } ;
} PTC_Type;                                     /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                            PTD                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Input/Output (PTD)
  */

typedef struct {                                /*!< (@ 0x400FF0C0) PTD Structure                                              */

  union {
    __IOM uint32_t GPIOD_PDOR;                  /*!< (@ 0x00000000) Port Data Output Register                                  */

    struct {
      __IOM uint32_t PDO        : 32;           /*!< [31..0] Port Data Output                                                  */
    } GPIOD_PDOR_b;
  } ;

  union {
    __OM  uint32_t GPIOD_PSOR;                  /*!< (@ 0x00000004) Port Set Output Register                                   */

    struct {
      __OM  uint32_t PTSO       : 32;           /*!< [31..0] Port Set Output                                                   */
    } GPIOD_PSOR_b;
  } ;

  union {
    __OM  uint32_t GPIOD_PCOR;                  /*!< (@ 0x00000008) Port Clear Output Register                                 */

    struct {
      __OM  uint32_t PTCO       : 32;           /*!< [31..0] Port Clear Output                                                 */
    } GPIOD_PCOR_b;
  } ;

  union {
    __OM  uint32_t GPIOD_PTOR;                  /*!< (@ 0x0000000C) Port Toggle Output Register                                */

    struct {
      __OM  uint32_t PTTO       : 32;           /*!< [31..0] Port Toggle Output                                                */
    } GPIOD_PTOR_b;
  } ;

  union {
    __IM  uint32_t GPIOD_PDIR;                  /*!< (@ 0x00000010) Port Data Input Register                                   */

    struct {
      __IM  uint32_t PDI        : 32;           /*!< [31..0] Port Data Input                                                   */
    } GPIOD_PDIR_b;
  } ;

  union {
    __IOM uint32_t GPIOD_PDDR;                  /*!< (@ 0x00000014) Port Data Direction Register                               */

    struct {
      __IOM uint32_t PDD        : 32;           /*!< [31..0] Port Data Direction                                               */
    } GPIOD_PDDR_b;
  } ;

  union {
    __IOM uint32_t GPIOD_PIDR;                  /*!< (@ 0x00000018) Port Input Disable Register                                */

    struct {
      __IOM uint32_t PID        : 32;           /*!< [31..0] Port Input Disable                                                */
    } GPIOD_PIDR_b;
  } ;
} PTD_Type;                                     /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                            PTE                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief General Purpose Input/Output (PTE)
  */

typedef struct {                                /*!< (@ 0x400FF100) PTE Structure                                              */

  union {
    __IOM uint32_t GPIOE_PDOR;                  /*!< (@ 0x00000000) Port Data Output Register                                  */

    struct {
      __IOM uint32_t PDO        : 32;           /*!< [31..0] Port Data Output                                                  */
    } GPIOE_PDOR_b;
  } ;

  union {
    __OM  uint32_t GPIOE_PSOR;                  /*!< (@ 0x00000004) Port Set Output Register                                   */

    struct {
      __OM  uint32_t PTSO       : 32;           /*!< [31..0] Port Set Output                                                   */
    } GPIOE_PSOR_b;
  } ;

  union {
    __OM  uint32_t GPIOE_PCOR;                  /*!< (@ 0x00000008) Port Clear Output Register                                 */

    struct {
      __OM  uint32_t PTCO       : 32;           /*!< [31..0] Port Clear Output                                                 */
    } GPIOE_PCOR_b;
  } ;

  union {
    __OM  uint32_t GPIOE_PTOR;                  /*!< (@ 0x0000000C) Port Toggle Output Register                                */

    struct {
      __OM  uint32_t PTTO       : 32;           /*!< [31..0] Port Toggle Output                                                */
    } GPIOE_PTOR_b;
  } ;

  union {
    __IM  uint32_t GPIOE_PDIR;                  /*!< (@ 0x00000010) Port Data Input Register                                   */

    struct {
      __IM  uint32_t PDI        : 32;           /*!< [31..0] Port Data Input                                                   */
    } GPIOE_PDIR_b;
  } ;

  union {
    __IOM uint32_t GPIOE_PDDR;                  /*!< (@ 0x00000014) Port Data Direction Register                               */

    struct {
      __IOM uint32_t PDD        : 32;           /*!< [31..0] Port Data Direction                                               */
    } GPIOE_PDDR_b;
  } ;

  union {
    __IOM uint32_t GPIOE_PIDR;                  /*!< (@ 0x00000018) Port Input Disable Register                                */

    struct {
      __IOM uint32_t PID        : 32;           /*!< [31..0] Port Input Disable                                                */
    } GPIOE_PIDR_b;
  } ;
} PTE_Type;                                     /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                          S32_SCB                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief System Control Registers (S32_SCB)
  */

typedef struct {                                /*!< (@ 0xE000E000) S32_SCB Structure                                          */
  __IM  uint32_t  RESERVED[2];
  __IM  uint32_t  SCB_ACTLR;                    /*!< (@ 0x00000008) Auxiliary Control Register,                                */
  __IM  uint32_t  RESERVED1[829];

  union {
    __IM  uint32_t SCB_CPUID;                   /*!< (@ 0x00000D00) CPUID Base Register                                        */

    struct {
      __IM  uint32_t REVISION   : 4;            /*!< [3..0] Indicates patch release: 0x0 = Patch 0                             */
      __IM  uint32_t PARTNO     : 12;           /*!< [15..4] Indicates part number                                             */
            uint32_t            : 4;
      __IM  uint32_t VARIANT    : 4;            /*!< [23..20] Indicates processor revision: 0x2 = Revision 2                   */
      __IM  uint32_t IMPLEMENTER : 8;           /*!< [31..24] Implementer code                                                 */
    } SCB_CPUID_b;
  } ;

  union {
    __IOM uint32_t SCB_ICSR;                    /*!< (@ 0x00000D04) Interrupt Control and State Register                       */

    struct {
      __IM  uint32_t VECTACTIVE : 6;            /*!< [5..0] Active exception number                                            */
            uint32_t            : 6;
      __IM  uint32_t VECTPENDING : 6;           /*!< [17..12] Exception number of the highest priority pending enabled
                                                     exception                                                                 */
            uint32_t            : 4;
      __IM  uint32_t ISRPENDING : 1;            /*!< [22..22] Interrupt pending flag, excluding NMI and Faults                 */
            uint32_t            : 2;
      __OM  uint32_t PENDSTCLR  : 1;            /*!< [25..25] SysTick exception clear-pending bit                              */
      __IOM uint32_t PENDSTSET  : 1;            /*!< [26..26] SysTick exception set-pending bit                                */
      __OM  uint32_t PENDSVCLR  : 1;            /*!< [27..27] PendSV clear-pending bit                                         */
      __IOM uint32_t PENDSVSET  : 1;            /*!< [28..28] PendSV set-pending bit                                           */
            uint32_t            : 2;
      __IOM uint32_t NMIPENDSET : 1;            /*!< [31..31] NMI set-pending bit                                              */
    } SCB_ICSR_b;
  } ;

  union {
    __IOM uint32_t SCB_VTOR;                    /*!< (@ 0x00000D08) Vector Table Offset Register                               */

    struct {
            uint32_t            : 7;
      __IOM uint32_t TBLOFF     : 25;           /*!< [31..7] Vector table base offset                                          */
    } SCB_VTOR_b;
  } ;

  union {
    __IOM uint32_t SCB_AIRCR;                   /*!< (@ 0x00000D0C) Application Interrupt and Reset Control Register           */

    struct {
            uint32_t            : 1;
      __OM  uint32_t VECTCLRACTIVE : 1;         /*!< [1..1] Reserved for debug use. This bit reads as 0. When writing
                                                     to the register you must write 0 to this bit, otherwise
                                                     behavior is Unpredictable.                                                */
      __OM  uint32_t SYSRESETREQ : 1;           /*!< [2..2] System reset request:                                              */
            uint32_t            : 12;
      __IM  uint32_t ENDIANNESS : 1;            /*!< [15..15] Data endianness implemented                                      */
      __IOM uint32_t VECTKEY    : 16;           /*!< [31..16] Register key                                                     */
    } SCB_AIRCR_b;
  } ;

  union {
    __IOM uint32_t SCB_SCR;                     /*!< (@ 0x00000D10) System Control Register                                    */

    struct {
            uint32_t            : 1;
      __IOM uint32_t SLEEPONEXIT : 1;           /*!< [1..1] Indicates sleep-on-exit when returning from Handler mode
                                                     to Thread mode                                                            */
      __IOM uint32_t SLEEPDEEP  : 1;            /*!< [2..2] Controls whether the processor uses sleep or deep sleep
                                                     as its low power mode                                                     */
            uint32_t            : 1;
      __IOM uint32_t SEVONPEND  : 1;            /*!< [4..4] Send Event on Pending bit                                          */
            uint32_t            : 27;
    } SCB_SCR_b;
  } ;

  union {
    __IM  uint32_t SCB_CCR;                     /*!< (@ 0x00000D14) Configuration and Control Register                         */

    struct {
            uint32_t            : 3;
      __IM  uint32_t UNALIGN_TRP : 1;           /*!< [3..3] Always reads as one, indicates that all unaligned accesses
                                                     generate a HardFault                                                      */
            uint32_t            : 5;
      __IM  uint32_t STKALIGN   : 1;            /*!< [9..9] Indicates stack alignment on exception entry                       */
            uint32_t            : 22;
    } SCB_CCR_b;
  } ;
  __IM  uint32_t  RESERVED2;

  union {
    __IOM uint32_t SCB_SHPR2;                   /*!< (@ 0x00000D1C) System Handler Priority Register 2                         */

    struct {
            uint32_t            : 24;
      __IOM uint32_t PRI_11     : 8;            /*!< [31..24] Priority of system handler 11, SVCall                            */
    } SCB_SHPR2_b;
  } ;

  union {
    __IOM uint32_t SCB_SHPR3;                   /*!< (@ 0x00000D20) System Handler Priority Register 3                         */

    struct {
            uint32_t            : 16;
      __IOM uint32_t PRI_14     : 8;            /*!< [23..16] Priority of system handler 14, PendSV                            */
      __IOM uint32_t PRI_15     : 8;            /*!< [31..24] Priority of system handler 15, SysTick exception                 */
    } SCB_SHPR3_b;
  } ;

  union {
    __IOM uint32_t SCB_SHCSR;                   /*!< (@ 0x00000D24) System Handler Control and State Register                  */

    struct {
            uint32_t            : 15;
      __IOM uint32_t SVCALLPENDED : 1;          /*!< [15..15] SVCall pending bit, reads as 1 if exception is pending           */
            uint32_t            : 16;
    } SCB_SHCSR_b;
  } ;
  __IM  uint32_t  RESERVED3[2];

  union {
    __IOM uint32_t SCB_DFSR;                    /*!< (@ 0x00000D30) Debug Fault Status Register                                */

    struct {
      __IOM uint32_t HALTED     : 1;            /*!< [0..0] HALTED                                                             */
      __IOM uint32_t BKPT       : 1;            /*!< [1..1] BKPT                                                               */
      __IOM uint32_t DWTTRAP    : 1;            /*!< [2..2] DWTTRAP                                                            */
      __IOM uint32_t VCATCH     : 1;            /*!< [3..3] VCATCH                                                             */
      __IOM uint32_t EXTERNAL   : 1;            /*!< [4..4] EXTERNAL                                                           */
            uint32_t            : 27;
    } SCB_DFSR_b;
  } ;
} S32_SCB_Type;                                 /*!< Size = 3380 (0xd34)                                                       */



/* =========================================================================================================================== */
/* ================                                        S32_SysTick                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief System timer (S32_SysTick)
  */

typedef struct {                                /*!< (@ 0xE000E010) S32_SysTick Structure                                      */

  union {
    __IOM uint32_t SYST_CSR;                    /*!< (@ 0x00000000) SysTick Control and Status Register                        */

    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Enables the counter                                                */
      __IOM uint32_t TICKINT    : 1;            /*!< [1..1] Enables SysTick exception request                                  */
      __IOM uint32_t CLKSOURCE  : 1;            /*!< [2..2] Indicates the clock source                                         */
            uint32_t            : 13;
      __IOM uint32_t COUNTFLAG  : 1;            /*!< [16..16] Returns 1 if timer counted to 0 since last time this
                                                     was read                                                                  */
            uint32_t            : 15;
    } SYST_CSR_b;
  } ;

  union {
    __IOM uint32_t SYST_RVR;                    /*!< (@ 0x00000004) SysTick Reload Value Register                              */

    struct {
      __IOM uint32_t RELOAD     : 24;           /*!< [23..0] Value to load into the SysTick Current Value Register
                                                     when the counter reaches 0                                                */
            uint32_t            : 8;
    } SYST_RVR_b;
  } ;

  union {
    __IOM uint32_t SYST_CVR;                    /*!< (@ 0x00000008) SysTick Current Value Register                             */

    struct {
      __IOM uint32_t CURRENT    : 24;           /*!< [23..0] Current value at the time the register is accessed                */
            uint32_t            : 8;
    } SYST_CVR_b;
  } ;

  union {
    __IM  uint32_t SYST_CALIB;                  /*!< (@ 0x0000000C) SysTick Calibration Value Register                         */

    struct {
      __IM  uint32_t TENMS      : 24;           /*!< [23..0] Reload value to use for 10ms timing                               */
            uint32_t            : 6;
      __IM  uint32_t SKEW       : 1;            /*!< [30..30] Indicates whether the TENMS value is exact                       */
      __IM  uint32_t NOREF      : 1;            /*!< [31..31] Indicates whether the device provides a reference clock
                                                     to the processor                                                          */
    } SYST_CALIB_b;
  } ;
} S32_SysTick_Type;                             /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                         S32_NVIC                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Nested Vectored Interrupt Controller (S32_NVIC)
  */

typedef struct {                                /*!< (@ 0xE000E100) S32_NVIC Structure                                         */

  union {
    __IOM uint32_t S32_NVIC_ISER;               /*!< (@ 0x00000000) Interrupt Set Enable Register                              */

    struct {
      __IOM uint32_t SETENA     : 32;           /*!< [31..0] Interrupt set enable bits                                         */
    } S32_NVIC_ISER_b;
  } ;
  __IM  uint32_t  RESERVED[31];

  union {
    __IOM uint32_t S32_NVIC_ICER;               /*!< (@ 0x00000080) Interrupt Clear Enable Register                            */

    struct {
      __IOM uint32_t CLRENA     : 32;           /*!< [31..0] Interrupt clear-enable bits                                       */
    } S32_NVIC_ICER_b;
  } ;
  __IM  uint32_t  RESERVED1[31];

  union {
    __IOM uint32_t S32_NVIC_ISPR;               /*!< (@ 0x00000100) Interrupt Set Pending Register                             */

    struct {
      __IOM uint32_t SETPEND    : 32;           /*!< [31..0] Interrupt set-pending bits                                        */
    } S32_NVIC_ISPR_b;
  } ;
  __IM  uint32_t  RESERVED2[31];

  union {
    __IOM uint32_t S32_NVIC_ICPR;               /*!< (@ 0x00000180) Interrupt Clear Pending Register                           */

    struct {
      __IOM uint32_t CLRPEND    : 32;           /*!< [31..0] Interrupt clear-pending bits                                      */
    } S32_NVIC_ICPR_b;
  } ;
  __IM  uint32_t  RESERVED3[95];

  union {
    __IOM uint32_t S32_NVIC_IPR0;               /*!< (@ 0x00000300) Interrupt Priority Register n                              */

    struct {
      __IOM uint32_t PRI_0      : 8;            /*!< [7..0] Priority of interrupt 0                                            */
      __IOM uint32_t PRI_1      : 8;            /*!< [15..8] Priority of interrupt 1                                           */
      __IOM uint32_t PRI_2      : 8;            /*!< [23..16] Priority of interrupt 2                                          */
      __IOM uint32_t PRI_3      : 8;            /*!< [31..24] Priority of interrupt 3                                          */
    } S32_NVIC_IPR0_b;
  } ;

  union {
    __IOM uint32_t S32_NVIC_IPR1;               /*!< (@ 0x00000304) Interrupt Priority Register n                              */

    struct {
      __IOM uint32_t PRI_0      : 8;            /*!< [7..0] Priority of interrupt 0                                            */
      __IOM uint32_t PRI_1      : 8;            /*!< [15..8] Priority of interrupt 1                                           */
      __IOM uint32_t PRI_2      : 8;            /*!< [23..16] Priority of interrupt 2                                          */
      __IOM uint32_t PRI_3      : 8;            /*!< [31..24] Priority of interrupt 3                                          */
    } S32_NVIC_IPR1_b;
  } ;

  union {
    __IOM uint32_t S32_NVIC_IPR2;               /*!< (@ 0x00000308) Interrupt Priority Register n                              */

    struct {
      __IOM uint32_t PRI_0      : 8;            /*!< [7..0] Priority of interrupt 0                                            */
      __IOM uint32_t PRI_1      : 8;            /*!< [15..8] Priority of interrupt 1                                           */
      __IOM uint32_t PRI_2      : 8;            /*!< [23..16] Priority of interrupt 2                                          */
      __IOM uint32_t PRI_3      : 8;            /*!< [31..24] Priority of interrupt 3                                          */
    } S32_NVIC_IPR2_b;
  } ;

  union {
    __IOM uint32_t S32_NVIC_IPR3;               /*!< (@ 0x0000030C) Interrupt Priority Register n                              */

    struct {
      __IOM uint32_t PRI_0      : 8;            /*!< [7..0] Priority of interrupt 0                                            */
      __IOM uint32_t PRI_1      : 8;            /*!< [15..8] Priority of interrupt 1                                           */
      __IOM uint32_t PRI_2      : 8;            /*!< [23..16] Priority of interrupt 2                                          */
      __IOM uint32_t PRI_3      : 8;            /*!< [31..24] Priority of interrupt 3                                          */
    } S32_NVIC_IPR3_b;
  } ;

  union {
    __IOM uint32_t S32_NVIC_IPR4;               /*!< (@ 0x00000310) Interrupt Priority Register n                              */

    struct {
      __IOM uint32_t PRI_0      : 8;            /*!< [7..0] Priority of interrupt 0                                            */
      __IOM uint32_t PRI_1      : 8;            /*!< [15..8] Priority of interrupt 1                                           */
      __IOM uint32_t PRI_2      : 8;            /*!< [23..16] Priority of interrupt 2                                          */
      __IOM uint32_t PRI_3      : 8;            /*!< [31..24] Priority of interrupt 3                                          */
    } S32_NVIC_IPR4_b;
  } ;

  union {
    __IOM uint32_t S32_NVIC_IPR5;               /*!< (@ 0x00000314) Interrupt Priority Register n                              */

    struct {
      __IOM uint32_t PRI_0      : 8;            /*!< [7..0] Priority of interrupt 0                                            */
      __IOM uint32_t PRI_1      : 8;            /*!< [15..8] Priority of interrupt 1                                           */
      __IOM uint32_t PRI_2      : 8;            /*!< [23..16] Priority of interrupt 2                                          */
      __IOM uint32_t PRI_3      : 8;            /*!< [31..24] Priority of interrupt 3                                          */
    } S32_NVIC_IPR5_b;
  } ;

  union {
    __IOM uint32_t S32_NVIC_IPR6;               /*!< (@ 0x00000318) Interrupt Priority Register n                              */

    struct {
      __IOM uint32_t PRI_0      : 8;            /*!< [7..0] Priority of interrupt 0                                            */
      __IOM uint32_t PRI_1      : 8;            /*!< [15..8] Priority of interrupt 1                                           */
      __IOM uint32_t PRI_2      : 8;            /*!< [23..16] Priority of interrupt 2                                          */
      __IOM uint32_t PRI_3      : 8;            /*!< [31..24] Priority of interrupt 3                                          */
    } S32_NVIC_IPR6_b;
  } ;

  union {
    __IOM uint32_t S32_NVIC_IPR7;               /*!< (@ 0x0000031C) Interrupt Priority Register n                              */

    struct {
      __IOM uint32_t PRI_0      : 8;            /*!< [7..0] Priority of interrupt 0                                            */
      __IOM uint32_t PRI_1      : 8;            /*!< [15..8] Priority of interrupt 1                                           */
      __IOM uint32_t PRI_2      : 8;            /*!< [23..16] Priority of interrupt 2                                          */
      __IOM uint32_t PRI_3      : 8;            /*!< [31..24] Priority of interrupt 3                                          */
    } S32_NVIC_IPR7_b;
  } ;
} S32_NVIC_Type;                                /*!< Size = 800 (0x320)                                                        */



/* =========================================================================================================================== */
/* ================                                           LMEM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Local Memory Controller (LMEM)
  */

typedef struct {                                /*!< (@ 0xE0082000) LMEM Structure                                             */

  union {
    __IOM uint32_t LMEM_LMEM_PCCCR;             /*!< (@ 0x00000000) Cache control register                                     */

    struct {
      __IOM uint32_t ENCACHE    : 1;            /*!< [0..0] Cache enable                                                       */
            uint32_t            : 1;
      __IOM uint32_t PCCR2      : 1;            /*!< [2..2] Forces all cacheable spaces to write through                       */
      __IOM uint32_t PCCR3      : 1;            /*!< [3..3] Forces no allocation on cache misses (must also have
                                                     PCCR2 asserted)                                                           */
            uint32_t            : 20;
      __IOM uint32_t INVW0      : 1;            /*!< [24..24] Invalidate Way 0                                                 */
      __IOM uint32_t PUSHW0     : 1;            /*!< [25..25] Push Way 0                                                       */
      __IOM uint32_t INVW1      : 1;            /*!< [26..26] Invalidate Way 1                                                 */
      __IOM uint32_t PUSHW1     : 1;            /*!< [27..27] Push Way 1                                                       */
            uint32_t            : 3;
      __IOM uint32_t GO         : 1;            /*!< [31..31] Initiate Cache Command                                           */
    } LMEM_LMEM_PCCCR_b;
  } ;

  union {
    __IOM uint32_t LMEM_LMEM_PCCLCR;            /*!< (@ 0x00000004) Cache line control register                                */

    struct {
      __IOM uint32_t LGO        : 1;            /*!< [0..0] Initiate Cache Line Command                                        */
            uint32_t            : 1;
      __IOM uint32_t CACHEADDR  : 12;           /*!< [13..2] Cache address                                                     */
      __IOM uint32_t WSEL       : 1;            /*!< [14..14] Way select                                                       */
            uint32_t            : 1;
      __IOM uint32_t TDSEL      : 1;            /*!< [16..16] Tag/Data Select                                                  */
            uint32_t            : 3;
      __IOM uint32_t LCIVB      : 1;            /*!< [20..20] Line Command Initial Valid Bit                                   */
      __IOM uint32_t LCIMB      : 1;            /*!< [21..21] Line Command Initial Modified Bit                                */
      __IOM uint32_t LCWAY      : 1;            /*!< [22..22] Line Command Way                                                 */
            uint32_t            : 1;
      __IOM uint32_t LCMD       : 2;            /*!< [25..24] Line Command                                                     */
      __IOM uint32_t LADSEL     : 1;            /*!< [26..26] Line Address Select                                              */
      __IOM uint32_t LACC       : 1;            /*!< [27..27] Line access type                                                 */
            uint32_t            : 4;
    } LMEM_LMEM_PCCLCR_b;
  } ;

  union {
    __IOM uint32_t LMEM_LMEM_PCCSAR;            /*!< (@ 0x00000008) Cache search address register                              */

    struct {
      __IOM uint32_t LGO        : 1;            /*!< [0..0] Initiate Cache Line Command                                        */
            uint32_t            : 1;
      __IOM uint32_t PHYADDR    : 30;           /*!< [31..2] Physical Address                                                  */
    } LMEM_LMEM_PCCSAR_b;
  } ;

  union {
    __IOM uint32_t LMEM_LMEM_PCCCVR;            /*!< (@ 0x0000000C) Cache read/write value register                            */

    struct {
      __IOM uint32_t DATA       : 32;           /*!< [31..0] Cache read/write Data                                             */
    } LMEM_LMEM_PCCCVR_b;
  } ;
  __IM  uint32_t  RESERVED[4];

  union {
    __IOM uint32_t LMEM_PCCRMR;                 /*!< (@ 0x00000020) Cache regions mode register                                */

    struct {
      __IOM uint32_t R15        : 2;            /*!< [1..0] Region 15 mode                                                     */
      __IOM uint32_t R14        : 2;            /*!< [3..2] Region 14 mode                                                     */
      __IOM uint32_t R13        : 2;            /*!< [5..4] Region 13 mode                                                     */
      __IOM uint32_t R12        : 2;            /*!< [7..6] Region 12 mode                                                     */
      __IOM uint32_t R11        : 2;            /*!< [9..8] Region 11 mode                                                     */
      __IOM uint32_t R10        : 2;            /*!< [11..10] Region 10 mode                                                   */
      __IOM uint32_t R9         : 2;            /*!< [13..12] Region 9 mode                                                    */
      __IOM uint32_t R8         : 2;            /*!< [15..14] Region 8 mode                                                    */
      __IOM uint32_t R7         : 2;            /*!< [17..16] Region 7 mode                                                    */
      __IOM uint32_t R6         : 2;            /*!< [19..18] Region 6 mode                                                    */
      __IOM uint32_t R5         : 2;            /*!< [21..20] Region 5 mode                                                    */
      __IOM uint32_t R4         : 2;            /*!< [23..22] Region 4 mode                                                    */
      __IOM uint32_t R3         : 2;            /*!< [25..24] Region 3 mode                                                    */
      __IOM uint32_t R2         : 2;            /*!< [27..26] Region 2 mode                                                    */
      __IOM uint32_t R1         : 2;            /*!< [29..28] Region 1 mode                                                    */
      __IOM uint32_t R0         : 2;            /*!< [31..30] Region 0 mode                                                    */
    } LMEM_PCCRMR_b;
  } ;
} LMEM_Type;                                    /*!< Size = 36 (0x24)                                                          */



/* =========================================================================================================================== */
/* ================                                          MTB_DWT                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief MTB data watchpoint and trace (MTB_DWT)
  */

typedef struct {                                /*!< (@ 0xF0001000) MTB_DWT Structure                                          */

  union {
    __IM  uint32_t MTB_DWT_CTRL;                /*!< (@ 0x00000000) MTB DWT Control Register                                   */

    struct {
      __IM  uint32_t DWTCFGCTRL : 28;           /*!< [27..0] DWT configuration controls                                        */
      __IM  uint32_t NUMCMP     : 4;            /*!< [31..28] Number of comparators                                            */
    } MTB_DWT_CTRL_b;
  } ;
  __IM  uint32_t  RESERVED[7];

  union {
    __IOM uint32_t MTB_DWT_COMP0;               /*!< (@ 0x00000020) MTB_DWT Comparator Register                                */

    struct {
      __IOM uint32_t COMP       : 32;           /*!< [31..0] Reference value for comparison                                    */
    } MTB_DWT_COMP0_b;
  } ;

  union {
    __IOM uint32_t MTB_DWT_MASK0;               /*!< (@ 0x00000024) MTB_DWT Comparator Mask Register                           */

    struct {
      __IOM uint32_t MASK       : 5;            /*!< [4..0] MASK                                                               */
            uint32_t            : 27;
    } MTB_DWT_MASK0_b;
  } ;

  union {
    __IOM uint32_t MTB_DWT_FCT0;                /*!< (@ 0x00000028) MTB_DWT Comparator Function Register 0                     */

    struct {
      __IOM uint32_t FUNCTION   : 4;            /*!< [3..0] Function                                                           */
            uint32_t            : 4;
      __IOM uint32_t DATAVMATCH : 1;            /*!< [8..8] Data Value Match                                                   */
            uint32_t            : 1;
      __IOM uint32_t DATAVSIZE  : 2;            /*!< [11..10] Data Value Size                                                  */
      __IOM uint32_t DATAVADDR0 : 4;            /*!< [15..12] Data Value Address 0                                             */
            uint32_t            : 8;
      __IM  uint32_t MATCHED    : 1;            /*!< [24..24] Comparator match                                                 */
            uint32_t            : 7;
    } MTB_DWT_FCT0_b;
  } ;
  __IM  uint32_t  RESERVED1;

  union {
    __IOM uint32_t MTB_DWT_COMP1;               /*!< (@ 0x00000030) MTB_DWT Comparator Register                                */

    struct {
      __IOM uint32_t COMP       : 32;           /*!< [31..0] Reference value for comparison                                    */
    } MTB_DWT_COMP1_b;
  } ;

  union {
    __IOM uint32_t MTB_DWT_MASK1;               /*!< (@ 0x00000034) MTB_DWT Comparator Mask Register                           */

    struct {
      __IOM uint32_t MASK       : 5;            /*!< [4..0] MASK                                                               */
            uint32_t            : 27;
    } MTB_DWT_MASK1_b;
  } ;

  union {
    __IOM uint32_t MTB_DWT_FCT1;                /*!< (@ 0x00000038) MTB_DWT Comparator Function Register 1                     */

    struct {
      __IOM uint32_t FUNCTION   : 4;            /*!< [3..0] Function                                                           */
            uint32_t            : 20;
      __IM  uint32_t MATCHED    : 1;            /*!< [24..24] Comparator match                                                 */
            uint32_t            : 7;
    } MTB_DWT_FCT1_b;
  } ;
  __IM  uint32_t  RESERVED2[113];

  union {
    __IOM uint32_t MTB_DWT_TBCTRL;              /*!< (@ 0x00000200) MTB_DWT Trace Buffer Control Register                      */

    struct {
      __IOM uint32_t ACOMP0     : 1;            /*!< [0..0] Action based on Comparator 0 match                                 */
      __IOM uint32_t ACOMP1     : 1;            /*!< [1..1] Action based on Comparator 1 match                                 */
            uint32_t            : 26;
      __IM  uint32_t NUMCOMP    : 4;            /*!< [31..28] Number of Comparators                                            */
    } MTB_DWT_TBCTRL_b;
  } ;
  __IM  uint32_t  RESERVED3[881];

  union {
    __IM  uint32_t MTB_DWT_DEVICECFG;           /*!< (@ 0x00000FC8) Device Configuration Register                              */

    struct {
      __IM  uint32_t DEVICECFG  : 32;           /*!< [31..0] DEVICECFG                                                         */
    } MTB_DWT_DEVICECFG_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_DEVICETYPID;         /*!< (@ 0x00000FCC) Device Type Identifier Register                            */

    struct {
      __IM  uint32_t DEVICETYPID : 32;          /*!< [31..0] DEVICETYPID                                                       */
    } MTB_DWT_DEVICETYPID_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_PERIPHID4;           /*!< (@ 0x00000FD0) Peripheral ID Register                                     */

    struct {
      __IM  uint32_t PERIPHID   : 32;           /*!< [31..0] PERIPHID                                                          */
    } MTB_DWT_PERIPHID4_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_PERIPHID5;           /*!< (@ 0x00000FD4) Peripheral ID Register                                     */

    struct {
      __IM  uint32_t PERIPHID   : 32;           /*!< [31..0] PERIPHID                                                          */
    } MTB_DWT_PERIPHID5_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_PERIPHID6;           /*!< (@ 0x00000FD8) Peripheral ID Register                                     */

    struct {
      __IM  uint32_t PERIPHID   : 32;           /*!< [31..0] PERIPHID                                                          */
    } MTB_DWT_PERIPHID6_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_PERIPHID7;           /*!< (@ 0x00000FDC) Peripheral ID Register                                     */

    struct {
      __IM  uint32_t PERIPHID   : 32;           /*!< [31..0] PERIPHID                                                          */
    } MTB_DWT_PERIPHID7_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_PERIPHID0;           /*!< (@ 0x00000FE0) Peripheral ID Register                                     */

    struct {
      __IM  uint32_t PERIPHID   : 32;           /*!< [31..0] PERIPHID                                                          */
    } MTB_DWT_PERIPHID0_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_PERIPHID1;           /*!< (@ 0x00000FE4) Peripheral ID Register                                     */

    struct {
      __IM  uint32_t PERIPHID   : 32;           /*!< [31..0] PERIPHID                                                          */
    } MTB_DWT_PERIPHID1_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_PERIPHID2;           /*!< (@ 0x00000FE8) Peripheral ID Register                                     */

    struct {
      __IM  uint32_t PERIPHID   : 32;           /*!< [31..0] PERIPHID                                                          */
    } MTB_DWT_PERIPHID2_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_PERIPHID3;           /*!< (@ 0x00000FEC) Peripheral ID Register                                     */

    struct {
      __IM  uint32_t PERIPHID   : 32;           /*!< [31..0] PERIPHID                                                          */
    } MTB_DWT_PERIPHID3_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_COMPID0;             /*!< (@ 0x00000FF0) Component ID Register                                      */

    struct {
      __IM  uint32_t COMPID     : 32;           /*!< [31..0] Component ID                                                      */
    } MTB_DWT_COMPID0_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_COMPID1;             /*!< (@ 0x00000FF4) Component ID Register                                      */

    struct {
      __IM  uint32_t COMPID     : 32;           /*!< [31..0] Component ID                                                      */
    } MTB_DWT_COMPID1_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_COMPID2;             /*!< (@ 0x00000FF8) Component ID Register                                      */

    struct {
      __IM  uint32_t COMPID     : 32;           /*!< [31..0] Component ID                                                      */
    } MTB_DWT_COMPID2_b;
  } ;

  union {
    __IM  uint32_t MTB_DWT_COMPID3;             /*!< (@ 0x00000FFC) Component ID Register                                      */

    struct {
      __IM  uint32_t COMPID     : 32;           /*!< [31..0] Component ID                                                      */
    } MTB_DWT_COMPID3_b;
  } ;
} MTB_DWT_Type;                                 /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                            MCM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Core Platform Miscellaneous Control Module (MCM)
  */

typedef struct {                                /*!< (@ 0xF0003000) MCM Structure                                              */
  __IM  uint32_t  RESERVED[2];

  union {
    __IM  uint16_t MCM_PLASC;                   /*!< (@ 0x00000008) Crossbar Switch (AXBS) Slave Configuration                 */

    struct {
      __IM  uint16_t ASC        : 8;            /*!< [7..0] Each bit in the ASC field indicates whether there is
                                                     a corresponding connection to the crossbar switchs slave
                                                     input port.                                                               */
            uint16_t            : 8;
    } MCM_PLASC_b;
  } ;

  union {
    __IM  uint16_t MCM_PLAMC;                   /*!< (@ 0x0000000A) Crossbar Switch (AXBS) Master Configuration                */

    struct {
      __IM  uint16_t AMC        : 8;            /*!< [7..0] Each bit in the AMC field indicates whether there is
                                                     a corresponding connection to the AXBS master input port.                 */
            uint16_t            : 8;
    } MCM_PLAMC_b;
  } ;

  union {
    __IOM uint32_t MCM_CPCR;                    /*!< (@ 0x0000000C) Core Platform Control Register                             */

    struct {
      __IM  uint32_t HLT_FSM_ST : 2;            /*!< [1..0] AXBS Halt State Machine Status                                     */
      __IM  uint32_t AXBS_HLT_REQ : 1;          /*!< [2..2] AXBS Halt Request                                                  */
      __IM  uint32_t AXBS_HLTD  : 1;            /*!< [3..3] AXBS Halted                                                        */
      __IM  uint32_t FMC_PF_IDLE : 1;           /*!< [4..4] Flash Memory Controller Program Flash Idle                         */
            uint32_t            : 1;
      __IM  uint32_t PBRIDGE_IDLE : 1;          /*!< [6..6] Peripheral Bridge Idle                                             */
            uint32_t            : 2;
      __IOM uint32_t CBRR       : 1;            /*!< [9..9] Crossbar Round-robin Arbitration Enable                            */
            uint32_t            : 22;
    } MCM_CPCR_b;
  } ;
  __IM  uint32_t  RESERVED1[8];

  union {
    __IOM uint32_t MCM_PID;                     /*!< (@ 0x00000030) Process ID Register                                        */

    struct {
      __IOM uint32_t PID        : 8;            /*!< [7..0] M0_PID and M1_PID for MPU                                          */
            uint32_t            : 24;
    } MCM_PID_b;
  } ;
  __IM  uint32_t  RESERVED2[3];

  union {
    __IOM uint32_t MCM_CPO;                     /*!< (@ 0x00000040) Compute Operation Control Register                         */

    struct {
      __IOM uint32_t CPOREQ     : 1;            /*!< [0..0] Compute Operation Request                                          */
      __IM  uint32_t CPOACK     : 1;            /*!< [1..1] Compute Operation Acknowledge                                      */
      __IOM uint32_t CPOWOI     : 1;            /*!< [2..2] Compute Operation Wakeup On Interrupt                              */
            uint32_t            : 29;
    } MCM_CPO_b;
  } ;
  __IM  uint32_t  RESERVED3[239];

  union {
    __IOM uint32_t MCM_LMDR0;                   /*!< (@ 0x00000400) Local Memory Descriptor Register                           */

    struct {
      __IOM uint32_t CF0        : 4;            /*!< [3..0] Control Field 0 LMDR0[CF0] bit field is Reserved and
                                                     Read-Only 0 for S32K11x variants.                                         */
            uint32_t            : 9;
      __IM  uint32_t MT         : 3;            /*!< [15..13] Memory Type                                                      */
            uint32_t            : 1;
      __IM  uint32_t DPW        : 3;            /*!< [19..17] LMEM Data Path Width. This field defines the width
                                                     of the local memory.                                                      */
      __IM  uint32_t WY         : 4;            /*!< [23..20] Level 1 Cache Ways                                               */
      __IM  uint32_t LMSZ       : 4;            /*!< [27..24] LMEM Size                                                        */
      __IM  uint32_t LMSZH      : 1;            /*!< [28..28] LMEM Size Hole                                                   */
            uint32_t            : 2;
      __IM  uint32_t V          : 1;            /*!< [31..31] Local Memory Valid                                               */
    } MCM_LMDR0_b;
  } ;

  union {
    __IOM uint32_t MCM_LMDR1;                   /*!< (@ 0x00000404) Local Memory Descriptor Register                           */

    struct {
      __IOM uint32_t CF0        : 4;            /*!< [3..0] Control Field 0 LMDR0[CF0] bit field is Reserved and
                                                     Read-Only 0 for S32K11x variants.                                         */
            uint32_t            : 9;
      __IM  uint32_t MT         : 3;            /*!< [15..13] Memory Type                                                      */
            uint32_t            : 1;
      __IM  uint32_t DPW        : 3;            /*!< [19..17] LMEM Data Path Width. This field defines the width
                                                     of the local memory.                                                      */
      __IM  uint32_t WY         : 4;            /*!< [23..20] Level 1 Cache Ways                                               */
      __IM  uint32_t LMSZ       : 4;            /*!< [27..24] LMEM Size                                                        */
      __IM  uint32_t LMSZH      : 1;            /*!< [28..28] LMEM Size Hole                                                   */
            uint32_t            : 2;
      __IM  uint32_t V          : 1;            /*!< [31..31] Local Memory Valid                                               */
    } MCM_LMDR1_b;
  } ;
  __IM  uint32_t  RESERVED4[30];
  __IM  uint32_t  MCM_LMPECR;                   /*!< (@ 0x00000480) LMEM Parity and ECC Control Register                       */
  __IM  uint32_t  RESERVED5;

  union {
    __IOM uint32_t MCM_LMPEIR;                  /*!< (@ 0x00000488) LMEM Parity and ECC Interrupt Register                     */

    struct {
      __IOM uint32_t ENC        : 8;            /*!< [7..0] ENCn = ECC Noncorrectable Error n                                  */
      __IOM uint32_t E1B        : 8;            /*!< [15..8] E1Bn = ECC 1-bit Error n                                          */
            uint32_t            : 8;
      __IM  uint32_t PEELOC     : 5;            /*!< [28..24] Parity or ECC Error Location                                     */
            uint32_t            : 2;
      __IM  uint32_t V          : 1;            /*!< [31..31] Valid Bit                                                        */
    } MCM_LMPEIR_b;
  } ;
  __IM  uint32_t  RESERVED6;

  union {
    __IM  uint32_t MCM_LMFAR;                   /*!< (@ 0x00000490) LMEM Fault Address Register                                */

    struct {
      __IM  uint32_t EFADD      : 32;           /*!< [31..0] ECC Fault Address                                                 */
    } MCM_LMFAR_b;
  } ;

  union {
    __IM  uint32_t MCM_LMFATR;                  /*!< (@ 0x00000494) LMEM Fault Attribute Register                              */

    struct {
      __IM  uint32_t PEFPRT     : 4;            /*!< [3..0] Parity/ECC Fault Protection                                        */
      __IM  uint32_t PEFSIZE    : 3;            /*!< [6..4] Parity/ECC Fault Master Size                                       */
      __IM  uint32_t PEFW       : 1;            /*!< [7..7] Parity/ECC Fault Write                                             */
      __IM  uint32_t PEFMST     : 8;            /*!< [15..8] Parity/ECC Fault Master Number                                    */
            uint32_t            : 15;
      __IM  uint32_t OVR        : 1;            /*!< [31..31] Overrun                                                          */
    } MCM_LMFATR_b;
  } ;
  __IM  uint32_t  RESERVED7[2];

  union {
    __IM  uint32_t MCM_LMFDHR;                  /*!< (@ 0x000004A0) LMEM Fault Data High Register                              */

    struct {
      __IM  uint32_t PEFDH      : 32;           /*!< [31..0] Parity or ECC Fault Data High                                     */
    } MCM_LMFDHR_b;
  } ;

  union {
    __IM  uint32_t MCM_LMFDLR;                  /*!< (@ 0x000004A4) LMEM Fault Data Low Register                               */

    struct {
      __IM  uint32_t PEFDL      : 32;           /*!< [31..0] Parity or ECC Fault Data Low                                      */
    } MCM_LMFDLR_b;
  } ;
} MCM_Type;                                     /*!< Size = 1192 (0x4a8)                                                       */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define CSE_PRAM_BASE               0x14000800UL
#define AIPS_BASE                   0x40000000UL
#define MSCM_BASE                   0x40001000UL
#define DMA_BASE                    0x40008000UL
#define MPU_BASE                    0x4000D000UL
#define ERM_BASE                    0x40018000UL
#define EIM_BASE                    0x40019000UL
#define FTFC_BASE                   0x40020000UL
#define DMAMUX_BASE                 0x40021000UL
#define CAN0_BASE                   0x40024000UL
#define LPSPI0_BASE                 0x4002C000UL
#define CRC_BASE                    0x40032000UL
#define PDB0_BASE                   0x40036000UL
#define LPIT0_BASE                  0x40037000UL
#define FTM0_BASE                   0x40038000UL
#define FTM1_BASE                   0x40039000UL
#define ADC0_BASE                   0x4003B000UL
#define RTC_BASE                    0x4003D000UL
#define CMU_FC_0_BASE               0x4003E000UL
#define CMU_FC_1_BASE               0x4003F000UL
#define LPTMR0_BASE                 0x40040000UL
#define SIM_BASE                    0x40048000UL
#define PORTA_BASE                  0x40049000UL
#define PORTB_BASE                  0x4004A000UL
#define PORTC_BASE                  0x4004B000UL
#define PORTD_BASE                  0x4004C000UL
#define PORTE_BASE                  0x4004D000UL
#define WDOG_BASE                   0x40052000UL
#define FLEXIO_BASE                 0x4005A000UL
#define TRGMUX_BASE                 0x40063000UL
#define SCG_BASE                    0x40064000UL
#define PCC_BASE                    0x40065000UL
#define LPI2C0_BASE                 0x40066000UL
#define LPUART0_BASE                0x4006A000UL
#define LPUART1_BASE                0x4006B000UL
#define CMP0_BASE                   0x40073000UL
#define PMC_BASE                    0x4007D000UL
#define SMC_BASE                    0x4007E000UL
#define RCM_BASE                    0x4007F000UL
#define PTA_BASE                    0x400FF000UL
#define PTB_BASE                    0x400FF040UL
#define PTC_BASE                    0x400FF080UL
#define PTD_BASE                    0x400FF0C0UL
#define PTE_BASE                    0x400FF100UL
#define S32_SCB_BASE                0xE000E000UL
#define S32_SysTick_BASE            0xE000E010UL
#define S32_NVIC_BASE               0xE000E100UL
#define LMEM_BASE                   0xE0082000UL
#define MTB_DWT_BASE                0xF0001000UL
#define MCM_BASE                    0xF0003000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define CSE_PRAM                    ((CSE_PRAM_Type*)          CSE_PRAM_BASE)
#define AIPS                        ((AIPS_Type*)              AIPS_BASE)
#define MSCM                        ((MSCM_Type*)              MSCM_BASE)
#define DMA                         ((DMA_Type*)               DMA_BASE)
#define MPU                         ((MPU_Type*)               MPU_BASE)
#define ERM                         ((ERM_Type*)               ERM_BASE)
#define EIM                         ((EIM_Type*)               EIM_BASE)
#define FTFC                        ((FTFC_Type*)              FTFC_BASE)
#define DMAMUX                      ((DMAMUX_Type*)            DMAMUX_BASE)
#define CAN0                        ((CAN0_Type*)              CAN0_BASE)
#define LPSPI0                      ((LPSPI0_Type*)            LPSPI0_BASE)
#define CRC                         ((CRC_Type*)               CRC_BASE)
#define PDB0                        ((PDB0_Type*)              PDB0_BASE)
#define LPIT0                       ((LPIT0_Type*)             LPIT0_BASE)
#define FTM0                        ((FTM0_Type*)              FTM0_BASE)
#define FTM1                        ((FTM1_Type*)              FTM1_BASE)
#define ADC0                        ((ADC0_Type*)              ADC0_BASE)
#define RTC                         ((RTC_Type*)               RTC_BASE)
#define CMU_FC_0                    ((CMU_FC_0_Type*)          CMU_FC_0_BASE)
#define CMU_FC_1                    ((CMU_FC_1_Type*)          CMU_FC_1_BASE)
#define LPTMR0                      ((LPTMR0_Type*)            LPTMR0_BASE)
#define SIM                         ((SIM_Type*)               SIM_BASE)
#define PORTA                       ((PORTA_Type*)             PORTA_BASE)
#define PORTB                       ((PORTB_Type*)             PORTB_BASE)
#define PORTC                       ((PORTC_Type*)             PORTC_BASE)
#define PORTD                       ((PORTD_Type*)             PORTD_BASE)
#define PORTE                       ((PORTE_Type*)             PORTE_BASE)
#define WDOG                        ((WDOG_Type*)              WDOG_BASE)
#define FLEXIO                      ((FLEXIO_Type*)            FLEXIO_BASE)
#define TRGMUX                      ((TRGMUX_Type*)            TRGMUX_BASE)
#define SCG                         ((SCG_Type*)               SCG_BASE)
#define PCC                         ((PCC_Type*)               PCC_BASE)
#define LPI2C0                      ((LPI2C0_Type*)            LPI2C0_BASE)
#define LPUART0                     ((LPUART0_Type*)           LPUART0_BASE)
#define LPUART1                     ((LPUART1_Type*)           LPUART1_BASE)
#define CMP0                        ((CMP0_Type*)              CMP0_BASE)
#define PMC                         ((PMC_Type*)               PMC_BASE)
#define SMC                         ((SMC_Type*)               SMC_BASE)
#define RCM                         ((RCM_Type*)               RCM_BASE)
#define PTA                         ((PTA_Type*)               PTA_BASE)
#define PTB                         ((PTB_Type*)               PTB_BASE)
#define PTC                         ((PTC_Type*)               PTC_BASE)
#define PTD                         ((PTD_Type*)               PTD_BASE)
#define PTE                         ((PTE_Type*)               PTE_BASE)
#define S32_SCB                     ((S32_SCB_Type*)           S32_SCB_BASE)
#define S32_SysTick                 ((S32_SysTick_Type*)       S32_SysTick_BASE)
#define S32_NVIC                    ((S32_NVIC_Type*)          S32_NVIC_BASE)
#define LMEM                        ((LMEM_Type*)              LMEM_BASE)
#define MTB_DWT                     ((MTB_DWT_Type*)           MTB_DWT_BASE)
#define MCM                         ((MCM_Type*)               MCM_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


/* =========================================================================================================================== */
/* ================                           Enumerated Values Peripheral Section                            ================ */
/* =========================================================================================================================== */


/** @addtogroup EnumValue_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                         CSE_PRAM                                          ================ */
/* =========================================================================================================================== */

/* ============================================  CSE_PRAM_EmbeddedRAM0_CSE_PRAM  ============================================= */
/* ===========================================  CSE_PRAM_EmbeddedRAM0LL_CSE_PRAM  ============================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM0LU  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM0HL  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM0HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM1_CSE_PRAM  ============================================= */
/* ===========================================  CSE_PRAM_EmbeddedRAM1LL_CSE_PRAM  ============================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM1LU  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM1HL  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM1HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM2_CSE_PRAM  ============================================= */
/* ===========================================  CSE_PRAM_EmbeddedRAM2LL_CSE_PRAM  ============================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM2LU  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM2HL  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM2HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM3_CSE_PRAM  ============================================= */
/* ===========================================  CSE_PRAM_EmbeddedRAM3LL_CSE_PRAM  ============================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM3LU  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM3HL  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM3HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM4_CSE_PRAM  ============================================= */
/* ===========================================  CSE_PRAM_EmbeddedRAM4LL_CSE_PRAM  ============================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM4LU  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM4HL  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM4HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM5_CSE_PRAM  ============================================= */
/* ===========================================  CSE_PRAM_EmbeddedRAM5LL_CSE_PRAM  ============================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM5LU  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM5HL  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM5HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM6_CSE_PRAM  ============================================= */
/* ===========================================  CSE_PRAM_EmbeddedRAM6LL_CSE_PRAM  ============================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM6LU  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM6HL  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM6HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM7_CSE_PRAM  ============================================= */
/* ===========================================  CSE_PRAM_EmbeddedRAM7LL_CSE_PRAM  ============================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM7LU  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM7HL  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM7HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM8_CSE_PRAM  ============================================= */
/* ===========================================  CSE_PRAM_EmbeddedRAM8LL_CSE_PRAM  ============================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM8LU  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM8HL  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM8HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM9_CSE_PRAM  ============================================= */
/* ===========================================  CSE_PRAM_EmbeddedRAM9LL_CSE_PRAM  ============================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM9LU  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM9HL  ================================================ */
/* ================================================  CSE_PRAM_EmbeddedRAM9HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM10_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM10LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM10LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM10HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM10HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM11_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM11LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM11LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM11HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM11HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM12_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM12LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM12LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM12HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM12HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM13_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM13LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM13LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM13HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM13HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM14_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM14LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM14LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM14HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM14HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM15_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM15LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM15LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM15HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM15HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM16_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM16LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM16LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM16HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM16HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM17_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM17LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM17LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM17HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM17HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM18_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM18LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM18LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM18HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM18HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM19_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM19LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM19LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM19HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM19HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM20_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM20LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM20LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM20HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM20HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM21_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM21LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM21LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM21HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM21HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM22_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM22LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM22LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM22HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM22HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM23_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM23LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM23LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM23HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM23HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM24_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM24LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM24LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM24HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM24HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM25_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM25LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM25LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM25HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM25HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM26_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM26LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM26LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM26HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM26HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM27_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM27LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM27LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM27HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM27HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM28_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM28LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM28LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM28HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM28HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM29_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM29LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM29LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM29HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM29HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM30_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM30LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM30LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM30HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM30HU  ================================================ */
/* ============================================  CSE_PRAM_EmbeddedRAM31_CSE_PRAM  ============================================ */
/* ===========================================  CSE_PRAM_EmbeddedRAM31LL_CSE_PRAM  =========================================== */
/* ===============================================  CSE_PRAM_EmbeddedRAM31LU  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM31HL  ================================================ */
/* ===============================================  CSE_PRAM_EmbeddedRAM31HU  ================================================ */


/* =========================================================================================================================== */
/* ================                                           AIPS                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  AIPS_MPRA  ======================================================= */
/* =============================================  AIPS AIPS_MPRA MPL2 [20..20]  ============================================== */
typedef enum {                                  /*!< AIPS_MPRA_MPL2                                                            */
  AIPS_MPRA_MPL2_0                     = 0,     /*!< 0 : Accesses from this master are forced to user-mode.                    */
  AIPS_MPRA_MPL2_1                     = 1,     /*!< 1 : Accesses from this master are not forced to user-mode.                */
} AIPS_MPRA_MPL2_Enum;

/* =============================================  AIPS AIPS_MPRA MTW2 [21..21]  ============================================== */
typedef enum {                                  /*!< AIPS_MPRA_MTW2                                                            */
  AIPS_MPRA_MTW2_0                     = 0,     /*!< 0 : This master is not trusted for write accesses.                        */
  AIPS_MPRA_MTW2_1                     = 1,     /*!< 1 : This master is trusted for write accesses.                            */
} AIPS_MPRA_MTW2_Enum;

/* =============================================  AIPS AIPS_MPRA MTR2 [22..22]  ============================================== */
typedef enum {                                  /*!< AIPS_MPRA_MTR2                                                            */
  AIPS_MPRA_MTR2_0                     = 0,     /*!< 0 : This master is not trusted for read accesses.                         */
  AIPS_MPRA_MTR2_1                     = 1,     /*!< 1 : This master is trusted for read accesses.                             */
} AIPS_MPRA_MTR2_Enum;

/* =============================================  AIPS AIPS_MPRA MPL1 [24..24]  ============================================== */
typedef enum {                                  /*!< AIPS_MPRA_MPL1                                                            */
  AIPS_MPRA_MPL1_0                     = 0,     /*!< 0 : Accesses from this master are forced to user-mode.                    */
  AIPS_MPRA_MPL1_1                     = 1,     /*!< 1 : Accesses from this master are not forced to user-mode.                */
} AIPS_MPRA_MPL1_Enum;

/* =============================================  AIPS AIPS_MPRA MTW1 [25..25]  ============================================== */
typedef enum {                                  /*!< AIPS_MPRA_MTW1                                                            */
  AIPS_MPRA_MTW1_0                     = 0,     /*!< 0 : This master is not trusted for write accesses.                        */
  AIPS_MPRA_MTW1_1                     = 1,     /*!< 1 : This master is trusted for write accesses.                            */
} AIPS_MPRA_MTW1_Enum;

/* =============================================  AIPS AIPS_MPRA MTR1 [26..26]  ============================================== */
typedef enum {                                  /*!< AIPS_MPRA_MTR1                                                            */
  AIPS_MPRA_MTR1_0                     = 0,     /*!< 0 : This master is not trusted for read accesses.                         */
  AIPS_MPRA_MTR1_1                     = 1,     /*!< 1 : This master is trusted for read accesses.                             */
} AIPS_MPRA_MTR1_Enum;

/* =============================================  AIPS AIPS_MPRA MPL0 [28..28]  ============================================== */
typedef enum {                                  /*!< AIPS_MPRA_MPL0                                                            */
  AIPS_MPRA_MPL0_0                     = 0,     /*!< 0 : Accesses from this master are forced to user-mode.                    */
  AIPS_MPRA_MPL0_1                     = 1,     /*!< 1 : Accesses from this master are not forced to user-mode.                */
} AIPS_MPRA_MPL0_Enum;

/* =============================================  AIPS AIPS_MPRA MTW0 [29..29]  ============================================== */
typedef enum {                                  /*!< AIPS_MPRA_MTW0                                                            */
  AIPS_MPRA_MTW0_0                     = 0,     /*!< 0 : This master is not trusted for write accesses.                        */
  AIPS_MPRA_MTW0_1                     = 1,     /*!< 1 : This master is trusted for write accesses.                            */
} AIPS_MPRA_MTW0_Enum;

/* =============================================  AIPS AIPS_MPRA MTR0 [30..30]  ============================================== */
typedef enum {                                  /*!< AIPS_MPRA_MTR0                                                            */
  AIPS_MPRA_MTR0_0                     = 0,     /*!< 0 : This master is not trusted for read accesses.                         */
  AIPS_MPRA_MTR0_1                     = 1,     /*!< 1 : This master is trusted for read accesses.                             */
} AIPS_MPRA_MTR0_Enum;

/* ======================================================  AIPS_PACRA  ======================================================= */
/* =============================================  AIPS AIPS_PACRA TP1 [24..24]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRA_TP1                                                            */
  AIPS_PACRA_TP1_0                     = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_PACRA_TP1_1                     = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_PACRA_TP1_Enum;

/* =============================================  AIPS AIPS_PACRA WP1 [25..25]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRA_WP1                                                            */
  AIPS_PACRA_WP1_0                     = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_PACRA_WP1_1                     = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_PACRA_WP1_Enum;

/* =============================================  AIPS AIPS_PACRA SP1 [26..26]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRA_SP1                                                            */
  AIPS_PACRA_SP1_0                     = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                                    for accesses.                                              */
  AIPS_PACRA_SP1_1                     = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_PACRA_SP1_Enum;

/* =============================================  AIPS AIPS_PACRA TP0 [28..28]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRA_TP0                                                            */
  AIPS_PACRA_TP0_0                     = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_PACRA_TP0_1                     = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_PACRA_TP0_Enum;

/* =============================================  AIPS AIPS_PACRA WP0 [29..29]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRA_WP0                                                            */
  AIPS_PACRA_WP0_0                     = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_PACRA_WP0_1                     = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_PACRA_WP0_Enum;

/* =============================================  AIPS AIPS_PACRA SP0 [30..30]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRA_SP0                                                            */
  AIPS_PACRA_SP0_0                     = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_PACRA_SP0_1                     = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_PACRA_SP0_Enum;

/* ======================================================  AIPS_PACRB  ======================================================= */
/* ==============================================  AIPS AIPS_PACRB TP5 [8..8]  =============================================== */
typedef enum {                                  /*!< AIPS_PACRB_TP5                                                            */
  AIPS_PACRB_TP5_0                     = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_PACRB_TP5_1                     = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_PACRB_TP5_Enum;

/* ==============================================  AIPS AIPS_PACRB WP5 [9..9]  =============================================== */
typedef enum {                                  /*!< AIPS_PACRB_WP5                                                            */
  AIPS_PACRB_WP5_0                     = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_PACRB_WP5_1                     = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_PACRB_WP5_Enum;

/* =============================================  AIPS AIPS_PACRB SP5 [10..10]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRB_SP5                                                            */
  AIPS_PACRB_SP5_0                     = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_PACRB_SP5_1                     = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_PACRB_SP5_Enum;

/* =============================================  AIPS AIPS_PACRB TP1 [24..24]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRB_TP1                                                            */
  AIPS_PACRB_TP1_0                     = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_PACRB_TP1_1                     = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_PACRB_TP1_Enum;

/* =============================================  AIPS AIPS_PACRB WP1 [25..25]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRB_WP1                                                            */
  AIPS_PACRB_WP1_0                     = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_PACRB_WP1_1                     = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_PACRB_WP1_Enum;

/* =============================================  AIPS AIPS_PACRB SP1 [26..26]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRB_SP1                                                            */
  AIPS_PACRB_SP1_0                     = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_PACRB_SP1_1                     = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_PACRB_SP1_Enum;

/* =============================================  AIPS AIPS_PACRB TP0 [28..28]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRB_TP0                                                            */
  AIPS_PACRB_TP0_0                     = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_PACRB_TP0_1                     = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_PACRB_TP0_Enum;

/* =============================================  AIPS AIPS_PACRB WP0 [29..29]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRB_WP0                                                            */
  AIPS_PACRB_WP0_0                     = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_PACRB_WP0_1                     = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_PACRB_WP0_Enum;

/* =============================================  AIPS AIPS_PACRB SP0 [30..30]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRB_SP0                                                            */
  AIPS_PACRB_SP0_0                     = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_PACRB_SP0_1                     = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_PACRB_SP0_Enum;

/* ======================================================  AIPS_PACRC  ======================================================= */
/* ======================================================  AIPS_PACRD  ======================================================= */
/* =============================================  AIPS AIPS_PACRD TP1 [24..24]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRD_TP1                                                            */
  AIPS_PACRD_TP1_0                     = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_PACRD_TP1_1                     = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_PACRD_TP1_Enum;

/* =============================================  AIPS AIPS_PACRD WP1 [25..25]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRD_WP1                                                            */
  AIPS_PACRD_WP1_0                     = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_PACRD_WP1_1                     = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_PACRD_WP1_Enum;

/* =============================================  AIPS AIPS_PACRD SP1 [26..26]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRD_SP1                                                            */
  AIPS_PACRD_SP1_0                     = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_PACRD_SP1_1                     = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_PACRD_SP1_Enum;

/* =============================================  AIPS AIPS_PACRD TP0 [28..28]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRD_TP0                                                            */
  AIPS_PACRD_TP0_0                     = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_PACRD_TP0_1                     = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_PACRD_TP0_Enum;

/* =============================================  AIPS AIPS_PACRD WP0 [29..29]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRD_WP0                                                            */
  AIPS_PACRD_WP0_0                     = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_PACRD_WP0_1                     = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_PACRD_WP0_Enum;

/* =============================================  AIPS AIPS_PACRD SP0 [30..30]  ============================================== */
typedef enum {                                  /*!< AIPS_PACRD_SP0                                                            */
  AIPS_PACRD_SP0_0                     = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_PACRD_SP0_1                     = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_PACRD_SP0_Enum;

/* ======================================================  AIPS_OPACRA  ====================================================== */
/* ==============================================  AIPS AIPS_OPACRA TP7 [0..0]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRA_TP7                                                           */
  AIPS_OPACRA_TP7_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRA_TP7_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRA_TP7_Enum;

/* ==============================================  AIPS AIPS_OPACRA WP7 [1..1]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRA_WP7                                                           */
  AIPS_OPACRA_WP7_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRA_WP7_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRA_WP7_Enum;

/* ==============================================  AIPS AIPS_OPACRA SP7 [2..2]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRA_SP7                                                           */
  AIPS_OPACRA_SP7_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRA_SP7_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRA_SP7_Enum;

/* ==============================================  AIPS AIPS_OPACRA TP6 [4..4]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRA_TP6                                                           */
  AIPS_OPACRA_TP6_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRA_TP6_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRA_TP6_Enum;

/* ==============================================  AIPS AIPS_OPACRA WP6 [5..5]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRA_WP6                                                           */
  AIPS_OPACRA_WP6_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRA_WP6_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRA_WP6_Enum;

/* ==============================================  AIPS AIPS_OPACRA SP6 [6..6]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRA_SP6                                                           */
  AIPS_OPACRA_SP6_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRA_SP6_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRA_SP6_Enum;

/* ==============================================  AIPS AIPS_OPACRA TP5 [8..8]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRA_TP5                                                           */
  AIPS_OPACRA_TP5_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRA_TP5_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRA_TP5_Enum;

/* ==============================================  AIPS AIPS_OPACRA WP5 [9..9]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRA_WP5                                                           */
  AIPS_OPACRA_WP5_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRA_WP5_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRA_WP5_Enum;

/* =============================================  AIPS AIPS_OPACRA SP5 [10..10]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRA_SP5                                                           */
  AIPS_OPACRA_SP5_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRA_SP5_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRA_SP5_Enum;

/* =============================================  AIPS AIPS_OPACRA TP4 [12..12]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRA_TP4                                                           */
  AIPS_OPACRA_TP4_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRA_TP4_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRA_TP4_Enum;

/* =============================================  AIPS AIPS_OPACRA WP4 [13..13]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRA_WP4                                                           */
  AIPS_OPACRA_WP4_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRA_WP4_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRA_WP4_Enum;

/* =============================================  AIPS AIPS_OPACRA SP4 [14..14]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRA_SP4                                                           */
  AIPS_OPACRA_SP4_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRA_SP4_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRA_SP4_Enum;

/* =============================================  AIPS AIPS_OPACRA TP1 [24..24]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRA_TP1                                                           */
  AIPS_OPACRA_TP1_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRA_TP1_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRA_TP1_Enum;

/* =============================================  AIPS AIPS_OPACRA WP1 [25..25]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRA_WP1                                                           */
  AIPS_OPACRA_WP1_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRA_WP1_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRA_WP1_Enum;

/* =============================================  AIPS AIPS_OPACRA SP1 [26..26]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRA_SP1                                                           */
  AIPS_OPACRA_SP1_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRA_SP1_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRA_SP1_Enum;

/* =============================================  AIPS AIPS_OPACRA TP0 [28..28]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRA_TP0                                                           */
  AIPS_OPACRA_TP0_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRA_TP0_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRA_TP0_Enum;

/* =============================================  AIPS AIPS_OPACRA WP0 [29..29]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRA_WP0                                                           */
  AIPS_OPACRA_WP0_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRA_WP0_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRA_WP0_Enum;

/* =============================================  AIPS AIPS_OPACRA SP0 [30..30]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRA_SP0                                                           */
  AIPS_OPACRA_SP0_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRA_SP0_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRA_SP0_Enum;

/* ======================================================  AIPS_OPACRB  ====================================================== */
/* ==============================================  AIPS AIPS_OPACRB TP6 [4..4]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRB_TP6                                                           */
  AIPS_OPACRB_TP6_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRB_TP6_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRB_TP6_Enum;

/* ==============================================  AIPS AIPS_OPACRB WP6 [5..5]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRB_WP6                                                           */
  AIPS_OPACRB_WP6_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRB_WP6_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRB_WP6_Enum;

/* ==============================================  AIPS AIPS_OPACRB SP6 [6..6]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRB_SP6                                                           */
  AIPS_OPACRB_SP6_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRB_SP6_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRB_SP6_Enum;

/* ==============================================  AIPS AIPS_OPACRB TP5 [8..8]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRB_TP5                                                           */
  AIPS_OPACRB_TP5_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRB_TP5_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRB_TP5_Enum;

/* ==============================================  AIPS AIPS_OPACRB WP5 [9..9]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRB_WP5                                                           */
  AIPS_OPACRB_WP5_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRB_WP5_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRB_WP5_Enum;

/* =============================================  AIPS AIPS_OPACRB SP5 [10..10]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRB_SP5                                                           */
  AIPS_OPACRB_SP5_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRB_SP5_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRB_SP5_Enum;

/* =============================================  AIPS AIPS_OPACRB TP4 [12..12]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRB_TP4                                                           */
  AIPS_OPACRB_TP4_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRB_TP4_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRB_TP4_Enum;

/* =============================================  AIPS AIPS_OPACRB WP4 [13..13]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRB_WP4                                                           */
  AIPS_OPACRB_WP4_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRB_WP4_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRB_WP4_Enum;

/* =============================================  AIPS AIPS_OPACRB SP4 [14..14]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRB_SP4                                                           */
  AIPS_OPACRB_SP4_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRB_SP4_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRB_SP4_Enum;

/* =============================================  AIPS AIPS_OPACRB TP3 [16..16]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRB_TP3                                                           */
  AIPS_OPACRB_TP3_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRB_TP3_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRB_TP3_Enum;

/* =============================================  AIPS AIPS_OPACRB WP3 [17..17]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRB_WP3                                                           */
  AIPS_OPACRB_WP3_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRB_WP3_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRB_WP3_Enum;

/* =============================================  AIPS AIPS_OPACRB SP3 [18..18]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRB_SP3                                                           */
  AIPS_OPACRB_SP3_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRB_SP3_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRB_SP3_Enum;

/* ======================================================  AIPS_OPACRC  ====================================================== */
/* ==============================================  AIPS AIPS_OPACRC TP7 [0..0]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRC_TP7                                                           */
  AIPS_OPACRC_TP7_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRC_TP7_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRC_TP7_Enum;

/* ==============================================  AIPS AIPS_OPACRC WP7 [1..1]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRC_WP7                                                           */
  AIPS_OPACRC_WP7_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRC_WP7_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRC_WP7_Enum;

/* ==============================================  AIPS AIPS_OPACRC SP7 [2..2]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRC_SP7                                                           */
  AIPS_OPACRC_SP7_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRC_SP7_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRC_SP7_Enum;

/* ==============================================  AIPS AIPS_OPACRC TP6 [4..4]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRC_TP6                                                           */
  AIPS_OPACRC_TP6_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRC_TP6_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRC_TP6_Enum;

/* ==============================================  AIPS AIPS_OPACRC WP6 [5..5]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRC_WP6                                                           */
  AIPS_OPACRC_WP6_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRC_WP6_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRC_WP6_Enum;

/* ==============================================  AIPS AIPS_OPACRC SP6 [6..6]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRC_SP6                                                           */
  AIPS_OPACRC_SP6_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRC_SP6_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRC_SP6_Enum;

/* =============================================  AIPS AIPS_OPACRC TP2 [20..20]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRC_TP2                                                           */
  AIPS_OPACRC_TP2_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRC_TP2_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRC_TP2_Enum;

/* =============================================  AIPS AIPS_OPACRC WP2 [21..21]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRC_WP2                                                           */
  AIPS_OPACRC_WP2_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRC_WP2_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRC_WP2_Enum;

/* =============================================  AIPS AIPS_OPACRC SP2 [22..22]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRC_SP2                                                           */
  AIPS_OPACRC_SP2_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRC_SP2_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRC_SP2_Enum;

/* =============================================  AIPS AIPS_OPACRC TP1 [24..24]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRC_TP1                                                           */
  AIPS_OPACRC_TP1_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRC_TP1_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRC_TP1_Enum;

/* =============================================  AIPS AIPS_OPACRC WP1 [25..25]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRC_WP1                                                           */
  AIPS_OPACRC_WP1_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRC_WP1_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRC_WP1_Enum;

/* =============================================  AIPS AIPS_OPACRC SP1 [26..26]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRC_SP1                                                           */
  AIPS_OPACRC_SP1_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRC_SP1_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRC_SP1_Enum;

/* ======================================================  AIPS_OPACRD  ====================================================== */
/* ==============================================  AIPS AIPS_OPACRD TP5 [8..8]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRD_TP5                                                           */
  AIPS_OPACRD_TP5_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRD_TP5_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRD_TP5_Enum;

/* ==============================================  AIPS AIPS_OPACRD WP5 [9..9]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRD_WP5                                                           */
  AIPS_OPACRD_WP5_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRD_WP5_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRD_WP5_Enum;

/* =============================================  AIPS AIPS_OPACRD SP5 [10..10]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_SP5                                                           */
  AIPS_OPACRD_SP5_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRD_SP5_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRD_SP5_Enum;

/* =============================================  AIPS AIPS_OPACRD TP3 [16..16]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_TP3                                                           */
  AIPS_OPACRD_TP3_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRD_TP3_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRD_TP3_Enum;

/* =============================================  AIPS AIPS_OPACRD WP3 [17..17]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_WP3                                                           */
  AIPS_OPACRD_WP3_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRD_WP3_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRD_WP3_Enum;

/* =============================================  AIPS AIPS_OPACRD SP3 [18..18]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_SP3                                                           */
  AIPS_OPACRD_SP3_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRD_SP3_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRD_SP3_Enum;

/* =============================================  AIPS AIPS_OPACRD TP2 [20..20]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_TP2                                                           */
  AIPS_OPACRD_TP2_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRD_TP2_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRD_TP2_Enum;

/* =============================================  AIPS AIPS_OPACRD WP2 [21..21]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_WP2                                                           */
  AIPS_OPACRD_WP2_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRD_WP2_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRD_WP2_Enum;

/* =============================================  AIPS AIPS_OPACRD SP2 [22..22]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_SP2                                                           */
  AIPS_OPACRD_SP2_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRD_SP2_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRD_SP2_Enum;

/* =============================================  AIPS AIPS_OPACRD TP1 [24..24]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_TP1                                                           */
  AIPS_OPACRD_TP1_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRD_TP1_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRD_TP1_Enum;

/* =============================================  AIPS AIPS_OPACRD WP1 [25..25]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_WP1                                                           */
  AIPS_OPACRD_WP1_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRD_WP1_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRD_WP1_Enum;

/* =============================================  AIPS AIPS_OPACRD SP1 [26..26]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_SP1                                                           */
  AIPS_OPACRD_SP1_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRD_SP1_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRD_SP1_Enum;

/* =============================================  AIPS AIPS_OPACRD TP0 [28..28]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_TP0                                                           */
  AIPS_OPACRD_TP0_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRD_TP0_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRD_TP0_Enum;

/* =============================================  AIPS AIPS_OPACRD WP0 [29..29]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_WP0                                                           */
  AIPS_OPACRD_WP0_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRD_WP0_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRD_WP0_Enum;

/* =============================================  AIPS AIPS_OPACRD SP0 [30..30]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRD_SP0                                                           */
  AIPS_OPACRD_SP0_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRD_SP0_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRD_SP0_Enum;

/* ======================================================  AIPS_OPACRE  ====================================================== */
/* ==============================================  AIPS AIPS_OPACRE TP6 [4..4]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRE_TP6                                                           */
  AIPS_OPACRE_TP6_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRE_TP6_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRE_TP6_Enum;

/* ==============================================  AIPS AIPS_OPACRE WP6 [5..5]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRE_WP6                                                           */
  AIPS_OPACRE_WP6_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRE_WP6_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRE_WP6_Enum;

/* ==============================================  AIPS AIPS_OPACRE SP6 [6..6]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRE_SP6                                                           */
  AIPS_OPACRE_SP6_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRE_SP6_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRE_SP6_Enum;

/* =============================================  AIPS AIPS_OPACRE TP0 [28..28]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRE_TP0                                                           */
  AIPS_OPACRE_TP0_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRE_TP0_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRE_TP0_Enum;

/* =============================================  AIPS AIPS_OPACRE WP0 [29..29]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRE_WP0                                                           */
  AIPS_OPACRE_WP0_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRE_WP0_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRE_WP0_Enum;

/* =============================================  AIPS AIPS_OPACRE SP0 [30..30]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRE_SP0                                                           */
  AIPS_OPACRE_SP0_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRE_SP0_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRE_SP0_Enum;

/* ======================================================  AIPS_OPACRF  ====================================================== */
/* ==============================================  AIPS AIPS_OPACRF TP5 [8..8]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRF_TP5                                                           */
  AIPS_OPACRF_TP5_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRF_TP5_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRF_TP5_Enum;

/* ==============================================  AIPS AIPS_OPACRF WP5 [9..9]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRF_WP5                                                           */
  AIPS_OPACRF_WP5_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRF_WP5_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRF_WP5_Enum;

/* =============================================  AIPS AIPS_OPACRF SP5 [10..10]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_SP5                                                           */
  AIPS_OPACRF_SP5_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRF_SP5_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRF_SP5_Enum;

/* =============================================  AIPS AIPS_OPACRF TP4 [12..12]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_TP4                                                           */
  AIPS_OPACRF_TP4_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRF_TP4_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRF_TP4_Enum;

/* =============================================  AIPS AIPS_OPACRF WP4 [13..13]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_WP4                                                           */
  AIPS_OPACRF_WP4_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRF_WP4_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRF_WP4_Enum;

/* =============================================  AIPS AIPS_OPACRF SP4 [14..14]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_SP4                                                           */
  AIPS_OPACRF_SP4_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRF_SP4_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRF_SP4_Enum;

/* =============================================  AIPS AIPS_OPACRF TP3 [16..16]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_TP3                                                           */
  AIPS_OPACRF_TP3_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRF_TP3_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRF_TP3_Enum;

/* =============================================  AIPS AIPS_OPACRF WP3 [17..17]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_WP3                                                           */
  AIPS_OPACRF_WP3_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRF_WP3_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRF_WP3_Enum;

/* =============================================  AIPS AIPS_OPACRF SP3 [18..18]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_SP3                                                           */
  AIPS_OPACRF_SP3_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRF_SP3_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRF_SP3_Enum;

/* =============================================  AIPS AIPS_OPACRF TP2 [20..20]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_TP2                                                           */
  AIPS_OPACRF_TP2_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRF_TP2_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRF_TP2_Enum;

/* =============================================  AIPS AIPS_OPACRF WP2 [21..21]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_WP2                                                           */
  AIPS_OPACRF_WP2_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRF_WP2_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRF_WP2_Enum;

/* =============================================  AIPS AIPS_OPACRF SP2 [22..22]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_SP2                                                           */
  AIPS_OPACRF_SP2_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRF_SP2_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRF_SP2_Enum;

/* =============================================  AIPS AIPS_OPACRF TP1 [24..24]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_TP1                                                           */
  AIPS_OPACRF_TP1_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRF_TP1_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRF_TP1_Enum;

/* =============================================  AIPS AIPS_OPACRF WP1 [25..25]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_WP1                                                           */
  AIPS_OPACRF_WP1_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRF_WP1_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRF_WP1_Enum;

/* =============================================  AIPS AIPS_OPACRF SP1 [26..26]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_SP1                                                           */
  AIPS_OPACRF_SP1_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRF_SP1_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRF_SP1_Enum;

/* =============================================  AIPS AIPS_OPACRF TP0 [28..28]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_TP0                                                           */
  AIPS_OPACRF_TP0_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRF_TP0_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRF_TP0_Enum;

/* =============================================  AIPS AIPS_OPACRF WP0 [29..29]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_WP0                                                           */
  AIPS_OPACRF_WP0_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRF_WP0_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRF_WP0_Enum;

/* =============================================  AIPS AIPS_OPACRF SP0 [30..30]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRF_SP0                                                           */
  AIPS_OPACRF_SP0_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRF_SP0_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRF_SP0_Enum;

/* ======================================================  AIPS_OPACRG  ====================================================== */
/* =============================================  AIPS AIPS_OPACRG TP2 [20..20]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRG_TP2                                                           */
  AIPS_OPACRG_TP2_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRG_TP2_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRG_TP2_Enum;

/* =============================================  AIPS AIPS_OPACRG WP2 [21..21]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRG_WP2                                                           */
  AIPS_OPACRG_WP2_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRG_WP2_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRG_WP2_Enum;

/* =============================================  AIPS AIPS_OPACRG SP2 [22..22]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRG_SP2                                                           */
  AIPS_OPACRG_SP2_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRG_SP2_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRG_SP2_Enum;

/* ======================================================  AIPS_OPACRH  ====================================================== */
/* =============================================  AIPS AIPS_OPACRH TP2 [20..20]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRH_TP2                                                           */
  AIPS_OPACRH_TP2_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRH_TP2_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRH_TP2_Enum;

/* =============================================  AIPS AIPS_OPACRH WP2 [21..21]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRH_WP2                                                           */
  AIPS_OPACRH_WP2_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRH_WP2_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRH_WP2_Enum;

/* =============================================  AIPS AIPS_OPACRH SP2 [22..22]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRH_SP2                                                           */
  AIPS_OPACRH_SP2_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRH_SP2_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRH_SP2_Enum;

/* ======================================================  AIPS_OPACRI  ====================================================== */
/* ==============================================  AIPS AIPS_OPACRI TP6 [4..4]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRI_TP6                                                           */
  AIPS_OPACRI_TP6_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRI_TP6_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRI_TP6_Enum;

/* ==============================================  AIPS AIPS_OPACRI WP6 [5..5]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRI_WP6                                                           */
  AIPS_OPACRI_WP6_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRI_WP6_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRI_WP6_Enum;

/* ==============================================  AIPS AIPS_OPACRI SP6 [6..6]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRI_SP6                                                           */
  AIPS_OPACRI_SP6_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRI_SP6_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRI_SP6_Enum;

/* ==============================================  AIPS AIPS_OPACRI TP5 [8..8]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRI_TP5                                                           */
  AIPS_OPACRI_TP5_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRI_TP5_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRI_TP5_Enum;

/* ==============================================  AIPS AIPS_OPACRI WP5 [9..9]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRI_WP5                                                           */
  AIPS_OPACRI_WP5_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRI_WP5_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRI_WP5_Enum;

/* =============================================  AIPS AIPS_OPACRI SP5 [10..10]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRI_SP5                                                           */
  AIPS_OPACRI_SP5_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRI_SP5_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRI_SP5_Enum;

/* =============================================  AIPS AIPS_OPACRI TP4 [12..12]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRI_TP4                                                           */
  AIPS_OPACRI_TP4_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRI_TP4_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRI_TP4_Enum;

/* =============================================  AIPS AIPS_OPACRI WP4 [13..13]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRI_WP4                                                           */
  AIPS_OPACRI_WP4_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRI_WP4_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRI_WP4_Enum;

/* =============================================  AIPS AIPS_OPACRI SP4 [14..14]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRI_SP4                                                           */
  AIPS_OPACRI_SP4_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRI_SP4_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRI_SP4_Enum;

/* =============================================  AIPS AIPS_OPACRI TP3 [16..16]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRI_TP3                                                           */
  AIPS_OPACRI_TP3_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRI_TP3_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRI_TP3_Enum;

/* =============================================  AIPS AIPS_OPACRI WP3 [17..17]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRI_WP3                                                           */
  AIPS_OPACRI_WP3_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRI_WP3_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRI_WP3_Enum;

/* =============================================  AIPS AIPS_OPACRI SP3 [18..18]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRI_SP3                                                           */
  AIPS_OPACRI_SP3_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRI_SP3_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRI_SP3_Enum;

/* =============================================  AIPS AIPS_OPACRI TP1 [24..24]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRI_TP1                                                           */
  AIPS_OPACRI_TP1_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRI_TP1_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRI_TP1_Enum;

/* =============================================  AIPS AIPS_OPACRI WP1 [25..25]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRI_WP1                                                           */
  AIPS_OPACRI_WP1_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRI_WP1_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRI_WP1_Enum;

/* =============================================  AIPS AIPS_OPACRI SP1 [26..26]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRI_SP1                                                           */
  AIPS_OPACRI_SP1_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRI_SP1_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRI_SP1_Enum;

/* ======================================================  AIPS_OPACRJ  ====================================================== */
/* =============================================  AIPS AIPS_OPACRJ TP4 [12..12]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRJ_TP4                                                           */
  AIPS_OPACRJ_TP4_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRJ_TP4_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRJ_TP4_Enum;

/* =============================================  AIPS AIPS_OPACRJ WP4 [13..13]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRJ_WP4                                                           */
  AIPS_OPACRJ_WP4_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRJ_WP4_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRJ_WP4_Enum;

/* =============================================  AIPS AIPS_OPACRJ SP4 [14..14]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRJ_SP4                                                           */
  AIPS_OPACRJ_SP4_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRJ_SP4_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRJ_SP4_Enum;

/* =============================================  AIPS AIPS_OPACRJ TP3 [16..16]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRJ_TP3                                                           */
  AIPS_OPACRJ_TP3_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRJ_TP3_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRJ_TP3_Enum;

/* =============================================  AIPS AIPS_OPACRJ WP3 [17..17]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRJ_WP3                                                           */
  AIPS_OPACRJ_WP3_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRJ_WP3_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRJ_WP3_Enum;

/* =============================================  AIPS AIPS_OPACRJ SP3 [18..18]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRJ_SP3                                                           */
  AIPS_OPACRJ_SP3_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRJ_SP3_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRJ_SP3_Enum;

/* =============================================  AIPS AIPS_OPACRJ TP2 [20..20]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRJ_TP2                                                           */
  AIPS_OPACRJ_TP2_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRJ_TP2_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRJ_TP2_Enum;

/* =============================================  AIPS AIPS_OPACRJ WP2 [21..21]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRJ_WP2                                                           */
  AIPS_OPACRJ_WP2_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRJ_WP2_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRJ_WP2_Enum;

/* =============================================  AIPS AIPS_OPACRJ SP2 [22..22]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRJ_SP2                                                           */
  AIPS_OPACRJ_SP2_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRJ_SP2_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRJ_SP2_Enum;

/* ======================================================  AIPS_OPACRK  ====================================================== */
/* =============================================  AIPS AIPS_OPACRK TP3 [16..16]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRK_TP3                                                           */
  AIPS_OPACRK_TP3_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRK_TP3_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRK_TP3_Enum;

/* =============================================  AIPS AIPS_OPACRK WP3 [17..17]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRK_WP3                                                           */
  AIPS_OPACRK_WP3_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRK_WP3_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRK_WP3_Enum;

/* =============================================  AIPS AIPS_OPACRK SP3 [18..18]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRK_SP3                                                           */
  AIPS_OPACRK_SP3_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRK_SP3_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRK_SP3_Enum;

/* ======================================================  AIPS_OPACRL  ====================================================== */
/* ==============================================  AIPS AIPS_OPACRL TP7 [0..0]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRL_TP7                                                           */
  AIPS_OPACRL_TP7_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRL_TP7_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRL_TP7_Enum;

/* ==============================================  AIPS AIPS_OPACRL WP7 [1..1]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRL_WP7                                                           */
  AIPS_OPACRL_WP7_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRL_WP7_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRL_WP7_Enum;

/* ==============================================  AIPS AIPS_OPACRL SP7 [2..2]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRL_SP7                                                           */
  AIPS_OPACRL_SP7_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRL_SP7_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRL_SP7_Enum;

/* ==============================================  AIPS AIPS_OPACRL TP6 [4..4]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRL_TP6                                                           */
  AIPS_OPACRL_TP6_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRL_TP6_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRL_TP6_Enum;

/* ==============================================  AIPS AIPS_OPACRL WP6 [5..5]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRL_WP6                                                           */
  AIPS_OPACRL_WP6_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRL_WP6_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRL_WP6_Enum;

/* ==============================================  AIPS AIPS_OPACRL SP6 [6..6]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRL_SP6                                                           */
  AIPS_OPACRL_SP6_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRL_SP6_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRL_SP6_Enum;

/* ==============================================  AIPS AIPS_OPACRL TP5 [8..8]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRL_TP5                                                           */
  AIPS_OPACRL_TP5_0                    = 0,     /*!< 0 : Accesses from an untrusted master are allowed.                        */
  AIPS_OPACRL_TP5_1                    = 1,     /*!< 1 : Accesses from an untrusted master are not allowed.                    */
} AIPS_OPACRL_TP5_Enum;

/* ==============================================  AIPS AIPS_OPACRL WP5 [9..9]  ============================================== */
typedef enum {                                  /*!< AIPS_OPACRL_WP5                                                           */
  AIPS_OPACRL_WP5_0                    = 0,     /*!< 0 : This peripheral allows write accesses.                                */
  AIPS_OPACRL_WP5_1                    = 1,     /*!< 1 : This peripheral is write protected.                                   */
} AIPS_OPACRL_WP5_Enum;

/* =============================================  AIPS AIPS_OPACRL SP5 [10..10]  ============================================= */
typedef enum {                                  /*!< AIPS_OPACRL_SP5                                                           */
  AIPS_OPACRL_SP5_0                    = 0,     /*!< 0 : This peripheral does not require supervisor privilege level
                                                     for accesses.                                                             */
  AIPS_OPACRL_SP5_1                    = 1,     /*!< 1 : This peripheral requires supervisor privilege level for
                                                     accesses.                                                                 */
} AIPS_OPACRL_SP5_Enum;



/* =========================================================================================================================== */
/* ================                                           MSCM                                            ================ */
/* =========================================================================================================================== */

/* =====================================================  MSCM_CPxTYPE  ====================================================== */
/* ======================================================  MSCM_CPxNUM  ====================================================== */
/* ====================================================  MSCM_CPxMASTER  ===================================================== */
/* =====================================================  MSCM_CPxCOUNT  ===================================================== */
/* =====================================================  MSCM_CPxCFG0  ====================================================== */
/* =====================================================  MSCM_CPxCFG1  ====================================================== */
/* =====================================================  MSCM_CPxCFG2  ====================================================== */
/* =====================================================  MSCM_CPxCFG3  ====================================================== */
/* =============================================  MSCM MSCM_CPxCFG3 FPU [0..0]  ============================================== */
typedef enum {                                  /*!< MSCM_CPxCFG3_FPU                                                          */
  MSCM_CPxCFG3_FPU_0                   = 0,     /*!< 0 : FPU support is not included.                                          */
  MSCM_CPxCFG3_FPU_1                   = 1,     /*!< 1 : FPU support is included.                                              */
} MSCM_CPxCFG3_FPU_Enum;

/* =============================================  MSCM MSCM_CPxCFG3 SIMD [1..1]  ============================================= */
typedef enum {                                  /*!< MSCM_CPxCFG3_SIMD                                                         */
  MSCM_CPxCFG3_SIMD_0                  = 0,     /*!< 0 : SIMD/NEON support is not included.                                    */
  MSCM_CPxCFG3_SIMD_1                  = 1,     /*!< 1 : SIMD/NEON support is included.                                        */
} MSCM_CPxCFG3_SIMD_Enum;

/* =============================================  MSCM MSCM_CPxCFG3 JAZ [2..2]  ============================================== */
typedef enum {                                  /*!< MSCM_CPxCFG3_JAZ                                                          */
  MSCM_CPxCFG3_JAZ_0                   = 0,     /*!< 0 : Jazelle support is not included.                                      */
  MSCM_CPxCFG3_JAZ_1                   = 1,     /*!< 1 : Jazelle support is included.                                          */
} MSCM_CPxCFG3_JAZ_Enum;

/* =============================================  MSCM MSCM_CPxCFG3 MMU [3..3]  ============================================== */
typedef enum {                                  /*!< MSCM_CPxCFG3_MMU                                                          */
  MSCM_CPxCFG3_MMU_0                   = 0,     /*!< 0 : MMU support is not included.                                          */
  MSCM_CPxCFG3_MMU_1                   = 1,     /*!< 1 : MMU support is included.                                              */
} MSCM_CPxCFG3_MMU_Enum;

/* ==============================================  MSCM MSCM_CPxCFG3 TZ [4..4]  ============================================== */
typedef enum {                                  /*!< MSCM_CPxCFG3_TZ                                                           */
  MSCM_CPxCFG3_TZ_0                    = 0,     /*!< 0 : Trust Zone support is not included.                                   */
  MSCM_CPxCFG3_TZ_1                    = 1,     /*!< 1 : Trust Zone support is included.                                       */
} MSCM_CPxCFG3_TZ_Enum;

/* =============================================  MSCM MSCM_CPxCFG3 CMP [5..5]  ============================================== */
typedef enum {                                  /*!< MSCM_CPxCFG3_CMP                                                          */
  MSCM_CPxCFG3_CMP_0                   = 0,     /*!< 0 : Core Memory Protection is not included.                               */
  MSCM_CPxCFG3_CMP_1                   = 1,     /*!< 1 : Core Memory Protection is included.                                   */
} MSCM_CPxCFG3_CMP_Enum;

/* ==============================================  MSCM MSCM_CPxCFG3 BB [6..6]  ============================================== */
typedef enum {                                  /*!< MSCM_CPxCFG3_BB                                                           */
  MSCM_CPxCFG3_BB_0                    = 0,     /*!< 0 : Bit Banding is not supported.                                         */
  MSCM_CPxCFG3_BB_1                    = 1,     /*!< 1 : Bit Banding is supported.                                             */
} MSCM_CPxCFG3_BB_Enum;

/* =====================================================  MSCM_CP0TYPE  ====================================================== */
/* ======================================================  MSCM_CP0NUM  ====================================================== */
/* ====================================================  MSCM_CP0MASTER  ===================================================== */
/* =====================================================  MSCM_CP0COUNT  ===================================================== */
/* =====================================================  MSCM_CP0CFG0  ====================================================== */
/* =====================================================  MSCM_CP0CFG1  ====================================================== */
/* =====================================================  MSCM_CP0CFG2  ====================================================== */
/* =====================================================  MSCM_CP0CFG3  ====================================================== */
/* =============================================  MSCM MSCM_CP0CFG3 FPU [0..0]  ============================================== */
typedef enum {                                  /*!< MSCM_CP0CFG3_FPU                                                          */
  MSCM_CP0CFG3_FPU_0                   = 0,     /*!< 0 : FPU support is not included.                                          */
  MSCM_CP0CFG3_FPU_1                   = 1,     /*!< 1 : FPU support is included.                                              */
} MSCM_CP0CFG3_FPU_Enum;

/* =============================================  MSCM MSCM_CP0CFG3 SIMD [1..1]  ============================================= */
typedef enum {                                  /*!< MSCM_CP0CFG3_SIMD                                                         */
  MSCM_CP0CFG3_SIMD_0                  = 0,     /*!< 0 : SIMD/NEON support is not included.                                    */
  MSCM_CP0CFG3_SIMD_1                  = 1,     /*!< 1 : SIMD/NEON support is included.                                        */
} MSCM_CP0CFG3_SIMD_Enum;

/* =============================================  MSCM MSCM_CP0CFG3 JAZ [2..2]  ============================================== */
typedef enum {                                  /*!< MSCM_CP0CFG3_JAZ                                                          */
  MSCM_CP0CFG3_JAZ_0                   = 0,     /*!< 0 : Jazelle support is not included.                                      */
  MSCM_CP0CFG3_JAZ_1                   = 1,     /*!< 1 : Jazelle support is included.                                          */
} MSCM_CP0CFG3_JAZ_Enum;

/* =============================================  MSCM MSCM_CP0CFG3 MMU [3..3]  ============================================== */
typedef enum {                                  /*!< MSCM_CP0CFG3_MMU                                                          */
  MSCM_CP0CFG3_MMU_0                   = 0,     /*!< 0 : MMU support is not included.                                          */
  MSCM_CP0CFG3_MMU_1                   = 1,     /*!< 1 : MMU support is included.                                              */
} MSCM_CP0CFG3_MMU_Enum;

/* ==============================================  MSCM MSCM_CP0CFG3 TZ [4..4]  ============================================== */
typedef enum {                                  /*!< MSCM_CP0CFG3_TZ                                                           */
  MSCM_CP0CFG3_TZ_0                    = 0,     /*!< 0 : Trust Zone support is not included.                                   */
  MSCM_CP0CFG3_TZ_1                    = 1,     /*!< 1 : Trust Zone support is included.                                       */
} MSCM_CP0CFG3_TZ_Enum;

/* =============================================  MSCM MSCM_CP0CFG3 CMP [5..5]  ============================================== */
typedef enum {                                  /*!< MSCM_CP0CFG3_CMP                                                          */
  MSCM_CP0CFG3_CMP_0                   = 0,     /*!< 0 : Core Memory Protection is not included.                               */
  MSCM_CP0CFG3_CMP_1                   = 1,     /*!< 1 : Core Memory Protection is included.                                   */
} MSCM_CP0CFG3_CMP_Enum;

/* ==============================================  MSCM MSCM_CP0CFG3 BB [6..6]  ============================================== */
typedef enum {                                  /*!< MSCM_CP0CFG3_BB                                                           */
  MSCM_CP0CFG3_BB_0                    = 0,     /*!< 0 : Bit Banding is not supported.                                         */
  MSCM_CP0CFG3_BB_1                    = 1,     /*!< 1 : Bit Banding is supported.                                             */
} MSCM_CP0CFG3_BB_Enum;

/* ======================================================  MSCM_OCMDR0  ====================================================== */
/* ============================================  MSCM MSCM_OCMDR0 OCMT [13..15]  ============================================= */
typedef enum {                                  /*!< MSCM_OCMDR0_OCMT                                                          */
  MSCM_OCMDR0_OCMT_100                 = 4,     /*!< 100 : OCMEMn is a Program Flash.                                          */
  MSCM_OCMDR0_OCMT_101                 = 5,     /*!< 101 : OCMEMn is a Data Flash.                                             */
  MSCM_OCMDR0_OCMT_110                 = 6,     /*!< 110 : OCMEMn is an EEE.                                                   */
} MSCM_OCMDR0_OCMT_Enum;

/* =============================================  MSCM MSCM_OCMDR0 RO [16..16]  ============================================== */
typedef enum {                                  /*!< MSCM_OCMDR0_RO                                                            */
  MSCM_OCMDR0_RO_0                     = 0,     /*!< 0 : Writes to the OCMDRn[11:0] are allowed                                */
  MSCM_OCMDR0_RO_1                     = 1,     /*!< 1 : Writes to the OCMDRn[11:0] are ignored                                */
} MSCM_OCMDR0_RO_Enum;

/* ============================================  MSCM MSCM_OCMDR0 OCMW [17..19]  ============================================= */
typedef enum {                                  /*!< MSCM_OCMDR0_OCMW                                                          */
  MSCM_OCMDR0_OCMW_010                 = 2,     /*!< 010 : OCMEMn 32-bits wide                                                 */
  MSCM_OCMDR0_OCMW_011                 = 3,     /*!< 011 : OCMEMn 64-bits wide                                                 */
  MSCM_OCMDR0_OCMW_100                 = 4,     /*!< 100 : OCMEMn 128-bits wide                                                */
  MSCM_OCMDR0_OCMW_101                 = 5,     /*!< 101 : OCMEMn 256-bits wide                                                */
} MSCM_OCMDR0_OCMW_Enum;

/* ============================================  MSCM MSCM_OCMDR0 OCMSZ [24..27]  ============================================ */
typedef enum {                                  /*!< MSCM_OCMDR0_OCMSZ                                                         */
  MSCM_OCMDR0_OCMSZ_0000               = 0,     /*!< 0000 : no OCMEMn                                                          */
  MSCM_OCMDR0_OCMSZ_0001               = 1,     /*!< 0001 : 1KB OCMEMn                                                         */
  MSCM_OCMDR0_OCMSZ_0010               = 2,     /*!< 0010 : 2KB OCMEMn                                                         */
  MSCM_OCMDR0_OCMSZ_0011               = 3,     /*!< 0011 : 4KB OCMEMn                                                         */
  MSCM_OCMDR0_OCMSZ_0100               = 4,     /*!< 0100 : 8KB OCMEMn                                                         */
  MSCM_OCMDR0_OCMSZ_0101               = 5,     /*!< 0101 : 16KB OCMEMn                                                        */
  MSCM_OCMDR0_OCMSZ_0110               = 6,     /*!< 0110 : 32KB OCMEMn                                                        */
  MSCM_OCMDR0_OCMSZ_0111               = 7,     /*!< 0111 : 64KB OCMEMn                                                        */
  MSCM_OCMDR0_OCMSZ_1000               = 8,     /*!< 1000 : 128KB OCMEMn                                                       */
  MSCM_OCMDR0_OCMSZ_1001               = 9,     /*!< 1001 : 256KB OCMEMn                                                       */
  MSCM_OCMDR0_OCMSZ_1010               = 10,    /*!< 1010 : 512KB OCMEMn                                                       */
  MSCM_OCMDR0_OCMSZ_1011               = 11,    /*!< 1011 : 1MB OCMEMn                                                         */
  MSCM_OCMDR0_OCMSZ_1100               = 12,    /*!< 1100 : 2MB OCMEMn                                                         */
  MSCM_OCMDR0_OCMSZ_1101               = 13,    /*!< 1101 : 4MB OCMEMn                                                         */
  MSCM_OCMDR0_OCMSZ_1110               = 14,    /*!< 1110 : 8MB OCMEMn                                                         */
  MSCM_OCMDR0_OCMSZ_1111               = 15,    /*!< 1111 : 16MB OCMEMn                                                        */
} MSCM_OCMDR0_OCMSZ_Enum;

/* ===========================================  MSCM MSCM_OCMDR0 OCMSZH [28..28]  ============================================ */
typedef enum {                                  /*!< MSCM_OCMDR0_OCMSZH                                                        */
  MSCM_OCMDR0_OCMSZH_0                 = 0,     /*!< 0 : OCMEMn is a power-of-2 capacity.                                      */
  MSCM_OCMDR0_OCMSZH_1                 = 1,     /*!< 1 : OCMEMn is not a power-of-2, with a capacity is 0.75 * OCMSZ.          */
} MSCM_OCMDR0_OCMSZH_Enum;

/* ==============================================  MSCM MSCM_OCMDR0 V [31..31]  ============================================== */
typedef enum {                                  /*!< MSCM_OCMDR0_V                                                             */
  MSCM_OCMDR0_V_0                      = 0,     /*!< 0 : OCMEMn is not present.                                                */
  MSCM_OCMDR0_V_1                      = 1,     /*!< 1 : OCMEMn is present.                                                    */
} MSCM_OCMDR0_V_Enum;

/* ======================================================  MSCM_OCMDR1  ====================================================== */
/* ============================================  MSCM MSCM_OCMDR1 OCMT [13..15]  ============================================= */
typedef enum {                                  /*!< MSCM_OCMDR1_OCMT                                                          */
  MSCM_OCMDR1_OCMT_100                 = 4,     /*!< 100 : OCMEMn is a Program Flash.                                          */
  MSCM_OCMDR1_OCMT_101                 = 5,     /*!< 101 : OCMEMn is a Data Flash.                                             */
  MSCM_OCMDR1_OCMT_110                 = 6,     /*!< 110 : OCMEMn is an EEE.                                                   */
} MSCM_OCMDR1_OCMT_Enum;

/* =============================================  MSCM MSCM_OCMDR1 RO [16..16]  ============================================== */
typedef enum {                                  /*!< MSCM_OCMDR1_RO                                                            */
  MSCM_OCMDR1_RO_0                     = 0,     /*!< 0 : Writes to the OCMDRn[11:0] are allowed                                */
  MSCM_OCMDR1_RO_1                     = 1,     /*!< 1 : Writes to the OCMDRn[11:0] are ignored                                */
} MSCM_OCMDR1_RO_Enum;

/* ============================================  MSCM MSCM_OCMDR1 OCMW [17..19]  ============================================= */
typedef enum {                                  /*!< MSCM_OCMDR1_OCMW                                                          */
  MSCM_OCMDR1_OCMW_010                 = 2,     /*!< 010 : OCMEMn 32-bits wide                                                 */
  MSCM_OCMDR1_OCMW_011                 = 3,     /*!< 011 : OCMEMn 64-bits wide                                                 */
  MSCM_OCMDR1_OCMW_100                 = 4,     /*!< 100 : OCMEMn 128-bits wide                                                */
  MSCM_OCMDR1_OCMW_101                 = 5,     /*!< 101 : OCMEMn 256-bits wide                                                */
} MSCM_OCMDR1_OCMW_Enum;

/* ============================================  MSCM MSCM_OCMDR1 OCMSZ [24..27]  ============================================ */
typedef enum {                                  /*!< MSCM_OCMDR1_OCMSZ                                                         */
  MSCM_OCMDR1_OCMSZ_0000               = 0,     /*!< 0000 : no OCMEMn                                                          */
  MSCM_OCMDR1_OCMSZ_0001               = 1,     /*!< 0001 : 1KB OCMEMn                                                         */
  MSCM_OCMDR1_OCMSZ_0010               = 2,     /*!< 0010 : 2KB OCMEMn                                                         */
  MSCM_OCMDR1_OCMSZ_0011               = 3,     /*!< 0011 : 4KB OCMEMn                                                         */
  MSCM_OCMDR1_OCMSZ_0100               = 4,     /*!< 0100 : 8KB OCMEMn                                                         */
  MSCM_OCMDR1_OCMSZ_0101               = 5,     /*!< 0101 : 16KB OCMEMn                                                        */
  MSCM_OCMDR1_OCMSZ_0110               = 6,     /*!< 0110 : 32KB OCMEMn                                                        */
  MSCM_OCMDR1_OCMSZ_0111               = 7,     /*!< 0111 : 64KB OCMEMn                                                        */
  MSCM_OCMDR1_OCMSZ_1000               = 8,     /*!< 1000 : 128KB OCMEMn                                                       */
  MSCM_OCMDR1_OCMSZ_1001               = 9,     /*!< 1001 : 256KB OCMEMn                                                       */
  MSCM_OCMDR1_OCMSZ_1010               = 10,    /*!< 1010 : 512KB OCMEMn                                                       */
  MSCM_OCMDR1_OCMSZ_1011               = 11,    /*!< 1011 : 1MB OCMEMn                                                         */
  MSCM_OCMDR1_OCMSZ_1100               = 12,    /*!< 1100 : 2MB OCMEMn                                                         */
  MSCM_OCMDR1_OCMSZ_1101               = 13,    /*!< 1101 : 4MB OCMEMn                                                         */
  MSCM_OCMDR1_OCMSZ_1110               = 14,    /*!< 1110 : 8MB OCMEMn                                                         */
  MSCM_OCMDR1_OCMSZ_1111               = 15,    /*!< 1111 : 16MB OCMEMn                                                        */
} MSCM_OCMDR1_OCMSZ_Enum;

/* ===========================================  MSCM MSCM_OCMDR1 OCMSZH [28..28]  ============================================ */
typedef enum {                                  /*!< MSCM_OCMDR1_OCMSZH                                                        */
  MSCM_OCMDR1_OCMSZH_0                 = 0,     /*!< 0 : OCMEMn is a power-of-2 capacity.                                      */
  MSCM_OCMDR1_OCMSZH_1                 = 1,     /*!< 1 : OCMEMn is not a power-of-2, with a capacity is 0.75 * OCMSZ.          */
} MSCM_OCMDR1_OCMSZH_Enum;

/* ==============================================  MSCM MSCM_OCMDR1 V [31..31]  ============================================== */
typedef enum {                                  /*!< MSCM_OCMDR1_V                                                             */
  MSCM_OCMDR1_V_0                      = 0,     /*!< 0 : OCMEMn is not present.                                                */
  MSCM_OCMDR1_V_1                      = 1,     /*!< 1 : OCMEMn is present.                                                    */
} MSCM_OCMDR1_V_Enum;

/* ======================================================  MSCM_OCMDR2  ====================================================== */
/* ============================================  MSCM MSCM_OCMDR2 OCMT [13..15]  ============================================= */
typedef enum {                                  /*!< MSCM_OCMDR2_OCMT                                                          */
  MSCM_OCMDR2_OCMT_100                 = 4,     /*!< 100 : OCMEMn is a Program Flash.                                          */
  MSCM_OCMDR2_OCMT_101                 = 5,     /*!< 101 : OCMEMn is a Data Flash.                                             */
  MSCM_OCMDR2_OCMT_110                 = 6,     /*!< 110 : OCMEMn is an EEE.                                                   */
} MSCM_OCMDR2_OCMT_Enum;

/* =============================================  MSCM MSCM_OCMDR2 RO [16..16]  ============================================== */
typedef enum {                                  /*!< MSCM_OCMDR2_RO                                                            */
  MSCM_OCMDR2_RO_0                     = 0,     /*!< 0 : Writes to the OCMDRn[11:0] are allowed                                */
  MSCM_OCMDR2_RO_1                     = 1,     /*!< 1 : Writes to the OCMDRn[11:0] are ignored                                */
} MSCM_OCMDR2_RO_Enum;

/* ============================================  MSCM MSCM_OCMDR2 OCMW [17..19]  ============================================= */
typedef enum {                                  /*!< MSCM_OCMDR2_OCMW                                                          */
  MSCM_OCMDR2_OCMW_010                 = 2,     /*!< 010 : OCMEMn 32-bits wide                                                 */
  MSCM_OCMDR2_OCMW_011                 = 3,     /*!< 011 : OCMEMn 64-bits wide                                                 */
  MSCM_OCMDR2_OCMW_100                 = 4,     /*!< 100 : OCMEMn 128-bits wide                                                */
  MSCM_OCMDR2_OCMW_101                 = 5,     /*!< 101 : OCMEMn 256-bits wide                                                */
} MSCM_OCMDR2_OCMW_Enum;

/* ============================================  MSCM MSCM_OCMDR2 OCMSZ [24..27]  ============================================ */
typedef enum {                                  /*!< MSCM_OCMDR2_OCMSZ                                                         */
  MSCM_OCMDR2_OCMSZ_0000               = 0,     /*!< 0000 : no OCMEMn                                                          */
  MSCM_OCMDR2_OCMSZ_0001               = 1,     /*!< 0001 : 1KB OCMEMn                                                         */
  MSCM_OCMDR2_OCMSZ_0010               = 2,     /*!< 0010 : 2KB OCMEMn                                                         */
  MSCM_OCMDR2_OCMSZ_0011               = 3,     /*!< 0011 : 4KB OCMEMn                                                         */
  MSCM_OCMDR2_OCMSZ_0100               = 4,     /*!< 0100 : 8KB OCMEMn                                                         */
  MSCM_OCMDR2_OCMSZ_0101               = 5,     /*!< 0101 : 16KB OCMEMn                                                        */
  MSCM_OCMDR2_OCMSZ_0110               = 6,     /*!< 0110 : 32KB OCMEMn                                                        */
  MSCM_OCMDR2_OCMSZ_0111               = 7,     /*!< 0111 : 64KB OCMEMn                                                        */
  MSCM_OCMDR2_OCMSZ_1000               = 8,     /*!< 1000 : 128KB OCMEMn                                                       */
  MSCM_OCMDR2_OCMSZ_1001               = 9,     /*!< 1001 : 256KB OCMEMn                                                       */
  MSCM_OCMDR2_OCMSZ_1010               = 10,    /*!< 1010 : 512KB OCMEMn                                                       */
  MSCM_OCMDR2_OCMSZ_1011               = 11,    /*!< 1011 : 1MB OCMEMn                                                         */
  MSCM_OCMDR2_OCMSZ_1100               = 12,    /*!< 1100 : 2MB OCMEMn                                                         */
  MSCM_OCMDR2_OCMSZ_1101               = 13,    /*!< 1101 : 4MB OCMEMn                                                         */
  MSCM_OCMDR2_OCMSZ_1110               = 14,    /*!< 1110 : 8MB OCMEMn                                                         */
  MSCM_OCMDR2_OCMSZ_1111               = 15,    /*!< 1111 : 16MB OCMEMn                                                        */
} MSCM_OCMDR2_OCMSZ_Enum;

/* ===========================================  MSCM MSCM_OCMDR2 OCMSZH [28..28]  ============================================ */
typedef enum {                                  /*!< MSCM_OCMDR2_OCMSZH                                                        */
  MSCM_OCMDR2_OCMSZH_0                 = 0,     /*!< 0 : OCMEMn is a power-of-2 capacity.                                      */
  MSCM_OCMDR2_OCMSZH_1                 = 1,     /*!< 1 : OCMEMn is not a power-of-2, with a capacity is 0.75 * OCMSZ.          */
} MSCM_OCMDR2_OCMSZH_Enum;

/* ==============================================  MSCM MSCM_OCMDR2 V [31..31]  ============================================== */
typedef enum {                                  /*!< MSCM_OCMDR2_V                                                             */
  MSCM_OCMDR2_V_0                      = 0,     /*!< 0 : OCMEMn is not present.                                                */
  MSCM_OCMDR2_V_1                      = 1,     /*!< 1 : OCMEMn is present.                                                    */
} MSCM_OCMDR2_V_Enum;



/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  DMA_CR  ========================================================= */
/* =================================================  DMA DMA_CR HOE [4..4]  ================================================= */
typedef enum {                                  /*!< DMA_CR_HOE                                                                */
  DMA_CR_HOE_0                         = 0,     /*!< 0 : Normal operation                                                      */
  DMA_CR_HOE_1                         = 1,     /*!< 1 : Any error causes the HALT bit to set. Subsequently, all
                                                     service requests are ignored until the HALT bit is cleared.               */
} DMA_CR_HOE_Enum;

/* ================================================  DMA DMA_CR HALT [5..5]  ================================================= */
typedef enum {                                  /*!< DMA_CR_HALT                                                               */
  DMA_CR_HALT_0                        = 0,     /*!< 0 : Normal operation                                                      */
  DMA_CR_HALT_1                        = 1,     /*!< 1 : Stall the start of any new channels. Executing channels
                                                     are allowed to complete. Channel execution resumes when
                                                     this bit is cleared.                                                      */
} DMA_CR_HALT_Enum;

/* =================================================  DMA DMA_CR CLM [6..6]  ================================================= */
typedef enum {                                  /*!< DMA_CR_CLM                                                                */
  DMA_CR_CLM_0                         = 0,     /*!< 0 : A minor loop channel link made to itself goes through channel
                                                     arbitration before being activated again.                                 */
  DMA_CR_CLM_1                         = 1,     /*!< 1 : A minor loop channel link made to itself does not go through
                                                     channel arbitration before being activated again. Upon
                                                     minor loop completion, the channel activates again if that
                                                     channel has a minor loop channel link enabled and the link
                                                     channel is itself. This effectively applies the minor loop
                                                     offsets and restarts the next minor loop.                                 */
} DMA_CR_CLM_Enum;

/* ================================================  DMA DMA_CR EMLM [7..7]  ================================================= */
typedef enum {                                  /*!< DMA_CR_EMLM                                                               */
  DMA_CR_EMLM_0                        = 0,     /*!< 0 : Disabled. TCDn.word2 is defined as a 32-bit NBYTES field.             */
  DMA_CR_EMLM_1                        = 1,     /*!< 1 : Enabled. TCDn.word2 is redefined to include individual enable
                                                     fields, an offset field, and the NBYTES field. The individual
                                                     enable fields allow the minor loop offset to be applied
                                                     to the source address, the destination address, or both.
                                                     The NBYTES field is reduced when either offset is enabled.                */
} DMA_CR_EMLM_Enum;

/* ================================================  DMA DMA_CR ECX [16..16]  ================================================ */
typedef enum {                                  /*!< DMA_CR_ECX                                                                */
  DMA_CR_ECX_0                         = 0,     /*!< 0 : Normal operation                                                      */
  DMA_CR_ECX_1                         = 1,     /*!< 1 : Cancel the remaining data transfer in the same fashion as
                                                     the CX bit. Stop the executing channel and force the minor
                                                     loop to finish. The cancel takes effect after the last
                                                     write of the current read/write sequence. The ECX bit clears
                                                     itself after the cancel is honored. In addition to cancelling
                                                     the transfer, ECX treats the cancel as an error condition,
                                                     thus updating the Error Status register (DMAx_ES) and generating
                                                     an optional error interrupt.                                              */
} DMA_CR_ECX_Enum;

/* ================================================  DMA DMA_CR CX [17..17]  ================================================= */
typedef enum {                                  /*!< DMA_CR_CX                                                                 */
  DMA_CR_CX_0                          = 0,     /*!< 0 : Normal operation                                                      */
  DMA_CR_CX_1                          = 1,     /*!< 1 : Cancel the remaining data transfer. Stop the executing channel
                                                     and force the minor loop to finish. The cancel takes effect
                                                     after the last write of the current read/write sequence.
                                                     The CX bit clears itself after the cancel has been honored.
                                                     This cancel retires the channel normally as if the minor
                                                     loop was completed.                                                       */
} DMA_CR_CX_Enum;

/* ==============================================  DMA DMA_CR ACTIVE [31..31]  =============================================== */
typedef enum {                                  /*!< DMA_CR_ACTIVE                                                             */
  DMA_CR_ACTIVE_0                      = 0,     /*!< 0 : eDMA is idle.                                                         */
  DMA_CR_ACTIVE_1                      = 1,     /*!< 1 : eDMA is executing a channel.                                          */
} DMA_CR_ACTIVE_Enum;

/* ========================================================  DMA_ES  ========================================================= */
/* =================================================  DMA DMA_ES DBE [0..0]  ================================================= */
typedef enum {                                  /*!< DMA_ES_DBE                                                                */
  DMA_ES_DBE_0                         = 0,     /*!< 0 : No destination bus error                                              */
  DMA_ES_DBE_1                         = 1,     /*!< 1 : The last recorded error was a bus error on a destination
                                                     write                                                                     */
} DMA_ES_DBE_Enum;

/* =================================================  DMA DMA_ES SBE [1..1]  ================================================= */
typedef enum {                                  /*!< DMA_ES_SBE                                                                */
  DMA_ES_SBE_0                         = 0,     /*!< 0 : No source bus error                                                   */
  DMA_ES_SBE_1                         = 1,     /*!< 1 : The last recorded error was a bus error on a source read              */
} DMA_ES_SBE_Enum;

/* =================================================  DMA DMA_ES SGE [2..2]  ================================================= */
typedef enum {                                  /*!< DMA_ES_SGE                                                                */
  DMA_ES_SGE_0                         = 0,     /*!< 0 : No scatter/gather configuration error                                 */
  DMA_ES_SGE_1                         = 1,     /*!< 1 : The last recorded error was a configuration error detected
                                                     in the TCDn_DLASTSGA field. This field is checked at the
                                                     beginning of a scatter/gather operation after major loop
                                                     completion if TCDn_CSR[ESG] is enabled. TCDn_DLASTSGA is
                                                     not on a 32 byte boundary.                                                */
} DMA_ES_SGE_Enum;

/* =================================================  DMA DMA_ES NCE [3..3]  ================================================= */
typedef enum {                                  /*!< DMA_ES_NCE                                                                */
  DMA_ES_NCE_0                         = 0,     /*!< 0 : No NBYTES/CITER configuration error                                   */
} DMA_ES_NCE_Enum;

/* =================================================  DMA DMA_ES DOE [4..4]  ================================================= */
typedef enum {                                  /*!< DMA_ES_DOE                                                                */
  DMA_ES_DOE_0                         = 0,     /*!< 0 : No destination offset configuration error                             */
  DMA_ES_DOE_1                         = 1,     /*!< 1 : The last recorded error was a configuration error detected
                                                     in the TCDn_DOFF field. TCDn_DOFF is inconsistent with
                                                     TCDn_ATTR[DSIZE].                                                         */
} DMA_ES_DOE_Enum;

/* =================================================  DMA DMA_ES DAE [5..5]  ================================================= */
typedef enum {                                  /*!< DMA_ES_DAE                                                                */
  DMA_ES_DAE_0                         = 0,     /*!< 0 : No destination address configuration error                            */
  DMA_ES_DAE_1                         = 1,     /*!< 1 : The last recorded error was a configuration error detected
                                                     in the TCDn_DADDR field. TCDn_DADDR is inconsistent with
                                                     TCDn_ATTR[DSIZE].                                                         */
} DMA_ES_DAE_Enum;

/* =================================================  DMA DMA_ES SOE [6..6]  ================================================= */
typedef enum {                                  /*!< DMA_ES_SOE                                                                */
  DMA_ES_SOE_0                         = 0,     /*!< 0 : No source offset configuration error                                  */
  DMA_ES_SOE_1                         = 1,     /*!< 1 : The last recorded error was a configuration error detected
                                                     in the TCDn_SOFF field. TCDn_SOFF is inconsistent with
                                                     TCDn_ATTR[SSIZE].                                                         */
} DMA_ES_SOE_Enum;

/* =================================================  DMA DMA_ES SAE [7..7]  ================================================= */
typedef enum {                                  /*!< DMA_ES_SAE                                                                */
  DMA_ES_SAE_0                         = 0,     /*!< 0 : No source address configuration error.                                */
  DMA_ES_SAE_1                         = 1,     /*!< 1 : The last recorded error was a configuration error detected
                                                     in the TCDn_SADDR field. TCDn_SADDR is inconsistent with
                                                     TCDn_ATTR[SSIZE].                                                         */
} DMA_ES_SAE_Enum;

/* ================================================  DMA DMA_ES CPE [14..14]  ================================================ */
typedef enum {                                  /*!< DMA_ES_CPE                                                                */
  DMA_ES_CPE_0                         = 0,     /*!< 0 : No channel priority error                                             */
} DMA_ES_CPE_Enum;

/* ================================================  DMA DMA_ES ECX [16..16]  ================================================ */
typedef enum {                                  /*!< DMA_ES_ECX                                                                */
  DMA_ES_ECX_0                         = 0,     /*!< 0 : No canceled transfers                                                 */
  DMA_ES_ECX_1                         = 1,     /*!< 1 : The last recorded entry was a canceled transfer by the error
                                                     cancel transfer input                                                     */
} DMA_ES_ECX_Enum;

/* ================================================  DMA DMA_ES VLD [31..31]  ================================================ */
typedef enum {                                  /*!< DMA_ES_VLD                                                                */
  DMA_ES_VLD_0                         = 0,     /*!< 0 : No ERR bits are set.                                                  */
  DMA_ES_VLD_1                         = 1,     /*!< 1 : At least one ERR bit is set indicating a valid error exists
                                                     that has not been cleared.                                                */
} DMA_ES_VLD_Enum;

/* ========================================================  DMA_ERQ  ======================================================== */
/* ================================================  DMA DMA_ERQ ERQ0 [0..0]  ================================================ */
typedef enum {                                  /*!< DMA_ERQ_ERQ0                                                              */
  DMA_ERQ_ERQ0_0                       = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ0_1                       = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ0_Enum;

/* ================================================  DMA DMA_ERQ ERQ1 [1..1]  ================================================ */
typedef enum {                                  /*!< DMA_ERQ_ERQ1                                                              */
  DMA_ERQ_ERQ1_0                       = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ1_1                       = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ1_Enum;

/* ================================================  DMA DMA_ERQ ERQ2 [2..2]  ================================================ */
typedef enum {                                  /*!< DMA_ERQ_ERQ2                                                              */
  DMA_ERQ_ERQ2_0                       = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ2_1                       = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ2_Enum;

/* ================================================  DMA DMA_ERQ ERQ3 [3..3]  ================================================ */
typedef enum {                                  /*!< DMA_ERQ_ERQ3                                                              */
  DMA_ERQ_ERQ3_0                       = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ3_1                       = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ3_Enum;

/* ================================================  DMA DMA_ERQ ERQ4 [4..4]  ================================================ */
typedef enum {                                  /*!< DMA_ERQ_ERQ4                                                              */
  DMA_ERQ_ERQ4_0                       = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ4_1                       = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ4_Enum;

/* ================================================  DMA DMA_ERQ ERQ5 [5..5]  ================================================ */
typedef enum {                                  /*!< DMA_ERQ_ERQ5                                                              */
  DMA_ERQ_ERQ5_0                       = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ5_1                       = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ5_Enum;

/* ================================================  DMA DMA_ERQ ERQ6 [6..6]  ================================================ */
typedef enum {                                  /*!< DMA_ERQ_ERQ6                                                              */
  DMA_ERQ_ERQ6_0                       = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ6_1                       = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ6_Enum;

/* ================================================  DMA DMA_ERQ ERQ7 [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_ERQ_ERQ7                                                              */
  DMA_ERQ_ERQ7_0                       = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ7_1                       = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ7_Enum;

/* ================================================  DMA DMA_ERQ ERQ8 [8..8]  ================================================ */
typedef enum {                                  /*!< DMA_ERQ_ERQ8                                                              */
  DMA_ERQ_ERQ8_0                       = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ8_1                       = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ8_Enum;

/* ================================================  DMA DMA_ERQ ERQ9 [9..9]  ================================================ */
typedef enum {                                  /*!< DMA_ERQ_ERQ9                                                              */
  DMA_ERQ_ERQ9_0                       = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ9_1                       = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ9_Enum;

/* ==============================================  DMA DMA_ERQ ERQ10 [10..10]  =============================================== */
typedef enum {                                  /*!< DMA_ERQ_ERQ10                                                             */
  DMA_ERQ_ERQ10_0                      = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ10_1                      = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ10_Enum;

/* ==============================================  DMA DMA_ERQ ERQ11 [11..11]  =============================================== */
typedef enum {                                  /*!< DMA_ERQ_ERQ11                                                             */
  DMA_ERQ_ERQ11_0                      = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ11_1                      = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ11_Enum;

/* ==============================================  DMA DMA_ERQ ERQ12 [12..12]  =============================================== */
typedef enum {                                  /*!< DMA_ERQ_ERQ12                                                             */
  DMA_ERQ_ERQ12_0                      = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ12_1                      = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ12_Enum;

/* ==============================================  DMA DMA_ERQ ERQ13 [13..13]  =============================================== */
typedef enum {                                  /*!< DMA_ERQ_ERQ13                                                             */
  DMA_ERQ_ERQ13_0                      = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ13_1                      = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ13_Enum;

/* ==============================================  DMA DMA_ERQ ERQ14 [14..14]  =============================================== */
typedef enum {                                  /*!< DMA_ERQ_ERQ14                                                             */
  DMA_ERQ_ERQ14_0                      = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ14_1                      = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ14_Enum;

/* ==============================================  DMA DMA_ERQ ERQ15 [15..15]  =============================================== */
typedef enum {                                  /*!< DMA_ERQ_ERQ15                                                             */
  DMA_ERQ_ERQ15_0                      = 0,     /*!< 0 : The DMA request signal for the corresponding channel is
                                                     disabled                                                                  */
  DMA_ERQ_ERQ15_1                      = 1,     /*!< 1 : The DMA request signal for the corresponding channel is
                                                     enabled                                                                   */
} DMA_ERQ_ERQ15_Enum;

/* ========================================================  DMA_EEI  ======================================================== */
/* ================================================  DMA DMA_EEI EEI0 [0..0]  ================================================ */
typedef enum {                                  /*!< DMA_EEI_EEI0                                                              */
  DMA_EEI_EEI0_0                       = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI0_1                       = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI0_Enum;

/* ================================================  DMA DMA_EEI EEI1 [1..1]  ================================================ */
typedef enum {                                  /*!< DMA_EEI_EEI1                                                              */
  DMA_EEI_EEI1_0                       = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI1_1                       = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI1_Enum;

/* ================================================  DMA DMA_EEI EEI2 [2..2]  ================================================ */
typedef enum {                                  /*!< DMA_EEI_EEI2                                                              */
  DMA_EEI_EEI2_0                       = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI2_1                       = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI2_Enum;

/* ================================================  DMA DMA_EEI EEI3 [3..3]  ================================================ */
typedef enum {                                  /*!< DMA_EEI_EEI3                                                              */
  DMA_EEI_EEI3_0                       = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI3_1                       = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI3_Enum;

/* ================================================  DMA DMA_EEI EEI4 [4..4]  ================================================ */
typedef enum {                                  /*!< DMA_EEI_EEI4                                                              */
  DMA_EEI_EEI4_0                       = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI4_1                       = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI4_Enum;

/* ================================================  DMA DMA_EEI EEI5 [5..5]  ================================================ */
typedef enum {                                  /*!< DMA_EEI_EEI5                                                              */
  DMA_EEI_EEI5_0                       = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI5_1                       = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI5_Enum;

/* ================================================  DMA DMA_EEI EEI6 [6..6]  ================================================ */
typedef enum {                                  /*!< DMA_EEI_EEI6                                                              */
  DMA_EEI_EEI6_0                       = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI6_1                       = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI6_Enum;

/* ================================================  DMA DMA_EEI EEI7 [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_EEI_EEI7                                                              */
  DMA_EEI_EEI7_0                       = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI7_1                       = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI7_Enum;

/* ================================================  DMA DMA_EEI EEI8 [8..8]  ================================================ */
typedef enum {                                  /*!< DMA_EEI_EEI8                                                              */
  DMA_EEI_EEI8_0                       = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI8_1                       = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI8_Enum;

/* ================================================  DMA DMA_EEI EEI9 [9..9]  ================================================ */
typedef enum {                                  /*!< DMA_EEI_EEI9                                                              */
  DMA_EEI_EEI9_0                       = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI9_1                       = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI9_Enum;

/* ==============================================  DMA DMA_EEI EEI10 [10..10]  =============================================== */
typedef enum {                                  /*!< DMA_EEI_EEI10                                                             */
  DMA_EEI_EEI10_0                      = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI10_1                      = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI10_Enum;

/* ==============================================  DMA DMA_EEI EEI11 [11..11]  =============================================== */
typedef enum {                                  /*!< DMA_EEI_EEI11                                                             */
  DMA_EEI_EEI11_0                      = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI11_1                      = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI11_Enum;

/* ==============================================  DMA DMA_EEI EEI12 [12..12]  =============================================== */
typedef enum {                                  /*!< DMA_EEI_EEI12                                                             */
  DMA_EEI_EEI12_0                      = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI12_1                      = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI12_Enum;

/* ==============================================  DMA DMA_EEI EEI13 [13..13]  =============================================== */
typedef enum {                                  /*!< DMA_EEI_EEI13                                                             */
  DMA_EEI_EEI13_0                      = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI13_1                      = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI13_Enum;

/* ==============================================  DMA DMA_EEI EEI14 [14..14]  =============================================== */
typedef enum {                                  /*!< DMA_EEI_EEI14                                                             */
  DMA_EEI_EEI14_0                      = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI14_1                      = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI14_Enum;

/* ==============================================  DMA DMA_EEI EEI15 [15..15]  =============================================== */
typedef enum {                                  /*!< DMA_EEI_EEI15                                                             */
  DMA_EEI_EEI15_0                      = 0,     /*!< 0 : The error signal for corresponding channel does not generate
                                                     an error interrupt                                                        */
  DMA_EEI_EEI15_1                      = 1,     /*!< 1 : The assertion of the error signal for corresponding channel
                                                     generates an error interrupt request                                      */
} DMA_EEI_EEI15_Enum;

/* =======================================================  DMA_CEEI  ======================================================== */
/* ================================================  DMA DMA_CEEI NOP [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_CEEI_NOP                                                              */
  DMA_CEEI_NOP_0                       = 0,     /*!< 0 : Normal operation                                                      */
  DMA_CEEI_NOP_1                       = 1,     /*!< 1 : No operation, ignore the other bits in this register                  */
} DMA_CEEI_NOP_Enum;

/* =======================================================  DMA_SEEI  ======================================================== */
/* ================================================  DMA DMA_SEEI NOP [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_SEEI_NOP                                                              */
  DMA_SEEI_NOP_0                       = 0,     /*!< 0 : Normal operation                                                      */
  DMA_SEEI_NOP_1                       = 1,     /*!< 1 : No operation, ignore the other bits in this register                  */
} DMA_SEEI_NOP_Enum;

/* =======================================================  DMA_CERQ  ======================================================== */
/* ================================================  DMA DMA_CERQ NOP [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_CERQ_NOP                                                              */
  DMA_CERQ_NOP_0                       = 0,     /*!< 0 : Normal operation                                                      */
  DMA_CERQ_NOP_1                       = 1,     /*!< 1 : No operation, ignore the other bits in this register                  */
} DMA_CERQ_NOP_Enum;

/* =======================================================  DMA_SERQ  ======================================================== */
/* ================================================  DMA DMA_SERQ NOP [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_SERQ_NOP                                                              */
  DMA_SERQ_NOP_0                       = 0,     /*!< 0 : Normal operation                                                      */
  DMA_SERQ_NOP_1                       = 1,     /*!< 1 : No operation, ignore the other bits in this register                  */
} DMA_SERQ_NOP_Enum;

/* =======================================================  DMA_CDNE  ======================================================== */
/* ===============================================  DMA DMA_CDNE CADN [6..6]  ================================================ */
typedef enum {                                  /*!< DMA_CDNE_CADN                                                             */
  DMA_CDNE_CADN_0                      = 0,     /*!< 0 : Clears only the TCDn_CSR[DONE] bit specified in the CDNE
                                                     field                                                                     */
  DMA_CDNE_CADN_1                      = 1,     /*!< 1 : Clears all bits in TCDn_CSR[DONE]                                     */
} DMA_CDNE_CADN_Enum;

/* ================================================  DMA DMA_CDNE NOP [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_CDNE_NOP                                                              */
  DMA_CDNE_NOP_0                       = 0,     /*!< 0 : Normal operation                                                      */
  DMA_CDNE_NOP_1                       = 1,     /*!< 1 : No operation, ignore the other bits in this register                  */
} DMA_CDNE_NOP_Enum;

/* =======================================================  DMA_SSRT  ======================================================== */
/* ===============================================  DMA DMA_SSRT SAST [6..6]  ================================================ */
typedef enum {                                  /*!< DMA_SSRT_SAST                                                             */
  DMA_SSRT_SAST_0                      = 0,     /*!< 0 : Set only the TCDn_CSR[START] bit specified in the SSRT field          */
  DMA_SSRT_SAST_1                      = 1,     /*!< 1 : Set all bits in TCDn_CSR[START]                                       */
} DMA_SSRT_SAST_Enum;

/* ================================================  DMA DMA_SSRT NOP [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_SSRT_NOP                                                              */
  DMA_SSRT_NOP_0                       = 0,     /*!< 0 : Normal operation                                                      */
  DMA_SSRT_NOP_1                       = 1,     /*!< 1 : No operation, ignore the other bits in this register                  */
} DMA_SSRT_NOP_Enum;

/* =======================================================  DMA_CERR  ======================================================== */
/* ================================================  DMA DMA_CERR NOP [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_CERR_NOP                                                              */
  DMA_CERR_NOP_0                       = 0,     /*!< 0 : Normal operation                                                      */
  DMA_CERR_NOP_1                       = 1,     /*!< 1 : No operation, ignore the other bits in this register                  */
} DMA_CERR_NOP_Enum;

/* =======================================================  DMA_CINT  ======================================================== */
/* ================================================  DMA DMA_CINT NOP [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_CINT_NOP                                                              */
  DMA_CINT_NOP_0                       = 0,     /*!< 0 : Normal operation                                                      */
  DMA_CINT_NOP_1                       = 1,     /*!< 1 : No operation, ignore the other bits in this register                  */
} DMA_CINT_NOP_Enum;

/* ========================================================  DMA_INT  ======================================================== */
/* ================================================  DMA DMA_INT INT0 [0..0]  ================================================ */
typedef enum {                                  /*!< DMA_INT_INT0                                                              */
  DMA_INT_INT0_0                       = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT0_1                       = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT0_Enum;

/* ================================================  DMA DMA_INT INT1 [1..1]  ================================================ */
typedef enum {                                  /*!< DMA_INT_INT1                                                              */
  DMA_INT_INT1_0                       = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT1_1                       = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT1_Enum;

/* ================================================  DMA DMA_INT INT2 [2..2]  ================================================ */
typedef enum {                                  /*!< DMA_INT_INT2                                                              */
  DMA_INT_INT2_0                       = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT2_1                       = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT2_Enum;

/* ================================================  DMA DMA_INT INT3 [3..3]  ================================================ */
typedef enum {                                  /*!< DMA_INT_INT3                                                              */
  DMA_INT_INT3_0                       = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT3_1                       = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT3_Enum;

/* ================================================  DMA DMA_INT INT4 [4..4]  ================================================ */
typedef enum {                                  /*!< DMA_INT_INT4                                                              */
  DMA_INT_INT4_0                       = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT4_1                       = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT4_Enum;

/* ================================================  DMA DMA_INT INT5 [5..5]  ================================================ */
typedef enum {                                  /*!< DMA_INT_INT5                                                              */
  DMA_INT_INT5_0                       = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT5_1                       = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT5_Enum;

/* ================================================  DMA DMA_INT INT6 [6..6]  ================================================ */
typedef enum {                                  /*!< DMA_INT_INT6                                                              */
  DMA_INT_INT6_0                       = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT6_1                       = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT6_Enum;

/* ================================================  DMA DMA_INT INT7 [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_INT_INT7                                                              */
  DMA_INT_INT7_0                       = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT7_1                       = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT7_Enum;

/* ================================================  DMA DMA_INT INT8 [8..8]  ================================================ */
typedef enum {                                  /*!< DMA_INT_INT8                                                              */
  DMA_INT_INT8_0                       = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT8_1                       = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT8_Enum;

/* ================================================  DMA DMA_INT INT9 [9..9]  ================================================ */
typedef enum {                                  /*!< DMA_INT_INT9                                                              */
  DMA_INT_INT9_0                       = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT9_1                       = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT9_Enum;

/* ==============================================  DMA DMA_INT INT10 [10..10]  =============================================== */
typedef enum {                                  /*!< DMA_INT_INT10                                                             */
  DMA_INT_INT10_0                      = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT10_1                      = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT10_Enum;

/* ==============================================  DMA DMA_INT INT11 [11..11]  =============================================== */
typedef enum {                                  /*!< DMA_INT_INT11                                                             */
  DMA_INT_INT11_0                      = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT11_1                      = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT11_Enum;

/* ==============================================  DMA DMA_INT INT12 [12..12]  =============================================== */
typedef enum {                                  /*!< DMA_INT_INT12                                                             */
  DMA_INT_INT12_0                      = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT12_1                      = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT12_Enum;

/* ==============================================  DMA DMA_INT INT13 [13..13]  =============================================== */
typedef enum {                                  /*!< DMA_INT_INT13                                                             */
  DMA_INT_INT13_0                      = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT13_1                      = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT13_Enum;

/* ==============================================  DMA DMA_INT INT14 [14..14]  =============================================== */
typedef enum {                                  /*!< DMA_INT_INT14                                                             */
  DMA_INT_INT14_0                      = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT14_1                      = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT14_Enum;

/* ==============================================  DMA DMA_INT INT15 [15..15]  =============================================== */
typedef enum {                                  /*!< DMA_INT_INT15                                                             */
  DMA_INT_INT15_0                      = 0,     /*!< 0 : The interrupt request for corresponding channel is cleared            */
  DMA_INT_INT15_1                      = 1,     /*!< 1 : The interrupt request for corresponding channel is active             */
} DMA_INT_INT15_Enum;

/* ========================================================  DMA_ERR  ======================================================== */
/* ================================================  DMA DMA_ERR ERR0 [0..0]  ================================================ */
typedef enum {                                  /*!< DMA_ERR_ERR0                                                              */
  DMA_ERR_ERR0_0                       = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR0_1                       = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR0_Enum;

/* ================================================  DMA DMA_ERR ERR1 [1..1]  ================================================ */
typedef enum {                                  /*!< DMA_ERR_ERR1                                                              */
  DMA_ERR_ERR1_0                       = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR1_1                       = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR1_Enum;

/* ================================================  DMA DMA_ERR ERR2 [2..2]  ================================================ */
typedef enum {                                  /*!< DMA_ERR_ERR2                                                              */
  DMA_ERR_ERR2_0                       = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR2_1                       = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR2_Enum;

/* ================================================  DMA DMA_ERR ERR3 [3..3]  ================================================ */
typedef enum {                                  /*!< DMA_ERR_ERR3                                                              */
  DMA_ERR_ERR3_0                       = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR3_1                       = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR3_Enum;

/* ================================================  DMA DMA_ERR ERR4 [4..4]  ================================================ */
typedef enum {                                  /*!< DMA_ERR_ERR4                                                              */
  DMA_ERR_ERR4_0                       = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR4_1                       = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR4_Enum;

/* ================================================  DMA DMA_ERR ERR5 [5..5]  ================================================ */
typedef enum {                                  /*!< DMA_ERR_ERR5                                                              */
  DMA_ERR_ERR5_0                       = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR5_1                       = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR5_Enum;

/* ================================================  DMA DMA_ERR ERR6 [6..6]  ================================================ */
typedef enum {                                  /*!< DMA_ERR_ERR6                                                              */
  DMA_ERR_ERR6_0                       = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR6_1                       = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR6_Enum;

/* ================================================  DMA DMA_ERR ERR7 [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_ERR_ERR7                                                              */
  DMA_ERR_ERR7_0                       = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR7_1                       = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR7_Enum;

/* ================================================  DMA DMA_ERR ERR8 [8..8]  ================================================ */
typedef enum {                                  /*!< DMA_ERR_ERR8                                                              */
  DMA_ERR_ERR8_0                       = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR8_1                       = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR8_Enum;

/* ================================================  DMA DMA_ERR ERR9 [9..9]  ================================================ */
typedef enum {                                  /*!< DMA_ERR_ERR9                                                              */
  DMA_ERR_ERR9_0                       = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR9_1                       = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR9_Enum;

/* ==============================================  DMA DMA_ERR ERR10 [10..10]  =============================================== */
typedef enum {                                  /*!< DMA_ERR_ERR10                                                             */
  DMA_ERR_ERR10_0                      = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR10_1                      = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR10_Enum;

/* ==============================================  DMA DMA_ERR ERR11 [11..11]  =============================================== */
typedef enum {                                  /*!< DMA_ERR_ERR11                                                             */
  DMA_ERR_ERR11_0                      = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR11_1                      = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR11_Enum;

/* ==============================================  DMA DMA_ERR ERR12 [12..12]  =============================================== */
typedef enum {                                  /*!< DMA_ERR_ERR12                                                             */
  DMA_ERR_ERR12_0                      = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR12_1                      = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR12_Enum;

/* ==============================================  DMA DMA_ERR ERR13 [13..13]  =============================================== */
typedef enum {                                  /*!< DMA_ERR_ERR13                                                             */
  DMA_ERR_ERR13_0                      = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR13_1                      = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR13_Enum;

/* ==============================================  DMA DMA_ERR ERR14 [14..14]  =============================================== */
typedef enum {                                  /*!< DMA_ERR_ERR14                                                             */
  DMA_ERR_ERR14_0                      = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR14_1                      = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR14_Enum;

/* ==============================================  DMA DMA_ERR ERR15 [15..15]  =============================================== */
typedef enum {                                  /*!< DMA_ERR_ERR15                                                             */
  DMA_ERR_ERR15_0                      = 0,     /*!< 0 : An error in this channel has not occurred                             */
  DMA_ERR_ERR15_1                      = 1,     /*!< 1 : An error in this channel has occurred                                 */
} DMA_ERR_ERR15_Enum;

/* ========================================================  DMA_HRS  ======================================================== */
/* ================================================  DMA DMA_HRS HRS0 [0..0]  ================================================ */
typedef enum {                                  /*!< DMA_HRS_HRS0                                                              */
  DMA_HRS_HRS0_0                       = 0,     /*!< 0 : A hardware service request for channel 0 is not present               */
  DMA_HRS_HRS0_1                       = 1,     /*!< 1 : A hardware service request for channel 0 is present                   */
} DMA_HRS_HRS0_Enum;

/* ================================================  DMA DMA_HRS HRS1 [1..1]  ================================================ */
typedef enum {                                  /*!< DMA_HRS_HRS1                                                              */
  DMA_HRS_HRS1_0                       = 0,     /*!< 0 : A hardware service request for channel 1 is not present               */
  DMA_HRS_HRS1_1                       = 1,     /*!< 1 : A hardware service request for channel 1 is present                   */
} DMA_HRS_HRS1_Enum;

/* ================================================  DMA DMA_HRS HRS2 [2..2]  ================================================ */
typedef enum {                                  /*!< DMA_HRS_HRS2                                                              */
  DMA_HRS_HRS2_0                       = 0,     /*!< 0 : A hardware service request for channel 2 is not present               */
  DMA_HRS_HRS2_1                       = 1,     /*!< 1 : A hardware service request for channel 2 is present                   */
} DMA_HRS_HRS2_Enum;

/* ================================================  DMA DMA_HRS HRS3 [3..3]  ================================================ */
typedef enum {                                  /*!< DMA_HRS_HRS3                                                              */
  DMA_HRS_HRS3_0                       = 0,     /*!< 0 : A hardware service request for channel 3 is not present               */
  DMA_HRS_HRS3_1                       = 1,     /*!< 1 : A hardware service request for channel 3 is present                   */
} DMA_HRS_HRS3_Enum;

/* ================================================  DMA DMA_HRS HRS4 [4..4]  ================================================ */
typedef enum {                                  /*!< DMA_HRS_HRS4                                                              */
  DMA_HRS_HRS4_0                       = 0,     /*!< 0 : A hardware service request for channel 4 is not present               */
  DMA_HRS_HRS4_1                       = 1,     /*!< 1 : A hardware service request for channel 4 is present                   */
} DMA_HRS_HRS4_Enum;

/* ================================================  DMA DMA_HRS HRS5 [5..5]  ================================================ */
typedef enum {                                  /*!< DMA_HRS_HRS5                                                              */
  DMA_HRS_HRS5_0                       = 0,     /*!< 0 : A hardware service request for channel 5 is not present               */
  DMA_HRS_HRS5_1                       = 1,     /*!< 1 : A hardware service request for channel 5 is present                   */
} DMA_HRS_HRS5_Enum;

/* ================================================  DMA DMA_HRS HRS6 [6..6]  ================================================ */
typedef enum {                                  /*!< DMA_HRS_HRS6                                                              */
  DMA_HRS_HRS6_0                       = 0,     /*!< 0 : A hardware service request for channel 6 is not present               */
  DMA_HRS_HRS6_1                       = 1,     /*!< 1 : A hardware service request for channel 6 is present                   */
} DMA_HRS_HRS6_Enum;

/* ================================================  DMA DMA_HRS HRS7 [7..7]  ================================================ */
typedef enum {                                  /*!< DMA_HRS_HRS7                                                              */
  DMA_HRS_HRS7_0                       = 0,     /*!< 0 : A hardware service request for channel 7 is not present               */
  DMA_HRS_HRS7_1                       = 1,     /*!< 1 : A hardware service request for channel 7 is present                   */
} DMA_HRS_HRS7_Enum;

/* ================================================  DMA DMA_HRS HRS8 [8..8]  ================================================ */
typedef enum {                                  /*!< DMA_HRS_HRS8                                                              */
  DMA_HRS_HRS8_0                       = 0,     /*!< 0 : A hardware service request for channel 8 is not present               */
  DMA_HRS_HRS8_1                       = 1,     /*!< 1 : A hardware service request for channel 8 is present                   */
} DMA_HRS_HRS8_Enum;

/* ================================================  DMA DMA_HRS HRS9 [9..9]  ================================================ */
typedef enum {                                  /*!< DMA_HRS_HRS9                                                              */
  DMA_HRS_HRS9_0                       = 0,     /*!< 0 : A hardware service request for channel 9 is not present               */
  DMA_HRS_HRS9_1                       = 1,     /*!< 1 : A hardware service request for channel 9 is present                   */
} DMA_HRS_HRS9_Enum;

/* ==============================================  DMA DMA_HRS HRS10 [10..10]  =============================================== */
typedef enum {                                  /*!< DMA_HRS_HRS10                                                             */
  DMA_HRS_HRS10_0                      = 0,     /*!< 0 : A hardware service request for channel 10 is not present              */
  DMA_HRS_HRS10_1                      = 1,     /*!< 1 : A hardware service request for channel 10 is present                  */
} DMA_HRS_HRS10_Enum;

/* ==============================================  DMA DMA_HRS HRS11 [11..11]  =============================================== */
typedef enum {                                  /*!< DMA_HRS_HRS11                                                             */
  DMA_HRS_HRS11_0                      = 0,     /*!< 0 : A hardware service request for channel 11 is not present              */
  DMA_HRS_HRS11_1                      = 1,     /*!< 1 : A hardware service request for channel 11 is present                  */
} DMA_HRS_HRS11_Enum;

/* ==============================================  DMA DMA_HRS HRS12 [12..12]  =============================================== */
typedef enum {                                  /*!< DMA_HRS_HRS12                                                             */
  DMA_HRS_HRS12_0                      = 0,     /*!< 0 : A hardware service request for channel 12 is not present              */
  DMA_HRS_HRS12_1                      = 1,     /*!< 1 : A hardware service request for channel 12 is present                  */
} DMA_HRS_HRS12_Enum;

/* ==============================================  DMA DMA_HRS HRS13 [13..13]  =============================================== */
typedef enum {                                  /*!< DMA_HRS_HRS13                                                             */
  DMA_HRS_HRS13_0                      = 0,     /*!< 0 : A hardware service request for channel 13 is not present              */
  DMA_HRS_HRS13_1                      = 1,     /*!< 1 : A hardware service request for channel 13 is present                  */
} DMA_HRS_HRS13_Enum;

/* ==============================================  DMA DMA_HRS HRS14 [14..14]  =============================================== */
typedef enum {                                  /*!< DMA_HRS_HRS14                                                             */
  DMA_HRS_HRS14_0                      = 0,     /*!< 0 : A hardware service request for channel 14 is not present              */
  DMA_HRS_HRS14_1                      = 1,     /*!< 1 : A hardware service request for channel 14 is present                  */
} DMA_HRS_HRS14_Enum;

/* ==============================================  DMA DMA_HRS HRS15 [15..15]  =============================================== */
typedef enum {                                  /*!< DMA_HRS_HRS15                                                             */
  DMA_HRS_HRS15_0                      = 0,     /*!< 0 : A hardware service request for channel 15 is not present              */
  DMA_HRS_HRS15_1                      = 1,     /*!< 1 : A hardware service request for channel 15 is present                  */
} DMA_HRS_HRS15_Enum;

/* =======================================================  DMA_EARS  ======================================================== */
/* ==============================================  DMA DMA_EARS EDREQ_0 [0..0]  ============================================== */
typedef enum {                                  /*!< DMA_EARS_EDREQ_0                                                          */
  DMA_EARS_EDREQ_0_0                   = 0,     /*!< 0 : Disable asynchronous DMA request for channel 0.                       */
  DMA_EARS_EDREQ_0_1                   = 1,     /*!< 1 : Enable asynchronous DMA request for channel 0.                        */
} DMA_EARS_EDREQ_0_Enum;

/* ==============================================  DMA DMA_EARS EDREQ_1 [1..1]  ============================================== */
typedef enum {                                  /*!< DMA_EARS_EDREQ_1                                                          */
  DMA_EARS_EDREQ_1_0                   = 0,     /*!< 0 : Disable asynchronous DMA request for channel 1                        */
  DMA_EARS_EDREQ_1_1                   = 1,     /*!< 1 : Enable asynchronous DMA request for channel 1.                        */
} DMA_EARS_EDREQ_1_Enum;

/* ==============================================  DMA DMA_EARS EDREQ_2 [2..2]  ============================================== */
typedef enum {                                  /*!< DMA_EARS_EDREQ_2                                                          */
  DMA_EARS_EDREQ_2_0                   = 0,     /*!< 0 : Disable asynchronous DMA request for channel 2.                       */
  DMA_EARS_EDREQ_2_1                   = 1,     /*!< 1 : Enable asynchronous DMA request for channel 2.                        */
} DMA_EARS_EDREQ_2_Enum;

/* ==============================================  DMA DMA_EARS EDREQ_3 [3..3]  ============================================== */
typedef enum {                                  /*!< DMA_EARS_EDREQ_3                                                          */
  DMA_EARS_EDREQ_3_0                   = 0,     /*!< 0 : Disable asynchronous DMA request for channel 3.                       */
  DMA_EARS_EDREQ_3_1                   = 1,     /*!< 1 : Enable asynchronous DMA request for channel 3.                        */
} DMA_EARS_EDREQ_3_Enum;

/* ==============================================  DMA DMA_EARS EDREQ_4 [4..4]  ============================================== */
typedef enum {                                  /*!< DMA_EARS_EDREQ_4                                                          */
  DMA_EARS_EDREQ_4_0                   = 0,     /*!< 0 : Disable asynchronous DMA request for channel 4.                       */
  DMA_EARS_EDREQ_4_1                   = 1,     /*!< 1 : Enable asynchronous DMA request for channel 4.                        */
} DMA_EARS_EDREQ_4_Enum;

/* ==============================================  DMA DMA_EARS EDREQ_5 [5..5]  ============================================== */
typedef enum {                                  /*!< DMA_EARS_EDREQ_5                                                          */
  DMA_EARS_EDREQ_5_0                   = 0,     /*!< 0 : Disable asynchronous DMA request for channel 5.                       */
  DMA_EARS_EDREQ_5_1                   = 1,     /*!< 1 : Enable asynchronous DMA request for channel 5.                        */
} DMA_EARS_EDREQ_5_Enum;

/* ==============================================  DMA DMA_EARS EDREQ_6 [6..6]  ============================================== */
typedef enum {                                  /*!< DMA_EARS_EDREQ_6                                                          */
  DMA_EARS_EDREQ_6_0                   = 0,     /*!< 0 : Disable asynchronous DMA request for channel 6.                       */
  DMA_EARS_EDREQ_6_1                   = 1,     /*!< 1 : Enable asynchronous DMA request for channel 6.                        */
} DMA_EARS_EDREQ_6_Enum;

/* ==============================================  DMA DMA_EARS EDREQ_7 [7..7]  ============================================== */
typedef enum {                                  /*!< DMA_EARS_EDREQ_7                                                          */
  DMA_EARS_EDREQ_7_0                   = 0,     /*!< 0 : Disable asynchronous DMA request for channel 7.                       */
  DMA_EARS_EDREQ_7_1                   = 1,     /*!< 1 : Enable asynchronous DMA request for channel 7.                        */
} DMA_EARS_EDREQ_7_Enum;

/* ==============================================  DMA DMA_EARS EDREQ_8 [8..8]  ============================================== */
typedef enum {                                  /*!< DMA_EARS_EDREQ_8                                                          */
  DMA_EARS_EDREQ_8_0                   = 0,     /*!< 0 : Disable asynchronous DMA request for channel 8.                       */
  DMA_EARS_EDREQ_8_1                   = 1,     /*!< 1 : Enable asynchronous DMA request for channel 8.                        */
} DMA_EARS_EDREQ_8_Enum;

/* ==============================================  DMA DMA_EARS EDREQ_9 [9..9]  ============================================== */
typedef enum {                                  /*!< DMA_EARS_EDREQ_9                                                          */
  DMA_EARS_EDREQ_9_0                   = 0,     /*!< 0 : Disable asynchronous DMA request for channel 9.                       */
  DMA_EARS_EDREQ_9_1                   = 1,     /*!< 1 : Enable asynchronous DMA request for channel 9.                        */
} DMA_EARS_EDREQ_9_Enum;

/* ============================================  DMA DMA_EARS EDREQ_10 [10..10]  ============================================= */
typedef enum {                                  /*!< DMA_EARS_EDREQ_10                                                         */
  DMA_EARS_EDREQ_10_0                  = 0,     /*!< 0 : Disable asynchronous DMA request for channel 10.                      */
  DMA_EARS_EDREQ_10_1                  = 1,     /*!< 1 : Enable asynchronous DMA request for channel 10.                       */
} DMA_EARS_EDREQ_10_Enum;

/* ============================================  DMA DMA_EARS EDREQ_11 [11..11]  ============================================= */
typedef enum {                                  /*!< DMA_EARS_EDREQ_11                                                         */
  DMA_EARS_EDREQ_11_0                  = 0,     /*!< 0 : Disable asynchronous DMA request for channel 11.                      */
  DMA_EARS_EDREQ_11_1                  = 1,     /*!< 1 : Enable asynchronous DMA request for channel 11.                       */
} DMA_EARS_EDREQ_11_Enum;

/* ============================================  DMA DMA_EARS EDREQ_12 [12..12]  ============================================= */
typedef enum {                                  /*!< DMA_EARS_EDREQ_12                                                         */
  DMA_EARS_EDREQ_12_0                  = 0,     /*!< 0 : Disable asynchronous DMA request for channel 12.                      */
  DMA_EARS_EDREQ_12_1                  = 1,     /*!< 1 : Enable asynchronous DMA request for channel 12.                       */
} DMA_EARS_EDREQ_12_Enum;

/* ============================================  DMA DMA_EARS EDREQ_13 [13..13]  ============================================= */
typedef enum {                                  /*!< DMA_EARS_EDREQ_13                                                         */
  DMA_EARS_EDREQ_13_0                  = 0,     /*!< 0 : Disable asynchronous DMA request for channel 13.                      */
  DMA_EARS_EDREQ_13_1                  = 1,     /*!< 1 : Enable asynchronous DMA request for channel 13.                       */
} DMA_EARS_EDREQ_13_Enum;

/* ============================================  DMA DMA_EARS EDREQ_14 [14..14]  ============================================= */
typedef enum {                                  /*!< DMA_EARS_EDREQ_14                                                         */
  DMA_EARS_EDREQ_14_0                  = 0,     /*!< 0 : Disable asynchronous DMA request for channel 14.                      */
  DMA_EARS_EDREQ_14_1                  = 1,     /*!< 1 : Enable asynchronous DMA request for channel 14.                       */
} DMA_EARS_EDREQ_14_Enum;

/* ============================================  DMA DMA_EARS EDREQ_15 [15..15]  ============================================= */
typedef enum {                                  /*!< DMA_EARS_EDREQ_15                                                         */
  DMA_EARS_EDREQ_15_0                  = 0,     /*!< 0 : Disable asynchronous DMA request for channel 15.                      */
  DMA_EARS_EDREQ_15_1                  = 1,     /*!< 1 : Enable asynchronous DMA request for channel 15.                       */
} DMA_EARS_EDREQ_15_Enum;

/* ======================================================  DMA_DCHPRI3  ====================================================== */
/* ==============================================  DMA DMA_DCHPRI3 DPA [6..6]  =============================================== */
typedef enum {                                  /*!< DMA_DCHPRI3_DPA                                                           */
  DMA_DCHPRI3_DPA_0                    = 0,     /*!< 0 : Channel n can suspend a lower priority channel.                       */
  DMA_DCHPRI3_DPA_1                    = 1,     /*!< 1 : Channel n cannot suspend any channel, regardless of channel
                                                     priority.                                                                 */
} DMA_DCHPRI3_DPA_Enum;

/* ==============================================  DMA DMA_DCHPRI3 ECP [7..7]  =============================================== */
typedef enum {                                  /*!< DMA_DCHPRI3_ECP                                                           */
  DMA_DCHPRI3_ECP_0                    = 0,     /*!< 0 : Channel n cannot be suspended by a higher priority channels
                                                     service request.                                                          */
  DMA_DCHPRI3_ECP_1                    = 1,     /*!< 1 : Channel n can be temporarily suspended by the service request
                                                     of a higher priority channel.                                             */
} DMA_DCHPRI3_ECP_Enum;

/* ======================================================  DMA_DCHPRI2  ====================================================== */
/* ==============================================  DMA DMA_DCHPRI2 DPA [6..6]  =============================================== */
typedef enum {                                  /*!< DMA_DCHPRI2_DPA                                                           */
  DMA_DCHPRI2_DPA_0                    = 0,     /*!< 0 : Channel n can suspend a lower priority channel.                       */
  DMA_DCHPRI2_DPA_1                    = 1,     /*!< 1 : Channel n cannot suspend any channel, regardless of channel
                                                     priority.                                                                 */
} DMA_DCHPRI2_DPA_Enum;

/* ==============================================  DMA DMA_DCHPRI2 ECP [7..7]  =============================================== */
typedef enum {                                  /*!< DMA_DCHPRI2_ECP                                                           */
  DMA_DCHPRI2_ECP_0                    = 0,     /*!< 0 : Channel n cannot be suspended by a higher priority channels
                                                     service request.                                                          */
  DMA_DCHPRI2_ECP_1                    = 1,     /*!< 1 : Channel n can be temporarily suspended by the service request
                                                     of a higher priority channel.                                             */
} DMA_DCHPRI2_ECP_Enum;

/* ======================================================  DMA_DCHPRI1  ====================================================== */
/* ==============================================  DMA DMA_DCHPRI1 DPA [6..6]  =============================================== */
typedef enum {                                  /*!< DMA_DCHPRI1_DPA                                                           */
  DMA_DCHPRI1_DPA_0                    = 0,     /*!< 0 : Channel n can suspend a lower priority channel.                       */
  DMA_DCHPRI1_DPA_1                    = 1,     /*!< 1 : Channel n cannot suspend any channel, regardless of channel
                                                     priority.                                                                 */
} DMA_DCHPRI1_DPA_Enum;

/* ==============================================  DMA DMA_DCHPRI1 ECP [7..7]  =============================================== */
typedef enum {                                  /*!< DMA_DCHPRI1_ECP                                                           */
  DMA_DCHPRI1_ECP_0                    = 0,     /*!< 0 : Channel n cannot be suspended by a higher priority channels
                                                     service request.                                                          */
  DMA_DCHPRI1_ECP_1                    = 1,     /*!< 1 : Channel n can be temporarily suspended by the service request
                                                     of a higher priority channel.                                             */
} DMA_DCHPRI1_ECP_Enum;

/* ======================================================  DMA_DCHPRI0  ====================================================== */
/* ==============================================  DMA DMA_DCHPRI0 DPA [6..6]  =============================================== */
typedef enum {                                  /*!< DMA_DCHPRI0_DPA                                                           */
  DMA_DCHPRI0_DPA_0                    = 0,     /*!< 0 : Channel n can suspend a lower priority channel.                       */
  DMA_DCHPRI0_DPA_1                    = 1,     /*!< 1 : Channel n cannot suspend any channel, regardless of channel
                                                     priority.                                                                 */
} DMA_DCHPRI0_DPA_Enum;

/* ==============================================  DMA DMA_DCHPRI0 ECP [7..7]  =============================================== */
typedef enum {                                  /*!< DMA_DCHPRI0_ECP                                                           */
  DMA_DCHPRI0_ECP_0                    = 0,     /*!< 0 : Channel n cannot be suspended by a higher priority channels
                                                     service request.                                                          */
  DMA_DCHPRI0_ECP_1                    = 1,     /*!< 1 : Channel n can be temporarily suspended by the service request
                                                     of a higher priority channel.                                             */
} DMA_DCHPRI0_ECP_Enum;

/* ====================================================  DMA_TCD0_SADDR  ===================================================== */
/* =====================================================  DMA_TCD0_SOFF  ===================================================== */
/* =====================================================  DMA_TCD0_ATTR  ===================================================== */
/* ============================================  DMA DMA_TCD0_ATTR SSIZE [8..10]  ============================================ */
typedef enum {                                  /*!< DMA_TCD0_ATTR_SSIZE                                                       */
  DMA_TCD0_ATTR_SSIZE_0                = 0,     /*!< 0 : 8-bit                                                                 */
  DMA_TCD0_ATTR_SSIZE_1                = 1,     /*!< 1 : 16-bit                                                                */
  DMA_TCD0_ATTR_SSIZE_10               = 2,     /*!< 10 : 32-bit                                                               */
} DMA_TCD0_ATTR_SSIZE_Enum;

/* ============================================  DMA DMA_TCD0_ATTR SMOD [11..15]  ============================================ */
typedef enum {                                  /*!< DMA_TCD0_ATTR_SMOD                                                        */
  DMA_TCD0_ATTR_SMOD_0                 = 0,     /*!< 0 : Source address modulo feature is disabled                             */
} DMA_TCD0_ATTR_SMOD_Enum;

/* ===============================================  DMA_TCD0_NBYTES_MLNO_DMA  ================================================ */
/* ==============================================  DMA_TCD0_NBYTES_MLOFFNO_DMA  ============================================== */
/* ====================================  DMA DMA_TCD0_NBYTES_MLOFFNO_DMA DMLOE [30..30]  ===================================== */
typedef enum {                                  /*!< DMA_TCD0_NBYTES_MLOFFNO_DMA_DMLOE                                         */
  DMA_TCD0_NBYTES_MLOFFNO_DMA_DMLOE_0  = 0,     /*!< 0 : The minor loop offset is not applied to the DADDR                     */
  DMA_TCD0_NBYTES_MLOFFNO_DMA_DMLOE_1  = 1,     /*!< 1 : The minor loop offset is applied to the DADDR                         */
} DMA_TCD0_NBYTES_MLOFFNO_DMA_DMLOE_Enum;

/* ====================================  DMA DMA_TCD0_NBYTES_MLOFFNO_DMA SMLOE [31..31]  ===================================== */
typedef enum {                                  /*!< DMA_TCD0_NBYTES_MLOFFNO_DMA_SMLOE                                         */
  DMA_TCD0_NBYTES_MLOFFNO_DMA_SMLOE_0  = 0,     /*!< 0 : The minor loop offset is not applied to the SADDR                     */
  DMA_TCD0_NBYTES_MLOFFNO_DMA_SMLOE_1  = 1,     /*!< 1 : The minor loop offset is applied to the SADDR                         */
} DMA_TCD0_NBYTES_MLOFFNO_DMA_SMLOE_Enum;

/* =============================================  DMA_TCD0_NBYTES_MLOFFYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD0_NBYTES_MLOFFYES_DMA DMLOE [30..30]  ==================================== */
typedef enum {                                  /*!< DMA_TCD0_NBYTES_MLOFFYES_DMA_DMLOE                                        */
  DMA_TCD0_NBYTES_MLOFFYES_DMA_DMLOE_0 = 0,     /*!< 0 : The minor loop offset is not applied to the DADDR                     */
  DMA_TCD0_NBYTES_MLOFFYES_DMA_DMLOE_1 = 1,     /*!< 1 : The minor loop offset is applied to the DADDR                         */
} DMA_TCD0_NBYTES_MLOFFYES_DMA_DMLOE_Enum;

/* ====================================  DMA DMA_TCD0_NBYTES_MLOFFYES_DMA SMLOE [31..31]  ==================================== */
typedef enum {                                  /*!< DMA_TCD0_NBYTES_MLOFFYES_DMA_SMLOE                                        */
  DMA_TCD0_NBYTES_MLOFFYES_DMA_SMLOE_0 = 0,     /*!< 0 : The minor loop offset is not applied to the SADDR                     */
  DMA_TCD0_NBYTES_MLOFFYES_DMA_SMLOE_1 = 1,     /*!< 1 : The minor loop offset is applied to the SADDR                         */
} DMA_TCD0_NBYTES_MLOFFYES_DMA_SMLOE_Enum;

/* ====================================================  DMA_TCD0_SLAST  ===================================================== */
/* ====================================================  DMA_TCD0_DADDR  ===================================================== */
/* =====================================================  DMA_TCD0_DOFF  ===================================================== */
/* ==============================================  DMA_TCD0_CITER_ELINKNO_DMA  =============================================== */
/* =====================================  DMA DMA_TCD0_CITER_ELINKNO_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD0_CITER_ELINKNO_DMA_ELINK                                          */
  DMA_TCD0_CITER_ELINKNO_DMA_ELINK_0   = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD0_CITER_ELINKNO_DMA_ELINK_1   = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD0_CITER_ELINKNO_DMA_ELINK_Enum;

/* ==============================================  DMA_TCD0_CITER_ELINKYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD0_CITER_ELINKYES_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD0_CITER_ELINKYES_DMA_ELINK                                         */
  DMA_TCD0_CITER_ELINKYES_DMA_ELINK_0  = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD0_CITER_ELINKYES_DMA_ELINK_1  = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD0_CITER_ELINKYES_DMA_ELINK_Enum;

/* ===================================================  DMA_TCD0_DLASTSGA  =================================================== */
/* =====================================================  DMA_TCD0_CSR  ====================================================== */
/* =============================================  DMA DMA_TCD0_CSR START [0..0]  ============================================= */
typedef enum {                                  /*!< DMA_TCD0_CSR_START                                                        */
  DMA_TCD0_CSR_START_0                 = 0,     /*!< 0 : The channel is not explicitly started.                                */
  DMA_TCD0_CSR_START_1                 = 1,     /*!< 1 : The channel is explicitly started via a software initiated
                                                     service request.                                                          */
} DMA_TCD0_CSR_START_Enum;

/* ===========================================  DMA DMA_TCD0_CSR INTMAJOR [1..1]  ============================================ */
typedef enum {                                  /*!< DMA_TCD0_CSR_INTMAJOR                                                     */
  DMA_TCD0_CSR_INTMAJOR_0              = 0,     /*!< 0 : The end-of-major loop interrupt is disabled.                          */
  DMA_TCD0_CSR_INTMAJOR_1              = 1,     /*!< 1 : The end-of-major loop interrupt is enabled.                           */
} DMA_TCD0_CSR_INTMAJOR_Enum;

/* ============================================  DMA DMA_TCD0_CSR INTHALF [2..2]  ============================================ */
typedef enum {                                  /*!< DMA_TCD0_CSR_INTHALF                                                      */
  DMA_TCD0_CSR_INTHALF_0               = 0,     /*!< 0 : The half-point interrupt is disabled.                                 */
  DMA_TCD0_CSR_INTHALF_1               = 1,     /*!< 1 : The half-point interrupt is enabled.                                  */
} DMA_TCD0_CSR_INTHALF_Enum;

/* ==============================================  DMA DMA_TCD0_CSR ESG [4..4]  ============================================== */
typedef enum {                                  /*!< DMA_TCD0_CSR_ESG                                                          */
  DMA_TCD0_CSR_ESG_0                   = 0,     /*!< 0 : The current channels TCD is normal format.                            */
  DMA_TCD0_CSR_ESG_1                   = 1,     /*!< 1 : The current channels TCD specifies a scatter gather format.
                                                     The DLASTSGA field provides a memory pointer to the next
                                                     TCD to be loaded into this channel after the major loop
                                                     completes its execution.                                                  */
} DMA_TCD0_CSR_ESG_Enum;

/* ==========================================  DMA DMA_TCD0_CSR MAJORELINK [5..5]  =========================================== */
typedef enum {                                  /*!< DMA_TCD0_CSR_MAJORELINK                                                   */
  DMA_TCD0_CSR_MAJORELINK_0            = 0,     /*!< 0 : The channel-to-channel linking is disabled.                           */
  DMA_TCD0_CSR_MAJORELINK_1            = 1,     /*!< 1 : The channel-to-channel linking is enabled.                            */
} DMA_TCD0_CSR_MAJORELINK_Enum;

/* =============================================  DMA DMA_TCD0_CSR BWC [14..15]  ============================================= */
typedef enum {                                  /*!< DMA_TCD0_CSR_BWC                                                          */
  DMA_TCD0_CSR_BWC_0                   = 0,     /*!< 0 : No eDMA engine stalls.                                                */
  DMA_TCD0_CSR_BWC_10                  = 2,     /*!< 10 : eDMA engine stalls for 4 cycles after each R/W.                      */
  DMA_TCD0_CSR_BWC_11                  = 3,     /*!< 11 : eDMA engine stalls for 8 cycles after each R/W.                      */
} DMA_TCD0_CSR_BWC_Enum;

/* ==============================================  DMA_TCD0_BITER_ELINKNO_DMA  =============================================== */
/* =====================================  DMA DMA_TCD0_BITER_ELINKNO_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD0_BITER_ELINKNO_DMA_ELINK                                          */
  DMA_TCD0_BITER_ELINKNO_DMA_ELINK_0   = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD0_BITER_ELINKNO_DMA_ELINK_1   = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD0_BITER_ELINKNO_DMA_ELINK_Enum;

/* ==============================================  DMA_TCD0_BITER_ELINKYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD0_BITER_ELINKYES_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD0_BITER_ELINKYES_DMA_ELINK                                         */
  DMA_TCD0_BITER_ELINKYES_DMA_ELINK_0  = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD0_BITER_ELINKYES_DMA_ELINK_1  = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD0_BITER_ELINKYES_DMA_ELINK_Enum;

/* ====================================================  DMA_TCD1_SADDR  ===================================================== */
/* =====================================================  DMA_TCD1_SOFF  ===================================================== */
/* =====================================================  DMA_TCD1_ATTR  ===================================================== */
/* ============================================  DMA DMA_TCD1_ATTR SSIZE [8..10]  ============================================ */
typedef enum {                                  /*!< DMA_TCD1_ATTR_SSIZE                                                       */
  DMA_TCD1_ATTR_SSIZE_0                = 0,     /*!< 0 : 8-bit                                                                 */
  DMA_TCD1_ATTR_SSIZE_1                = 1,     /*!< 1 : 16-bit                                                                */
  DMA_TCD1_ATTR_SSIZE_10               = 2,     /*!< 10 : 32-bit                                                               */
} DMA_TCD1_ATTR_SSIZE_Enum;

/* ============================================  DMA DMA_TCD1_ATTR SMOD [11..15]  ============================================ */
typedef enum {                                  /*!< DMA_TCD1_ATTR_SMOD                                                        */
  DMA_TCD1_ATTR_SMOD_0                 = 0,     /*!< 0 : Source address modulo feature is disabled                             */
} DMA_TCD1_ATTR_SMOD_Enum;

/* ===============================================  DMA_TCD1_NBYTES_MLNO_DMA  ================================================ */
/* ==============================================  DMA_TCD1_NBYTES_MLOFFNO_DMA  ============================================== */
/* ====================================  DMA DMA_TCD1_NBYTES_MLOFFNO_DMA DMLOE [30..30]  ===================================== */
typedef enum {                                  /*!< DMA_TCD1_NBYTES_MLOFFNO_DMA_DMLOE                                         */
  DMA_TCD1_NBYTES_MLOFFNO_DMA_DMLOE_0  = 0,     /*!< 0 : The minor loop offset is not applied to the DADDR                     */
  DMA_TCD1_NBYTES_MLOFFNO_DMA_DMLOE_1  = 1,     /*!< 1 : The minor loop offset is applied to the DADDR                         */
} DMA_TCD1_NBYTES_MLOFFNO_DMA_DMLOE_Enum;

/* ====================================  DMA DMA_TCD1_NBYTES_MLOFFNO_DMA SMLOE [31..31]  ===================================== */
typedef enum {                                  /*!< DMA_TCD1_NBYTES_MLOFFNO_DMA_SMLOE                                         */
  DMA_TCD1_NBYTES_MLOFFNO_DMA_SMLOE_0  = 0,     /*!< 0 : The minor loop offset is not applied to the SADDR                     */
  DMA_TCD1_NBYTES_MLOFFNO_DMA_SMLOE_1  = 1,     /*!< 1 : The minor loop offset is applied to the SADDR                         */
} DMA_TCD1_NBYTES_MLOFFNO_DMA_SMLOE_Enum;

/* =============================================  DMA_TCD1_NBYTES_MLOFFYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD1_NBYTES_MLOFFYES_DMA DMLOE [30..30]  ==================================== */
typedef enum {                                  /*!< DMA_TCD1_NBYTES_MLOFFYES_DMA_DMLOE                                        */
  DMA_TCD1_NBYTES_MLOFFYES_DMA_DMLOE_0 = 0,     /*!< 0 : The minor loop offset is not applied to the DADDR                     */
  DMA_TCD1_NBYTES_MLOFFYES_DMA_DMLOE_1 = 1,     /*!< 1 : The minor loop offset is applied to the DADDR                         */
} DMA_TCD1_NBYTES_MLOFFYES_DMA_DMLOE_Enum;

/* ====================================  DMA DMA_TCD1_NBYTES_MLOFFYES_DMA SMLOE [31..31]  ==================================== */
typedef enum {                                  /*!< DMA_TCD1_NBYTES_MLOFFYES_DMA_SMLOE                                        */
  DMA_TCD1_NBYTES_MLOFFYES_DMA_SMLOE_0 = 0,     /*!< 0 : The minor loop offset is not applied to the SADDR                     */
  DMA_TCD1_NBYTES_MLOFFYES_DMA_SMLOE_1 = 1,     /*!< 1 : The minor loop offset is applied to the SADDR                         */
} DMA_TCD1_NBYTES_MLOFFYES_DMA_SMLOE_Enum;

/* ====================================================  DMA_TCD1_SLAST  ===================================================== */
/* ====================================================  DMA_TCD1_DADDR  ===================================================== */
/* =====================================================  DMA_TCD1_DOFF  ===================================================== */
/* ==============================================  DMA_TCD1_CITER_ELINKNO_DMA  =============================================== */
/* =====================================  DMA DMA_TCD1_CITER_ELINKNO_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD1_CITER_ELINKNO_DMA_ELINK                                          */
  DMA_TCD1_CITER_ELINKNO_DMA_ELINK_0   = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD1_CITER_ELINKNO_DMA_ELINK_1   = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD1_CITER_ELINKNO_DMA_ELINK_Enum;

/* ==============================================  DMA_TCD1_CITER_ELINKYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD1_CITER_ELINKYES_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD1_CITER_ELINKYES_DMA_ELINK                                         */
  DMA_TCD1_CITER_ELINKYES_DMA_ELINK_0  = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD1_CITER_ELINKYES_DMA_ELINK_1  = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD1_CITER_ELINKYES_DMA_ELINK_Enum;

/* ===================================================  DMA_TCD1_DLASTSGA  =================================================== */
/* =====================================================  DMA_TCD1_CSR  ====================================================== */
/* =============================================  DMA DMA_TCD1_CSR START [0..0]  ============================================= */
typedef enum {                                  /*!< DMA_TCD1_CSR_START                                                        */
  DMA_TCD1_CSR_START_0                 = 0,     /*!< 0 : The channel is not explicitly started.                                */
  DMA_TCD1_CSR_START_1                 = 1,     /*!< 1 : The channel is explicitly started via a software initiated
                                                     service request.                                                          */
} DMA_TCD1_CSR_START_Enum;

/* ===========================================  DMA DMA_TCD1_CSR INTMAJOR [1..1]  ============================================ */
typedef enum {                                  /*!< DMA_TCD1_CSR_INTMAJOR                                                     */
  DMA_TCD1_CSR_INTMAJOR_0              = 0,     /*!< 0 : The end-of-major loop interrupt is disabled.                          */
  DMA_TCD1_CSR_INTMAJOR_1              = 1,     /*!< 1 : The end-of-major loop interrupt is enabled.                           */
} DMA_TCD1_CSR_INTMAJOR_Enum;

/* ============================================  DMA DMA_TCD1_CSR INTHALF [2..2]  ============================================ */
typedef enum {                                  /*!< DMA_TCD1_CSR_INTHALF                                                      */
  DMA_TCD1_CSR_INTHALF_0               = 0,     /*!< 0 : The half-point interrupt is disabled.                                 */
  DMA_TCD1_CSR_INTHALF_1               = 1,     /*!< 1 : The half-point interrupt is enabled.                                  */
} DMA_TCD1_CSR_INTHALF_Enum;

/* ==============================================  DMA DMA_TCD1_CSR ESG [4..4]  ============================================== */
typedef enum {                                  /*!< DMA_TCD1_CSR_ESG                                                          */
  DMA_TCD1_CSR_ESG_0                   = 0,     /*!< 0 : The current channels TCD is normal format.                            */
  DMA_TCD1_CSR_ESG_1                   = 1,     /*!< 1 : The current channels TCD specifies a scatter gather format.
                                                     The DLASTSGA field provides a memory pointer to the next
                                                     TCD to be loaded into this channel after the major loop
                                                     completes its execution.                                                  */
} DMA_TCD1_CSR_ESG_Enum;

/* ==========================================  DMA DMA_TCD1_CSR MAJORELINK [5..5]  =========================================== */
typedef enum {                                  /*!< DMA_TCD1_CSR_MAJORELINK                                                   */
  DMA_TCD1_CSR_MAJORELINK_0            = 0,     /*!< 0 : The channel-to-channel linking is disabled.                           */
  DMA_TCD1_CSR_MAJORELINK_1            = 1,     /*!< 1 : The channel-to-channel linking is enabled.                            */
} DMA_TCD1_CSR_MAJORELINK_Enum;

/* =============================================  DMA DMA_TCD1_CSR BWC [14..15]  ============================================= */
typedef enum {                                  /*!< DMA_TCD1_CSR_BWC                                                          */
  DMA_TCD1_CSR_BWC_0                   = 0,     /*!< 0 : No eDMA engine stalls.                                                */
  DMA_TCD1_CSR_BWC_10                  = 2,     /*!< 10 : eDMA engine stalls for 4 cycles after each R/W.                      */
  DMA_TCD1_CSR_BWC_11                  = 3,     /*!< 11 : eDMA engine stalls for 8 cycles after each R/W.                      */
} DMA_TCD1_CSR_BWC_Enum;

/* ==============================================  DMA_TCD1_BITER_ELINKNO_DMA  =============================================== */
/* =====================================  DMA DMA_TCD1_BITER_ELINKNO_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD1_BITER_ELINKNO_DMA_ELINK                                          */
  DMA_TCD1_BITER_ELINKNO_DMA_ELINK_0   = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD1_BITER_ELINKNO_DMA_ELINK_1   = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD1_BITER_ELINKNO_DMA_ELINK_Enum;

/* ==============================================  DMA_TCD1_BITER_ELINKYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD1_BITER_ELINKYES_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD1_BITER_ELINKYES_DMA_ELINK                                         */
  DMA_TCD1_BITER_ELINKYES_DMA_ELINK_0  = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD1_BITER_ELINKYES_DMA_ELINK_1  = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD1_BITER_ELINKYES_DMA_ELINK_Enum;

/* ====================================================  DMA_TCD2_SADDR  ===================================================== */
/* =====================================================  DMA_TCD2_SOFF  ===================================================== */
/* =====================================================  DMA_TCD2_ATTR  ===================================================== */
/* ============================================  DMA DMA_TCD2_ATTR SSIZE [8..10]  ============================================ */
typedef enum {                                  /*!< DMA_TCD2_ATTR_SSIZE                                                       */
  DMA_TCD2_ATTR_SSIZE_0                = 0,     /*!< 0 : 8-bit                                                                 */
  DMA_TCD2_ATTR_SSIZE_1                = 1,     /*!< 1 : 16-bit                                                                */
  DMA_TCD2_ATTR_SSIZE_10               = 2,     /*!< 10 : 32-bit                                                               */
} DMA_TCD2_ATTR_SSIZE_Enum;

/* ============================================  DMA DMA_TCD2_ATTR SMOD [11..15]  ============================================ */
typedef enum {                                  /*!< DMA_TCD2_ATTR_SMOD                                                        */
  DMA_TCD2_ATTR_SMOD_0                 = 0,     /*!< 0 : Source address modulo feature is disabled                             */
} DMA_TCD2_ATTR_SMOD_Enum;

/* ===============================================  DMA_TCD2_NBYTES_MLNO_DMA  ================================================ */
/* ==============================================  DMA_TCD2_NBYTES_MLOFFNO_DMA  ============================================== */
/* ====================================  DMA DMA_TCD2_NBYTES_MLOFFNO_DMA DMLOE [30..30]  ===================================== */
typedef enum {                                  /*!< DMA_TCD2_NBYTES_MLOFFNO_DMA_DMLOE                                         */
  DMA_TCD2_NBYTES_MLOFFNO_DMA_DMLOE_0  = 0,     /*!< 0 : The minor loop offset is not applied to the DADDR                     */
  DMA_TCD2_NBYTES_MLOFFNO_DMA_DMLOE_1  = 1,     /*!< 1 : The minor loop offset is applied to the DADDR                         */
} DMA_TCD2_NBYTES_MLOFFNO_DMA_DMLOE_Enum;

/* ====================================  DMA DMA_TCD2_NBYTES_MLOFFNO_DMA SMLOE [31..31]  ===================================== */
typedef enum {                                  /*!< DMA_TCD2_NBYTES_MLOFFNO_DMA_SMLOE                                         */
  DMA_TCD2_NBYTES_MLOFFNO_DMA_SMLOE_0  = 0,     /*!< 0 : The minor loop offset is not applied to the SADDR                     */
  DMA_TCD2_NBYTES_MLOFFNO_DMA_SMLOE_1  = 1,     /*!< 1 : The minor loop offset is applied to the SADDR                         */
} DMA_TCD2_NBYTES_MLOFFNO_DMA_SMLOE_Enum;

/* =============================================  DMA_TCD2_NBYTES_MLOFFYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD2_NBYTES_MLOFFYES_DMA DMLOE [30..30]  ==================================== */
typedef enum {                                  /*!< DMA_TCD2_NBYTES_MLOFFYES_DMA_DMLOE                                        */
  DMA_TCD2_NBYTES_MLOFFYES_DMA_DMLOE_0 = 0,     /*!< 0 : The minor loop offset is not applied to the DADDR                     */
  DMA_TCD2_NBYTES_MLOFFYES_DMA_DMLOE_1 = 1,     /*!< 1 : The minor loop offset is applied to the DADDR                         */
} DMA_TCD2_NBYTES_MLOFFYES_DMA_DMLOE_Enum;

/* ====================================  DMA DMA_TCD2_NBYTES_MLOFFYES_DMA SMLOE [31..31]  ==================================== */
typedef enum {                                  /*!< DMA_TCD2_NBYTES_MLOFFYES_DMA_SMLOE                                        */
  DMA_TCD2_NBYTES_MLOFFYES_DMA_SMLOE_0 = 0,     /*!< 0 : The minor loop offset is not applied to the SADDR                     */
  DMA_TCD2_NBYTES_MLOFFYES_DMA_SMLOE_1 = 1,     /*!< 1 : The minor loop offset is applied to the SADDR                         */
} DMA_TCD2_NBYTES_MLOFFYES_DMA_SMLOE_Enum;

/* ====================================================  DMA_TCD2_SLAST  ===================================================== */
/* ====================================================  DMA_TCD2_DADDR  ===================================================== */
/* =====================================================  DMA_TCD2_DOFF  ===================================================== */
/* ==============================================  DMA_TCD2_CITER_ELINKNO_DMA  =============================================== */
/* =====================================  DMA DMA_TCD2_CITER_ELINKNO_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD2_CITER_ELINKNO_DMA_ELINK                                          */
  DMA_TCD2_CITER_ELINKNO_DMA_ELINK_0   = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD2_CITER_ELINKNO_DMA_ELINK_1   = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD2_CITER_ELINKNO_DMA_ELINK_Enum;

/* ==============================================  DMA_TCD2_CITER_ELINKYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD2_CITER_ELINKYES_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD2_CITER_ELINKYES_DMA_ELINK                                         */
  DMA_TCD2_CITER_ELINKYES_DMA_ELINK_0  = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD2_CITER_ELINKYES_DMA_ELINK_1  = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD2_CITER_ELINKYES_DMA_ELINK_Enum;

/* ===================================================  DMA_TCD2_DLASTSGA  =================================================== */
/* =====================================================  DMA_TCD2_CSR  ====================================================== */
/* =============================================  DMA DMA_TCD2_CSR START [0..0]  ============================================= */
typedef enum {                                  /*!< DMA_TCD2_CSR_START                                                        */
  DMA_TCD2_CSR_START_0                 = 0,     /*!< 0 : The channel is not explicitly started.                                */
  DMA_TCD2_CSR_START_1                 = 1,     /*!< 1 : The channel is explicitly started via a software initiated
                                                     service request.                                                          */
} DMA_TCD2_CSR_START_Enum;

/* ===========================================  DMA DMA_TCD2_CSR INTMAJOR [1..1]  ============================================ */
typedef enum {                                  /*!< DMA_TCD2_CSR_INTMAJOR                                                     */
  DMA_TCD2_CSR_INTMAJOR_0              = 0,     /*!< 0 : The end-of-major loop interrupt is disabled.                          */
  DMA_TCD2_CSR_INTMAJOR_1              = 1,     /*!< 1 : The end-of-major loop interrupt is enabled.                           */
} DMA_TCD2_CSR_INTMAJOR_Enum;

/* ============================================  DMA DMA_TCD2_CSR INTHALF [2..2]  ============================================ */
typedef enum {                                  /*!< DMA_TCD2_CSR_INTHALF                                                      */
  DMA_TCD2_CSR_INTHALF_0               = 0,     /*!< 0 : The half-point interrupt is disabled.                                 */
  DMA_TCD2_CSR_INTHALF_1               = 1,     /*!< 1 : The half-point interrupt is enabled.                                  */
} DMA_TCD2_CSR_INTHALF_Enum;

/* ==============================================  DMA DMA_TCD2_CSR ESG [4..4]  ============================================== */
typedef enum {                                  /*!< DMA_TCD2_CSR_ESG                                                          */
  DMA_TCD2_CSR_ESG_0                   = 0,     /*!< 0 : The current channels TCD is normal format.                            */
  DMA_TCD2_CSR_ESG_1                   = 1,     /*!< 1 : The current channels TCD specifies a scatter gather format.
                                                     The DLASTSGA field provides a memory pointer to the next
                                                     TCD to be loaded into this channel after the major loop
                                                     completes its execution.                                                  */
} DMA_TCD2_CSR_ESG_Enum;

/* ==========================================  DMA DMA_TCD2_CSR MAJORELINK [5..5]  =========================================== */
typedef enum {                                  /*!< DMA_TCD2_CSR_MAJORELINK                                                   */
  DMA_TCD2_CSR_MAJORELINK_0            = 0,     /*!< 0 : The channel-to-channel linking is disabled.                           */
  DMA_TCD2_CSR_MAJORELINK_1            = 1,     /*!< 1 : The channel-to-channel linking is enabled.                            */
} DMA_TCD2_CSR_MAJORELINK_Enum;

/* =============================================  DMA DMA_TCD2_CSR BWC [14..15]  ============================================= */
typedef enum {                                  /*!< DMA_TCD2_CSR_BWC                                                          */
  DMA_TCD2_CSR_BWC_0                   = 0,     /*!< 0 : No eDMA engine stalls.                                                */
  DMA_TCD2_CSR_BWC_10                  = 2,     /*!< 10 : eDMA engine stalls for 4 cycles after each R/W.                      */
  DMA_TCD2_CSR_BWC_11                  = 3,     /*!< 11 : eDMA engine stalls for 8 cycles after each R/W.                      */
} DMA_TCD2_CSR_BWC_Enum;

/* ==============================================  DMA_TCD2_BITER_ELINKNO_DMA  =============================================== */
/* =====================================  DMA DMA_TCD2_BITER_ELINKNO_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD2_BITER_ELINKNO_DMA_ELINK                                          */
  DMA_TCD2_BITER_ELINKNO_DMA_ELINK_0   = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD2_BITER_ELINKNO_DMA_ELINK_1   = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD2_BITER_ELINKNO_DMA_ELINK_Enum;

/* ==============================================  DMA_TCD2_BITER_ELINKYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD2_BITER_ELINKYES_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD2_BITER_ELINKYES_DMA_ELINK                                         */
  DMA_TCD2_BITER_ELINKYES_DMA_ELINK_0  = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD2_BITER_ELINKYES_DMA_ELINK_1  = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD2_BITER_ELINKYES_DMA_ELINK_Enum;

/* ====================================================  DMA_TCD3_SADDR  ===================================================== */
/* =====================================================  DMA_TCD3_SOFF  ===================================================== */
/* =====================================================  DMA_TCD3_ATTR  ===================================================== */
/* ============================================  DMA DMA_TCD3_ATTR SSIZE [8..10]  ============================================ */
typedef enum {                                  /*!< DMA_TCD3_ATTR_SSIZE                                                       */
  DMA_TCD3_ATTR_SSIZE_0                = 0,     /*!< 0 : 8-bit                                                                 */
  DMA_TCD3_ATTR_SSIZE_1                = 1,     /*!< 1 : 16-bit                                                                */
  DMA_TCD3_ATTR_SSIZE_10               = 2,     /*!< 10 : 32-bit                                                               */
} DMA_TCD3_ATTR_SSIZE_Enum;

/* ============================================  DMA DMA_TCD3_ATTR SMOD [11..15]  ============================================ */
typedef enum {                                  /*!< DMA_TCD3_ATTR_SMOD                                                        */
  DMA_TCD3_ATTR_SMOD_0                 = 0,     /*!< 0 : Source address modulo feature is disabled                             */
} DMA_TCD3_ATTR_SMOD_Enum;

/* ===============================================  DMA_TCD3_NBYTES_MLNO_DMA  ================================================ */
/* ==============================================  DMA_TCD3_NBYTES_MLOFFNO_DMA  ============================================== */
/* ====================================  DMA DMA_TCD3_NBYTES_MLOFFNO_DMA DMLOE [30..30]  ===================================== */
typedef enum {                                  /*!< DMA_TCD3_NBYTES_MLOFFNO_DMA_DMLOE                                         */
  DMA_TCD3_NBYTES_MLOFFNO_DMA_DMLOE_0  = 0,     /*!< 0 : The minor loop offset is not applied to the DADDR                     */
  DMA_TCD3_NBYTES_MLOFFNO_DMA_DMLOE_1  = 1,     /*!< 1 : The minor loop offset is applied to the DADDR                         */
} DMA_TCD3_NBYTES_MLOFFNO_DMA_DMLOE_Enum;

/* ====================================  DMA DMA_TCD3_NBYTES_MLOFFNO_DMA SMLOE [31..31]  ===================================== */
typedef enum {                                  /*!< DMA_TCD3_NBYTES_MLOFFNO_DMA_SMLOE                                         */
  DMA_TCD3_NBYTES_MLOFFNO_DMA_SMLOE_0  = 0,     /*!< 0 : The minor loop offset is not applied to the SADDR                     */
  DMA_TCD3_NBYTES_MLOFFNO_DMA_SMLOE_1  = 1,     /*!< 1 : The minor loop offset is applied to the SADDR                         */
} DMA_TCD3_NBYTES_MLOFFNO_DMA_SMLOE_Enum;

/* =============================================  DMA_TCD3_NBYTES_MLOFFYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD3_NBYTES_MLOFFYES_DMA DMLOE [30..30]  ==================================== */
typedef enum {                                  /*!< DMA_TCD3_NBYTES_MLOFFYES_DMA_DMLOE                                        */
  DMA_TCD3_NBYTES_MLOFFYES_DMA_DMLOE_0 = 0,     /*!< 0 : The minor loop offset is not applied to the DADDR                     */
  DMA_TCD3_NBYTES_MLOFFYES_DMA_DMLOE_1 = 1,     /*!< 1 : The minor loop offset is applied to the DADDR                         */
} DMA_TCD3_NBYTES_MLOFFYES_DMA_DMLOE_Enum;

/* ====================================  DMA DMA_TCD3_NBYTES_MLOFFYES_DMA SMLOE [31..31]  ==================================== */
typedef enum {                                  /*!< DMA_TCD3_NBYTES_MLOFFYES_DMA_SMLOE                                        */
  DMA_TCD3_NBYTES_MLOFFYES_DMA_SMLOE_0 = 0,     /*!< 0 : The minor loop offset is not applied to the SADDR                     */
  DMA_TCD3_NBYTES_MLOFFYES_DMA_SMLOE_1 = 1,     /*!< 1 : The minor loop offset is applied to the SADDR                         */
} DMA_TCD3_NBYTES_MLOFFYES_DMA_SMLOE_Enum;

/* ====================================================  DMA_TCD3_SLAST  ===================================================== */
/* ====================================================  DMA_TCD3_DADDR  ===================================================== */
/* =====================================================  DMA_TCD3_DOFF  ===================================================== */
/* ==============================================  DMA_TCD3_CITER_ELINKNO_DMA  =============================================== */
/* =====================================  DMA DMA_TCD3_CITER_ELINKNO_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD3_CITER_ELINKNO_DMA_ELINK                                          */
  DMA_TCD3_CITER_ELINKNO_DMA_ELINK_0   = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD3_CITER_ELINKNO_DMA_ELINK_1   = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD3_CITER_ELINKNO_DMA_ELINK_Enum;

/* ==============================================  DMA_TCD3_CITER_ELINKYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD3_CITER_ELINKYES_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD3_CITER_ELINKYES_DMA_ELINK                                         */
  DMA_TCD3_CITER_ELINKYES_DMA_ELINK_0  = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD3_CITER_ELINKYES_DMA_ELINK_1  = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD3_CITER_ELINKYES_DMA_ELINK_Enum;

/* ===================================================  DMA_TCD3_DLASTSGA  =================================================== */
/* =====================================================  DMA_TCD3_CSR  ====================================================== */
/* =============================================  DMA DMA_TCD3_CSR START [0..0]  ============================================= */
typedef enum {                                  /*!< DMA_TCD3_CSR_START                                                        */
  DMA_TCD3_CSR_START_0                 = 0,     /*!< 0 : The channel is not explicitly started.                                */
  DMA_TCD3_CSR_START_1                 = 1,     /*!< 1 : The channel is explicitly started via a software initiated
                                                     service request.                                                          */
} DMA_TCD3_CSR_START_Enum;

/* ===========================================  DMA DMA_TCD3_CSR INTMAJOR [1..1]  ============================================ */
typedef enum {                                  /*!< DMA_TCD3_CSR_INTMAJOR                                                     */
  DMA_TCD3_CSR_INTMAJOR_0              = 0,     /*!< 0 : The end-of-major loop interrupt is disabled.                          */
  DMA_TCD3_CSR_INTMAJOR_1              = 1,     /*!< 1 : The end-of-major loop interrupt is enabled.                           */
} DMA_TCD3_CSR_INTMAJOR_Enum;

/* ============================================  DMA DMA_TCD3_CSR INTHALF [2..2]  ============================================ */
typedef enum {                                  /*!< DMA_TCD3_CSR_INTHALF                                                      */
  DMA_TCD3_CSR_INTHALF_0               = 0,     /*!< 0 : The half-point interrupt is disabled.                                 */
  DMA_TCD3_CSR_INTHALF_1               = 1,     /*!< 1 : The half-point interrupt is enabled.                                  */
} DMA_TCD3_CSR_INTHALF_Enum;

/* ==============================================  DMA DMA_TCD3_CSR ESG [4..4]  ============================================== */
typedef enum {                                  /*!< DMA_TCD3_CSR_ESG                                                          */
  DMA_TCD3_CSR_ESG_0                   = 0,     /*!< 0 : The current channels TCD is normal format.                            */
  DMA_TCD3_CSR_ESG_1                   = 1,     /*!< 1 : The current channels TCD specifies a scatter gather format.
                                                     The DLASTSGA field provides a memory pointer to the next
                                                     TCD to be loaded into this channel after the major loop
                                                     completes its execution.                                                  */
} DMA_TCD3_CSR_ESG_Enum;

/* ==========================================  DMA DMA_TCD3_CSR MAJORELINK [5..5]  =========================================== */
typedef enum {                                  /*!< DMA_TCD3_CSR_MAJORELINK                                                   */
  DMA_TCD3_CSR_MAJORELINK_0            = 0,     /*!< 0 : The channel-to-channel linking is disabled.                           */
  DMA_TCD3_CSR_MAJORELINK_1            = 1,     /*!< 1 : The channel-to-channel linking is enabled.                            */
} DMA_TCD3_CSR_MAJORELINK_Enum;

/* =============================================  DMA DMA_TCD3_CSR BWC [14..15]  ============================================= */
typedef enum {                                  /*!< DMA_TCD3_CSR_BWC                                                          */
  DMA_TCD3_CSR_BWC_0                   = 0,     /*!< 0 : No eDMA engine stalls.                                                */
  DMA_TCD3_CSR_BWC_10                  = 2,     /*!< 10 : eDMA engine stalls for 4 cycles after each R/W.                      */
  DMA_TCD3_CSR_BWC_11                  = 3,     /*!< 11 : eDMA engine stalls for 8 cycles after each R/W.                      */
} DMA_TCD3_CSR_BWC_Enum;

/* ==============================================  DMA_TCD3_BITER_ELINKNO_DMA  =============================================== */
/* =====================================  DMA DMA_TCD3_BITER_ELINKNO_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD3_BITER_ELINKNO_DMA_ELINK                                          */
  DMA_TCD3_BITER_ELINKNO_DMA_ELINK_0   = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD3_BITER_ELINKNO_DMA_ELINK_1   = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD3_BITER_ELINKNO_DMA_ELINK_Enum;

/* ==============================================  DMA_TCD3_BITER_ELINKYES_DMA  ============================================== */
/* ====================================  DMA DMA_TCD3_BITER_ELINKYES_DMA ELINK [15..15]  ===================================== */
typedef enum {                                  /*!< DMA_TCD3_BITER_ELINKYES_DMA_ELINK                                         */
  DMA_TCD3_BITER_ELINKYES_DMA_ELINK_0  = 0,     /*!< 0 : The channel-to-channel linking is disabled                            */
  DMA_TCD3_BITER_ELINKYES_DMA_ELINK_1  = 1,     /*!< 1 : The channel-to-channel linking is enabled                             */
} DMA_TCD3_BITER_ELINKYES_DMA_ELINK_Enum;



/* =========================================================================================================================== */
/* ================                                            MPU                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  MPU_CESR  ======================================================== */
/* ================================================  MPU MPU_CESR VLD [0..0]  ================================================ */
typedef enum {                                  /*!< MPU_CESR_VLD                                                              */
  MPU_CESR_VLD_0                       = 0,     /*!< 0 : MPU is disabled. All accesses from all bus masters are allowed.       */
  MPU_CESR_VLD_1                       = 1,     /*!< 1 : MPU is enabled                                                        */
} MPU_CESR_VLD_Enum;

/* ===============================================  MPU MPU_CESR NRGD [8..11]  =============================================== */
typedef enum {                                  /*!< MPU_CESR_NRGD                                                             */
  MPU_CESR_NRGD_0000                   = 0,     /*!< 0000 : 8 region descriptors                                               */
  MPU_CESR_NRGD_0001                   = 1,     /*!< 0001 : 12 region descriptors                                              */
  MPU_CESR_NRGD_0010                   = 2,     /*!< 0010 : 16 region descriptors                                              */
} MPU_CESR_NRGD_Enum;

/* =============================================  MPU MPU_CESR SPERR1 [30..30]  ============================================== */
typedef enum {                                  /*!< MPU_CESR_SPERR1                                                           */
  MPU_CESR_SPERR1_0                    = 0,     /*!< 0 : No error has occurred for slave port 1.                               */
  MPU_CESR_SPERR1_1                    = 1,     /*!< 1 : An error has occurred for slave port 1.                               */
} MPU_CESR_SPERR1_Enum;

/* =============================================  MPU MPU_CESR SPERR0 [31..31]  ============================================== */
typedef enum {                                  /*!< MPU_CESR_SPERR0                                                           */
  MPU_CESR_SPERR0_0                    = 0,     /*!< 0 : No error has occurred for slave port 0.                               */
  MPU_CESR_SPERR0_1                    = 1,     /*!< 1 : An error has occurred for slave port 0.                               */
} MPU_CESR_SPERR0_Enum;

/* =======================================================  MPU_EAR0  ======================================================== */
/* =======================================================  MPU_EDR0  ======================================================== */
/* ================================================  MPU MPU_EDR0 ERW [0..0]  ================================================ */
typedef enum {                                  /*!< MPU_EDR0_ERW                                                              */
  MPU_EDR0_ERW_0                       = 0,     /*!< 0 : Read                                                                  */
  MPU_EDR0_ERW_1                       = 1,     /*!< 1 : Write                                                                 */
} MPU_EDR0_ERW_Enum;

/* ===============================================  MPU MPU_EDR0 EATTR [1..3]  =============================================== */
typedef enum {                                  /*!< MPU_EDR0_EATTR                                                            */
  MPU_EDR0_EATTR_000                   = 0,     /*!< 000 : User mode, instruction access                                       */
  MPU_EDR0_EATTR_001                   = 1,     /*!< 001 : User mode, data access                                              */
  MPU_EDR0_EATTR_010                   = 2,     /*!< 010 : Supervisor mode, instruction access                                 */
  MPU_EDR0_EATTR_011                   = 3,     /*!< 011 : Supervisor mode, data access                                        */
} MPU_EDR0_EATTR_Enum;

/* =======================================================  MPU_EAR1  ======================================================== */
/* =======================================================  MPU_EDR1  ======================================================== */
/* ================================================  MPU MPU_EDR1 ERW [0..0]  ================================================ */
typedef enum {                                  /*!< MPU_EDR1_ERW                                                              */
  MPU_EDR1_ERW_0                       = 0,     /*!< 0 : Read                                                                  */
  MPU_EDR1_ERW_1                       = 1,     /*!< 1 : Write                                                                 */
} MPU_EDR1_ERW_Enum;

/* ===============================================  MPU MPU_EDR1 EATTR [1..3]  =============================================== */
typedef enum {                                  /*!< MPU_EDR1_EATTR                                                            */
  MPU_EDR1_EATTR_000                   = 0,     /*!< 000 : User mode, instruction access                                       */
  MPU_EDR1_EATTR_001                   = 1,     /*!< 001 : User mode, data access                                              */
  MPU_EDR1_EATTR_010                   = 2,     /*!< 010 : Supervisor mode, instruction access                                 */
  MPU_EDR1_EATTR_011                   = 3,     /*!< 011 : Supervisor mode, data access                                        */
} MPU_EDR1_EATTR_Enum;

/* ====================================================  MPU_RGD0_WORD0  ===================================================== */
/* ====================================================  MPU_RGD0_WORD1  ===================================================== */
/* ====================================================  MPU_RGD0_WORD2  ===================================================== */
/* ============================================  MPU MPU_RGD0_WORD2 M0SM [3..4]  ============================================= */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M0SM                                                       */
  MPU_RGD0_WORD2_M0SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD0_WORD2_M0SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD0_WORD2_M0SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD0_WORD2_M0SM_11               = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGD0_WORD2_M0SM_Enum;

/* ============================================  MPU MPU_RGD0_WORD2 M0PE [5..5]  ============================================= */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M0PE                                                       */
  MPU_RGD0_WORD2_M0PE_0                = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGD0_WORD2_M0PE_1                = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGD0_WORD2_M0PE_Enum;

/* ============================================  MPU MPU_RGD0_WORD2 M1SM [9..10]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M1SM                                                       */
  MPU_RGD0_WORD2_M1SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD0_WORD2_M1SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD0_WORD2_M1SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD0_WORD2_M1SM_11               = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGD0_WORD2_M1SM_Enum;

/* ===========================================  MPU MPU_RGD0_WORD2 M2SM [15..16]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M2SM                                                       */
  MPU_RGD0_WORD2_M2SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD0_WORD2_M2SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD0_WORD2_M2SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD0_WORD2_M2SM_11               = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGD0_WORD2_M2SM_Enum;

/* ===========================================  MPU MPU_RGD0_WORD2 M3SM [21..22]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M3SM                                                       */
  MPU_RGD0_WORD2_M3SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD0_WORD2_M3SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD0_WORD2_M3SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD0_WORD2_M3SM_11               = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGD0_WORD2_M3SM_Enum;

/* ===========================================  MPU MPU_RGD0_WORD2 M4WE [24..24]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M4WE                                                       */
  MPU_RGD0_WORD2_M4WE_0                = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD0_WORD2_M4WE_1                = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGD0_WORD2_M4WE_Enum;

/* ===========================================  MPU MPU_RGD0_WORD2 M4RE [25..25]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M4RE                                                       */
  MPU_RGD0_WORD2_M4RE_0                = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD0_WORD2_M4RE_1                = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGD0_WORD2_M4RE_Enum;

/* ===========================================  MPU MPU_RGD0_WORD2 M5WE [26..26]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M5WE                                                       */
  MPU_RGD0_WORD2_M5WE_0                = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD0_WORD2_M5WE_1                = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGD0_WORD2_M5WE_Enum;

/* ===========================================  MPU MPU_RGD0_WORD2 M5RE [27..27]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M5RE                                                       */
  MPU_RGD0_WORD2_M5RE_0                = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD0_WORD2_M5RE_1                = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGD0_WORD2_M5RE_Enum;

/* ===========================================  MPU MPU_RGD0_WORD2 M6WE [28..28]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M6WE                                                       */
  MPU_RGD0_WORD2_M6WE_0                = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD0_WORD2_M6WE_1                = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGD0_WORD2_M6WE_Enum;

/* ===========================================  MPU MPU_RGD0_WORD2 M6RE [29..29]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M6RE                                                       */
  MPU_RGD0_WORD2_M6RE_0                = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD0_WORD2_M6RE_1                = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGD0_WORD2_M6RE_Enum;

/* ===========================================  MPU MPU_RGD0_WORD2 M7WE [30..30]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M7WE                                                       */
  MPU_RGD0_WORD2_M7WE_0                = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD0_WORD2_M7WE_1                = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGD0_WORD2_M7WE_Enum;

/* ===========================================  MPU MPU_RGD0_WORD2 M7RE [31..31]  ============================================ */
typedef enum {                                  /*!< MPU_RGD0_WORD2_M7RE                                                       */
  MPU_RGD0_WORD2_M7RE_0                = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD0_WORD2_M7RE_1                = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGD0_WORD2_M7RE_Enum;

/* ====================================================  MPU_RGD0_WORD3  ===================================================== */
/* =============================================  MPU MPU_RGD0_WORD3 VLD [0..0]  ============================================= */
typedef enum {                                  /*!< MPU_RGD0_WORD3_VLD                                                        */
  MPU_RGD0_WORD3_VLD_0                 = 0,     /*!< 0 : Region descriptor is invalid                                          */
  MPU_RGD0_WORD3_VLD_1                 = 1,     /*!< 1 : Region descriptor is valid                                            */
} MPU_RGD0_WORD3_VLD_Enum;

/* ====================================================  MPU_RGD1_WORD0  ===================================================== */
/* ====================================================  MPU_RGD1_WORD1  ===================================================== */
/* ====================================================  MPU_RGD1_WORD2  ===================================================== */
/* ============================================  MPU MPU_RGD1_WORD2 M0SM [3..4]  ============================================= */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M0SM                                                       */
  MPU_RGD1_WORD2_M0SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD1_WORD2_M0SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD1_WORD2_M0SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD1_WORD2_M0SM_11               = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGD1_WORD2_M0SM_Enum;

/* ============================================  MPU MPU_RGD1_WORD2 M0PE [5..5]  ============================================= */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M0PE                                                       */
  MPU_RGD1_WORD2_M0PE_0                = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGD1_WORD2_M0PE_1                = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGD1_WORD2_M0PE_Enum;

/* ============================================  MPU MPU_RGD1_WORD2 M1SM [9..10]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M1SM                                                       */
  MPU_RGD1_WORD2_M1SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD1_WORD2_M1SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD1_WORD2_M1SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD1_WORD2_M1SM_11               = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGD1_WORD2_M1SM_Enum;

/* ===========================================  MPU MPU_RGD1_WORD2 M2SM [15..16]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M2SM                                                       */
  MPU_RGD1_WORD2_M2SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD1_WORD2_M2SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD1_WORD2_M2SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD1_WORD2_M2SM_11               = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGD1_WORD2_M2SM_Enum;

/* ===========================================  MPU MPU_RGD1_WORD2 M3SM [21..22]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M3SM                                                       */
  MPU_RGD1_WORD2_M3SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD1_WORD2_M3SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD1_WORD2_M3SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD1_WORD2_M3SM_11               = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGD1_WORD2_M3SM_Enum;

/* ===========================================  MPU MPU_RGD1_WORD2 M4WE [24..24]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M4WE                                                       */
  MPU_RGD1_WORD2_M4WE_0                = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD1_WORD2_M4WE_1                = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGD1_WORD2_M4WE_Enum;

/* ===========================================  MPU MPU_RGD1_WORD2 M4RE [25..25]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M4RE                                                       */
  MPU_RGD1_WORD2_M4RE_0                = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD1_WORD2_M4RE_1                = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGD1_WORD2_M4RE_Enum;

/* ===========================================  MPU MPU_RGD1_WORD2 M5WE [26..26]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M5WE                                                       */
  MPU_RGD1_WORD2_M5WE_0                = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD1_WORD2_M5WE_1                = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGD1_WORD2_M5WE_Enum;

/* ===========================================  MPU MPU_RGD1_WORD2 M5RE [27..27]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M5RE                                                       */
  MPU_RGD1_WORD2_M5RE_0                = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD1_WORD2_M5RE_1                = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGD1_WORD2_M5RE_Enum;

/* ===========================================  MPU MPU_RGD1_WORD2 M6WE [28..28]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M6WE                                                       */
  MPU_RGD1_WORD2_M6WE_0                = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD1_WORD2_M6WE_1                = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGD1_WORD2_M6WE_Enum;

/* ===========================================  MPU MPU_RGD1_WORD2 M6RE [29..29]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M6RE                                                       */
  MPU_RGD1_WORD2_M6RE_0                = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD1_WORD2_M6RE_1                = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGD1_WORD2_M6RE_Enum;

/* ===========================================  MPU MPU_RGD1_WORD2 M7WE [30..30]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M7WE                                                       */
  MPU_RGD1_WORD2_M7WE_0                = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD1_WORD2_M7WE_1                = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGD1_WORD2_M7WE_Enum;

/* ===========================================  MPU MPU_RGD1_WORD2 M7RE [31..31]  ============================================ */
typedef enum {                                  /*!< MPU_RGD1_WORD2_M7RE                                                       */
  MPU_RGD1_WORD2_M7RE_0                = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD1_WORD2_M7RE_1                = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGD1_WORD2_M7RE_Enum;

/* ====================================================  MPU_RGD1_WORD3  ===================================================== */
/* =============================================  MPU MPU_RGD1_WORD3 VLD [0..0]  ============================================= */
typedef enum {                                  /*!< MPU_RGD1_WORD3_VLD                                                        */
  MPU_RGD1_WORD3_VLD_0                 = 0,     /*!< 0 : Region descriptor is invalid                                          */
  MPU_RGD1_WORD3_VLD_1                 = 1,     /*!< 1 : Region descriptor is valid                                            */
} MPU_RGD1_WORD3_VLD_Enum;

/* ====================================================  MPU_RGD2_WORD0  ===================================================== */
/* ====================================================  MPU_RGD2_WORD1  ===================================================== */
/* ====================================================  MPU_RGD2_WORD2  ===================================================== */
/* ============================================  MPU MPU_RGD2_WORD2 M0SM [3..4]  ============================================= */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M0SM                                                       */
  MPU_RGD2_WORD2_M0SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD2_WORD2_M0SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD2_WORD2_M0SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD2_WORD2_M0SM_11               = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGD2_WORD2_M0SM_Enum;

/* ============================================  MPU MPU_RGD2_WORD2 M0PE [5..5]  ============================================= */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M0PE                                                       */
  MPU_RGD2_WORD2_M0PE_0                = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGD2_WORD2_M0PE_1                = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGD2_WORD2_M0PE_Enum;

/* ============================================  MPU MPU_RGD2_WORD2 M1SM [9..10]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M1SM                                                       */
  MPU_RGD2_WORD2_M1SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD2_WORD2_M1SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD2_WORD2_M1SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD2_WORD2_M1SM_11               = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGD2_WORD2_M1SM_Enum;

/* ===========================================  MPU MPU_RGD2_WORD2 M2SM [15..16]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M2SM                                                       */
  MPU_RGD2_WORD2_M2SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD2_WORD2_M2SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD2_WORD2_M2SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD2_WORD2_M2SM_11               = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGD2_WORD2_M2SM_Enum;

/* ===========================================  MPU MPU_RGD2_WORD2 M3SM [21..22]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M3SM                                                       */
  MPU_RGD2_WORD2_M3SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD2_WORD2_M3SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD2_WORD2_M3SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD2_WORD2_M3SM_11               = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGD2_WORD2_M3SM_Enum;

/* ===========================================  MPU MPU_RGD2_WORD2 M4WE [24..24]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M4WE                                                       */
  MPU_RGD2_WORD2_M4WE_0                = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD2_WORD2_M4WE_1                = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGD2_WORD2_M4WE_Enum;

/* ===========================================  MPU MPU_RGD2_WORD2 M4RE [25..25]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M4RE                                                       */
  MPU_RGD2_WORD2_M4RE_0                = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD2_WORD2_M4RE_1                = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGD2_WORD2_M4RE_Enum;

/* ===========================================  MPU MPU_RGD2_WORD2 M5WE [26..26]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M5WE                                                       */
  MPU_RGD2_WORD2_M5WE_0                = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD2_WORD2_M5WE_1                = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGD2_WORD2_M5WE_Enum;

/* ===========================================  MPU MPU_RGD2_WORD2 M5RE [27..27]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M5RE                                                       */
  MPU_RGD2_WORD2_M5RE_0                = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD2_WORD2_M5RE_1                = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGD2_WORD2_M5RE_Enum;

/* ===========================================  MPU MPU_RGD2_WORD2 M6WE [28..28]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M6WE                                                       */
  MPU_RGD2_WORD2_M6WE_0                = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD2_WORD2_M6WE_1                = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGD2_WORD2_M6WE_Enum;

/* ===========================================  MPU MPU_RGD2_WORD2 M6RE [29..29]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M6RE                                                       */
  MPU_RGD2_WORD2_M6RE_0                = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD2_WORD2_M6RE_1                = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGD2_WORD2_M6RE_Enum;

/* ===========================================  MPU MPU_RGD2_WORD2 M7WE [30..30]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M7WE                                                       */
  MPU_RGD2_WORD2_M7WE_0                = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD2_WORD2_M7WE_1                = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGD2_WORD2_M7WE_Enum;

/* ===========================================  MPU MPU_RGD2_WORD2 M7RE [31..31]  ============================================ */
typedef enum {                                  /*!< MPU_RGD2_WORD2_M7RE                                                       */
  MPU_RGD2_WORD2_M7RE_0                = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD2_WORD2_M7RE_1                = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGD2_WORD2_M7RE_Enum;

/* ====================================================  MPU_RGD2_WORD3  ===================================================== */
/* =============================================  MPU MPU_RGD2_WORD3 VLD [0..0]  ============================================= */
typedef enum {                                  /*!< MPU_RGD2_WORD3_VLD                                                        */
  MPU_RGD2_WORD3_VLD_0                 = 0,     /*!< 0 : Region descriptor is invalid                                          */
  MPU_RGD2_WORD3_VLD_1                 = 1,     /*!< 1 : Region descriptor is valid                                            */
} MPU_RGD2_WORD3_VLD_Enum;

/* ====================================================  MPU_RGD3_WORD0  ===================================================== */
/* ====================================================  MPU_RGD3_WORD1  ===================================================== */
/* ====================================================  MPU_RGD3_WORD2  ===================================================== */
/* ============================================  MPU MPU_RGD3_WORD2 M0SM [3..4]  ============================================= */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M0SM                                                       */
  MPU_RGD3_WORD2_M0SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD3_WORD2_M0SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD3_WORD2_M0SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD3_WORD2_M0SM_11               = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGD3_WORD2_M0SM_Enum;

/* ============================================  MPU MPU_RGD3_WORD2 M0PE [5..5]  ============================================= */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M0PE                                                       */
  MPU_RGD3_WORD2_M0PE_0                = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGD3_WORD2_M0PE_1                = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGD3_WORD2_M0PE_Enum;

/* ============================================  MPU MPU_RGD3_WORD2 M1SM [9..10]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M1SM                                                       */
  MPU_RGD3_WORD2_M1SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD3_WORD2_M1SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD3_WORD2_M1SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD3_WORD2_M1SM_11               = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGD3_WORD2_M1SM_Enum;

/* ===========================================  MPU MPU_RGD3_WORD2 M2SM [15..16]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M2SM                                                       */
  MPU_RGD3_WORD2_M2SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD3_WORD2_M2SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD3_WORD2_M2SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD3_WORD2_M2SM_11               = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGD3_WORD2_M2SM_Enum;

/* ===========================================  MPU MPU_RGD3_WORD2 M3SM [21..22]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M3SM                                                       */
  MPU_RGD3_WORD2_M3SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD3_WORD2_M3SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD3_WORD2_M3SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD3_WORD2_M3SM_11               = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGD3_WORD2_M3SM_Enum;

/* ===========================================  MPU MPU_RGD3_WORD2 M4WE [24..24]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M4WE                                                       */
  MPU_RGD3_WORD2_M4WE_0                = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD3_WORD2_M4WE_1                = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGD3_WORD2_M4WE_Enum;

/* ===========================================  MPU MPU_RGD3_WORD2 M4RE [25..25]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M4RE                                                       */
  MPU_RGD3_WORD2_M4RE_0                = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD3_WORD2_M4RE_1                = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGD3_WORD2_M4RE_Enum;

/* ===========================================  MPU MPU_RGD3_WORD2 M5WE [26..26]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M5WE                                                       */
  MPU_RGD3_WORD2_M5WE_0                = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD3_WORD2_M5WE_1                = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGD3_WORD2_M5WE_Enum;

/* ===========================================  MPU MPU_RGD3_WORD2 M5RE [27..27]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M5RE                                                       */
  MPU_RGD3_WORD2_M5RE_0                = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD3_WORD2_M5RE_1                = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGD3_WORD2_M5RE_Enum;

/* ===========================================  MPU MPU_RGD3_WORD2 M6WE [28..28]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M6WE                                                       */
  MPU_RGD3_WORD2_M6WE_0                = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD3_WORD2_M6WE_1                = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGD3_WORD2_M6WE_Enum;

/* ===========================================  MPU MPU_RGD3_WORD2 M6RE [29..29]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M6RE                                                       */
  MPU_RGD3_WORD2_M6RE_0                = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD3_WORD2_M6RE_1                = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGD3_WORD2_M6RE_Enum;

/* ===========================================  MPU MPU_RGD3_WORD2 M7WE [30..30]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M7WE                                                       */
  MPU_RGD3_WORD2_M7WE_0                = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD3_WORD2_M7WE_1                = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGD3_WORD2_M7WE_Enum;

/* ===========================================  MPU MPU_RGD3_WORD2 M7RE [31..31]  ============================================ */
typedef enum {                                  /*!< MPU_RGD3_WORD2_M7RE                                                       */
  MPU_RGD3_WORD2_M7RE_0                = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD3_WORD2_M7RE_1                = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGD3_WORD2_M7RE_Enum;

/* ====================================================  MPU_RGD3_WORD3  ===================================================== */
/* =============================================  MPU MPU_RGD3_WORD3 VLD [0..0]  ============================================= */
typedef enum {                                  /*!< MPU_RGD3_WORD3_VLD                                                        */
  MPU_RGD3_WORD3_VLD_0                 = 0,     /*!< 0 : Region descriptor is invalid                                          */
  MPU_RGD3_WORD3_VLD_1                 = 1,     /*!< 1 : Region descriptor is valid                                            */
} MPU_RGD3_WORD3_VLD_Enum;

/* ====================================================  MPU_RGD4_WORD0  ===================================================== */
/* ====================================================  MPU_RGD4_WORD1  ===================================================== */
/* ====================================================  MPU_RGD4_WORD2  ===================================================== */
/* ============================================  MPU MPU_RGD4_WORD2 M0SM [3..4]  ============================================= */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M0SM                                                       */
  MPU_RGD4_WORD2_M0SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD4_WORD2_M0SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD4_WORD2_M0SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD4_WORD2_M0SM_11               = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGD4_WORD2_M0SM_Enum;

/* ============================================  MPU MPU_RGD4_WORD2 M0PE [5..5]  ============================================= */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M0PE                                                       */
  MPU_RGD4_WORD2_M0PE_0                = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGD4_WORD2_M0PE_1                = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGD4_WORD2_M0PE_Enum;

/* ============================================  MPU MPU_RGD4_WORD2 M1SM [9..10]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M1SM                                                       */
  MPU_RGD4_WORD2_M1SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD4_WORD2_M1SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD4_WORD2_M1SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD4_WORD2_M1SM_11               = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGD4_WORD2_M1SM_Enum;

/* ===========================================  MPU MPU_RGD4_WORD2 M2SM [15..16]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M2SM                                                       */
  MPU_RGD4_WORD2_M2SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD4_WORD2_M2SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD4_WORD2_M2SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD4_WORD2_M2SM_11               = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGD4_WORD2_M2SM_Enum;

/* ===========================================  MPU MPU_RGD4_WORD2 M3SM [21..22]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M3SM                                                       */
  MPU_RGD4_WORD2_M3SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD4_WORD2_M3SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD4_WORD2_M3SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD4_WORD2_M3SM_11               = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGD4_WORD2_M3SM_Enum;

/* ===========================================  MPU MPU_RGD4_WORD2 M4WE [24..24]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M4WE                                                       */
  MPU_RGD4_WORD2_M4WE_0                = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD4_WORD2_M4WE_1                = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGD4_WORD2_M4WE_Enum;

/* ===========================================  MPU MPU_RGD4_WORD2 M4RE [25..25]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M4RE                                                       */
  MPU_RGD4_WORD2_M4RE_0                = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD4_WORD2_M4RE_1                = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGD4_WORD2_M4RE_Enum;

/* ===========================================  MPU MPU_RGD4_WORD2 M5WE [26..26]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M5WE                                                       */
  MPU_RGD4_WORD2_M5WE_0                = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD4_WORD2_M5WE_1                = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGD4_WORD2_M5WE_Enum;

/* ===========================================  MPU MPU_RGD4_WORD2 M5RE [27..27]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M5RE                                                       */
  MPU_RGD4_WORD2_M5RE_0                = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD4_WORD2_M5RE_1                = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGD4_WORD2_M5RE_Enum;

/* ===========================================  MPU MPU_RGD4_WORD2 M6WE [28..28]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M6WE                                                       */
  MPU_RGD4_WORD2_M6WE_0                = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD4_WORD2_M6WE_1                = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGD4_WORD2_M6WE_Enum;

/* ===========================================  MPU MPU_RGD4_WORD2 M6RE [29..29]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M6RE                                                       */
  MPU_RGD4_WORD2_M6RE_0                = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD4_WORD2_M6RE_1                = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGD4_WORD2_M6RE_Enum;

/* ===========================================  MPU MPU_RGD4_WORD2 M7WE [30..30]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M7WE                                                       */
  MPU_RGD4_WORD2_M7WE_0                = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD4_WORD2_M7WE_1                = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGD4_WORD2_M7WE_Enum;

/* ===========================================  MPU MPU_RGD4_WORD2 M7RE [31..31]  ============================================ */
typedef enum {                                  /*!< MPU_RGD4_WORD2_M7RE                                                       */
  MPU_RGD4_WORD2_M7RE_0                = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD4_WORD2_M7RE_1                = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGD4_WORD2_M7RE_Enum;

/* ====================================================  MPU_RGD4_WORD3  ===================================================== */
/* =============================================  MPU MPU_RGD4_WORD3 VLD [0..0]  ============================================= */
typedef enum {                                  /*!< MPU_RGD4_WORD3_VLD                                                        */
  MPU_RGD4_WORD3_VLD_0                 = 0,     /*!< 0 : Region descriptor is invalid                                          */
  MPU_RGD4_WORD3_VLD_1                 = 1,     /*!< 1 : Region descriptor is valid                                            */
} MPU_RGD4_WORD3_VLD_Enum;

/* ====================================================  MPU_RGD5_WORD0  ===================================================== */
/* ====================================================  MPU_RGD5_WORD1  ===================================================== */
/* ====================================================  MPU_RGD5_WORD2  ===================================================== */
/* ============================================  MPU MPU_RGD5_WORD2 M0SM [3..4]  ============================================= */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M0SM                                                       */
  MPU_RGD5_WORD2_M0SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD5_WORD2_M0SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD5_WORD2_M0SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD5_WORD2_M0SM_11               = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGD5_WORD2_M0SM_Enum;

/* ============================================  MPU MPU_RGD5_WORD2 M0PE [5..5]  ============================================= */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M0PE                                                       */
  MPU_RGD5_WORD2_M0PE_0                = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGD5_WORD2_M0PE_1                = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGD5_WORD2_M0PE_Enum;

/* ============================================  MPU MPU_RGD5_WORD2 M1SM [9..10]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M1SM                                                       */
  MPU_RGD5_WORD2_M1SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD5_WORD2_M1SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD5_WORD2_M1SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD5_WORD2_M1SM_11               = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGD5_WORD2_M1SM_Enum;

/* ===========================================  MPU MPU_RGD5_WORD2 M2SM [15..16]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M2SM                                                       */
  MPU_RGD5_WORD2_M2SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD5_WORD2_M2SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD5_WORD2_M2SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD5_WORD2_M2SM_11               = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGD5_WORD2_M2SM_Enum;

/* ===========================================  MPU MPU_RGD5_WORD2 M3SM [21..22]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M3SM                                                       */
  MPU_RGD5_WORD2_M3SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD5_WORD2_M3SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD5_WORD2_M3SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD5_WORD2_M3SM_11               = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGD5_WORD2_M3SM_Enum;

/* ===========================================  MPU MPU_RGD5_WORD2 M4WE [24..24]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M4WE                                                       */
  MPU_RGD5_WORD2_M4WE_0                = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD5_WORD2_M4WE_1                = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGD5_WORD2_M4WE_Enum;

/* ===========================================  MPU MPU_RGD5_WORD2 M4RE [25..25]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M4RE                                                       */
  MPU_RGD5_WORD2_M4RE_0                = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD5_WORD2_M4RE_1                = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGD5_WORD2_M4RE_Enum;

/* ===========================================  MPU MPU_RGD5_WORD2 M5WE [26..26]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M5WE                                                       */
  MPU_RGD5_WORD2_M5WE_0                = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD5_WORD2_M5WE_1                = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGD5_WORD2_M5WE_Enum;

/* ===========================================  MPU MPU_RGD5_WORD2 M5RE [27..27]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M5RE                                                       */
  MPU_RGD5_WORD2_M5RE_0                = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD5_WORD2_M5RE_1                = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGD5_WORD2_M5RE_Enum;

/* ===========================================  MPU MPU_RGD5_WORD2 M6WE [28..28]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M6WE                                                       */
  MPU_RGD5_WORD2_M6WE_0                = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD5_WORD2_M6WE_1                = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGD5_WORD2_M6WE_Enum;

/* ===========================================  MPU MPU_RGD5_WORD2 M6RE [29..29]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M6RE                                                       */
  MPU_RGD5_WORD2_M6RE_0                = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD5_WORD2_M6RE_1                = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGD5_WORD2_M6RE_Enum;

/* ===========================================  MPU MPU_RGD5_WORD2 M7WE [30..30]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M7WE                                                       */
  MPU_RGD5_WORD2_M7WE_0                = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD5_WORD2_M7WE_1                = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGD5_WORD2_M7WE_Enum;

/* ===========================================  MPU MPU_RGD5_WORD2 M7RE [31..31]  ============================================ */
typedef enum {                                  /*!< MPU_RGD5_WORD2_M7RE                                                       */
  MPU_RGD5_WORD2_M7RE_0                = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD5_WORD2_M7RE_1                = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGD5_WORD2_M7RE_Enum;

/* ====================================================  MPU_RGD5_WORD3  ===================================================== */
/* =============================================  MPU MPU_RGD5_WORD3 VLD [0..0]  ============================================= */
typedef enum {                                  /*!< MPU_RGD5_WORD3_VLD                                                        */
  MPU_RGD5_WORD3_VLD_0                 = 0,     /*!< 0 : Region descriptor is invalid                                          */
  MPU_RGD5_WORD3_VLD_1                 = 1,     /*!< 1 : Region descriptor is valid                                            */
} MPU_RGD5_WORD3_VLD_Enum;

/* ====================================================  MPU_RGD6_WORD0  ===================================================== */
/* ====================================================  MPU_RGD6_WORD1  ===================================================== */
/* ====================================================  MPU_RGD6_WORD2  ===================================================== */
/* ============================================  MPU MPU_RGD6_WORD2 M0SM [3..4]  ============================================= */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M0SM                                                       */
  MPU_RGD6_WORD2_M0SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD6_WORD2_M0SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD6_WORD2_M0SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD6_WORD2_M0SM_11               = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGD6_WORD2_M0SM_Enum;

/* ============================================  MPU MPU_RGD6_WORD2 M0PE [5..5]  ============================================= */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M0PE                                                       */
  MPU_RGD6_WORD2_M0PE_0                = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGD6_WORD2_M0PE_1                = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGD6_WORD2_M0PE_Enum;

/* ============================================  MPU MPU_RGD6_WORD2 M1SM [9..10]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M1SM                                                       */
  MPU_RGD6_WORD2_M1SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD6_WORD2_M1SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD6_WORD2_M1SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD6_WORD2_M1SM_11               = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGD6_WORD2_M1SM_Enum;

/* ===========================================  MPU MPU_RGD6_WORD2 M2SM [15..16]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M2SM                                                       */
  MPU_RGD6_WORD2_M2SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD6_WORD2_M2SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD6_WORD2_M2SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD6_WORD2_M2SM_11               = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGD6_WORD2_M2SM_Enum;

/* ===========================================  MPU MPU_RGD6_WORD2 M3SM [21..22]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M3SM                                                       */
  MPU_RGD6_WORD2_M3SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD6_WORD2_M3SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD6_WORD2_M3SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD6_WORD2_M3SM_11               = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGD6_WORD2_M3SM_Enum;

/* ===========================================  MPU MPU_RGD6_WORD2 M4WE [24..24]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M4WE                                                       */
  MPU_RGD6_WORD2_M4WE_0                = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD6_WORD2_M4WE_1                = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGD6_WORD2_M4WE_Enum;

/* ===========================================  MPU MPU_RGD6_WORD2 M4RE [25..25]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M4RE                                                       */
  MPU_RGD6_WORD2_M4RE_0                = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD6_WORD2_M4RE_1                = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGD6_WORD2_M4RE_Enum;

/* ===========================================  MPU MPU_RGD6_WORD2 M5WE [26..26]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M5WE                                                       */
  MPU_RGD6_WORD2_M5WE_0                = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD6_WORD2_M5WE_1                = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGD6_WORD2_M5WE_Enum;

/* ===========================================  MPU MPU_RGD6_WORD2 M5RE [27..27]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M5RE                                                       */
  MPU_RGD6_WORD2_M5RE_0                = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD6_WORD2_M5RE_1                = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGD6_WORD2_M5RE_Enum;

/* ===========================================  MPU MPU_RGD6_WORD2 M6WE [28..28]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M6WE                                                       */
  MPU_RGD6_WORD2_M6WE_0                = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD6_WORD2_M6WE_1                = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGD6_WORD2_M6WE_Enum;

/* ===========================================  MPU MPU_RGD6_WORD2 M6RE [29..29]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M6RE                                                       */
  MPU_RGD6_WORD2_M6RE_0                = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD6_WORD2_M6RE_1                = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGD6_WORD2_M6RE_Enum;

/* ===========================================  MPU MPU_RGD6_WORD2 M7WE [30..30]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M7WE                                                       */
  MPU_RGD6_WORD2_M7WE_0                = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD6_WORD2_M7WE_1                = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGD6_WORD2_M7WE_Enum;

/* ===========================================  MPU MPU_RGD6_WORD2 M7RE [31..31]  ============================================ */
typedef enum {                                  /*!< MPU_RGD6_WORD2_M7RE                                                       */
  MPU_RGD6_WORD2_M7RE_0                = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD6_WORD2_M7RE_1                = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGD6_WORD2_M7RE_Enum;

/* ====================================================  MPU_RGD6_WORD3  ===================================================== */
/* =============================================  MPU MPU_RGD6_WORD3 VLD [0..0]  ============================================= */
typedef enum {                                  /*!< MPU_RGD6_WORD3_VLD                                                        */
  MPU_RGD6_WORD3_VLD_0                 = 0,     /*!< 0 : Region descriptor is invalid                                          */
  MPU_RGD6_WORD3_VLD_1                 = 1,     /*!< 1 : Region descriptor is valid                                            */
} MPU_RGD6_WORD3_VLD_Enum;

/* ====================================================  MPU_RGD7_WORD0  ===================================================== */
/* ====================================================  MPU_RGD7_WORD1  ===================================================== */
/* ====================================================  MPU_RGD7_WORD2  ===================================================== */
/* ============================================  MPU MPU_RGD7_WORD2 M0SM [3..4]  ============================================= */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M0SM                                                       */
  MPU_RGD7_WORD2_M0SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD7_WORD2_M0SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD7_WORD2_M0SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD7_WORD2_M0SM_11               = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGD7_WORD2_M0SM_Enum;

/* ============================================  MPU MPU_RGD7_WORD2 M0PE [5..5]  ============================================= */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M0PE                                                       */
  MPU_RGD7_WORD2_M0PE_0                = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGD7_WORD2_M0PE_1                = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGD7_WORD2_M0PE_Enum;

/* ============================================  MPU MPU_RGD7_WORD2 M1SM [9..10]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M1SM                                                       */
  MPU_RGD7_WORD2_M1SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD7_WORD2_M1SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD7_WORD2_M1SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD7_WORD2_M1SM_11               = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGD7_WORD2_M1SM_Enum;

/* ===========================================  MPU MPU_RGD7_WORD2 M2SM [15..16]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M2SM                                                       */
  MPU_RGD7_WORD2_M2SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD7_WORD2_M2SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD7_WORD2_M2SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD7_WORD2_M2SM_11               = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGD7_WORD2_M2SM_Enum;

/* ===========================================  MPU MPU_RGD7_WORD2 M3SM [21..22]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M3SM                                                       */
  MPU_RGD7_WORD2_M3SM_00               = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGD7_WORD2_M3SM_01               = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGD7_WORD2_M3SM_10               = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGD7_WORD2_M3SM_11               = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGD7_WORD2_M3SM_Enum;

/* ===========================================  MPU MPU_RGD7_WORD2 M4WE [24..24]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M4WE                                                       */
  MPU_RGD7_WORD2_M4WE_0                = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD7_WORD2_M4WE_1                = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGD7_WORD2_M4WE_Enum;

/* ===========================================  MPU MPU_RGD7_WORD2 M4RE [25..25]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M4RE                                                       */
  MPU_RGD7_WORD2_M4RE_0                = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD7_WORD2_M4RE_1                = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGD7_WORD2_M4RE_Enum;

/* ===========================================  MPU MPU_RGD7_WORD2 M5WE [26..26]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M5WE                                                       */
  MPU_RGD7_WORD2_M5WE_0                = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD7_WORD2_M5WE_1                = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGD7_WORD2_M5WE_Enum;

/* ===========================================  MPU MPU_RGD7_WORD2 M5RE [27..27]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M5RE                                                       */
  MPU_RGD7_WORD2_M5RE_0                = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD7_WORD2_M5RE_1                = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGD7_WORD2_M5RE_Enum;

/* ===========================================  MPU MPU_RGD7_WORD2 M6WE [28..28]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M6WE                                                       */
  MPU_RGD7_WORD2_M6WE_0                = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD7_WORD2_M6WE_1                = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGD7_WORD2_M6WE_Enum;

/* ===========================================  MPU MPU_RGD7_WORD2 M6RE [29..29]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M6RE                                                       */
  MPU_RGD7_WORD2_M6RE_0                = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD7_WORD2_M6RE_1                = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGD7_WORD2_M6RE_Enum;

/* ===========================================  MPU MPU_RGD7_WORD2 M7WE [30..30]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M7WE                                                       */
  MPU_RGD7_WORD2_M7WE_0                = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGD7_WORD2_M7WE_1                = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGD7_WORD2_M7WE_Enum;

/* ===========================================  MPU MPU_RGD7_WORD2 M7RE [31..31]  ============================================ */
typedef enum {                                  /*!< MPU_RGD7_WORD2_M7RE                                                       */
  MPU_RGD7_WORD2_M7RE_0                = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGD7_WORD2_M7RE_1                = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGD7_WORD2_M7RE_Enum;

/* ====================================================  MPU_RGD7_WORD3  ===================================================== */
/* =============================================  MPU MPU_RGD7_WORD3 VLD [0..0]  ============================================= */
typedef enum {                                  /*!< MPU_RGD7_WORD3_VLD                                                        */
  MPU_RGD7_WORD3_VLD_0                 = 0,     /*!< 0 : Region descriptor is invalid                                          */
  MPU_RGD7_WORD3_VLD_1                 = 1,     /*!< 1 : Region descriptor is valid                                            */
} MPU_RGD7_WORD3_VLD_Enum;

/* ======================================================  MPU_RGDAAC0  ====================================================== */
/* ==============================================  MPU MPU_RGDAAC0 M0SM [3..4]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC0_M0SM                                                          */
  MPU_RGDAAC0_M0SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC0_M0SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC0_M0SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC0_M0SM_11                  = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGDAAC0_M0SM_Enum;

/* ==============================================  MPU MPU_RGDAAC0 M0PE [5..5]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC0_M0PE                                                          */
  MPU_RGDAAC0_M0PE_0                   = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGDAAC0_M0PE_1                   = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGDAAC0_M0PE_Enum;

/* =============================================  MPU MPU_RGDAAC0 M1SM [9..10]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC0_M1SM                                                          */
  MPU_RGDAAC0_M1SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC0_M1SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC0_M1SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC0_M1SM_11                  = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGDAAC0_M1SM_Enum;

/* =============================================  MPU MPU_RGDAAC0 M2SM [15..16]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC0_M2SM                                                          */
  MPU_RGDAAC0_M2SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC0_M2SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC0_M2SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC0_M2SM_11                  = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGDAAC0_M2SM_Enum;

/* =============================================  MPU MPU_RGDAAC0 M3SM [21..22]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC0_M3SM                                                          */
  MPU_RGDAAC0_M3SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC0_M3SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC0_M3SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC0_M3SM_11                  = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGDAAC0_M3SM_Enum;

/* =============================================  MPU MPU_RGDAAC0 M4WE [24..24]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC0_M4WE                                                          */
  MPU_RGDAAC0_M4WE_0                   = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC0_M4WE_1                   = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGDAAC0_M4WE_Enum;

/* =============================================  MPU MPU_RGDAAC0 M4RE [25..25]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC0_M4RE                                                          */
  MPU_RGDAAC0_M4RE_0                   = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC0_M4RE_1                   = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGDAAC0_M4RE_Enum;

/* =============================================  MPU MPU_RGDAAC0 M5WE [26..26]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC0_M5WE                                                          */
  MPU_RGDAAC0_M5WE_0                   = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC0_M5WE_1                   = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGDAAC0_M5WE_Enum;

/* =============================================  MPU MPU_RGDAAC0 M5RE [27..27]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC0_M5RE                                                          */
  MPU_RGDAAC0_M5RE_0                   = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC0_M5RE_1                   = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGDAAC0_M5RE_Enum;

/* =============================================  MPU MPU_RGDAAC0 M6WE [28..28]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC0_M6WE                                                          */
  MPU_RGDAAC0_M6WE_0                   = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC0_M6WE_1                   = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGDAAC0_M6WE_Enum;

/* =============================================  MPU MPU_RGDAAC0 M6RE [29..29]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC0_M6RE                                                          */
  MPU_RGDAAC0_M6RE_0                   = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC0_M6RE_1                   = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGDAAC0_M6RE_Enum;

/* =============================================  MPU MPU_RGDAAC0 M7WE [30..30]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC0_M7WE                                                          */
  MPU_RGDAAC0_M7WE_0                   = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC0_M7WE_1                   = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGDAAC0_M7WE_Enum;

/* =============================================  MPU MPU_RGDAAC0 M7RE [31..31]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC0_M7RE                                                          */
  MPU_RGDAAC0_M7RE_0                   = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC0_M7RE_1                   = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGDAAC0_M7RE_Enum;

/* ======================================================  MPU_RGDAAC1  ====================================================== */
/* ==============================================  MPU MPU_RGDAAC1 M0SM [3..4]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC1_M0SM                                                          */
  MPU_RGDAAC1_M0SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC1_M0SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC1_M0SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC1_M0SM_11                  = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGDAAC1_M0SM_Enum;

/* ==============================================  MPU MPU_RGDAAC1 M0PE [5..5]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC1_M0PE                                                          */
  MPU_RGDAAC1_M0PE_0                   = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGDAAC1_M0PE_1                   = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGDAAC1_M0PE_Enum;

/* =============================================  MPU MPU_RGDAAC1 M1SM [9..10]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC1_M1SM                                                          */
  MPU_RGDAAC1_M1SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC1_M1SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC1_M1SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC1_M1SM_11                  = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGDAAC1_M1SM_Enum;

/* =============================================  MPU MPU_RGDAAC1 M2SM [15..16]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC1_M2SM                                                          */
  MPU_RGDAAC1_M2SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC1_M2SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC1_M2SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC1_M2SM_11                  = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGDAAC1_M2SM_Enum;

/* =============================================  MPU MPU_RGDAAC1 M3SM [21..22]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC1_M3SM                                                          */
  MPU_RGDAAC1_M3SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC1_M3SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC1_M3SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC1_M3SM_11                  = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGDAAC1_M3SM_Enum;

/* =============================================  MPU MPU_RGDAAC1 M4WE [24..24]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC1_M4WE                                                          */
  MPU_RGDAAC1_M4WE_0                   = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC1_M4WE_1                   = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGDAAC1_M4WE_Enum;

/* =============================================  MPU MPU_RGDAAC1 M4RE [25..25]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC1_M4RE                                                          */
  MPU_RGDAAC1_M4RE_0                   = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC1_M4RE_1                   = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGDAAC1_M4RE_Enum;

/* =============================================  MPU MPU_RGDAAC1 M5WE [26..26]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC1_M5WE                                                          */
  MPU_RGDAAC1_M5WE_0                   = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC1_M5WE_1                   = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGDAAC1_M5WE_Enum;

/* =============================================  MPU MPU_RGDAAC1 M5RE [27..27]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC1_M5RE                                                          */
  MPU_RGDAAC1_M5RE_0                   = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC1_M5RE_1                   = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGDAAC1_M5RE_Enum;

/* =============================================  MPU MPU_RGDAAC1 M6WE [28..28]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC1_M6WE                                                          */
  MPU_RGDAAC1_M6WE_0                   = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC1_M6WE_1                   = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGDAAC1_M6WE_Enum;

/* =============================================  MPU MPU_RGDAAC1 M6RE [29..29]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC1_M6RE                                                          */
  MPU_RGDAAC1_M6RE_0                   = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC1_M6RE_1                   = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGDAAC1_M6RE_Enum;

/* =============================================  MPU MPU_RGDAAC1 M7WE [30..30]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC1_M7WE                                                          */
  MPU_RGDAAC1_M7WE_0                   = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC1_M7WE_1                   = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGDAAC1_M7WE_Enum;

/* =============================================  MPU MPU_RGDAAC1 M7RE [31..31]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC1_M7RE                                                          */
  MPU_RGDAAC1_M7RE_0                   = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC1_M7RE_1                   = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGDAAC1_M7RE_Enum;

/* ======================================================  MPU_RGDAAC2  ====================================================== */
/* ==============================================  MPU MPU_RGDAAC2 M0SM [3..4]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC2_M0SM                                                          */
  MPU_RGDAAC2_M0SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC2_M0SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC2_M0SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC2_M0SM_11                  = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGDAAC2_M0SM_Enum;

/* ==============================================  MPU MPU_RGDAAC2 M0PE [5..5]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC2_M0PE                                                          */
  MPU_RGDAAC2_M0PE_0                   = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGDAAC2_M0PE_1                   = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGDAAC2_M0PE_Enum;

/* =============================================  MPU MPU_RGDAAC2 M1SM [9..10]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC2_M1SM                                                          */
  MPU_RGDAAC2_M1SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC2_M1SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC2_M1SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC2_M1SM_11                  = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGDAAC2_M1SM_Enum;

/* =============================================  MPU MPU_RGDAAC2 M2SM [15..16]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC2_M2SM                                                          */
  MPU_RGDAAC2_M2SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC2_M2SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC2_M2SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC2_M2SM_11                  = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGDAAC2_M2SM_Enum;

/* =============================================  MPU MPU_RGDAAC2 M3SM [21..22]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC2_M3SM                                                          */
  MPU_RGDAAC2_M3SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC2_M3SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC2_M3SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC2_M3SM_11                  = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGDAAC2_M3SM_Enum;

/* =============================================  MPU MPU_RGDAAC2 M4WE [24..24]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC2_M4WE                                                          */
  MPU_RGDAAC2_M4WE_0                   = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC2_M4WE_1                   = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGDAAC2_M4WE_Enum;

/* =============================================  MPU MPU_RGDAAC2 M4RE [25..25]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC2_M4RE                                                          */
  MPU_RGDAAC2_M4RE_0                   = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC2_M4RE_1                   = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGDAAC2_M4RE_Enum;

/* =============================================  MPU MPU_RGDAAC2 M5WE [26..26]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC2_M5WE                                                          */
  MPU_RGDAAC2_M5WE_0                   = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC2_M5WE_1                   = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGDAAC2_M5WE_Enum;

/* =============================================  MPU MPU_RGDAAC2 M5RE [27..27]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC2_M5RE                                                          */
  MPU_RGDAAC2_M5RE_0                   = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC2_M5RE_1                   = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGDAAC2_M5RE_Enum;

/* =============================================  MPU MPU_RGDAAC2 M6WE [28..28]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC2_M6WE                                                          */
  MPU_RGDAAC2_M6WE_0                   = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC2_M6WE_1                   = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGDAAC2_M6WE_Enum;

/* =============================================  MPU MPU_RGDAAC2 M6RE [29..29]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC2_M6RE                                                          */
  MPU_RGDAAC2_M6RE_0                   = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC2_M6RE_1                   = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGDAAC2_M6RE_Enum;

/* =============================================  MPU MPU_RGDAAC2 M7WE [30..30]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC2_M7WE                                                          */
  MPU_RGDAAC2_M7WE_0                   = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC2_M7WE_1                   = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGDAAC2_M7WE_Enum;

/* =============================================  MPU MPU_RGDAAC2 M7RE [31..31]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC2_M7RE                                                          */
  MPU_RGDAAC2_M7RE_0                   = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC2_M7RE_1                   = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGDAAC2_M7RE_Enum;

/* ======================================================  MPU_RGDAAC3  ====================================================== */
/* ==============================================  MPU MPU_RGDAAC3 M0SM [3..4]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC3_M0SM                                                          */
  MPU_RGDAAC3_M0SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC3_M0SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC3_M0SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC3_M0SM_11                  = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGDAAC3_M0SM_Enum;

/* ==============================================  MPU MPU_RGDAAC3 M0PE [5..5]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC3_M0PE                                                          */
  MPU_RGDAAC3_M0PE_0                   = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGDAAC3_M0PE_1                   = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGDAAC3_M0PE_Enum;

/* =============================================  MPU MPU_RGDAAC3 M1SM [9..10]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC3_M1SM                                                          */
  MPU_RGDAAC3_M1SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC3_M1SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC3_M1SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC3_M1SM_11                  = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGDAAC3_M1SM_Enum;

/* =============================================  MPU MPU_RGDAAC3 M2SM [15..16]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC3_M2SM                                                          */
  MPU_RGDAAC3_M2SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC3_M2SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC3_M2SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC3_M2SM_11                  = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGDAAC3_M2SM_Enum;

/* =============================================  MPU MPU_RGDAAC3 M3SM [21..22]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC3_M3SM                                                          */
  MPU_RGDAAC3_M3SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC3_M3SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC3_M3SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC3_M3SM_11                  = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGDAAC3_M3SM_Enum;

/* =============================================  MPU MPU_RGDAAC3 M4WE [24..24]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC3_M4WE                                                          */
  MPU_RGDAAC3_M4WE_0                   = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC3_M4WE_1                   = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGDAAC3_M4WE_Enum;

/* =============================================  MPU MPU_RGDAAC3 M4RE [25..25]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC3_M4RE                                                          */
  MPU_RGDAAC3_M4RE_0                   = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC3_M4RE_1                   = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGDAAC3_M4RE_Enum;

/* =============================================  MPU MPU_RGDAAC3 M5WE [26..26]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC3_M5WE                                                          */
  MPU_RGDAAC3_M5WE_0                   = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC3_M5WE_1                   = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGDAAC3_M5WE_Enum;

/* =============================================  MPU MPU_RGDAAC3 M5RE [27..27]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC3_M5RE                                                          */
  MPU_RGDAAC3_M5RE_0                   = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC3_M5RE_1                   = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGDAAC3_M5RE_Enum;

/* =============================================  MPU MPU_RGDAAC3 M6WE [28..28]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC3_M6WE                                                          */
  MPU_RGDAAC3_M6WE_0                   = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC3_M6WE_1                   = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGDAAC3_M6WE_Enum;

/* =============================================  MPU MPU_RGDAAC3 M6RE [29..29]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC3_M6RE                                                          */
  MPU_RGDAAC3_M6RE_0                   = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC3_M6RE_1                   = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGDAAC3_M6RE_Enum;

/* =============================================  MPU MPU_RGDAAC3 M7WE [30..30]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC3_M7WE                                                          */
  MPU_RGDAAC3_M7WE_0                   = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC3_M7WE_1                   = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGDAAC3_M7WE_Enum;

/* =============================================  MPU MPU_RGDAAC3 M7RE [31..31]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC3_M7RE                                                          */
  MPU_RGDAAC3_M7RE_0                   = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC3_M7RE_1                   = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGDAAC3_M7RE_Enum;

/* ======================================================  MPU_RGDAAC4  ====================================================== */
/* ==============================================  MPU MPU_RGDAAC4 M0SM [3..4]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC4_M0SM                                                          */
  MPU_RGDAAC4_M0SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC4_M0SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC4_M0SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC4_M0SM_11                  = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGDAAC4_M0SM_Enum;

/* ==============================================  MPU MPU_RGDAAC4 M0PE [5..5]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC4_M0PE                                                          */
  MPU_RGDAAC4_M0PE_0                   = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGDAAC4_M0PE_1                   = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGDAAC4_M0PE_Enum;

/* =============================================  MPU MPU_RGDAAC4 M1SM [9..10]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC4_M1SM                                                          */
  MPU_RGDAAC4_M1SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC4_M1SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC4_M1SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC4_M1SM_11                  = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGDAAC4_M1SM_Enum;

/* =============================================  MPU MPU_RGDAAC4 M2SM [15..16]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC4_M2SM                                                          */
  MPU_RGDAAC4_M2SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC4_M2SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC4_M2SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC4_M2SM_11                  = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGDAAC4_M2SM_Enum;

/* =============================================  MPU MPU_RGDAAC4 M3SM [21..22]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC4_M3SM                                                          */
  MPU_RGDAAC4_M3SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC4_M3SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC4_M3SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC4_M3SM_11                  = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGDAAC4_M3SM_Enum;

/* =============================================  MPU MPU_RGDAAC4 M4WE [24..24]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC4_M4WE                                                          */
  MPU_RGDAAC4_M4WE_0                   = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC4_M4WE_1                   = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGDAAC4_M4WE_Enum;

/* =============================================  MPU MPU_RGDAAC4 M4RE [25..25]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC4_M4RE                                                          */
  MPU_RGDAAC4_M4RE_0                   = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC4_M4RE_1                   = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGDAAC4_M4RE_Enum;

/* =============================================  MPU MPU_RGDAAC4 M5WE [26..26]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC4_M5WE                                                          */
  MPU_RGDAAC4_M5WE_0                   = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC4_M5WE_1                   = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGDAAC4_M5WE_Enum;

/* =============================================  MPU MPU_RGDAAC4 M5RE [27..27]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC4_M5RE                                                          */
  MPU_RGDAAC4_M5RE_0                   = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC4_M5RE_1                   = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGDAAC4_M5RE_Enum;

/* =============================================  MPU MPU_RGDAAC4 M6WE [28..28]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC4_M6WE                                                          */
  MPU_RGDAAC4_M6WE_0                   = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC4_M6WE_1                   = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGDAAC4_M6WE_Enum;

/* =============================================  MPU MPU_RGDAAC4 M6RE [29..29]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC4_M6RE                                                          */
  MPU_RGDAAC4_M6RE_0                   = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC4_M6RE_1                   = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGDAAC4_M6RE_Enum;

/* =============================================  MPU MPU_RGDAAC4 M7WE [30..30]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC4_M7WE                                                          */
  MPU_RGDAAC4_M7WE_0                   = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC4_M7WE_1                   = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGDAAC4_M7WE_Enum;

/* =============================================  MPU MPU_RGDAAC4 M7RE [31..31]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC4_M7RE                                                          */
  MPU_RGDAAC4_M7RE_0                   = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC4_M7RE_1                   = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGDAAC4_M7RE_Enum;

/* ======================================================  MPU_RGDAAC5  ====================================================== */
/* ==============================================  MPU MPU_RGDAAC5 M0SM [3..4]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC5_M0SM                                                          */
  MPU_RGDAAC5_M0SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC5_M0SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC5_M0SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC5_M0SM_11                  = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGDAAC5_M0SM_Enum;

/* ==============================================  MPU MPU_RGDAAC5 M0PE [5..5]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC5_M0PE                                                          */
  MPU_RGDAAC5_M0PE_0                   = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGDAAC5_M0PE_1                   = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGDAAC5_M0PE_Enum;

/* =============================================  MPU MPU_RGDAAC5 M1SM [9..10]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC5_M1SM                                                          */
  MPU_RGDAAC5_M1SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC5_M1SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC5_M1SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC5_M1SM_11                  = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGDAAC5_M1SM_Enum;

/* =============================================  MPU MPU_RGDAAC5 M2SM [15..16]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC5_M2SM                                                          */
  MPU_RGDAAC5_M2SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC5_M2SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC5_M2SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC5_M2SM_11                  = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGDAAC5_M2SM_Enum;

/* =============================================  MPU MPU_RGDAAC5 M3SM [21..22]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC5_M3SM                                                          */
  MPU_RGDAAC5_M3SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC5_M3SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC5_M3SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC5_M3SM_11                  = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGDAAC5_M3SM_Enum;

/* =============================================  MPU MPU_RGDAAC5 M4WE [24..24]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC5_M4WE                                                          */
  MPU_RGDAAC5_M4WE_0                   = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC5_M4WE_1                   = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGDAAC5_M4WE_Enum;

/* =============================================  MPU MPU_RGDAAC5 M4RE [25..25]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC5_M4RE                                                          */
  MPU_RGDAAC5_M4RE_0                   = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC5_M4RE_1                   = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGDAAC5_M4RE_Enum;

/* =============================================  MPU MPU_RGDAAC5 M5WE [26..26]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC5_M5WE                                                          */
  MPU_RGDAAC5_M5WE_0                   = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC5_M5WE_1                   = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGDAAC5_M5WE_Enum;

/* =============================================  MPU MPU_RGDAAC5 M5RE [27..27]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC5_M5RE                                                          */
  MPU_RGDAAC5_M5RE_0                   = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC5_M5RE_1                   = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGDAAC5_M5RE_Enum;

/* =============================================  MPU MPU_RGDAAC5 M6WE [28..28]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC5_M6WE                                                          */
  MPU_RGDAAC5_M6WE_0                   = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC5_M6WE_1                   = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGDAAC5_M6WE_Enum;

/* =============================================  MPU MPU_RGDAAC5 M6RE [29..29]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC5_M6RE                                                          */
  MPU_RGDAAC5_M6RE_0                   = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC5_M6RE_1                   = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGDAAC5_M6RE_Enum;

/* =============================================  MPU MPU_RGDAAC5 M7WE [30..30]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC5_M7WE                                                          */
  MPU_RGDAAC5_M7WE_0                   = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC5_M7WE_1                   = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGDAAC5_M7WE_Enum;

/* =============================================  MPU MPU_RGDAAC5 M7RE [31..31]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC5_M7RE                                                          */
  MPU_RGDAAC5_M7RE_0                   = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC5_M7RE_1                   = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGDAAC5_M7RE_Enum;

/* ======================================================  MPU_RGDAAC6  ====================================================== */
/* ==============================================  MPU MPU_RGDAAC6 M0SM [3..4]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC6_M0SM                                                          */
  MPU_RGDAAC6_M0SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC6_M0SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC6_M0SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC6_M0SM_11                  = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGDAAC6_M0SM_Enum;

/* ==============================================  MPU MPU_RGDAAC6 M0PE [5..5]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC6_M0PE                                                          */
  MPU_RGDAAC6_M0PE_0                   = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGDAAC6_M0PE_1                   = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGDAAC6_M0PE_Enum;

/* =============================================  MPU MPU_RGDAAC6 M1SM [9..10]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC6_M1SM                                                          */
  MPU_RGDAAC6_M1SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC6_M1SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC6_M1SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC6_M1SM_11                  = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGDAAC6_M1SM_Enum;

/* =============================================  MPU MPU_RGDAAC6 M2SM [15..16]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC6_M2SM                                                          */
  MPU_RGDAAC6_M2SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC6_M2SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC6_M2SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC6_M2SM_11                  = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGDAAC6_M2SM_Enum;

/* =============================================  MPU MPU_RGDAAC6 M3SM [21..22]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC6_M3SM                                                          */
  MPU_RGDAAC6_M3SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC6_M3SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC6_M3SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC6_M3SM_11                  = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGDAAC6_M3SM_Enum;

/* =============================================  MPU MPU_RGDAAC6 M4WE [24..24]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC6_M4WE                                                          */
  MPU_RGDAAC6_M4WE_0                   = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC6_M4WE_1                   = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGDAAC6_M4WE_Enum;

/* =============================================  MPU MPU_RGDAAC6 M4RE [25..25]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC6_M4RE                                                          */
  MPU_RGDAAC6_M4RE_0                   = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC6_M4RE_1                   = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGDAAC6_M4RE_Enum;

/* =============================================  MPU MPU_RGDAAC6 M5WE [26..26]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC6_M5WE                                                          */
  MPU_RGDAAC6_M5WE_0                   = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC6_M5WE_1                   = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGDAAC6_M5WE_Enum;

/* =============================================  MPU MPU_RGDAAC6 M5RE [27..27]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC6_M5RE                                                          */
  MPU_RGDAAC6_M5RE_0                   = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC6_M5RE_1                   = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGDAAC6_M5RE_Enum;

/* =============================================  MPU MPU_RGDAAC6 M6WE [28..28]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC6_M6WE                                                          */
  MPU_RGDAAC6_M6WE_0                   = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC6_M6WE_1                   = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGDAAC6_M6WE_Enum;

/* =============================================  MPU MPU_RGDAAC6 M6RE [29..29]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC6_M6RE                                                          */
  MPU_RGDAAC6_M6RE_0                   = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC6_M6RE_1                   = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGDAAC6_M6RE_Enum;

/* =============================================  MPU MPU_RGDAAC6 M7WE [30..30]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC6_M7WE                                                          */
  MPU_RGDAAC6_M7WE_0                   = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC6_M7WE_1                   = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGDAAC6_M7WE_Enum;

/* =============================================  MPU MPU_RGDAAC6 M7RE [31..31]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC6_M7RE                                                          */
  MPU_RGDAAC6_M7RE_0                   = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC6_M7RE_1                   = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGDAAC6_M7RE_Enum;

/* ======================================================  MPU_RGDAAC7  ====================================================== */
/* ==============================================  MPU MPU_RGDAAC7 M0SM [3..4]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC7_M0SM                                                          */
  MPU_RGDAAC7_M0SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC7_M0SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC7_M0SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC7_M0SM_11                  = 3,     /*!< 11 : Same as User mode defined in M0UM                                    */
} MPU_RGDAAC7_M0SM_Enum;

/* ==============================================  MPU MPU_RGDAAC7 M0PE [5..5]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC7_M0PE                                                          */
  MPU_RGDAAC7_M0PE_0                   = 0,     /*!< 0 : Do not include the process identifier in the evaluation               */
  MPU_RGDAAC7_M0PE_1                   = 1,     /*!< 1 : Include the process identifier and mask (RGDn.RGDAAC) in
                                                     the region hit evaluation                                                 */
} MPU_RGDAAC7_M0PE_Enum;

/* =============================================  MPU MPU_RGDAAC7 M1SM [9..10]  ============================================== */
typedef enum {                                  /*!< MPU_RGDAAC7_M1SM                                                          */
  MPU_RGDAAC7_M1SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC7_M1SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC7_M1SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC7_M1SM_11                  = 3,     /*!< 11 : Same as User mode defined in M1UM                                    */
} MPU_RGDAAC7_M1SM_Enum;

/* =============================================  MPU MPU_RGDAAC7 M2SM [15..16]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC7_M2SM                                                          */
  MPU_RGDAAC7_M2SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC7_M2SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC7_M2SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC7_M2SM_11                  = 3,     /*!< 11 : Same as User mode defined in M2UM                                    */
} MPU_RGDAAC7_M2SM_Enum;

/* =============================================  MPU MPU_RGDAAC7 M3SM [21..22]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC7_M3SM                                                          */
  MPU_RGDAAC7_M3SM_00                  = 0,     /*!< 00 : r/w/x; read, write and execute allowed                               */
  MPU_RGDAAC7_M3SM_01                  = 1,     /*!< 01 : r/x; read and execute allowed, but no write                          */
  MPU_RGDAAC7_M3SM_10                  = 2,     /*!< 10 : r/w; read and write allowed, but no execute                          */
  MPU_RGDAAC7_M3SM_11                  = 3,     /*!< 11 : Same as User mode defined in M3UM                                    */
} MPU_RGDAAC7_M3SM_Enum;

/* =============================================  MPU MPU_RGDAAC7 M4WE [24..24]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC7_M4WE                                                          */
  MPU_RGDAAC7_M4WE_0                   = 0,     /*!< 0 : Bus master 4 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC7_M4WE_1                   = 1,     /*!< 1 : Bus master 4 writes allowed                                           */
} MPU_RGDAAC7_M4WE_Enum;

/* =============================================  MPU MPU_RGDAAC7 M4RE [25..25]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC7_M4RE                                                          */
  MPU_RGDAAC7_M4RE_0                   = 0,     /*!< 0 : Bus master 4 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC7_M4RE_1                   = 1,     /*!< 1 : Bus master 4 reads allowed                                            */
} MPU_RGDAAC7_M4RE_Enum;

/* =============================================  MPU MPU_RGDAAC7 M5WE [26..26]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC7_M5WE                                                          */
  MPU_RGDAAC7_M5WE_0                   = 0,     /*!< 0 : Bus master 5 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC7_M5WE_1                   = 1,     /*!< 1 : Bus master 5 writes allowed                                           */
} MPU_RGDAAC7_M5WE_Enum;

/* =============================================  MPU MPU_RGDAAC7 M5RE [27..27]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC7_M5RE                                                          */
  MPU_RGDAAC7_M5RE_0                   = 0,     /*!< 0 : Bus master 5 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC7_M5RE_1                   = 1,     /*!< 1 : Bus master 5 reads allowed                                            */
} MPU_RGDAAC7_M5RE_Enum;

/* =============================================  MPU MPU_RGDAAC7 M6WE [28..28]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC7_M6WE                                                          */
  MPU_RGDAAC7_M6WE_0                   = 0,     /*!< 0 : Bus master 6 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC7_M6WE_1                   = 1,     /*!< 1 : Bus master 6 writes allowed                                           */
} MPU_RGDAAC7_M6WE_Enum;

/* =============================================  MPU MPU_RGDAAC7 M6RE [29..29]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC7_M6RE                                                          */
  MPU_RGDAAC7_M6RE_0                   = 0,     /*!< 0 : Bus master 6 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC7_M6RE_1                   = 1,     /*!< 1 : Bus master 6 reads allowed                                            */
} MPU_RGDAAC7_M6RE_Enum;

/* =============================================  MPU MPU_RGDAAC7 M7WE [30..30]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC7_M7WE                                                          */
  MPU_RGDAAC7_M7WE_0                   = 0,     /*!< 0 : Bus master 7 writes terminate with an access error and the
                                                     write is not performed                                                    */
  MPU_RGDAAC7_M7WE_1                   = 1,     /*!< 1 : Bus master 7 writes allowed                                           */
} MPU_RGDAAC7_M7WE_Enum;

/* =============================================  MPU MPU_RGDAAC7 M7RE [31..31]  ============================================= */
typedef enum {                                  /*!< MPU_RGDAAC7_M7RE                                                          */
  MPU_RGDAAC7_M7RE_0                   = 0,     /*!< 0 : Bus master 7 reads terminate with an access error and the
                                                     read is not performed                                                     */
  MPU_RGDAAC7_M7RE_1                   = 1,     /*!< 1 : Bus master 7 reads allowed                                            */
} MPU_RGDAAC7_M7RE_Enum;



/* =========================================================================================================================== */
/* ================                                            ERM                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  ERM_CR0  ======================================================== */
/* ==============================================  ERM ERM_CR0 ENCIE0 [30..30]  ============================================== */
typedef enum {                                  /*!< ERM_CR0_ENCIE0                                                            */
  ERM_CR0_ENCIE0_0                     = 0,     /*!< 0 : Interrupt notification of Memory 0 non-correctable error
                                                     events is disabled.                                                       */
  ERM_CR0_ENCIE0_1                     = 1,     /*!< 1 : Interrupt notification of Memory 0 non-correctable error
                                                     events is enabled.                                                        */
} ERM_CR0_ENCIE0_Enum;

/* ==============================================  ERM ERM_CR0 ESCIE0 [31..31]  ============================================== */
typedef enum {                                  /*!< ERM_CR0_ESCIE0                                                            */
  ERM_CR0_ESCIE0_0                     = 0,     /*!< 0 : Interrupt notification of Memory 0 single-bit correction
                                                     events is disabled.                                                       */
  ERM_CR0_ESCIE0_1                     = 1,     /*!< 1 : Interrupt notification of Memory 0 single-bit correction
                                                     events is enabled.                                                        */
} ERM_CR0_ESCIE0_Enum;

/* ========================================================  ERM_SR0  ======================================================== */
/* ===============================================  ERM ERM_SR0 NCE0 [30..30]  =============================================== */
typedef enum {                                  /*!< ERM_SR0_NCE0                                                              */
  ERM_SR0_NCE0_0                       = 0,     /*!< 0 : No non-correctable error event on Memory 0 detected                   */
  ERM_SR0_NCE0_1                       = 1,     /*!< 1 : Non-correctable error event on Memory 0 detected                      */
} ERM_SR0_NCE0_Enum;

/* ===============================================  ERM ERM_SR0 SBC0 [31..31]  =============================================== */
typedef enum {                                  /*!< ERM_SR0_SBC0                                                              */
  ERM_SR0_SBC0_0                       = 0,     /*!< 0 : No single-bit correction event on Memory 0 detected                   */
  ERM_SR0_SBC0_1                       = 1,     /*!< 1 : Single-bit correction event on Memory 0 detected                      */
} ERM_SR0_SBC0_Enum;

/* =======================================================  ERM_EAR0  ======================================================== */


/* =========================================================================================================================== */
/* ================                                            EIM                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  EIM_EIMCR  ======================================================= */
/* ==============================================  EIM EIM_EIMCR GEIEN [0..0]  =============================================== */
typedef enum {                                  /*!< EIM_EIMCR_GEIEN                                                           */
  EIM_EIMCR_GEIEN_0                    = 0,     /*!< 0 : Disabled                                                              */
  EIM_EIMCR_GEIEN_1                    = 1,     /*!< 1 : Enabled                                                               */
} EIM_EIMCR_GEIEN_Enum;

/* ======================================================  EIM_EICHEN  ======================================================= */
/* ============================================  EIM EIM_EICHEN EICH0EN [31..31]  ============================================ */
typedef enum {                                  /*!< EIM_EICHEN_EICH0EN                                                        */
  EIM_EICHEN_EICH0EN_0                 = 0,     /*!< 0 : Error injection is disabled on Error Injection Channel 0              */
  EIM_EICHEN_EICH0EN_1                 = 1,     /*!< 1 : Error injection is enabled on Error Injection Channel 0               */
} EIM_EICHEN_EICH0EN_Enum;

/* ===================================================  EIM_EICHD0_WORD0  ==================================================== */
/* ===================================================  EIM_EICHD0_WORD1  ==================================================== */


/* =========================================================================================================================== */
/* ================                                           FTFC                                            ================ */
/* =========================================================================================================================== */

/* ======================================================  FTFC_FSTAT  ======================================================= */
/* =============================================  FTFC FTFC_FSTAT FPVIOL [4..4]  ============================================= */
typedef enum {                                  /*!< FTFC_FSTAT_FPVIOL                                                         */
  FTFC_FSTAT_FPVIOL_0                  = 0,     /*!< 0 : No protection violation detected                                      */
  FTFC_FSTAT_FPVIOL_1                  = 1,     /*!< 1 : Protection violation detected                                         */
} FTFC_FSTAT_FPVIOL_Enum;

/* =============================================  FTFC FTFC_FSTAT ACCERR [5..5]  ============================================= */
typedef enum {                                  /*!< FTFC_FSTAT_ACCERR                                                         */
  FTFC_FSTAT_ACCERR_0                  = 0,     /*!< 0 : No access error detected                                              */
  FTFC_FSTAT_ACCERR_1                  = 1,     /*!< 1 : Access error detected                                                 */
} FTFC_FSTAT_ACCERR_Enum;

/* ============================================  FTFC FTFC_FSTAT RDCOLERR [6..6]  ============================================ */
typedef enum {                                  /*!< FTFC_FSTAT_RDCOLERR                                                       */
  FTFC_FSTAT_RDCOLERR_0                = 0,     /*!< 0 : No collision error detected                                           */
  FTFC_FSTAT_RDCOLERR_1                = 1,     /*!< 1 : Collision error detected                                              */
} FTFC_FSTAT_RDCOLERR_Enum;

/* ======================================================  FTFC_FCNFG  ======================================================= */
/* ============================================  FTFC FTFC_FCNFG ERSSUSP [4..4]  ============================================= */
typedef enum {                                  /*!< FTFC_FCNFG_ERSSUSP                                                        */
  FTFC_FCNFG_ERSSUSP_0                 = 0,     /*!< 0 : No suspend requested                                                  */
  FTFC_FCNFG_ERSSUSP_1                 = 1,     /*!< 1 : Suspend the current Erase Flash Sector command execution              */
} FTFC_FCNFG_ERSSUSP_Enum;

/* ============================================  FTFC FTFC_FCNFG ERSAREQ [5..5]  ============================================= */
typedef enum {                                  /*!< FTFC_FCNFG_ERSAREQ                                                        */
  FTFC_FCNFG_ERSAREQ_0                 = 0,     /*!< 0 : No request or request complete                                        */
} FTFC_FCNFG_ERSAREQ_Enum;

/* ============================================  FTFC FTFC_FCNFG RDCOLLIE [6..6]  ============================================ */
typedef enum {                                  /*!< FTFC_FCNFG_RDCOLLIE                                                       */
  FTFC_FCNFG_RDCOLLIE_0                = 0,     /*!< 0 : Read collision error interrupt disabled                               */
  FTFC_FCNFG_RDCOLLIE_1                = 1,     /*!< 1 : Read collision error interrupt enabled. An interrupt request
                                                     is generated whenever an FTFC read collision error is detected
                                                     (see the description of FSTAT[RDCOLERR]).                                 */
} FTFC_FCNFG_RDCOLLIE_Enum;

/* ==============================================  FTFC FTFC_FCNFG CCIE [7..7]  ============================================== */
typedef enum {                                  /*!< FTFC_FCNFG_CCIE                                                           */
  FTFC_FCNFG_CCIE_0                    = 0,     /*!< 0 : Command complete interrupt disabled                                   */
  FTFC_FCNFG_CCIE_1                    = 1,     /*!< 1 : Command complete interrupt enabled. An interrupt request
                                                     is generated whenever the FSTAT[CCIF] flag is set.                        */
} FTFC_FCNFG_CCIE_Enum;

/* =======================================================  FTFC_FSEC  ======================================================= */
/* ===============================================  FTFC FTFC_FSEC SEC [0..1]  =============================================== */
typedef enum {                                  /*!< FTFC_FSEC_SEC                                                             */
  FTFC_FSEC_SEC_10                     = 2,     /*!< 10 : MCU security status is unsecure (The standard shipping
                                                     condition of the FTFC is unsecure.)                                       */
} FTFC_FSEC_SEC_Enum;

/* =============================================  FTFC FTFC_FSEC FSLACC [2..3]  ============================================== */
typedef enum {                                  /*!< FTFC_FSEC_FSLACC                                                          */
  FTFC_FSEC_FSLACC_00                  = 0,     /*!< 00 : Factory access granted                                               */
  FTFC_FSEC_FSLACC_11                  = 3,     /*!< 11 : Factory access granted                                               */
} FTFC_FSEC_FSLACC_Enum;

/* ==============================================  FTFC FTFC_FSEC MEEN [4..5]  =============================================== */
typedef enum {                                  /*!< FTFC_FSEC_MEEN                                                            */
  FTFC_FSEC_MEEN_00                    = 0,     /*!< 00 : Mass erase is enabled                                                */
  FTFC_FSEC_MEEN_01                    = 1,     /*!< 01 : Mass erase is enabled                                                */
  FTFC_FSEC_MEEN_11                    = 3,     /*!< 11 : Mass erase is enabled                                                */
} FTFC_FSEC_MEEN_Enum;

/* ==============================================  FTFC FTFC_FSEC KEYEN [6..7]  ============================================== */
typedef enum {                                  /*!< FTFC_FSEC_KEYEN                                                           */
  FTFC_FSEC_KEYEN_00                   = 0,     /*!< 00 : Backdoor key access disabled                                         */
  FTFC_FSEC_KEYEN_01                   = 1,     /*!< 01 : Backdoor key access disabled (preferred KEYEN state to
                                                     disable backdoor key access)                                              */
  FTFC_FSEC_KEYEN_10                   = 2,     /*!< 10 : Backdoor key access enabled                                          */
  FTFC_FSEC_KEYEN_11                   = 3,     /*!< 11 : Backdoor key access disabled                                         */
} FTFC_FSEC_KEYEN_Enum;

/* =======================================================  FTFC_FOPT  ======================================================= */
/* ======================================================  FTFC_FCCOB3  ====================================================== */
/* ======================================================  FTFC_FCCOB2  ====================================================== */
/* ======================================================  FTFC_FCCOB1  ====================================================== */
/* ======================================================  FTFC_FCCOB0  ====================================================== */
/* ======================================================  FTFC_FCCOB7  ====================================================== */
/* ======================================================  FTFC_FCCOB6  ====================================================== */
/* ======================================================  FTFC_FCCOB5  ====================================================== */
/* ======================================================  FTFC_FCCOB4  ====================================================== */
/* ======================================================  FTFC_FCCOBB  ====================================================== */
/* ======================================================  FTFC_FCCOBA  ====================================================== */
/* ======================================================  FTFC_FCCOB9  ====================================================== */
/* ======================================================  FTFC_FCCOB8  ====================================================== */
/* ======================================================  FTFC_FPROT3  ====================================================== */
/* ======================================================  FTFC_FPROT2  ====================================================== */
/* ======================================================  FTFC_FPROT1  ====================================================== */
/* ======================================================  FTFC_FPROT0  ====================================================== */
/* ======================================================  FTFC_FEPROT  ====================================================== */
/* ======================================================  FTFC_FDPROT  ====================================================== */
/* =============================================  FTFC FTFC_FDPROT DPROT [0..7]  ============================================= */
typedef enum {                                  /*!< FTFC_FDPROT_DPROT                                                         */
  FTFC_FDPROT_DPROT_00000000           = 0,     /*!< 00000000 : Data Flash region is protected                                 */
  FTFC_FDPROT_DPROT_00000001           = 1,     /*!< 00000001 : Data Flash region is not protected                             */
} FTFC_FDPROT_DPROT_Enum;

/* =====================================================  FTFC_FCSESTAT  ===================================================== */
/* =====================================================  FTFC_FERSTAT  ====================================================== */
/* ============================================  FTFC FTFC_FERSTAT DFDIF [1..1]  ============================================= */
typedef enum {                                  /*!< FTFC_FERSTAT_DFDIF                                                        */
  FTFC_FERSTAT_DFDIF_0                 = 0,     /*!< 0 : Double bit fault not detected during a valid flash read
                                                     access from the platform flash controller                                 */
  FTFC_FERSTAT_DFDIF_1                 = 1,     /*!< 1 : Double bit fault detected (or FERCNFG[FDFD] is set) during
                                                     a valid flash read access from the platform flash controller              */
} FTFC_FERSTAT_DFDIF_Enum;

/* =====================================================  FTFC_FERCNFG  ====================================================== */
/* ============================================  FTFC FTFC_FERCNFG DFDIE [1..1]  ============================================= */
typedef enum {                                  /*!< FTFC_FERCNFG_DFDIE                                                        */
  FTFC_FERCNFG_DFDIE_0                 = 0,     /*!< 0 : Double bit fault detect interrupt disabled                            */
  FTFC_FERCNFG_DFDIE_1                 = 1,     /*!< 1 : Double bit fault detect interrupt enabled. An interrupt
                                                     request is generated whenever the FERSTAT[DFDIF] flag is
                                                     set.                                                                      */
} FTFC_FERCNFG_DFDIE_Enum;

/* =============================================  FTFC FTFC_FERCNFG FDFD [5..5]  ============================================= */
typedef enum {                                  /*!< FTFC_FERCNFG_FDFD                                                         */
  FTFC_FERCNFG_FDFD_0                  = 0,     /*!< 0 : FERSTAT[DFDIF] sets only if a double bit fault is detected
                                                     during read access from the platform flash controller                     */
  FTFC_FERCNFG_FDFD_1                  = 1,     /*!< 1 : FERSTAT[DFDIF] sets during any valid flash read access from
                                                     the platform flash controller. An interrupt request is
                                                     generated if the DFDIE bit is set.                                        */
} FTFC_FERCNFG_FDFD_Enum;



/* =========================================================================================================================== */
/* ================                                          DMAMUX                                           ================ */
/* =========================================================================================================================== */

/* =====================================================  DMAMUX_CHCFG0  ===================================================== */
/* ===========================================  DMAMUX DMAMUX_CHCFG0 TRIG [6..6]  ============================================ */
typedef enum {                                  /*!< DMAMUX_CHCFG0_TRIG                                                        */
  DMAMUX_CHCFG0_TRIG_0                 = 0,     /*!< 0 : Triggering is disabled. If triggering is disabled and ENBL
                                                     is set, the DMA Channel will simply route the specified
                                                     source to the DMA channel. (Normal mode)                                  */
  DMAMUX_CHCFG0_TRIG_1                 = 1,     /*!< 1 : Triggering is enabled. If triggering is enabled and ENBL
                                                     is set, the DMAMUX is in Periodic Trigger mode.                           */
} DMAMUX_CHCFG0_TRIG_Enum;

/* ===========================================  DMAMUX DMAMUX_CHCFG0 ENBL [7..7]  ============================================ */
typedef enum {                                  /*!< DMAMUX_CHCFG0_ENBL                                                        */
  DMAMUX_CHCFG0_ENBL_0                 = 0,     /*!< 0 : DMA channel is disabled. This mode is primarily used during
                                                     configuration of the DMAMux. The DMA has separate channel
                                                     enables/disables, which should be used to disable or reconfigure
                                                     a DMA channel.                                                            */
  DMAMUX_CHCFG0_ENBL_1                 = 1,     /*!< 1 : DMA channel is enabled                                                */
} DMAMUX_CHCFG0_ENBL_Enum;

/* =====================================================  DMAMUX_CHCFG1  ===================================================== */
/* ===========================================  DMAMUX DMAMUX_CHCFG1 TRIG [6..6]  ============================================ */
typedef enum {                                  /*!< DMAMUX_CHCFG1_TRIG                                                        */
  DMAMUX_CHCFG1_TRIG_0                 = 0,     /*!< 0 : Triggering is disabled. If triggering is disabled and ENBL
                                                     is set, the DMA Channel will simply route the specified
                                                     source to the DMA channel. (Normal mode)                                  */
  DMAMUX_CHCFG1_TRIG_1                 = 1,     /*!< 1 : Triggering is enabled. If triggering is enabled and ENBL
                                                     is set, the DMAMUX is in Periodic Trigger mode.                           */
} DMAMUX_CHCFG1_TRIG_Enum;

/* ===========================================  DMAMUX DMAMUX_CHCFG1 ENBL [7..7]  ============================================ */
typedef enum {                                  /*!< DMAMUX_CHCFG1_ENBL                                                        */
  DMAMUX_CHCFG1_ENBL_0                 = 0,     /*!< 0 : DMA channel is disabled. This mode is primarily used during
                                                     configuration of the DMAMux. The DMA has separate channel
                                                     enables/disables, which should be used to disable or reconfigure
                                                     a DMA channel.                                                            */
  DMAMUX_CHCFG1_ENBL_1                 = 1,     /*!< 1 : DMA channel is enabled                                                */
} DMAMUX_CHCFG1_ENBL_Enum;

/* =====================================================  DMAMUX_CHCFG2  ===================================================== */
/* ===========================================  DMAMUX DMAMUX_CHCFG2 TRIG [6..6]  ============================================ */
typedef enum {                                  /*!< DMAMUX_CHCFG2_TRIG                                                        */
  DMAMUX_CHCFG2_TRIG_0                 = 0,     /*!< 0 : Triggering is disabled. If triggering is disabled and ENBL
                                                     is set, the DMA Channel will simply route the specified
                                                     source to the DMA channel. (Normal mode)                                  */
  DMAMUX_CHCFG2_TRIG_1                 = 1,     /*!< 1 : Triggering is enabled. If triggering is enabled and ENBL
                                                     is set, the DMAMUX is in Periodic Trigger mode.                           */
} DMAMUX_CHCFG2_TRIG_Enum;

/* ===========================================  DMAMUX DMAMUX_CHCFG2 ENBL [7..7]  ============================================ */
typedef enum {                                  /*!< DMAMUX_CHCFG2_ENBL                                                        */
  DMAMUX_CHCFG2_ENBL_0                 = 0,     /*!< 0 : DMA channel is disabled. This mode is primarily used during
                                                     configuration of the DMAMux. The DMA has separate channel
                                                     enables/disables, which should be used to disable or reconfigure
                                                     a DMA channel.                                                            */
  DMAMUX_CHCFG2_ENBL_1                 = 1,     /*!< 1 : DMA channel is enabled                                                */
} DMAMUX_CHCFG2_ENBL_Enum;

/* =====================================================  DMAMUX_CHCFG3  ===================================================== */
/* ===========================================  DMAMUX DMAMUX_CHCFG3 TRIG [6..6]  ============================================ */
typedef enum {                                  /*!< DMAMUX_CHCFG3_TRIG                                                        */
  DMAMUX_CHCFG3_TRIG_0                 = 0,     /*!< 0 : Triggering is disabled. If triggering is disabled and ENBL
                                                     is set, the DMA Channel will simply route the specified
                                                     source to the DMA channel. (Normal mode)                                  */
  DMAMUX_CHCFG3_TRIG_1                 = 1,     /*!< 1 : Triggering is enabled. If triggering is enabled and ENBL
                                                     is set, the DMAMUX is in Periodic Trigger mode.                           */
} DMAMUX_CHCFG3_TRIG_Enum;

/* ===========================================  DMAMUX DMAMUX_CHCFG3 ENBL [7..7]  ============================================ */
typedef enum {                                  /*!< DMAMUX_CHCFG3_ENBL                                                        */
  DMAMUX_CHCFG3_ENBL_0                 = 0,     /*!< 0 : DMA channel is disabled. This mode is primarily used during
                                                     configuration of the DMAMux. The DMA has separate channel
                                                     enables/disables, which should be used to disable or reconfigure
                                                     a DMA channel.                                                            */
  DMAMUX_CHCFG3_ENBL_1                 = 1,     /*!< 1 : DMA channel is enabled                                                */
} DMAMUX_CHCFG3_ENBL_Enum;



/* =========================================================================================================================== */
/* ================                                           CAN0                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  CAN0_MCR  ======================================================== */
/* ===============================================  CAN0 CAN0_MCR IDAM [8..9]  =============================================== */
typedef enum {                                  /*!< CAN0_MCR_IDAM                                                             */
  CAN0_MCR_IDAM_00                     = 0,     /*!< 00 : Format A: One full ID (standard and extended) per ID Filter
                                                     Table element.                                                            */
  CAN0_MCR_IDAM_01                     = 1,     /*!< 01 : Format B: Two full standard IDs or two partial 14-bit (standard
                                                     and extended) IDs per ID Filter Table element.                            */
  CAN0_MCR_IDAM_10                     = 2,     /*!< 10 : Format C: Four partial 8-bit Standard IDs per ID Filter
                                                     Table element.                                                            */
  CAN0_MCR_IDAM_11                     = 3,     /*!< 11 : Format D: All frames rejected.                                       */
} CAN0_MCR_IDAM_Enum;

/* ==============================================  CAN0 CAN0_MCR FDEN [11..11]  ============================================== */
typedef enum {                                  /*!< CAN0_MCR_FDEN                                                             */
  CAN0_MCR_FDEN_1                      = 1,     /*!< 1 : CAN FD is enabled. FlexCAN is able to receive and transmit
                                                     messages in both CAN FD and CAN 2.0 formats.                              */
  CAN0_MCR_FDEN_0                      = 0,     /*!< 0 : CAN FD is disabled. FlexCAN is able to receive and transmit
                                                     messages in CAN 2.0 format.                                               */
} CAN0_MCR_FDEN_Enum;

/* ==============================================  CAN0 CAN0_MCR AEN [12..12]  =============================================== */
typedef enum {                                  /*!< CAN0_MCR_AEN                                                              */
  CAN0_MCR_AEN_0                       = 0,     /*!< 0 : Abort disabled.                                                       */
  CAN0_MCR_AEN_1                       = 1,     /*!< 1 : Abort enabled.                                                        */
} CAN0_MCR_AEN_Enum;

/* ============================================  CAN0 CAN0_MCR LPRIOEN [13..13]  ============================================= */
typedef enum {                                  /*!< CAN0_MCR_LPRIOEN                                                          */
  CAN0_MCR_LPRIOEN_0                   = 0,     /*!< 0 : Local Priority disabled.                                              */
  CAN0_MCR_LPRIOEN_1                   = 1,     /*!< 1 : Local Priority enabled.                                               */
} CAN0_MCR_LPRIOEN_Enum;

/* ============================================  CAN0 CAN0_MCR PNET_EN [14..14]  ============================================= */
typedef enum {                                  /*!< CAN0_MCR_PNET_EN                                                          */
  CAN0_MCR_PNET_EN_0                   = 0,     /*!< 0 : Pretended Networking mode is disabled.                                */
  CAN0_MCR_PNET_EN_1                   = 1,     /*!< 1 : Pretended Networking mode is enabled.                                 */
} CAN0_MCR_PNET_EN_Enum;

/* ==============================================  CAN0 CAN0_MCR DMA [15..15]  =============================================== */
typedef enum {                                  /*!< CAN0_MCR_DMA                                                              */
  CAN0_MCR_DMA_0                       = 0,     /*!< 0 : DMA feature for RX FIFO disabled.                                     */
  CAN0_MCR_DMA_1                       = 1,     /*!< 1 : DMA feature for RX FIFO enabled.                                      */
} CAN0_MCR_DMA_Enum;

/* ==============================================  CAN0 CAN0_MCR IRMQ [16..16]  ============================================== */
typedef enum {                                  /*!< CAN0_MCR_IRMQ                                                             */
  CAN0_MCR_IRMQ_0                      = 0,     /*!< 0 : Individual Rx masking and queue feature are disabled. For
                                                     backward compatibility with legacy applications, the reading
                                                     of C/S word locks the MB even if it is EMPTY.                             */
  CAN0_MCR_IRMQ_1                      = 1,     /*!< 1 : Individual Rx masking and queue feature are enabled.                  */
} CAN0_MCR_IRMQ_Enum;

/* =============================================  CAN0 CAN0_MCR SRXDIS [17..17]  ============================================= */
typedef enum {                                  /*!< CAN0_MCR_SRXDIS                                                           */
  CAN0_MCR_SRXDIS_0                    = 0,     /*!< 0 : Self reception enabled.                                               */
  CAN0_MCR_SRXDIS_1                    = 1,     /*!< 1 : Self reception disabled.                                              */
} CAN0_MCR_SRXDIS_Enum;

/* =============================================  CAN0 CAN0_MCR LPMACK [20..20]  ============================================= */
typedef enum {                                  /*!< CAN0_MCR_LPMACK                                                           */
  CAN0_MCR_LPMACK_0                    = 0,     /*!< 0 : FlexCAN is not in a low-power mode.                                   */
  CAN0_MCR_LPMACK_1                    = 1,     /*!< 1 : FlexCAN is in a low-power mode.                                       */
} CAN0_MCR_LPMACK_Enum;

/* =============================================  CAN0 CAN0_MCR WRNEN [21..21]  ============================================== */
typedef enum {                                  /*!< CAN0_MCR_WRNEN                                                            */
  CAN0_MCR_WRNEN_0                     = 0,     /*!< 0 : TWRNINT and RWRNINT bits are zero, independent of the values
                                                     in the error counters.                                                    */
  CAN0_MCR_WRNEN_1                     = 1,     /*!< 1 : TWRNINT and RWRNINT bits are set when the respective error
                                                     counter transitions from less than 96 to greater than or
                                                     equal to 96.                                                              */
} CAN0_MCR_WRNEN_Enum;

/* =============================================  CAN0 CAN0_MCR FRZACK [24..24]  ============================================= */
typedef enum {                                  /*!< CAN0_MCR_FRZACK                                                           */
  CAN0_MCR_FRZACK_0                    = 0,     /*!< 0 : FlexCAN not in Freeze mode, prescaler running.                        */
  CAN0_MCR_FRZACK_1                    = 1,     /*!< 1 : FlexCAN in Freeze mode, prescaler stopped.                            */
} CAN0_MCR_FRZACK_Enum;

/* ============================================  CAN0 CAN0_MCR SOFTRST [25..25]  ============================================= */
typedef enum {                                  /*!< CAN0_MCR_SOFTRST                                                          */
  CAN0_MCR_SOFTRST_0                   = 0,     /*!< 0 : No reset request.                                                     */
  CAN0_MCR_SOFTRST_1                   = 1,     /*!< 1 : Resets the registers affected by soft reset.                          */
} CAN0_MCR_SOFTRST_Enum;

/* =============================================  CAN0 CAN0_MCR NOTRDY [27..27]  ============================================= */
typedef enum {                                  /*!< CAN0_MCR_NOTRDY                                                           */
  CAN0_MCR_NOTRDY_0                    = 0,     /*!< 0 : FlexCAN module is either in Normal mode, Listen-Only mode
                                                     or Loop-Back mode.                                                        */
} CAN0_MCR_NOTRDY_Enum;

/* ==============================================  CAN0 CAN0_MCR HALT [28..28]  ============================================== */
typedef enum {                                  /*!< CAN0_MCR_HALT                                                             */
  CAN0_MCR_HALT_0                      = 0,     /*!< 0 : No Freeze mode request.                                               */
  CAN0_MCR_HALT_1                      = 1,     /*!< 1 : Enters Freeze mode if the FRZ bit is asserted.                        */
} CAN0_MCR_HALT_Enum;

/* ==============================================  CAN0 CAN0_MCR RFEN [29..29]  ============================================== */
typedef enum {                                  /*!< CAN0_MCR_RFEN                                                             */
  CAN0_MCR_RFEN_0                      = 0,     /*!< 0 : Rx FIFO not enabled.                                                  */
  CAN0_MCR_RFEN_1                      = 1,     /*!< 1 : Rx FIFO enabled.                                                      */
} CAN0_MCR_RFEN_Enum;

/* ==============================================  CAN0 CAN0_MCR FRZ [30..30]  =============================================== */
typedef enum {                                  /*!< CAN0_MCR_FRZ                                                              */
  CAN0_MCR_FRZ_0                       = 0,     /*!< 0 : Not enabled to enter Freeze mode.                                     */
  CAN0_MCR_FRZ_1                       = 1,     /*!< 1 : Enabled to enter Freeze mode.                                         */
} CAN0_MCR_FRZ_Enum;

/* ==============================================  CAN0 CAN0_MCR MDIS [31..31]  ============================================== */
typedef enum {                                  /*!< CAN0_MCR_MDIS                                                             */
  CAN0_MCR_MDIS_0                      = 0,     /*!< 0 : Enable the FlexCAN module.                                            */
  CAN0_MCR_MDIS_1                      = 1,     /*!< 1 : Disable the FlexCAN module.                                           */
} CAN0_MCR_MDIS_Enum;

/* ======================================================  CAN0_CTRL1  ======================================================= */
/* ==============================================  CAN0 CAN0_CTRL1 LOM [3..3]  =============================================== */
typedef enum {                                  /*!< CAN0_CTRL1_LOM                                                            */
  CAN0_CTRL1_LOM_0                     = 0,     /*!< 0 : Listen-Only mode is deactivated.                                      */
  CAN0_CTRL1_LOM_1                     = 1,     /*!< 1 : FlexCAN module operates in Listen-Only mode.                          */
} CAN0_CTRL1_LOM_Enum;

/* ==============================================  CAN0 CAN0_CTRL1 LBUF [4..4]  ============================================== */
typedef enum {                                  /*!< CAN0_CTRL1_LBUF                                                           */
  CAN0_CTRL1_LBUF_0                    = 0,     /*!< 0 : Buffer with highest priority is transmitted first.                    */
  CAN0_CTRL1_LBUF_1                    = 1,     /*!< 1 : Lowest number buffer is transmitted first.                            */
} CAN0_CTRL1_LBUF_Enum;

/* ==============================================  CAN0 CAN0_CTRL1 TSYN [5..5]  ============================================== */
typedef enum {                                  /*!< CAN0_CTRL1_TSYN                                                           */
  CAN0_CTRL1_TSYN_0                    = 0,     /*!< 0 : Timer Sync feature disabled                                           */
  CAN0_CTRL1_TSYN_1                    = 1,     /*!< 1 : Timer Sync feature enabled                                            */
} CAN0_CTRL1_TSYN_Enum;

/* ============================================  CAN0 CAN0_CTRL1 BOFFREC [6..6]  ============================================= */
typedef enum {                                  /*!< CAN0_CTRL1_BOFFREC                                                        */
  CAN0_CTRL1_BOFFREC_0                 = 0,     /*!< 0 : Automatic recovering from Bus Off state enabled.                      */
  CAN0_CTRL1_BOFFREC_1                 = 1,     /*!< 1 : Automatic recovering from Bus Off state disabled.                     */
} CAN0_CTRL1_BOFFREC_Enum;

/* ==============================================  CAN0 CAN0_CTRL1 SMP [7..7]  =============================================== */
typedef enum {                                  /*!< CAN0_CTRL1_SMP                                                            */
  CAN0_CTRL1_SMP_0                     = 0,     /*!< 0 : Just one sample is used to determine the bit value.                   */
  CAN0_CTRL1_SMP_1                     = 1,     /*!< 1 : Three samples are used to determine the value of the received
                                                     bit: the regular one (sample point) and 2 preceding samples;
                                                     a majority rule is used.                                                  */
} CAN0_CTRL1_SMP_Enum;

/* ===========================================  CAN0 CAN0_CTRL1 RWRNMSK [10..10]  ============================================ */
typedef enum {                                  /*!< CAN0_CTRL1_RWRNMSK                                                        */
  CAN0_CTRL1_RWRNMSK_0                 = 0,     /*!< 0 : Rx Warning Interrupt disabled.                                        */
  CAN0_CTRL1_RWRNMSK_1                 = 1,     /*!< 1 : Rx Warning Interrupt enabled.                                         */
} CAN0_CTRL1_RWRNMSK_Enum;

/* ===========================================  CAN0 CAN0_CTRL1 TWRNMSK [11..11]  ============================================ */
typedef enum {                                  /*!< CAN0_CTRL1_TWRNMSK                                                        */
  CAN0_CTRL1_TWRNMSK_0                 = 0,     /*!< 0 : Tx Warning Interrupt disabled.                                        */
  CAN0_CTRL1_TWRNMSK_1                 = 1,     /*!< 1 : Tx Warning Interrupt enabled.                                         */
} CAN0_CTRL1_TWRNMSK_Enum;

/* =============================================  CAN0 CAN0_CTRL1 LPB [12..12]  ============================================== */
typedef enum {                                  /*!< CAN0_CTRL1_LPB                                                            */
  CAN0_CTRL1_LPB_0                     = 0,     /*!< 0 : Loop Back disabled.                                                   */
  CAN0_CTRL1_LPB_1                     = 1,     /*!< 1 : Loop Back enabled.                                                    */
} CAN0_CTRL1_LPB_Enum;

/* ============================================  CAN0 CAN0_CTRL1 CLKSRC [13..13]  ============================================ */
typedef enum {                                  /*!< CAN0_CTRL1_CLKSRC                                                         */
  CAN0_CTRL1_CLKSRC_0                  = 0,     /*!< 0 : The CAN engine clock source is the oscillator clock. Under
                                                     this condition, the oscillator clock frequency must be
                                                     lower than the bus clock.                                                 */
  CAN0_CTRL1_CLKSRC_1                  = 1,     /*!< 1 : The CAN engine clock source is the peripheral clock.                  */
} CAN0_CTRL1_CLKSRC_Enum;

/* ============================================  CAN0 CAN0_CTRL1 ERRMSK [14..14]  ============================================ */
typedef enum {                                  /*!< CAN0_CTRL1_ERRMSK                                                         */
  CAN0_CTRL1_ERRMSK_0                  = 0,     /*!< 0 : Error interrupt disabled.                                             */
  CAN0_CTRL1_ERRMSK_1                  = 1,     /*!< 1 : Error interrupt enabled.                                              */
} CAN0_CTRL1_ERRMSK_Enum;

/* ===========================================  CAN0 CAN0_CTRL1 BOFFMSK [15..15]  ============================================ */
typedef enum {                                  /*!< CAN0_CTRL1_BOFFMSK                                                        */
  CAN0_CTRL1_BOFFMSK_0                 = 0,     /*!< 0 : Bus Off interrupt disabled.                                           */
  CAN0_CTRL1_BOFFMSK_1                 = 1,     /*!< 1 : Bus Off interrupt enabled.                                            */
} CAN0_CTRL1_BOFFMSK_Enum;

/* ======================================================  CAN0_TIMER  ======================================================= */
/* =====================================================  CAN0_RXMGMASK  ===================================================== */
/* =====================================================  CAN0_RX14MASK  ===================================================== */
/* =====================================================  CAN0_RX15MASK  ===================================================== */
/* =======================================================  CAN0_ECR  ======================================================== */
/* =======================================================  CAN0_ESR1  ======================================================= */
/* =============================================  CAN0 CAN0_ESR1 ERRINT [1..1]  ============================================== */
typedef enum {                                  /*!< CAN0_ESR1_ERRINT                                                          */
  CAN0_ESR1_ERRINT_0                   = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_ERRINT_1                   = 1,     /*!< 1 : Indicates setting of any Error Bit in the Error and Status
                                                     Register.                                                                 */
} CAN0_ESR1_ERRINT_Enum;

/* =============================================  CAN0 CAN0_ESR1 BOFFINT [2..2]  ============================================= */
typedef enum {                                  /*!< CAN0_ESR1_BOFFINT                                                         */
  CAN0_ESR1_BOFFINT_0                  = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_BOFFINT_1                  = 1,     /*!< 1 : FlexCAN module entered Bus Off state.                                 */
} CAN0_ESR1_BOFFINT_Enum;

/* ===============================================  CAN0 CAN0_ESR1 RX [3..3]  ================================================ */
typedef enum {                                  /*!< CAN0_ESR1_RX                                                              */
  CAN0_ESR1_RX_0                       = 0,     /*!< 0 : FlexCAN is not receiving a message.                                   */
  CAN0_ESR1_RX_1                       = 1,     /*!< 1 : FlexCAN is receiving a message.                                       */
} CAN0_ESR1_RX_Enum;

/* =============================================  CAN0 CAN0_ESR1 FLTCONF [4..5]  ============================================= */
typedef enum {                                  /*!< CAN0_ESR1_FLTCONF                                                         */
  CAN0_ESR1_FLTCONF_00                 = 0,     /*!< 00 : Error Active                                                         */
  CAN0_ESR1_FLTCONF_01                 = 1,     /*!< 01 : Error Passive                                                        */
  CAN0_ESR1_FLTCONF_1x_2               = 2,     /*!< 1x_2 : Bus Off                                                            */
  CAN0_ESR1_FLTCONF_1x_3               = 3,     /*!< 1x_3 : Bus Off                                                            */
} CAN0_ESR1_FLTCONF_Enum;

/* ===============================================  CAN0 CAN0_ESR1 TX [6..6]  ================================================ */
typedef enum {                                  /*!< CAN0_ESR1_TX                                                              */
  CAN0_ESR1_TX_0                       = 0,     /*!< 0 : FlexCAN is not transmitting a message.                                */
  CAN0_ESR1_TX_1                       = 1,     /*!< 1 : FlexCAN is transmitting a message.                                    */
} CAN0_ESR1_TX_Enum;

/* ==============================================  CAN0 CAN0_ESR1 IDLE [7..7]  =============================================== */
typedef enum {                                  /*!< CAN0_ESR1_IDLE                                                            */
  CAN0_ESR1_IDLE_0                     = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_IDLE_1                     = 1,     /*!< 1 : CAN bus is now IDLE.                                                  */
} CAN0_ESR1_IDLE_Enum;

/* ==============================================  CAN0 CAN0_ESR1 RXWRN [8..8]  ============================================== */
typedef enum {                                  /*!< CAN0_ESR1_RXWRN                                                           */
  CAN0_ESR1_RXWRN_0                    = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_RXWRN_1                    = 1,     /*!< 1 : RXERRCNT is greater than or equal to 96.                              */
} CAN0_ESR1_RXWRN_Enum;

/* ==============================================  CAN0 CAN0_ESR1 TXWRN [9..9]  ============================================== */
typedef enum {                                  /*!< CAN0_ESR1_TXWRN                                                           */
  CAN0_ESR1_TXWRN_0                    = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_TXWRN_1                    = 1,     /*!< 1 : TXERRCNT is greater than or equal to 96.                              */
} CAN0_ESR1_TXWRN_Enum;

/* ============================================  CAN0 CAN0_ESR1 STFERR [10..10]  ============================================= */
typedef enum {                                  /*!< CAN0_ESR1_STFERR                                                          */
  CAN0_ESR1_STFERR_0                   = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_STFERR_1                   = 1,     /*!< 1 : A Stuffing Error occurred since last read of this register.           */
} CAN0_ESR1_STFERR_Enum;

/* ============================================  CAN0 CAN0_ESR1 FRMERR [11..11]  ============================================= */
typedef enum {                                  /*!< CAN0_ESR1_FRMERR                                                          */
  CAN0_ESR1_FRMERR_0                   = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_FRMERR_1                   = 1,     /*!< 1 : A Form Error occurred since last read of this register.               */
} CAN0_ESR1_FRMERR_Enum;

/* ============================================  CAN0 CAN0_ESR1 CRCERR [12..12]  ============================================= */
typedef enum {                                  /*!< CAN0_ESR1_CRCERR                                                          */
  CAN0_ESR1_CRCERR_0                   = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_CRCERR_1                   = 1,     /*!< 1 : A CRC error occurred since last read of this register.                */
} CAN0_ESR1_CRCERR_Enum;

/* ============================================  CAN0 CAN0_ESR1 ACKERR [13..13]  ============================================= */
typedef enum {                                  /*!< CAN0_ESR1_ACKERR                                                          */
  CAN0_ESR1_ACKERR_0                   = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_ACKERR_1                   = 1,     /*!< 1 : An ACK error occurred since last read of this register.               */
} CAN0_ESR1_ACKERR_Enum;

/* ============================================  CAN0 CAN0_ESR1 BIT0ERR [14..14]  ============================================ */
typedef enum {                                  /*!< CAN0_ESR1_BIT0ERR                                                         */
  CAN0_ESR1_BIT0ERR_0                  = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_BIT0ERR_1                  = 1,     /*!< 1 : At least one bit sent as dominant is received as recessive.           */
} CAN0_ESR1_BIT0ERR_Enum;

/* ============================================  CAN0 CAN0_ESR1 BIT1ERR [15..15]  ============================================ */
typedef enum {                                  /*!< CAN0_ESR1_BIT1ERR                                                         */
  CAN0_ESR1_BIT1ERR_0                  = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_BIT1ERR_1                  = 1,     /*!< 1 : At least one bit sent as recessive is received as dominant.           */
} CAN0_ESR1_BIT1ERR_Enum;

/* ============================================  CAN0 CAN0_ESR1 RWRNINT [16..16]  ============================================ */
typedef enum {                                  /*!< CAN0_ESR1_RWRNINT                                                         */
  CAN0_ESR1_RWRNINT_0                  = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_RWRNINT_1                  = 1,     /*!< 1 : The Rx error counter transitioned from less than 96 to greater
                                                     than or equal to 96.                                                      */
} CAN0_ESR1_RWRNINT_Enum;

/* ============================================  CAN0 CAN0_ESR1 TWRNINT [17..17]  ============================================ */
typedef enum {                                  /*!< CAN0_ESR1_TWRNINT                                                         */
  CAN0_ESR1_TWRNINT_0                  = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_TWRNINT_1                  = 1,     /*!< 1 : The Tx error counter transitioned from less than 96 to greater
                                                     than or equal to 96.                                                      */
} CAN0_ESR1_TWRNINT_Enum;

/* =============================================  CAN0 CAN0_ESR1 SYNCH [18..18]  ============================================= */
typedef enum {                                  /*!< CAN0_ESR1_SYNCH                                                           */
  CAN0_ESR1_SYNCH_0                    = 0,     /*!< 0 : FlexCAN is not synchronized to the CAN bus.                           */
  CAN0_ESR1_SYNCH_1                    = 1,     /*!< 1 : FlexCAN is synchronized to the CAN bus.                               */
} CAN0_ESR1_SYNCH_Enum;

/* ==========================================  CAN0 CAN0_ESR1 BOFFDONEINT [19..19]  ========================================== */
typedef enum {                                  /*!< CAN0_ESR1_BOFFDONEINT                                                     */
  CAN0_ESR1_BOFFDONEINT_0              = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_BOFFDONEINT_1              = 1,     /*!< 1 : FlexCAN module has completed Bus Off process.                         */
} CAN0_ESR1_BOFFDONEINT_Enum;

/* ==========================================  CAN0 CAN0_ESR1 ERRINT_FAST [20..20]  ========================================== */
typedef enum {                                  /*!< CAN0_ESR1_ERRINT_FAST                                                     */
  CAN0_ESR1_ERRINT_FAST_0              = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_ERRINT_FAST_1              = 1,     /*!< 1 : Indicates setting of any Error Bit detected in the Data
                                                     Phase of CAN FD frames with the BRS bit set.                              */
} CAN0_ESR1_ERRINT_FAST_Enum;

/* ============================================  CAN0 CAN0_ESR1 ERROVR [21..21]  ============================================= */
typedef enum {                                  /*!< CAN0_ESR1_ERROVR                                                          */
  CAN0_ESR1_ERROVR_0                   = 0,     /*!< 0 : Overrun has not occurred.                                             */
  CAN0_ESR1_ERROVR_1                   = 1,     /*!< 1 : Overrun has occurred.                                                 */
} CAN0_ESR1_ERROVR_Enum;

/* ==========================================  CAN0 CAN0_ESR1 STFERR_FAST [26..26]  ========================================== */
typedef enum {                                  /*!< CAN0_ESR1_STFERR_FAST                                                     */
  CAN0_ESR1_STFERR_FAST_0              = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_STFERR_FAST_1              = 1,     /*!< 1 : A Stuffing Error occurred since last read of this register.           */
} CAN0_ESR1_STFERR_FAST_Enum;

/* ==========================================  CAN0 CAN0_ESR1 FRMERR_FAST [27..27]  ========================================== */
typedef enum {                                  /*!< CAN0_ESR1_FRMERR_FAST                                                     */
  CAN0_ESR1_FRMERR_FAST_0              = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_FRMERR_FAST_1              = 1,     /*!< 1 : A Form Error occurred since last read of this register.               */
} CAN0_ESR1_FRMERR_FAST_Enum;

/* ==========================================  CAN0 CAN0_ESR1 CRCERR_FAST [28..28]  ========================================== */
typedef enum {                                  /*!< CAN0_ESR1_CRCERR_FAST                                                     */
  CAN0_ESR1_CRCERR_FAST_0              = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_CRCERR_FAST_1              = 1,     /*!< 1 : A CRC error occurred since last read of this register.                */
} CAN0_ESR1_CRCERR_FAST_Enum;

/* =========================================  CAN0 CAN0_ESR1 BIT0ERR_FAST [30..30]  ========================================== */
typedef enum {                                  /*!< CAN0_ESR1_BIT0ERR_FAST                                                    */
  CAN0_ESR1_BIT0ERR_FAST_0             = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_BIT0ERR_FAST_1             = 1,     /*!< 1 : At least one bit sent as dominant is received as recessive.           */
} CAN0_ESR1_BIT0ERR_FAST_Enum;

/* =========================================  CAN0 CAN0_ESR1 BIT1ERR_FAST [31..31]  ========================================== */
typedef enum {                                  /*!< CAN0_ESR1_BIT1ERR_FAST                                                    */
  CAN0_ESR1_BIT1ERR_FAST_0             = 0,     /*!< 0 : No such occurrence.                                                   */
  CAN0_ESR1_BIT1ERR_FAST_1             = 1,     /*!< 1 : At least one bit sent as recessive is received as dominant.           */
} CAN0_ESR1_BIT1ERR_FAST_Enum;

/* ======================================================  CAN0_IMASK1  ====================================================== */
/* ======================================================  CAN0_IFLAG1  ====================================================== */
/* =============================================  CAN0 CAN0_IFLAG1 BUF0I [0..0]  ============================================= */
typedef enum {                                  /*!< CAN0_IFLAG1_BUF0I                                                         */
  CAN0_IFLAG1_BUF0I_0                  = 0,     /*!< 0 : The corresponding buffer has no occurrence of successfully
                                                     completed transmission or reception when MCR[RFEN]=0.                     */
  CAN0_IFLAG1_BUF0I_1                  = 1,     /*!< 1 : The corresponding buffer has successfully completed transmission
                                                     or reception when MCR[RFEN]=0.                                            */
} CAN0_IFLAG1_BUF0I_Enum;

/* =============================================  CAN0 CAN0_IFLAG1 BUF5I [5..5]  ============================================= */
typedef enum {                                  /*!< CAN0_IFLAG1_BUF5I                                                         */
  CAN0_IFLAG1_BUF5I_0                  = 0,     /*!< 0 : No occurrence of MB5 completing transmission/reception when
                                                     MCR[RFEN]=0, or of frame(s) available in the FIFO, when
                                                     MCR[RFEN]=1                                                               */
  CAN0_IFLAG1_BUF5I_1                  = 1,     /*!< 1 : MB5 completed transmission/reception when MCR[RFEN]=0, or
                                                     frame(s) available in the Rx FIFO when MCR[RFEN]=1. It
                                                     generates a DMA request in case of MCR[RFEN] and MCR[DMA]
                                                     are enabled.                                                              */
} CAN0_IFLAG1_BUF5I_Enum;

/* =============================================  CAN0 CAN0_IFLAG1 BUF6I [6..6]  ============================================= */
typedef enum {                                  /*!< CAN0_IFLAG1_BUF6I                                                         */
  CAN0_IFLAG1_BUF6I_0                  = 0,     /*!< 0 : No occurrence of MB6 completing transmission/reception when
                                                     MCR[RFEN]=0, or of Rx FIFO almost full when MCR[RFEN]=1                   */
  CAN0_IFLAG1_BUF6I_1                  = 1,     /*!< 1 : MB6 completed transmission/reception when MCR[RFEN]=0, or
                                                     Rx FIFO almost full when MCR[RFEN]=1                                      */
} CAN0_IFLAG1_BUF6I_Enum;

/* =============================================  CAN0 CAN0_IFLAG1 BUF7I [7..7]  ============================================= */
typedef enum {                                  /*!< CAN0_IFLAG1_BUF7I                                                         */
  CAN0_IFLAG1_BUF7I_0                  = 0,     /*!< 0 : No occurrence of MB7 completing transmission/reception when
                                                     MCR[RFEN]=0, or of Rx FIFO overflow when MCR[RFEN]=1                      */
  CAN0_IFLAG1_BUF7I_1                  = 1,     /*!< 1 : MB7 completed transmission/reception when MCR[RFEN]=0, or
                                                     Rx FIFO overflow when MCR[RFEN]=1                                         */
} CAN0_IFLAG1_BUF7I_Enum;

/* ======================================================  CAN0_CTRL2  ======================================================= */
/* ===========================================  CAN0 CAN0_CTRL2 EDFLTDIS [11..11]  =========================================== */
typedef enum {                                  /*!< CAN0_CTRL2_EDFLTDIS                                                       */
  CAN0_CTRL2_EDFLTDIS_0                = 0,     /*!< 0 : Edge Filter is enabled.                                               */
  CAN0_CTRL2_EDFLTDIS_1                = 1,     /*!< 1 : Edge Filter is disabled.                                              */
} CAN0_CTRL2_EDFLTDIS_Enum;

/* ==========================================  CAN0 CAN0_CTRL2 ISOCANFDEN [12..12]  ========================================== */
typedef enum {                                  /*!< CAN0_CTRL2_ISOCANFDEN                                                     */
  CAN0_CTRL2_ISOCANFDEN_0              = 0,     /*!< 0 : FlexCAN operates using the non-ISO CAN FD protocol.                   */
  CAN0_CTRL2_ISOCANFDEN_1              = 1,     /*!< 1 : FlexCAN operates using the ISO CAN FD protocol (ISO 11898-1).         */
} CAN0_CTRL2_ISOCANFDEN_Enum;

/* ===========================================  CAN0 CAN0_CTRL2 PREXCEN [14..14]  ============================================ */
typedef enum {                                  /*!< CAN0_CTRL2_PREXCEN                                                        */
  CAN0_CTRL2_PREXCEN_0                 = 0,     /*!< 0 : Protocol Exception is disabled.                                       */
  CAN0_CTRL2_PREXCEN_1                 = 1,     /*!< 1 : Protocol Exception is enabled.                                        */
} CAN0_CTRL2_PREXCEN_Enum;

/* ==========================================  CAN0 CAN0_CTRL2 TIMER_SRC [15..15]  =========================================== */
typedef enum {                                  /*!< CAN0_CTRL2_TIMER_SRC                                                      */
  CAN0_CTRL2_TIMER_SRC_0               = 0,     /*!< 0 : The Free Running Timer is clocked by the CAN bit clock,
                                                     which defines the baud rate on the CAN bus.                               */
  CAN0_CTRL2_TIMER_SRC_1               = 1,     /*!< 1 : The Free Running Timer is clocked by an external time tick.
                                                     The period can be either adjusted to be equal to the baud
                                                     rate on the CAN bus, or a different value as required.
                                                     See the device specific section for details about the external
                                                     time tick.                                                                */
} CAN0_CTRL2_TIMER_SRC_Enum;

/* ============================================  CAN0 CAN0_CTRL2 EACEN [16..16]  ============================================= */
typedef enum {                                  /*!< CAN0_CTRL2_EACEN                                                          */
  CAN0_CTRL2_EACEN_0                   = 0,     /*!< 0 : Rx Mailbox filters IDE bit is always compared and RTR is
                                                     never compared despite mask bits.                                         */
  CAN0_CTRL2_EACEN_1                   = 1,     /*!< 1 : Enables the comparison of both Rx Mailbox filters IDE and
                                                     RTR bit with their corresponding bits within the incoming
                                                     frame. Mask bits do apply.                                                */
} CAN0_CTRL2_EACEN_Enum;

/* =============================================  CAN0 CAN0_CTRL2 RRS [17..17]  ============================================== */
typedef enum {                                  /*!< CAN0_CTRL2_RRS                                                            */
  CAN0_CTRL2_RRS_0                     = 0,     /*!< 0 : Remote Response Frame is generated.                                   */
  CAN0_CTRL2_RRS_1                     = 1,     /*!< 1 : Remote Request Frame is stored.                                       */
} CAN0_CTRL2_RRS_Enum;

/* =============================================  CAN0 CAN0_CTRL2 MRP [18..18]  ============================================== */
typedef enum {                                  /*!< CAN0_CTRL2_MRP                                                            */
  CAN0_CTRL2_MRP_0                     = 0,     /*!< 0 : Matching starts from Rx FIFO and continues on Mailboxes.              */
  CAN0_CTRL2_MRP_1                     = 1,     /*!< 1 : Matching starts from Mailboxes and continues on Rx FIFO.              */
} CAN0_CTRL2_MRP_Enum;

/* =========================================  CAN0 CAN0_CTRL2 BOFFDONEMSK [30..30]  ========================================== */
typedef enum {                                  /*!< CAN0_CTRL2_BOFFDONEMSK                                                    */
  CAN0_CTRL2_BOFFDONEMSK_0             = 0,     /*!< 0 : Bus Off Done interrupt disabled.                                      */
  CAN0_CTRL2_BOFFDONEMSK_1             = 1,     /*!< 1 : Bus Off Done interrupt enabled.                                       */
} CAN0_CTRL2_BOFFDONEMSK_Enum;

/* =========================================  CAN0 CAN0_CTRL2 ERRMSK_FAST [31..31]  ========================================== */
typedef enum {                                  /*!< CAN0_CTRL2_ERRMSK_FAST                                                    */
  CAN0_CTRL2_ERRMSK_FAST_0             = 0,     /*!< 0 : ERRINT_FAST Error interrupt disabled.                                 */
  CAN0_CTRL2_ERRMSK_FAST_1             = 1,     /*!< 1 : ERRINT_FAST Error interrupt enabled.                                  */
} CAN0_CTRL2_ERRMSK_FAST_Enum;

/* =======================================================  CAN0_ESR2  ======================================================= */
/* ==============================================  CAN0 CAN0_ESR2 IMB [13..13]  ============================================== */
typedef enum {                                  /*!< CAN0_ESR2_IMB                                                             */
  CAN0_ESR2_IMB_0                      = 0,     /*!< 0 : If ESR2[VPS] is asserted, the ESR2[LPTM] is not an inactive
                                                     Mailbox.                                                                  */
  CAN0_ESR2_IMB_1                      = 1,     /*!< 1 : If ESR2[VPS] is asserted, there is at least one inactive
                                                     Mailbox. LPTM content is the number of the first one.                     */
} CAN0_ESR2_IMB_Enum;

/* ==============================================  CAN0 CAN0_ESR2 VPS [14..14]  ============================================== */
typedef enum {                                  /*!< CAN0_ESR2_VPS                                                             */
  CAN0_ESR2_VPS_0                      = 0,     /*!< 0 : Contents of IMB and LPTM are invalid.                                 */
  CAN0_ESR2_VPS_1                      = 1,     /*!< 1 : Contents of IMB and LPTM are valid.                                   */
} CAN0_ESR2_VPS_Enum;

/* =======================================================  CAN0_CRCR  ======================================================= */
/* =====================================================  CAN0_RXFGMASK  ===================================================== */
/* ======================================================  CAN0_RXFIR  ======================================================= */
/* =======================================================  CAN0_CBT  ======================================================== */
/* ==============================================  CAN0 CAN0_CBT BTF [31..31]  =============================================== */
typedef enum {                                  /*!< CAN0_CBT_BTF                                                              */
  CAN0_CBT_BTF_0                       = 0,     /*!< 0 : Extended bit time definitions disabled.                               */
  CAN0_CBT_BTF_1                       = 1,     /*!< 1 : Extended bit time definitions enabled.                                */
} CAN0_CBT_BTF_Enum;

/* ======================================================  CAN0_RAMn0  ======================================================= */
/* ======================================================  CAN0_RAMn1  ======================================================= */
/* ======================================================  CAN0_RAMn2  ======================================================= */
/* ======================================================  CAN0_RAMn3  ======================================================= */
/* ======================================================  CAN0_RAMn4  ======================================================= */
/* ======================================================  CAN0_RAMn5  ======================================================= */
/* ======================================================  CAN0_RAMn6  ======================================================= */
/* ======================================================  CAN0_RAMn7  ======================================================= */
/* ======================================================  CAN0_RAMn8  ======================================================= */
/* ======================================================  CAN0_RAMn9  ======================================================= */
/* ======================================================  CAN0_RAMn10  ====================================================== */
/* ======================================================  CAN0_RAMn11  ====================================================== */
/* ======================================================  CAN0_RAMn12  ====================================================== */
/* ======================================================  CAN0_RAMn13  ====================================================== */
/* ======================================================  CAN0_RAMn14  ====================================================== */
/* ======================================================  CAN0_RAMn15  ====================================================== */
/* ======================================================  CAN0_RAMn16  ====================================================== */
/* ======================================================  CAN0_RAMn17  ====================================================== */
/* ======================================================  CAN0_RAMn18  ====================================================== */
/* ======================================================  CAN0_RAMn19  ====================================================== */
/* ======================================================  CAN0_RAMn20  ====================================================== */
/* ======================================================  CAN0_RAMn21  ====================================================== */
/* ======================================================  CAN0_RAMn22  ====================================================== */
/* ======================================================  CAN0_RAMn23  ====================================================== */
/* ======================================================  CAN0_RAMn24  ====================================================== */
/* ======================================================  CAN0_RAMn25  ====================================================== */
/* ======================================================  CAN0_RAMn26  ====================================================== */
/* ======================================================  CAN0_RAMn27  ====================================================== */
/* ======================================================  CAN0_RAMn28  ====================================================== */
/* ======================================================  CAN0_RAMn29  ====================================================== */
/* ======================================================  CAN0_RAMn30  ====================================================== */
/* ======================================================  CAN0_RAMn31  ====================================================== */
/* ======================================================  CAN0_RAMn32  ====================================================== */
/* ======================================================  CAN0_RAMn33  ====================================================== */
/* ======================================================  CAN0_RAMn34  ====================================================== */
/* ======================================================  CAN0_RAMn35  ====================================================== */
/* ======================================================  CAN0_RAMn36  ====================================================== */
/* ======================================================  CAN0_RAMn37  ====================================================== */
/* ======================================================  CAN0_RAMn38  ====================================================== */
/* ======================================================  CAN0_RAMn39  ====================================================== */
/* ======================================================  CAN0_RAMn40  ====================================================== */
/* ======================================================  CAN0_RAMn41  ====================================================== */
/* ======================================================  CAN0_RAMn42  ====================================================== */
/* ======================================================  CAN0_RAMn43  ====================================================== */
/* ======================================================  CAN0_RAMn44  ====================================================== */
/* ======================================================  CAN0_RAMn45  ====================================================== */
/* ======================================================  CAN0_RAMn46  ====================================================== */
/* ======================================================  CAN0_RAMn47  ====================================================== */
/* ======================================================  CAN0_RAMn48  ====================================================== */
/* ======================================================  CAN0_RAMn49  ====================================================== */
/* ======================================================  CAN0_RAMn50  ====================================================== */
/* ======================================================  CAN0_RAMn51  ====================================================== */
/* ======================================================  CAN0_RAMn52  ====================================================== */
/* ======================================================  CAN0_RAMn53  ====================================================== */
/* ======================================================  CAN0_RAMn54  ====================================================== */
/* ======================================================  CAN0_RAMn55  ====================================================== */
/* ======================================================  CAN0_RAMn56  ====================================================== */
/* ======================================================  CAN0_RAMn57  ====================================================== */
/* ======================================================  CAN0_RAMn58  ====================================================== */
/* ======================================================  CAN0_RAMn59  ====================================================== */
/* ======================================================  CAN0_RAMn60  ====================================================== */
/* ======================================================  CAN0_RAMn61  ====================================================== */
/* ======================================================  CAN0_RAMn62  ====================================================== */
/* ======================================================  CAN0_RAMn63  ====================================================== */
/* ======================================================  CAN0_RAMn64  ====================================================== */
/* ======================================================  CAN0_RAMn65  ====================================================== */
/* ======================================================  CAN0_RAMn66  ====================================================== */
/* ======================================================  CAN0_RAMn67  ====================================================== */
/* ======================================================  CAN0_RAMn68  ====================================================== */
/* ======================================================  CAN0_RAMn69  ====================================================== */
/* ======================================================  CAN0_RAMn70  ====================================================== */
/* ======================================================  CAN0_RAMn71  ====================================================== */
/* ======================================================  CAN0_RAMn72  ====================================================== */
/* ======================================================  CAN0_RAMn73  ====================================================== */
/* ======================================================  CAN0_RAMn74  ====================================================== */
/* ======================================================  CAN0_RAMn75  ====================================================== */
/* ======================================================  CAN0_RAMn76  ====================================================== */
/* ======================================================  CAN0_RAMn77  ====================================================== */
/* ======================================================  CAN0_RAMn78  ====================================================== */
/* ======================================================  CAN0_RAMn79  ====================================================== */
/* ======================================================  CAN0_RAMn80  ====================================================== */
/* ======================================================  CAN0_RAMn81  ====================================================== */
/* ======================================================  CAN0_RAMn82  ====================================================== */
/* ======================================================  CAN0_RAMn83  ====================================================== */
/* ======================================================  CAN0_RAMn84  ====================================================== */
/* ======================================================  CAN0_RAMn85  ====================================================== */
/* ======================================================  CAN0_RAMn86  ====================================================== */
/* ======================================================  CAN0_RAMn87  ====================================================== */
/* ======================================================  CAN0_RAMn88  ====================================================== */
/* ======================================================  CAN0_RAMn89  ====================================================== */
/* ======================================================  CAN0_RAMn90  ====================================================== */
/* ======================================================  CAN0_RAMn91  ====================================================== */
/* ======================================================  CAN0_RAMn92  ====================================================== */
/* ======================================================  CAN0_RAMn93  ====================================================== */
/* ======================================================  CAN0_RAMn94  ====================================================== */
/* ======================================================  CAN0_RAMn95  ====================================================== */
/* ======================================================  CAN0_RAMn96  ====================================================== */
/* ======================================================  CAN0_RAMn97  ====================================================== */
/* ======================================================  CAN0_RAMn98  ====================================================== */
/* ======================================================  CAN0_RAMn99  ====================================================== */
/* =====================================================  CAN0_RAMn100  ====================================================== */
/* =====================================================  CAN0_RAMn101  ====================================================== */
/* =====================================================  CAN0_RAMn102  ====================================================== */
/* =====================================================  CAN0_RAMn103  ====================================================== */
/* =====================================================  CAN0_RAMn104  ====================================================== */
/* =====================================================  CAN0_RAMn105  ====================================================== */
/* =====================================================  CAN0_RAMn106  ====================================================== */
/* =====================================================  CAN0_RAMn107  ====================================================== */
/* =====================================================  CAN0_RAMn108  ====================================================== */
/* =====================================================  CAN0_RAMn109  ====================================================== */
/* =====================================================  CAN0_RAMn110  ====================================================== */
/* =====================================================  CAN0_RAMn111  ====================================================== */
/* =====================================================  CAN0_RAMn112  ====================================================== */
/* =====================================================  CAN0_RAMn113  ====================================================== */
/* =====================================================  CAN0_RAMn114  ====================================================== */
/* =====================================================  CAN0_RAMn115  ====================================================== */
/* =====================================================  CAN0_RAMn116  ====================================================== */
/* =====================================================  CAN0_RAMn117  ====================================================== */
/* =====================================================  CAN0_RAMn118  ====================================================== */
/* =====================================================  CAN0_RAMn119  ====================================================== */
/* =====================================================  CAN0_RAMn120  ====================================================== */
/* =====================================================  CAN0_RAMn121  ====================================================== */
/* =====================================================  CAN0_RAMn122  ====================================================== */
/* =====================================================  CAN0_RAMn123  ====================================================== */
/* =====================================================  CAN0_RAMn124  ====================================================== */
/* =====================================================  CAN0_RAMn125  ====================================================== */
/* =====================================================  CAN0_RAMn126  ====================================================== */
/* =====================================================  CAN0_RAMn127  ====================================================== */
/* ======================================================  CAN0_RXIMR0  ====================================================== */
/* ======================================================  CAN0_RXIMR1  ====================================================== */
/* ======================================================  CAN0_RXIMR2  ====================================================== */
/* ======================================================  CAN0_RXIMR3  ====================================================== */
/* ======================================================  CAN0_RXIMR4  ====================================================== */
/* ======================================================  CAN0_RXIMR5  ====================================================== */
/* ======================================================  CAN0_RXIMR6  ====================================================== */
/* ======================================================  CAN0_RXIMR7  ====================================================== */
/* ======================================================  CAN0_RXIMR8  ====================================================== */
/* ======================================================  CAN0_RXIMR9  ====================================================== */
/* =====================================================  CAN0_RXIMR10  ====================================================== */
/* =====================================================  CAN0_RXIMR11  ====================================================== */
/* =====================================================  CAN0_RXIMR12  ====================================================== */
/* =====================================================  CAN0_RXIMR13  ====================================================== */
/* =====================================================  CAN0_RXIMR14  ====================================================== */
/* =====================================================  CAN0_RXIMR15  ====================================================== */
/* =====================================================  CAN0_RXIMR16  ====================================================== */
/* =====================================================  CAN0_RXIMR17  ====================================================== */
/* =====================================================  CAN0_RXIMR18  ====================================================== */
/* =====================================================  CAN0_RXIMR19  ====================================================== */
/* =====================================================  CAN0_RXIMR20  ====================================================== */
/* =====================================================  CAN0_RXIMR21  ====================================================== */
/* =====================================================  CAN0_RXIMR22  ====================================================== */
/* =====================================================  CAN0_RXIMR23  ====================================================== */
/* =====================================================  CAN0_RXIMR24  ====================================================== */
/* =====================================================  CAN0_RXIMR25  ====================================================== */
/* =====================================================  CAN0_RXIMR26  ====================================================== */
/* =====================================================  CAN0_RXIMR27  ====================================================== */
/* =====================================================  CAN0_RXIMR28  ====================================================== */
/* =====================================================  CAN0_RXIMR29  ====================================================== */
/* =====================================================  CAN0_RXIMR30  ====================================================== */
/* =====================================================  CAN0_RXIMR31  ====================================================== */
/* =====================================================  CAN0_CTRL1_PN  ===================================================== */
/* =============================================  CAN0 CAN0_CTRL1_PN FCS [0..1]  ============================================= */
typedef enum {                                  /*!< CAN0_CTRL1_PN_FCS                                                         */
  CAN0_CTRL1_PN_FCS_00                 = 0,     /*!< 00 : Message ID filtering only                                            */
  CAN0_CTRL1_PN_FCS_01                 = 1,     /*!< 01 : Message ID filtering and payload filtering                           */
  CAN0_CTRL1_PN_FCS_10                 = 2,     /*!< 10 : Message ID filtering occurring a specified number of times.          */
  CAN0_CTRL1_PN_FCS_11                 = 3,     /*!< 11 : Message ID filtering and payload filtering a specified
                                                     number of times                                                           */
} CAN0_CTRL1_PN_FCS_Enum;

/* ============================================  CAN0 CAN0_CTRL1_PN IDFS [2..3]  ============================================= */
typedef enum {                                  /*!< CAN0_CTRL1_PN_IDFS                                                        */
  CAN0_CTRL1_PN_IDFS_00                = 0,     /*!< 00 : Match upon a ID contents against an exact target value               */
  CAN0_CTRL1_PN_IDFS_01                = 1,     /*!< 01 : Match upon a ID value greater than or equal to a specified
                                                     target value                                                              */
  CAN0_CTRL1_PN_IDFS_10                = 2,     /*!< 10 : Match upon a ID value smaller than or equal to a specified
                                                     target value                                                              */
  CAN0_CTRL1_PN_IDFS_11                = 3,     /*!< 11 : Match upon a ID value inside a range, greater than or equal
                                                     to a specified lower limit and smaller than or equal a
                                                     specified upper limit                                                     */
} CAN0_CTRL1_PN_IDFS_Enum;

/* ============================================  CAN0 CAN0_CTRL1_PN PLFS [4..5]  ============================================= */
typedef enum {                                  /*!< CAN0_CTRL1_PN_PLFS                                                        */
  CAN0_CTRL1_PN_PLFS_00                = 0,     /*!< 00 : Match upon a payload contents against an exact target value          */
  CAN0_CTRL1_PN_PLFS_01                = 1,     /*!< 01 : Match upon a payload value greater than or equal to a specified
                                                     target value                                                              */
  CAN0_CTRL1_PN_PLFS_10                = 2,     /*!< 10 : Match upon a payload value smaller than or equal to a specified
                                                     target value                                                              */
  CAN0_CTRL1_PN_PLFS_11                = 3,     /*!< 11 : Match upon a payload value inside a range, greater than
                                                     or equal to a specified lower limit and smaller than or
                                                     equal a specified upper limit                                             */
} CAN0_CTRL1_PN_PLFS_Enum;

/* ===========================================  CAN0 CAN0_CTRL1_PN NMATCH [8..15]  =========================================== */
typedef enum {                                  /*!< CAN0_CTRL1_PN_NMATCH                                                      */
  CAN0_CTRL1_PN_NMATCH_00000001        = 1,     /*!< 00000001 : Received message must match the predefined filtering
                                                     criteria for ID and/or PL once before generating a wake
                                                     up event.                                                                 */
  CAN0_CTRL1_PN_NMATCH_00000010        = 2,     /*!< 00000010 : Received message must match the predefined filtering
                                                     criteria for ID and/or PL twice before generating a wake
                                                     up event.                                                                 */
  CAN0_CTRL1_PN_NMATCH_11111111        = 255,   /*!< 11111111 : Received message must match the predefined filtering
                                                     criteria for ID and/or PL 255 times before generating a
                                                     wake up event.                                                            */
} CAN0_CTRL1_PN_NMATCH_Enum;

/* =========================================  CAN0 CAN0_CTRL1_PN WUMF_MSK [16..16]  ========================================== */
typedef enum {                                  /*!< CAN0_CTRL1_PN_WUMF_MSK                                                    */
  CAN0_CTRL1_PN_WUMF_MSK_0             = 0,     /*!< 0 : Wake up match event is disabled                                       */
  CAN0_CTRL1_PN_WUMF_MSK_1             = 1,     /*!< 1 : Wake up match event is enabled                                        */
} CAN0_CTRL1_PN_WUMF_MSK_Enum;

/* =========================================  CAN0 CAN0_CTRL1_PN WTOF_MSK [17..17]  ========================================== */
typedef enum {                                  /*!< CAN0_CTRL1_PN_WTOF_MSK                                                    */
  CAN0_CTRL1_PN_WTOF_MSK_0             = 0,     /*!< 0 : Timeout wake up event is disabled                                     */
  CAN0_CTRL1_PN_WTOF_MSK_1             = 1,     /*!< 1 : Timeout wake up event is enabled                                      */
} CAN0_CTRL1_PN_WTOF_MSK_Enum;

/* =====================================================  CAN0_CTRL2_PN  ===================================================== */
/* ======================================================  CAN0_WU_MTC  ====================================================== */
/* ============================================  CAN0 CAN0_WU_MTC WUMF [16..16]  ============================================= */
typedef enum {                                  /*!< CAN0_WU_MTC_WUMF                                                          */
  CAN0_WU_MTC_WUMF_0                   = 0,     /*!< 0 : No wake up by match event detected                                    */
  CAN0_WU_MTC_WUMF_1                   = 1,     /*!< 1 : Wake up by match event detected                                       */
} CAN0_WU_MTC_WUMF_Enum;

/* ============================================  CAN0 CAN0_WU_MTC WTOF [17..17]  ============================================= */
typedef enum {                                  /*!< CAN0_WU_MTC_WTOF                                                          */
  CAN0_WU_MTC_WTOF_0                   = 0,     /*!< 0 : No wake up by timeout event detected                                  */
  CAN0_WU_MTC_WTOF_1                   = 1,     /*!< 1 : Wake up by timeout event detected                                     */
} CAN0_WU_MTC_WTOF_Enum;

/* =====================================================  CAN0_FLT_ID1  ====================================================== */
/* ==========================================  CAN0 CAN0_FLT_ID1 FLT_RTR [29..29]  =========================================== */
typedef enum {                                  /*!< CAN0_FLT_ID1_FLT_RTR                                                      */
  CAN0_FLT_ID1_FLT_RTR_0               = 0,     /*!< 0 : Reject remote frame (accept data frame)                               */
  CAN0_FLT_ID1_FLT_RTR_1               = 1,     /*!< 1 : Accept remote frame                                                   */
} CAN0_FLT_ID1_FLT_RTR_Enum;

/* ==========================================  CAN0 CAN0_FLT_ID1 FLT_IDE [30..30]  =========================================== */
typedef enum {                                  /*!< CAN0_FLT_ID1_FLT_IDE                                                      */
  CAN0_FLT_ID1_FLT_IDE_0               = 0,     /*!< 0 : Accept standard frame format                                          */
  CAN0_FLT_ID1_FLT_IDE_1               = 1,     /*!< 1 : Accept extended frame format                                          */
} CAN0_FLT_ID1_FLT_IDE_Enum;

/* =====================================================  CAN0_FLT_DLC  ====================================================== */
/* ======================================================  CAN0_PL1_LO  ====================================================== */
/* ======================================================  CAN0_PL1_HI  ====================================================== */
/* ==================================================  CAN0_FLT_ID2_IDMASK  ================================================== */
/* =======================================  CAN0 CAN0_FLT_ID2_IDMASK RTR_MSK [29..29]  ======================================= */
typedef enum {                                  /*!< CAN0_FLT_ID2_IDMASK_RTR_MSK                                               */
  CAN0_FLT_ID2_IDMASK_RTR_MSK_0        = 0,     /*!< 0 : The corresponding bit in the filter is 'dont care'                    */
  CAN0_FLT_ID2_IDMASK_RTR_MSK_1        = 1,     /*!< 1 : The corresponding bit in the filter is checked                        */
} CAN0_FLT_ID2_IDMASK_RTR_MSK_Enum;

/* =======================================  CAN0 CAN0_FLT_ID2_IDMASK IDE_MSK [30..30]  ======================================= */
typedef enum {                                  /*!< CAN0_FLT_ID2_IDMASK_IDE_MSK                                               */
  CAN0_FLT_ID2_IDMASK_IDE_MSK_0        = 0,     /*!< 0 : The corresponding bit in the filter is 'dont care'                    */
  CAN0_FLT_ID2_IDMASK_IDE_MSK_1        = 1,     /*!< 1 : The corresponding bit in the filter is checked                        */
} CAN0_FLT_ID2_IDMASK_IDE_MSK_Enum;

/* ==================================================  CAN0_PL2_PLMASK_LO  =================================================== */
/* ==================================================  CAN0_PL2_PLMASK_HI  =================================================== */
/* =====================================================  CAN0_WMB0_CS  ====================================================== */
/* ============================================  CAN0 CAN0_WMB0_CS RTR [20..20]  ============================================= */
typedef enum {                                  /*!< CAN0_WMB0_CS_RTR                                                          */
  CAN0_WMB0_CS_RTR_0                   = 0,     /*!< 0 : Frame is data one (not remote)                                        */
  CAN0_WMB0_CS_RTR_1                   = 1,     /*!< 1 : Frame is a remote one                                                 */
} CAN0_WMB0_CS_RTR_Enum;

/* ============================================  CAN0 CAN0_WMB0_CS IDE [21..21]  ============================================= */
typedef enum {                                  /*!< CAN0_WMB0_CS_IDE                                                          */
  CAN0_WMB0_CS_IDE_0                   = 0,     /*!< 0 : Frame format is standard                                              */
  CAN0_WMB0_CS_IDE_1                   = 1,     /*!< 1 : Frame format is extended                                              */
} CAN0_WMB0_CS_IDE_Enum;

/* =====================================================  CAN0_WMB0_ID  ====================================================== */
/* =====================================================  CAN0_WMB0_D03  ===================================================== */
/* =====================================================  CAN0_WMB0_D47  ===================================================== */
/* =====================================================  CAN0_WMB1_CS  ====================================================== */
/* ============================================  CAN0 CAN0_WMB1_CS RTR [20..20]  ============================================= */
typedef enum {                                  /*!< CAN0_WMB1_CS_RTR                                                          */
  CAN0_WMB1_CS_RTR_0                   = 0,     /*!< 0 : Frame is data one (not remote)                                        */
  CAN0_WMB1_CS_RTR_1                   = 1,     /*!< 1 : Frame is a remote one                                                 */
} CAN0_WMB1_CS_RTR_Enum;

/* ============================================  CAN0 CAN0_WMB1_CS IDE [21..21]  ============================================= */
typedef enum {                                  /*!< CAN0_WMB1_CS_IDE                                                          */
  CAN0_WMB1_CS_IDE_0                   = 0,     /*!< 0 : Frame format is standard                                              */
  CAN0_WMB1_CS_IDE_1                   = 1,     /*!< 1 : Frame format is extended                                              */
} CAN0_WMB1_CS_IDE_Enum;

/* =====================================================  CAN0_WMB1_ID  ====================================================== */
/* =====================================================  CAN0_WMB1_D03  ===================================================== */
/* =====================================================  CAN0_WMB1_D47  ===================================================== */
/* =====================================================  CAN0_WMB2_CS  ====================================================== */
/* ============================================  CAN0 CAN0_WMB2_CS RTR [20..20]  ============================================= */
typedef enum {                                  /*!< CAN0_WMB2_CS_RTR                                                          */
  CAN0_WMB2_CS_RTR_0                   = 0,     /*!< 0 : Frame is data one (not remote)                                        */
  CAN0_WMB2_CS_RTR_1                   = 1,     /*!< 1 : Frame is a remote one                                                 */
} CAN0_WMB2_CS_RTR_Enum;

/* ============================================  CAN0 CAN0_WMB2_CS IDE [21..21]  ============================================= */
typedef enum {                                  /*!< CAN0_WMB2_CS_IDE                                                          */
  CAN0_WMB2_CS_IDE_0                   = 0,     /*!< 0 : Frame format is standard                                              */
  CAN0_WMB2_CS_IDE_1                   = 1,     /*!< 1 : Frame format is extended                                              */
} CAN0_WMB2_CS_IDE_Enum;

/* =====================================================  CAN0_WMB2_ID  ====================================================== */
/* =====================================================  CAN0_WMB2_D03  ===================================================== */
/* =====================================================  CAN0_WMB2_D47  ===================================================== */
/* =====================================================  CAN0_WMB3_CS  ====================================================== */
/* ============================================  CAN0 CAN0_WMB3_CS RTR [20..20]  ============================================= */
typedef enum {                                  /*!< CAN0_WMB3_CS_RTR                                                          */
  CAN0_WMB3_CS_RTR_0                   = 0,     /*!< 0 : Frame is data one (not remote)                                        */
  CAN0_WMB3_CS_RTR_1                   = 1,     /*!< 1 : Frame is a remote one                                                 */
} CAN0_WMB3_CS_RTR_Enum;

/* ============================================  CAN0 CAN0_WMB3_CS IDE [21..21]  ============================================= */
typedef enum {                                  /*!< CAN0_WMB3_CS_IDE                                                          */
  CAN0_WMB3_CS_IDE_0                   = 0,     /*!< 0 : Frame format is standard                                              */
  CAN0_WMB3_CS_IDE_1                   = 1,     /*!< 1 : Frame format is extended                                              */
} CAN0_WMB3_CS_IDE_Enum;

/* =====================================================  CAN0_WMB3_ID  ====================================================== */
/* =====================================================  CAN0_WMB3_D03  ===================================================== */
/* =====================================================  CAN0_WMB3_D47  ===================================================== */
/* ======================================================  CAN0_FDCTRL  ====================================================== */
/* ===========================================  CAN0 CAN0_FDCTRL TDCFAIL [14..14]  =========================================== */
typedef enum {                                  /*!< CAN0_FDCTRL_TDCFAIL                                                       */
  CAN0_FDCTRL_TDCFAIL_0                = 0,     /*!< 0 : Measured loop delay is in range.                                      */
  CAN0_FDCTRL_TDCFAIL_1                = 1,     /*!< 1 : Measured loop delay is out of range.                                  */
} CAN0_FDCTRL_TDCFAIL_Enum;

/* ============================================  CAN0 CAN0_FDCTRL TDCEN [15..15]  ============================================ */
typedef enum {                                  /*!< CAN0_FDCTRL_TDCEN                                                         */
  CAN0_FDCTRL_TDCEN_0                  = 0,     /*!< 0 : TDC is disabled                                                       */
  CAN0_FDCTRL_TDCEN_1                  = 1,     /*!< 1 : TDC is enabled                                                        */
} CAN0_FDCTRL_TDCEN_Enum;

/* ===========================================  CAN0 CAN0_FDCTRL MBDSR0 [16..17]  ============================================ */
typedef enum {                                  /*!< CAN0_FDCTRL_MBDSR0                                                        */
  CAN0_FDCTRL_MBDSR0_00                = 0,     /*!< 00 : Selects 8 bytes per Message Buffer.                                  */
  CAN0_FDCTRL_MBDSR0_01                = 1,     /*!< 01 : Selects 16 bytes per Message Buffer.                                 */
  CAN0_FDCTRL_MBDSR0_10                = 2,     /*!< 10 : Selects 32 bytes per Message Buffer.                                 */
  CAN0_FDCTRL_MBDSR0_11                = 3,     /*!< 11 : Selects 64 bytes per Message Buffer.                                 */
} CAN0_FDCTRL_MBDSR0_Enum;

/* ===========================================  CAN0 CAN0_FDCTRL FDRATE [31..31]  ============================================ */
typedef enum {                                  /*!< CAN0_FDCTRL_FDRATE                                                        */
  CAN0_FDCTRL_FDRATE_0                 = 0,     /*!< 0 : Transmit a frame in nominal rate. The BRS bit in the Tx
                                                     MB has no effect.                                                         */
  CAN0_FDCTRL_FDRATE_1                 = 1,     /*!< 1 : Transmit a frame with bit rate switching if the BRS bit
                                                     in the Tx MB is recessive.                                                */
} CAN0_FDCTRL_FDRATE_Enum;

/* ======================================================  CAN0_FDCBT  ======================================================= */
/* ======================================================  CAN0_FDCRC  ======================================================= */


/* =========================================================================================================================== */
/* ================                                          LPSPI0                                           ================ */
/* =========================================================================================================================== */

/* =====================================================  LPSPI0_VERID  ====================================================== */
/* ==========================================  LPSPI0 LPSPI0_VERID FEATURE [0..15]  ========================================== */
typedef enum {                                  /*!< LPSPI0_VERID_FEATURE                                                      */
  LPSPI0_VERID_FEATURE_0000000000000100 = 4,    /*!< 0000000000000100 : Standard feature set supporting 32-bit shift
                                                     register.                                                                 */
} LPSPI0_VERID_FEATURE_Enum;

/* =====================================================  LPSPI0_PARAM  ====================================================== */
/* =======================================================  LPSPI0_CR  ======================================================= */
/* ==============================================  LPSPI0 LPSPI0_CR MEN [0..0]  ============================================== */
typedef enum {                                  /*!< LPSPI0_CR_MEN                                                             */
  LPSPI0_CR_MEN_0                      = 0,     /*!< 0 : Module is disabled.                                                   */
  LPSPI0_CR_MEN_1                      = 1,     /*!< 1 : Module is enabled.                                                    */
} LPSPI0_CR_MEN_Enum;

/* ==============================================  LPSPI0 LPSPI0_CR RST [1..1]  ============================================== */
typedef enum {                                  /*!< LPSPI0_CR_RST                                                             */
  LPSPI0_CR_RST_0                      = 0,     /*!< 0 : Master logic is not reset.                                            */
  LPSPI0_CR_RST_1                      = 1,     /*!< 1 : Master logic is reset.                                                */
} LPSPI0_CR_RST_Enum;

/* =============================================  LPSPI0 LPSPI0_CR DOZEN [2..2]  ============================================= */
typedef enum {                                  /*!< LPSPI0_CR_DOZEN                                                           */
  LPSPI0_CR_DOZEN_0                    = 0,     /*!< 0 : Module is enabled in Doze mode.                                       */
  LPSPI0_CR_DOZEN_1                    = 1,     /*!< 1 : Module is disabled in Doze mode.                                      */
} LPSPI0_CR_DOZEN_Enum;

/* =============================================  LPSPI0 LPSPI0_CR DBGEN [3..3]  ============================================= */
typedef enum {                                  /*!< LPSPI0_CR_DBGEN                                                           */
  LPSPI0_CR_DBGEN_0                    = 0,     /*!< 0 : Module is disabled in debug mode.                                     */
  LPSPI0_CR_DBGEN_1                    = 1,     /*!< 1 : Module is enabled in debug mode.                                      */
} LPSPI0_CR_DBGEN_Enum;

/* ==============================================  LPSPI0 LPSPI0_CR RTF [8..8]  ============================================== */
typedef enum {                                  /*!< LPSPI0_CR_RTF                                                             */
  LPSPI0_CR_RTF_0                      = 0,     /*!< 0 : No effect.                                                            */
  LPSPI0_CR_RTF_1                      = 1,     /*!< 1 : Transmit FIFO is reset.                                               */
} LPSPI0_CR_RTF_Enum;

/* ==============================================  LPSPI0 LPSPI0_CR RRF [9..9]  ============================================== */
typedef enum {                                  /*!< LPSPI0_CR_RRF                                                             */
  LPSPI0_CR_RRF_0                      = 0,     /*!< 0 : No effect.                                                            */
  LPSPI0_CR_RRF_1                      = 1,     /*!< 1 : Receive FIFO is reset.                                                */
} LPSPI0_CR_RRF_Enum;

/* =======================================================  LPSPI0_SR  ======================================================= */
/* ==============================================  LPSPI0 LPSPI0_SR TDF [0..0]  ============================================== */
typedef enum {                                  /*!< LPSPI0_SR_TDF                                                             */
  LPSPI0_SR_TDF_0                      = 0,     /*!< 0 : Transmit data not requested.                                          */
  LPSPI0_SR_TDF_1                      = 1,     /*!< 1 : Transmit data is requested.                                           */
} LPSPI0_SR_TDF_Enum;

/* ==============================================  LPSPI0 LPSPI0_SR RDF [1..1]  ============================================== */
typedef enum {                                  /*!< LPSPI0_SR_RDF                                                             */
  LPSPI0_SR_RDF_0                      = 0,     /*!< 0 : Receive Data is not ready.                                            */
  LPSPI0_SR_RDF_1                      = 1,     /*!< 1 : Receive data is ready.                                                */
} LPSPI0_SR_RDF_Enum;

/* ==============================================  LPSPI0 LPSPI0_SR WCF [8..8]  ============================================== */
typedef enum {                                  /*!< LPSPI0_SR_WCF                                                             */
  LPSPI0_SR_WCF_0                      = 0,     /*!< 0 : Transfer word not completed.                                          */
  LPSPI0_SR_WCF_1                      = 1,     /*!< 1 : Transfer word completed.                                              */
} LPSPI0_SR_WCF_Enum;

/* ==============================================  LPSPI0 LPSPI0_SR FCF [9..9]  ============================================== */
typedef enum {                                  /*!< LPSPI0_SR_FCF                                                             */
  LPSPI0_SR_FCF_0                      = 0,     /*!< 0 : Frame transfer has not completed.                                     */
  LPSPI0_SR_FCF_1                      = 1,     /*!< 1 : Frame transfer has completed.                                         */
} LPSPI0_SR_FCF_Enum;

/* =============================================  LPSPI0 LPSPI0_SR TCF [10..10]  ============================================= */
typedef enum {                                  /*!< LPSPI0_SR_TCF                                                             */
  LPSPI0_SR_TCF_0                      = 0,     /*!< 0 : All transfers have not completed.                                     */
  LPSPI0_SR_TCF_1                      = 1,     /*!< 1 : All transfers have completed.                                         */
} LPSPI0_SR_TCF_Enum;

/* =============================================  LPSPI0 LPSPI0_SR TEF [11..11]  ============================================= */
typedef enum {                                  /*!< LPSPI0_SR_TEF                                                             */
  LPSPI0_SR_TEF_0                      = 0,     /*!< 0 : Transmit FIFO underrun has not occurred.                              */
  LPSPI0_SR_TEF_1                      = 1,     /*!< 1 : Transmit FIFO underrun has occurred                                   */
} LPSPI0_SR_TEF_Enum;

/* =============================================  LPSPI0 LPSPI0_SR REF [12..12]  ============================================= */
typedef enum {                                  /*!< LPSPI0_SR_REF                                                             */
  LPSPI0_SR_REF_0                      = 0,     /*!< 0 : Receive FIFO has not overflowed.                                      */
  LPSPI0_SR_REF_1                      = 1,     /*!< 1 : Receive FIFO has overflowed.                                          */
} LPSPI0_SR_REF_Enum;

/* =============================================  LPSPI0 LPSPI0_SR DMF [13..13]  ============================================= */
typedef enum {                                  /*!< LPSPI0_SR_DMF                                                             */
  LPSPI0_SR_DMF_0                      = 0,     /*!< 0 : Have not received matching data.                                      */
  LPSPI0_SR_DMF_1                      = 1,     /*!< 1 : Have received matching data.                                          */
} LPSPI0_SR_DMF_Enum;

/* =============================================  LPSPI0 LPSPI0_SR MBF [24..24]  ============================================= */
typedef enum {                                  /*!< LPSPI0_SR_MBF                                                             */
  LPSPI0_SR_MBF_0                      = 0,     /*!< 0 : LPSPI is idle.                                                        */
  LPSPI0_SR_MBF_1                      = 1,     /*!< 1 : LPSPI is busy.                                                        */
} LPSPI0_SR_MBF_Enum;

/* ======================================================  LPSPI0_IER  ======================================================= */
/* =============================================  LPSPI0 LPSPI0_IER TDIE [0..0]  ============================================= */
typedef enum {                                  /*!< LPSPI0_IER_TDIE                                                           */
  LPSPI0_IER_TDIE_0                    = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPSPI0_IER_TDIE_1                    = 1,     /*!< 1 : Interrupt enabled                                                     */
} LPSPI0_IER_TDIE_Enum;

/* =============================================  LPSPI0 LPSPI0_IER RDIE [1..1]  ============================================= */
typedef enum {                                  /*!< LPSPI0_IER_RDIE                                                           */
  LPSPI0_IER_RDIE_0                    = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPSPI0_IER_RDIE_1                    = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPSPI0_IER_RDIE_Enum;

/* =============================================  LPSPI0 LPSPI0_IER WCIE [8..8]  ============================================= */
typedef enum {                                  /*!< LPSPI0_IER_WCIE                                                           */
  LPSPI0_IER_WCIE_0                    = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPSPI0_IER_WCIE_1                    = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPSPI0_IER_WCIE_Enum;

/* =============================================  LPSPI0 LPSPI0_IER FCIE [9..9]  ============================================= */
typedef enum {                                  /*!< LPSPI0_IER_FCIE                                                           */
  LPSPI0_IER_FCIE_0                    = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPSPI0_IER_FCIE_1                    = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPSPI0_IER_FCIE_Enum;

/* ============================================  LPSPI0 LPSPI0_IER TCIE [10..10]  ============================================ */
typedef enum {                                  /*!< LPSPI0_IER_TCIE                                                           */
  LPSPI0_IER_TCIE_0                    = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPSPI0_IER_TCIE_1                    = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPSPI0_IER_TCIE_Enum;

/* ============================================  LPSPI0 LPSPI0_IER TEIE [11..11]  ============================================ */
typedef enum {                                  /*!< LPSPI0_IER_TEIE                                                           */
  LPSPI0_IER_TEIE_0                    = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPSPI0_IER_TEIE_1                    = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPSPI0_IER_TEIE_Enum;

/* ============================================  LPSPI0 LPSPI0_IER REIE [12..12]  ============================================ */
typedef enum {                                  /*!< LPSPI0_IER_REIE                                                           */
  LPSPI0_IER_REIE_0                    = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPSPI0_IER_REIE_1                    = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPSPI0_IER_REIE_Enum;

/* ============================================  LPSPI0 LPSPI0_IER DMIE [13..13]  ============================================ */
typedef enum {                                  /*!< LPSPI0_IER_DMIE                                                           */
  LPSPI0_IER_DMIE_0                    = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPSPI0_IER_DMIE_1                    = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPSPI0_IER_DMIE_Enum;

/* ======================================================  LPSPI0_DER  ======================================================= */
/* =============================================  LPSPI0 LPSPI0_DER TDDE [0..0]  ============================================= */
typedef enum {                                  /*!< LPSPI0_DER_TDDE                                                           */
  LPSPI0_DER_TDDE_0                    = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPSPI0_DER_TDDE_1                    = 1,     /*!< 1 : DMA request enabled                                                   */
} LPSPI0_DER_TDDE_Enum;

/* =============================================  LPSPI0 LPSPI0_DER RDDE [1..1]  ============================================= */
typedef enum {                                  /*!< LPSPI0_DER_RDDE                                                           */
  LPSPI0_DER_RDDE_0                    = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPSPI0_DER_RDDE_1                    = 1,     /*!< 1 : DMA request enabled.                                                  */
} LPSPI0_DER_RDDE_Enum;

/* =====================================================  LPSPI0_CFGR0  ====================================================== */
/* ============================================  LPSPI0 LPSPI0_CFGR0 HREN [0..0]  ============================================ */
typedef enum {                                  /*!< LPSPI0_CFGR0_HREN                                                         */
  LPSPI0_CFGR0_HREN_0                  = 0,     /*!< 0 : Host request is disabled.                                             */
  LPSPI0_CFGR0_HREN_1                  = 1,     /*!< 1 : Host request is enabled.                                              */
} LPSPI0_CFGR0_HREN_Enum;

/* ===========================================  LPSPI0 LPSPI0_CFGR0 HRPOL [1..1]  ============================================ */
typedef enum {                                  /*!< LPSPI0_CFGR0_HRPOL                                                        */
  LPSPI0_CFGR0_HRPOL_0                 = 0,     /*!< 0 : Active low.                                                           */
  LPSPI0_CFGR0_HRPOL_1                 = 1,     /*!< 1 : Active high.                                                          */
} LPSPI0_CFGR0_HRPOL_Enum;

/* ===========================================  LPSPI0 LPSPI0_CFGR0 HRSEL [2..2]  ============================================ */
typedef enum {                                  /*!< LPSPI0_CFGR0_HRSEL                                                        */
  LPSPI0_CFGR0_HRSEL_0                 = 0,     /*!< 0 : Host request input is pin LPSPI_HREQ.                                 */
  LPSPI0_CFGR0_HRSEL_1                 = 1,     /*!< 1 : Host request input is input trigger.                                  */
} LPSPI0_CFGR0_HRSEL_Enum;

/* ==========================================  LPSPI0 LPSPI0_CFGR0 CIRFIFO [8..8]  =========================================== */
typedef enum {                                  /*!< LPSPI0_CFGR0_CIRFIFO                                                      */
  LPSPI0_CFGR0_CIRFIFO_0               = 0,     /*!< 0 : Circular FIFO is disabled.                                            */
  LPSPI0_CFGR0_CIRFIFO_1               = 1,     /*!< 1 : Circular FIFO is enabled.                                             */
} LPSPI0_CFGR0_CIRFIFO_Enum;

/* ============================================  LPSPI0 LPSPI0_CFGR0 RDMO [9..9]  ============================================ */
typedef enum {                                  /*!< LPSPI0_CFGR0_RDMO                                                         */
  LPSPI0_CFGR0_RDMO_0                  = 0,     /*!< 0 : Received data is stored in the receive FIFO as normal.                */
  LPSPI0_CFGR0_RDMO_1                  = 1,     /*!< 1 : Received data is discarded unless the DMF is set.                     */
} LPSPI0_CFGR0_RDMO_Enum;

/* =====================================================  LPSPI0_CFGR1  ====================================================== */
/* ===========================================  LPSPI0 LPSPI0_CFGR1 MASTER [0..0]  =========================================== */
typedef enum {                                  /*!< LPSPI0_CFGR1_MASTER                                                       */
  LPSPI0_CFGR1_MASTER_0                = 0,     /*!< 0 : Slave mode.                                                           */
  LPSPI0_CFGR1_MASTER_1                = 1,     /*!< 1 : Master mode.                                                          */
} LPSPI0_CFGR1_MASTER_Enum;

/* ===========================================  LPSPI0 LPSPI0_CFGR1 SAMPLE [1..1]  =========================================== */
typedef enum {                                  /*!< LPSPI0_CFGR1_SAMPLE                                                       */
  LPSPI0_CFGR1_SAMPLE_0                = 0,     /*!< 0 : Input data sampled on SCK edge.                                       */
  LPSPI0_CFGR1_SAMPLE_1                = 1,     /*!< 1 : Input data sampled on delayed SCK edge.                               */
} LPSPI0_CFGR1_SAMPLE_Enum;

/* ==========================================  LPSPI0 LPSPI0_CFGR1 AUTOPCS [2..2]  =========================================== */
typedef enum {                                  /*!< LPSPI0_CFGR1_AUTOPCS                                                      */
  LPSPI0_CFGR1_AUTOPCS_0               = 0,     /*!< 0 : Automatic PCS generation disabled.                                    */
  LPSPI0_CFGR1_AUTOPCS_1               = 1,     /*!< 1 : Automatic PCS generation enabled.                                     */
} LPSPI0_CFGR1_AUTOPCS_Enum;

/* ==========================================  LPSPI0 LPSPI0_CFGR1 NOSTALL [3..3]  =========================================== */
typedef enum {                                  /*!< LPSPI0_CFGR1_NOSTALL                                                      */
  LPSPI0_CFGR1_NOSTALL_0               = 0,     /*!< 0 : Transfers will stall when transmit FIFO is empty or receive
                                                     FIFO is full.                                                             */
  LPSPI0_CFGR1_NOSTALL_1               = 1,     /*!< 1 : Transfers will not stall, allowing transmit FIFO underrun
                                                     or receive FIFO overrun to occur.                                         */
} LPSPI0_CFGR1_NOSTALL_Enum;

/* ==========================================  LPSPI0 LPSPI0_CFGR1 PCSPOL [8..11]  =========================================== */
typedef enum {                                  /*!< LPSPI0_CFGR1_PCSPOL                                                       */
  LPSPI0_CFGR1_PCSPOL_0000             = 0,     /*!< 0000 : The PCSx is active low.                                            */
  LPSPI0_CFGR1_PCSPOL_0001             = 1,     /*!< 0001 : The PCSx is active high.                                           */
} LPSPI0_CFGR1_PCSPOL_Enum;

/* ==========================================  LPSPI0 LPSPI0_CFGR1 MATCFG [16..18]  ========================================== */
typedef enum {                                  /*!< LPSPI0_CFGR1_MATCFG                                                       */
  LPSPI0_CFGR1_MATCFG_000              = 0,     /*!< 000 : Match is disabled.                                                  */
  LPSPI0_CFGR1_MATCFG_010              = 2,     /*!< 010 : 010b - Match is enabled, if 1st data word equals MATCH0
                                                     OR MATCH1, i.e., (1st data word = MATCH0 + MATCH1)                        */
  LPSPI0_CFGR1_MATCFG_011              = 3,     /*!< 011 : 011b - Match is enabled, if any data word equals MATCH0
                                                     OR MATCH1, i.e., (any data word = MATCH0 + MATCH1)                        */
  LPSPI0_CFGR1_MATCFG_100              = 4,     /*!< 100 : 100b - Match is enabled, if 1st data word equals MATCH0
                                                     AND 2nd data word equals MATCH1, i.e., [(1st data word
                                                     = MATCH0) * (2nd data word = MATCH1)]                                     */
  LPSPI0_CFGR1_MATCFG_101              = 5,     /*!< 101 : 101b - Match is enabled, if any data word equals MATCH0
                                                     AND the next data word equals MATCH1, i.e., [(any data
                                                     word = MATCH0) * (next data word = MATCH1)]                               */
  LPSPI0_CFGR1_MATCFG_110              = 6,     /*!< 110 : 110b - Match is enabled, if (1st data word AND MATCH1)
                                                     equals (MATCH0 AND MATCH1), i.e., [(1st data word * MATCH1)
                                                     = (MATCH0 * MATCH1)]                                                      */
  LPSPI0_CFGR1_MATCFG_111              = 7,     /*!< 111 : 111b - Match is enabled, if (any data word AND MATCH1)
                                                     equals (MATCH0 AND MATCH1), i.e., [(any data word * MATCH1)
                                                     = (MATCH0 * MATCH1)]                                                      */
} LPSPI0_CFGR1_MATCFG_Enum;

/* ==========================================  LPSPI0 LPSPI0_CFGR1 PINCFG [24..25]  ========================================== */
typedef enum {                                  /*!< LPSPI0_CFGR1_PINCFG                                                       */
  LPSPI0_CFGR1_PINCFG_00               = 0,     /*!< 00 : SIN is used for input data and SOUT for output data.                 */
  LPSPI0_CFGR1_PINCFG_01               = 1,     /*!< 01 : SIN is used for both input and output data.                          */
  LPSPI0_CFGR1_PINCFG_10               = 2,     /*!< 10 : SOUT is used for both input and output data.                         */
  LPSPI0_CFGR1_PINCFG_11               = 3,     /*!< 11 : SOUT is used for input data and SIN for output data.                 */
} LPSPI0_CFGR1_PINCFG_Enum;

/* ==========================================  LPSPI0 LPSPI0_CFGR1 OUTCFG [26..26]  ========================================== */
typedef enum {                                  /*!< LPSPI0_CFGR1_OUTCFG                                                       */
  LPSPI0_CFGR1_OUTCFG_0                = 0,     /*!< 0 : Output data retains last value when chip select is negated.           */
  LPSPI0_CFGR1_OUTCFG_1                = 1,     /*!< 1 : Output data is tristated when chip select is negated.                 */
} LPSPI0_CFGR1_OUTCFG_Enum;

/* ==========================================  LPSPI0 LPSPI0_CFGR1 PCSCFG [27..27]  ========================================== */
typedef enum {                                  /*!< LPSPI0_CFGR1_PCSCFG                                                       */
  LPSPI0_CFGR1_PCSCFG_0                = 0,     /*!< 0 : PCS[3:2] are enabled.                                                 */
  LPSPI0_CFGR1_PCSCFG_1                = 1,     /*!< 1 : PCS[3:2] are disabled.                                                */
} LPSPI0_CFGR1_PCSCFG_Enum;

/* ======================================================  LPSPI0_DMR0  ====================================================== */
/* ======================================================  LPSPI0_DMR1  ====================================================== */
/* ======================================================  LPSPI0_CCR  ======================================================= */
/* ======================================================  LPSPI0_FCR  ======================================================= */
/* ======================================================  LPSPI0_FSR  ======================================================= */
/* ======================================================  LPSPI0_TCR  ======================================================= */
/* ===========================================  LPSPI0 LPSPI0_TCR WIDTH [16..17]  ============================================ */
typedef enum {                                  /*!< LPSPI0_TCR_WIDTH                                                          */
  LPSPI0_TCR_WIDTH_00                  = 0,     /*!< 00 : Single bit transfer.                                                 */
  LPSPI0_TCR_WIDTH_01                  = 1,     /*!< 01 : Two bit transfer.                                                    */
  LPSPI0_TCR_WIDTH_10                  = 2,     /*!< 10 : Four bit transfer.                                                   */
} LPSPI0_TCR_WIDTH_Enum;

/* ===========================================  LPSPI0 LPSPI0_TCR TXMSK [18..18]  ============================================ */
typedef enum {                                  /*!< LPSPI0_TCR_TXMSK                                                          */
  LPSPI0_TCR_TXMSK_0                   = 0,     /*!< 0 : Normal transfer.                                                      */
  LPSPI0_TCR_TXMSK_1                   = 1,     /*!< 1 : Mask transmit data.                                                   */
} LPSPI0_TCR_TXMSK_Enum;

/* ===========================================  LPSPI0 LPSPI0_TCR RXMSK [19..19]  ============================================ */
typedef enum {                                  /*!< LPSPI0_TCR_RXMSK                                                          */
  LPSPI0_TCR_RXMSK_0                   = 0,     /*!< 0 : Normal transfer.                                                      */
  LPSPI0_TCR_RXMSK_1                   = 1,     /*!< 1 : Receive data is masked.                                               */
} LPSPI0_TCR_RXMSK_Enum;

/* ===========================================  LPSPI0 LPSPI0_TCR CONTC [20..20]  ============================================ */
typedef enum {                                  /*!< LPSPI0_TCR_CONTC                                                          */
  LPSPI0_TCR_CONTC_0                   = 0,     /*!< 0 : Command word for start of new transfer.                               */
  LPSPI0_TCR_CONTC_1                   = 1,     /*!< 1 : Command word for continuing transfer.                                 */
} LPSPI0_TCR_CONTC_Enum;

/* ============================================  LPSPI0 LPSPI0_TCR CONT [21..21]  ============================================ */
typedef enum {                                  /*!< LPSPI0_TCR_CONT                                                           */
  LPSPI0_TCR_CONT_0                    = 0,     /*!< 0 : Continuous transfer disabled.                                         */
  LPSPI0_TCR_CONT_1                    = 1,     /*!< 1 : Continuous transfer enabled.                                          */
} LPSPI0_TCR_CONT_Enum;

/* ============================================  LPSPI0 LPSPI0_TCR BYSW [22..22]  ============================================ */
typedef enum {                                  /*!< LPSPI0_TCR_BYSW                                                           */
  LPSPI0_TCR_BYSW_0                    = 0,     /*!< 0 : Byte swap disabled.                                                   */
  LPSPI0_TCR_BYSW_1                    = 1,     /*!< 1 : Byte swap enabled.                                                    */
} LPSPI0_TCR_BYSW_Enum;

/* ============================================  LPSPI0 LPSPI0_TCR LSBF [23..23]  ============================================ */
typedef enum {                                  /*!< LPSPI0_TCR_LSBF                                                           */
  LPSPI0_TCR_LSBF_0                    = 0,     /*!< 0 : Data is transferred MSB first.                                        */
  LPSPI0_TCR_LSBF_1                    = 1,     /*!< 1 : Data is transferred LSB first.                                        */
} LPSPI0_TCR_LSBF_Enum;

/* ============================================  LPSPI0 LPSPI0_TCR PCS [24..25]  ============================================= */
typedef enum {                                  /*!< LPSPI0_TCR_PCS                                                            */
  LPSPI0_TCR_PCS_00                    = 0,     /*!< 00 : Transfer using LPSPI_PCS[0]                                          */
  LPSPI0_TCR_PCS_01                    = 1,     /*!< 01 : Transfer using LPSPI_PCS[1]                                          */
  LPSPI0_TCR_PCS_10                    = 2,     /*!< 10 : Transfer using LPSPI_PCS[2]                                          */
  LPSPI0_TCR_PCS_11                    = 3,     /*!< 11 : Transfer using LPSPI_PCS[3]                                          */
} LPSPI0_TCR_PCS_Enum;

/* ==========================================  LPSPI0 LPSPI0_TCR PRESCALE [27..29]  ========================================== */
typedef enum {                                  /*!< LPSPI0_TCR_PRESCALE                                                       */
  LPSPI0_TCR_PRESCALE_000              = 0,     /*!< 000 : Divide by 1.                                                        */
  LPSPI0_TCR_PRESCALE_001              = 1,     /*!< 001 : Divide by 2.                                                        */
  LPSPI0_TCR_PRESCALE_010              = 2,     /*!< 010 : Divide by 4.                                                        */
  LPSPI0_TCR_PRESCALE_011              = 3,     /*!< 011 : Divide by 8.                                                        */
  LPSPI0_TCR_PRESCALE_100              = 4,     /*!< 100 : Divide by 16.                                                       */
  LPSPI0_TCR_PRESCALE_101              = 5,     /*!< 101 : Divide by 32.                                                       */
  LPSPI0_TCR_PRESCALE_110              = 6,     /*!< 110 : Divide by 64.                                                       */
  LPSPI0_TCR_PRESCALE_111              = 7,     /*!< 111 : Divide by 128.                                                      */
} LPSPI0_TCR_PRESCALE_Enum;

/* ============================================  LPSPI0 LPSPI0_TCR CPHA [30..30]  ============================================ */
typedef enum {                                  /*!< LPSPI0_TCR_CPHA                                                           */
  LPSPI0_TCR_CPHA_0                    = 0,     /*!< 0 : Data is captured on the leading edge of SCK and changed
                                                     on the following edge.                                                    */
  LPSPI0_TCR_CPHA_1                    = 1,     /*!< 1 : Data is changed on the leading edge of SCK and captured
                                                     on the following edge.                                                    */
} LPSPI0_TCR_CPHA_Enum;

/* ============================================  LPSPI0 LPSPI0_TCR CPOL [31..31]  ============================================ */
typedef enum {                                  /*!< LPSPI0_TCR_CPOL                                                           */
  LPSPI0_TCR_CPOL_0                    = 0,     /*!< 0 : The inactive state value of SCK is low.                               */
  LPSPI0_TCR_CPOL_1                    = 1,     /*!< 1 : The inactive state value of SCK is high.                              */
} LPSPI0_TCR_CPOL_Enum;

/* ======================================================  LPSPI0_TDR  ======================================================= */
/* ======================================================  LPSPI0_RSR  ======================================================= */
/* =============================================  LPSPI0 LPSPI0_RSR SOF [0..0]  ============================================== */
typedef enum {                                  /*!< LPSPI0_RSR_SOF                                                            */
  LPSPI0_RSR_SOF_0                     = 0,     /*!< 0 : Subsequent data word received after LPSPI_PCS assertion.              */
  LPSPI0_RSR_SOF_1                     = 1,     /*!< 1 : First data word received after LPSPI_PCS assertion.                   */
} LPSPI0_RSR_SOF_Enum;

/* ===========================================  LPSPI0 LPSPI0_RSR RXEMPTY [1..1]  ============================================ */
typedef enum {                                  /*!< LPSPI0_RSR_RXEMPTY                                                        */
  LPSPI0_RSR_RXEMPTY_0                 = 0,     /*!< 0 : RX FIFO is not empty.                                                 */
  LPSPI0_RSR_RXEMPTY_1                 = 1,     /*!< 1 : RX FIFO is empty.                                                     */
} LPSPI0_RSR_RXEMPTY_Enum;

/* ======================================================  LPSPI0_RDR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            CRC                                            ================ */
/* =========================================================================================================================== */

/* =====================================================  CRC_DATA_CRC  ====================================================== */
/* =====================================================  CRC_DATAL_CRC  ===================================================== */
/* ====================================================  CRC_DATALL_CRC  ===================================================== */
/* ======================================================  CRC_DATALU  ======================================================= */
/* =====================================================  CRC_DATAH_CRC  ===================================================== */
/* ====================================================  CRC_DATAHL_CRC  ===================================================== */
/* ======================================================  CRC_DATAHU  ======================================================= */
/* =======================================================  CRC_GPOLY  ======================================================= */
/* =======================================================  CRC_CTRL  ======================================================== */
/* ==============================================  CRC CRC_CTRL TCRC [24..24]  =============================================== */
typedef enum {                                  /*!< CRC_CTRL_TCRC                                                             */
  CRC_CTRL_TCRC_0                      = 0,     /*!< 0 : 16-bit CRC protocol.                                                  */
  CRC_CTRL_TCRC_1                      = 1,     /*!< 1 : 32-bit CRC protocol.                                                  */
} CRC_CTRL_TCRC_Enum;

/* ===============================================  CRC CRC_CTRL WAS [25..25]  =============================================== */
typedef enum {                                  /*!< CRC_CTRL_WAS                                                              */
  CRC_CTRL_WAS_0                       = 0,     /*!< 0 : Writes to the CRC data register are data values.                      */
  CRC_CTRL_WAS_1                       = 1,     /*!< 1 : Writes to the CRC data register are seed values.                      */
} CRC_CTRL_WAS_Enum;

/* ==============================================  CRC CRC_CTRL FXOR [26..26]  =============================================== */
typedef enum {                                  /*!< CRC_CTRL_FXOR                                                             */
  CRC_CTRL_FXOR_0                      = 0,     /*!< 0 : No XOR on reading.                                                    */
  CRC_CTRL_FXOR_1                      = 1,     /*!< 1 : Invert or complement the read value of the CRC Data register.         */
} CRC_CTRL_FXOR_Enum;

/* ==============================================  CRC CRC_CTRL TOTR [28..29]  =============================================== */
typedef enum {                                  /*!< CRC_CTRL_TOTR                                                             */
  CRC_CTRL_TOTR_00                     = 0,     /*!< 00 : No transposition.                                                    */
  CRC_CTRL_TOTR_01                     = 1,     /*!< 01 : Bits in bytes are transposed; bytes are not transposed.              */
  CRC_CTRL_TOTR_10                     = 2,     /*!< 10 : Both bits in bytes and bytes are transposed.                         */
  CRC_CTRL_TOTR_11                     = 3,     /*!< 11 : Only bytes are transposed; no bits in a byte are transposed.         */
} CRC_CTRL_TOTR_Enum;

/* ===============================================  CRC CRC_CTRL TOT [30..31]  =============================================== */
typedef enum {                                  /*!< CRC_CTRL_TOT                                                              */
  CRC_CTRL_TOT_00                      = 0,     /*!< 00 : No transposition.                                                    */
  CRC_CTRL_TOT_01                      = 1,     /*!< 01 : Bits in bytes are transposed; bytes are not transposed.              */
  CRC_CTRL_TOT_10                      = 2,     /*!< 10 : Both bits in bytes and bytes are transposed.                         */
  CRC_CTRL_TOT_11                      = 3,     /*!< 11 : Only bytes are transposed; no bits in a byte are transposed.         */
} CRC_CTRL_TOT_Enum;



/* =========================================================================================================================== */
/* ================                                           PDB0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  PDB0_SC  ======================================================== */
/* ===============================================  PDB0 PDB0_SC CONT [1..1]  ================================================ */
typedef enum {                                  /*!< PDB0_SC_CONT                                                              */
  PDB0_SC_CONT_0                       = 0,     /*!< 0 : PDB operation in One-Shot mode                                        */
  PDB0_SC_CONT_1                       = 1,     /*!< 1 : PDB operation in Continuous mode                                      */
} PDB0_SC_CONT_Enum;

/* ===============================================  PDB0 PDB0_SC MULT [2..3]  ================================================ */
typedef enum {                                  /*!< PDB0_SC_MULT                                                              */
  PDB0_SC_MULT_00                      = 0,     /*!< 00 : Multiplication factor is 1.                                          */
  PDB0_SC_MULT_01                      = 1,     /*!< 01 : Multiplication factor is 10.                                         */
  PDB0_SC_MULT_10                      = 2,     /*!< 10 : Multiplication factor is 20.                                         */
  PDB0_SC_MULT_11                      = 3,     /*!< 11 : Multiplication factor is 40.                                         */
} PDB0_SC_MULT_Enum;

/* ===============================================  PDB0 PDB0_SC PDBIE [5..5]  =============================================== */
typedef enum {                                  /*!< PDB0_SC_PDBIE                                                             */
  PDB0_SC_PDBIE_0                      = 0,     /*!< 0 : PDB interrupt disabled.                                               */
  PDB0_SC_PDBIE_1                      = 1,     /*!< 1 : PDB interrupt enabled.                                                */
} PDB0_SC_PDBIE_Enum;

/* ===============================================  PDB0 PDB0_SC PDBEN [7..7]  =============================================== */
typedef enum {                                  /*!< PDB0_SC_PDBEN                                                             */
  PDB0_SC_PDBEN_0                      = 0,     /*!< 0 : PDB disabled. Counter is off.                                         */
  PDB0_SC_PDBEN_1                      = 1,     /*!< 1 : PDB enabled.                                                          */
} PDB0_SC_PDBEN_Enum;

/* ==============================================  PDB0 PDB0_SC TRGSEL [8..11]  ============================================== */
typedef enum {                                  /*!< PDB0_SC_TRGSEL                                                            */
  PDB0_SC_TRGSEL_0000                  = 0,     /*!< 0000 : Trigger-In 0 is selected.                                          */
  PDB0_SC_TRGSEL_0001                  = 1,     /*!< 0001 : Trigger-In 1 is selected.                                          */
  PDB0_SC_TRGSEL_0010                  = 2,     /*!< 0010 : Trigger-In 2 is selected.                                          */
  PDB0_SC_TRGSEL_0011                  = 3,     /*!< 0011 : Trigger-In 3 is selected.                                          */
  PDB0_SC_TRGSEL_0100                  = 4,     /*!< 0100 : Trigger-In 4 is selected.                                          */
  PDB0_SC_TRGSEL_0101                  = 5,     /*!< 0101 : Trigger-In 5 is selected.                                          */
  PDB0_SC_TRGSEL_0110                  = 6,     /*!< 0110 : Trigger-In 6 is selected.                                          */
  PDB0_SC_TRGSEL_0111                  = 7,     /*!< 0111 : Trigger-In 7 is selected.                                          */
  PDB0_SC_TRGSEL_1000                  = 8,     /*!< 1000 : Trigger-In 8 is selected.                                          */
  PDB0_SC_TRGSEL_1001                  = 9,     /*!< 1001 : Trigger-In 9 is selected.                                          */
  PDB0_SC_TRGSEL_1010                  = 10,    /*!< 1010 : Trigger-In 10 is selected.                                         */
  PDB0_SC_TRGSEL_1011                  = 11,    /*!< 1011 : Trigger-In 11 is selected.                                         */
  PDB0_SC_TRGSEL_1100                  = 12,    /*!< 1100 : Trigger-In 12 is selected.                                         */
  PDB0_SC_TRGSEL_1101                  = 13,    /*!< 1101 : Trigger-In 13 is selected.                                         */
  PDB0_SC_TRGSEL_1110                  = 14,    /*!< 1110 : Trigger-In 14 is selected.                                         */
  PDB0_SC_TRGSEL_1111                  = 15,    /*!< 1111 : Software trigger is selected.                                      */
} PDB0_SC_TRGSEL_Enum;

/* ============================================  PDB0 PDB0_SC PRESCALER [12..14]  ============================================ */
typedef enum {                                  /*!< PDB0_SC_PRESCALER                                                         */
  PDB0_SC_PRESCALER_000                = 0,     /*!< 000 : Counting uses the peripheral clock divided by MULT (the
                                                     multiplication factor).                                                   */
  PDB0_SC_PRESCALER_001                = 1,     /*!< 001 : Counting uses the peripheral clock divided by 2 x MULT
                                                     (the multiplication factor).                                              */
  PDB0_SC_PRESCALER_010                = 2,     /*!< 010 : Counting uses the peripheral clock divided by 4 x MULT
                                                     (the multiplication factor).                                              */
  PDB0_SC_PRESCALER_011                = 3,     /*!< 011 : Counting uses the peripheral clock divided by 8 x MULT
                                                     (the multiplication factor).                                              */
  PDB0_SC_PRESCALER_100                = 4,     /*!< 100 : Counting uses the peripheral clock divided by 16 x MULT
                                                     (the multiplication factor).                                              */
  PDB0_SC_PRESCALER_101                = 5,     /*!< 101 : Counting uses the peripheral clock divided by 32 x MULT
                                                     (the multiplication factor).                                              */
  PDB0_SC_PRESCALER_110                = 6,     /*!< 110 : Counting uses the peripheral clock divided by 64 x MULT
                                                     (the multiplication factor).                                              */
  PDB0_SC_PRESCALER_111                = 7,     /*!< 111 : Counting uses the peripheral clock divided by 128 x MULT
                                                     (the multiplication factor).                                              */
} PDB0_SC_PRESCALER_Enum;

/* ==============================================  PDB0 PDB0_SC DMAEN [15..15]  ============================================== */
typedef enum {                                  /*!< PDB0_SC_DMAEN                                                             */
  PDB0_SC_DMAEN_0                      = 0,     /*!< 0 : DMA disabled.                                                         */
  PDB0_SC_DMAEN_1                      = 1,     /*!< 1 : DMA enabled.                                                          */
} PDB0_SC_DMAEN_Enum;

/* =============================================  PDB0 PDB0_SC PDBEIE [17..17]  ============================================== */
typedef enum {                                  /*!< PDB0_SC_PDBEIE                                                            */
  PDB0_SC_PDBEIE_0                     = 0,     /*!< 0 : PDB sequence error interrupt disabled.                                */
  PDB0_SC_PDBEIE_1                     = 1,     /*!< 1 : PDB sequence error interrupt enabled.                                 */
} PDB0_SC_PDBEIE_Enum;

/* ==============================================  PDB0 PDB0_SC LDMOD [18..19]  ============================================== */
typedef enum {                                  /*!< PDB0_SC_LDMOD                                                             */
  PDB0_SC_LDMOD_00                     = 0,     /*!< 00 : The internal registers are loaded with the values from
                                                     their buffers, immediately after 1 is written to LDOK.                    */
  PDB0_SC_LDMOD_01                     = 1,     /*!< 01 : The internal registers are loaded with the values from
                                                     their buffers when the PDB counter (CNT) = MOD + 1 CNT
                                                     delay elapsed, after 1 is written to LDOK.                                */
  PDB0_SC_LDMOD_10                     = 2,     /*!< 10 : The internal registers are loaded with the values from
                                                     their buffers when a trigger input event is detected, after
                                                     1 is written to LDOK.                                                     */
  PDB0_SC_LDMOD_11                     = 3,     /*!< 11 : The internal registers are loaded with the values from
                                                     their buffers when either the PDB counter (CNT) = MOD +
                                                     1 CNT delay elapsed, or a trigger input event is detected,
                                                     after 1 is written to LDOK.                                               */
} PDB0_SC_LDMOD_Enum;

/* =======================================================  PDB0_MOD  ======================================================== */
/* =======================================================  PDB0_CNT  ======================================================== */
/* =======================================================  PDB0_IDLY  ======================================================= */
/* ======================================================  PDB0_CH0C1  ======================================================= */
/* ===============================================  PDB0 PDB0_CH0C1 EN [0..7]  =============================================== */
typedef enum {                                  /*!< PDB0_CHC1_CHC1_CH0C1_EN                                                   */
  PDB0_CHC1_CHC1_CH0C1_EN_0            = 0,     /*!< 0 : PDB channels corresponding pre-trigger disabled.                      */
  PDB0_CHC1_CHC1_CH0C1_EN_1            = 1,     /*!< 1 : PDB channels corresponding pre-trigger enabled.                       */
} PDB0_CHC1_CHC1_CH0C1_EN_Enum;

/* ==============================================  PDB0 PDB0_CH0C1 TOS [8..15]  ============================================== */
typedef enum {                                  /*!< PDB0_CHC1_CHC1_CH0C1_TOS                                                  */
  PDB0_CHC1_CHC1_CH0C1_TOS_0           = 0,     /*!< 0 : PDB channels corresponding pre-trigger is in bypassed mode.
                                                     The pre-trigger asserts one peripheral clock cycle after
                                                     a rising edge is detected on selected trigger input source
                                                     or software trigger is selected and SWTRIG is written with
                                                     1.                                                                        */
  PDB0_CHC1_CHC1_CH0C1_TOS_1           = 1,     /*!< 1 : PDB channels corresponding pre-trigger asserts when the
                                                     counter reaches the channel delay register and one peripheral
                                                     clock cycle after a rising edge is detected on selected
                                                     trigger input source or software trigger is selected and
                                                     SWTRIG is written with 1.                                                 */
} PDB0_CHC1_CHC1_CH0C1_TOS_Enum;

/* ==============================================  PDB0 PDB0_CH0C1 BB [16..23]  ============================================== */
typedef enum {                                  /*!< PDB0_CHC1_CHC1_CH0C1_BB                                                   */
  PDB0_CHC1_CHC1_CH0C1_BB_0            = 0,     /*!< 0 : PDB channels corresponding pre-trigger back-to-back operation
                                                     disabled.                                                                 */
  PDB0_CHC1_CHC1_CH0C1_BB_1            = 1,     /*!< 1 : PDB channels corresponding pre-trigger back-to-back operation
                                                     enabled.                                                                  */
} PDB0_CHC1_CHC1_CH0C1_BB_Enum;

/* ======================================================  PDB0_CH1C1  ======================================================= */
/* ===============================================  PDB0 PDB0_CH1C1 EN [0..7]  =============================================== */
typedef enum {                                  /*!< PDB0_CHC1_CHC1_CH1C1_EN                                                   */
  PDB0_CHC1_CHC1_CH1C1_EN_0            = 0,     /*!< 0 : PDB channels corresponding pre-trigger disabled.                      */
  PDB0_CHC1_CHC1_CH1C1_EN_1            = 1,     /*!< 1 : PDB channels corresponding pre-trigger enabled.                       */
} PDB0_CHC1_CHC1_CH1C1_EN_Enum;

/* ==============================================  PDB0 PDB0_CH1C1 TOS [8..15]  ============================================== */
typedef enum {                                  /*!< PDB0_CHC1_CHC1_CH1C1_TOS                                                  */
  PDB0_CHC1_CHC1_CH1C1_TOS_0           = 0,     /*!< 0 : PDB channels corresponding pre-trigger is in bypassed mode.
                                                     The pre-trigger asserts one peripheral clock cycle after
                                                     a rising edge is detected on selected trigger input source
                                                     or software trigger is selected and SWTRIG is written with
                                                     1.                                                                        */
  PDB0_CHC1_CHC1_CH1C1_TOS_1           = 1,     /*!< 1 : PDB channels corresponding pre-trigger asserts when the
                                                     counter reaches the channel delay register and one peripheral
                                                     clock cycle after a rising edge is detected on selected
                                                     trigger input source or software trigger is selected and
                                                     SWTRIG is written with 1.                                                 */
} PDB0_CHC1_CHC1_CH1C1_TOS_Enum;

/* ==============================================  PDB0 PDB0_CH1C1 BB [16..23]  ============================================== */
typedef enum {                                  /*!< PDB0_CHC1_CHC1_CH1C1_BB                                                   */
  PDB0_CHC1_CHC1_CH1C1_BB_0            = 0,     /*!< 0 : PDB channels corresponding pre-trigger back-to-back operation
                                                     disabled.                                                                 */
  PDB0_CHC1_CHC1_CH1C1_BB_1            = 1,     /*!< 1 : PDB channels corresponding pre-trigger back-to-back operation
                                                     enabled.                                                                  */
} PDB0_CHC1_CHC1_CH1C1_BB_Enum;

/* =======================================================  PDB0_CH0S  ======================================================= */
/* ===============================================  PDB0 PDB0_CH0S ERR [0..7]  =============================================== */
typedef enum {                                  /*!< PDB0_CHS_CHS_CH0S_ERR                                                     */
  PDB0_CHS_CHS_CH0S_ERR_0              = 0,     /*!< 0 : Sequence error not detected on PDB channels corresponding
                                                     pre-trigger.                                                              */
  PDB0_CHS_CHS_CH0S_ERR_1              = 1,     /*!< 1 : Sequence error detected on PDB channels corresponding pre-trigger.
                                                     ADCn block can be triggered for a conversion by one pre-trigger
                                                     from PDB channel n. When one conversion, which is triggered
                                                     by one of the pre-triggers from PDB channel n, is in progress,
                                                     new trigger from PDB channels corresponding pre-trigger
                                                     m cannot be accepted by ADCn, and ERR[m] is set. Writing
                                                     0s to clear the sequence error flags.                                     */
} PDB0_CHS_CHS_CH0S_ERR_Enum;

/* =======================================================  PDB0_CH1S  ======================================================= */
/* ===============================================  PDB0 PDB0_CH1S ERR [0..7]  =============================================== */
typedef enum {                                  /*!< PDB0_CHS_CHS_CH1S_ERR                                                     */
  PDB0_CHS_CHS_CH1S_ERR_0              = 0,     /*!< 0 : Sequence error not detected on PDB channels corresponding
                                                     pre-trigger.                                                              */
  PDB0_CHS_CHS_CH1S_ERR_1              = 1,     /*!< 1 : Sequence error detected on PDB channels corresponding pre-trigger.
                                                     ADCn block can be triggered for a conversion by one pre-trigger
                                                     from PDB channel n. When one conversion, which is triggered
                                                     by one of the pre-triggers from PDB channel n, is in progress,
                                                     new trigger from PDB channels corresponding pre-trigger
                                                     m cannot be accepted by ADCn, and ERR[m] is set. Writing
                                                     0s to clear the sequence error flags.                                     */
} PDB0_CHS_CHS_CH1S_ERR_Enum;

/* =====================================================  PDB0_CH0DLY0  ====================================================== */
/* =====================================================  PDB0_CH1DLY0  ====================================================== */
/* =====================================================  PDB0_CH0DLY1  ====================================================== */
/* =====================================================  PDB0_CH1DLY1  ====================================================== */
/* =====================================================  PDB0_CH0DLY2  ====================================================== */
/* =====================================================  PDB0_CH1DLY2  ====================================================== */
/* =====================================================  PDB0_CH0DLY3  ====================================================== */
/* =====================================================  PDB0_CH1DLY3  ====================================================== */
/* =====================================================  PDB0_CH0DLY4  ====================================================== */
/* =====================================================  PDB0_CH1DLY4  ====================================================== */
/* =====================================================  PDB0_CH0DLY5  ====================================================== */
/* =====================================================  PDB0_CH1DLY5  ====================================================== */
/* =====================================================  PDB0_CH0DLY6  ====================================================== */
/* =====================================================  PDB0_CH1DLY6  ====================================================== */
/* =====================================================  PDB0_CH0DLY7  ====================================================== */
/* =====================================================  PDB0_CH1DLY7  ====================================================== */
/* =======================================================  PDB0_POEN  ======================================================= */
/* ==============================================  PDB0 PDB0_POEN POEN [0..7]  =============================================== */
typedef enum {                                  /*!< PDB0_POEN_POEN                                                            */
  PDB0_POEN_POEN_0                     = 0,     /*!< 0 : PDB Pulse-Out disabled                                                */
  PDB0_POEN_POEN_1                     = 1,     /*!< 1 : PDB Pulse-Out enabled                                                 */
} PDB0_POEN_POEN_Enum;

/* ====================================================  PDB0_PODLY_PDB0  ==================================================== */
/* ====================================================  PDB0_DLY2_PDB0  ===================================================== */
/* =======================================================  PDB0_DLY1  ======================================================= */


/* =========================================================================================================================== */
/* ================                                           LPIT0                                           ================ */
/* =========================================================================================================================== */

/* ======================================================  LPIT0_VERID  ====================================================== */
/* ======================================================  LPIT0_PARAM  ====================================================== */
/* =======================================================  LPIT0_MCR  ======================================================= */
/* =============================================  LPIT0 LPIT0_MCR M_CEN [0..0]  ============================================== */
typedef enum {                                  /*!< LPIT0_MCR_M_CEN                                                           */
  LPIT0_MCR_M_CEN_0                    = 0,     /*!< 0 : Peripheral clock to timers is disabled                                */
  LPIT0_MCR_M_CEN_1                    = 1,     /*!< 1 : Peripheral clock to timers is enabled                                 */
} LPIT0_MCR_M_CEN_Enum;

/* =============================================  LPIT0 LPIT0_MCR SW_RST [1..1]  ============================================= */
typedef enum {                                  /*!< LPIT0_MCR_SW_RST                                                          */
  LPIT0_MCR_SW_RST_0                   = 0,     /*!< 0 : Timer channels and registers are not reset                            */
  LPIT0_MCR_SW_RST_1                   = 1,     /*!< 1 : Timer channels and registers are reset                                */
} LPIT0_MCR_SW_RST_Enum;

/* ============================================  LPIT0 LPIT0_MCR DOZE_EN [2..2]  ============================================= */
typedef enum {                                  /*!< LPIT0_MCR_DOZE_EN                                                         */
  LPIT0_MCR_DOZE_EN_0                  = 0,     /*!< 0 : Timer channels are stopped in DOZE mode                               */
  LPIT0_MCR_DOZE_EN_1                  = 1,     /*!< 1 : Timer channels continue to run in DOZE mode                           */
} LPIT0_MCR_DOZE_EN_Enum;

/* =============================================  LPIT0 LPIT0_MCR DBG_EN [3..3]  ============================================= */
typedef enum {                                  /*!< LPIT0_MCR_DBG_EN                                                          */
  LPIT0_MCR_DBG_EN_0                   = 0,     /*!< 0 : Timer channels are stopped in Debug mode                              */
  LPIT0_MCR_DBG_EN_1                   = 1,     /*!< 1 : Timer channels continue to run in Debug mode                          */
} LPIT0_MCR_DBG_EN_Enum;

/* =======================================================  LPIT0_MSR  ======================================================= */
/* ==============================================  LPIT0 LPIT0_MSR TIF0 [0..0]  ============================================== */
typedef enum {                                  /*!< LPIT0_MSR_TIF0                                                            */
  LPIT0_MSR_TIF0_0                     = 0,     /*!< 0 : Timer has not timed out                                               */
  LPIT0_MSR_TIF0_1                     = 1,     /*!< 1 : Timeout has occurred                                                  */
} LPIT0_MSR_TIF0_Enum;

/* ==============================================  LPIT0 LPIT0_MSR TIF1 [1..1]  ============================================== */
typedef enum {                                  /*!< LPIT0_MSR_TIF1                                                            */
  LPIT0_MSR_TIF1_0                     = 0,     /*!< 0 : Timer has not timed out                                               */
  LPIT0_MSR_TIF1_1                     = 1,     /*!< 1 : Timeout has occurred                                                  */
} LPIT0_MSR_TIF1_Enum;

/* ==============================================  LPIT0 LPIT0_MSR TIF2 [2..2]  ============================================== */
typedef enum {                                  /*!< LPIT0_MSR_TIF2                                                            */
  LPIT0_MSR_TIF2_0                     = 0,     /*!< 0 : Timer has not timed out                                               */
  LPIT0_MSR_TIF2_1                     = 1,     /*!< 1 : Timeout has occurred                                                  */
} LPIT0_MSR_TIF2_Enum;

/* ==============================================  LPIT0 LPIT0_MSR TIF3 [3..3]  ============================================== */
typedef enum {                                  /*!< LPIT0_MSR_TIF3                                                            */
  LPIT0_MSR_TIF3_0                     = 0,     /*!< 0 : Timer has not timed out                                               */
  LPIT0_MSR_TIF3_1                     = 1,     /*!< 1 : Timeout has occurred                                                  */
} LPIT0_MSR_TIF3_Enum;

/* ======================================================  LPIT0_MIER  ======================================================= */
/* =============================================  LPIT0 LPIT0_MIER TIE0 [0..0]  ============================================== */
typedef enum {                                  /*!< LPIT0_MIER_TIE0                                                           */
  LPIT0_MIER_TIE0_0                    = 0,     /*!< 0 : Interrupt generation is disabled                                      */
  LPIT0_MIER_TIE0_1                    = 1,     /*!< 1 : Interrupt generation is enabled                                       */
} LPIT0_MIER_TIE0_Enum;

/* =============================================  LPIT0 LPIT0_MIER TIE1 [1..1]  ============================================== */
typedef enum {                                  /*!< LPIT0_MIER_TIE1                                                           */
  LPIT0_MIER_TIE1_0                    = 0,     /*!< 0 : Interrupt generation is disabled                                      */
  LPIT0_MIER_TIE1_1                    = 1,     /*!< 1 : Interrupt generation is enabled                                       */
} LPIT0_MIER_TIE1_Enum;

/* =============================================  LPIT0 LPIT0_MIER TIE2 [2..2]  ============================================== */
typedef enum {                                  /*!< LPIT0_MIER_TIE2                                                           */
  LPIT0_MIER_TIE2_0                    = 0,     /*!< 0 : Interrupt generation is disabled                                      */
  LPIT0_MIER_TIE2_1                    = 1,     /*!< 1 : Interrupt generation is enabled                                       */
} LPIT0_MIER_TIE2_Enum;

/* =============================================  LPIT0 LPIT0_MIER TIE3 [3..3]  ============================================== */
typedef enum {                                  /*!< LPIT0_MIER_TIE3                                                           */
  LPIT0_MIER_TIE3_0                    = 0,     /*!< 0 : Interrupt generation is disabled                                      */
  LPIT0_MIER_TIE3_1                    = 1,     /*!< 1 : Interrupt generation is enabled                                       */
} LPIT0_MIER_TIE3_Enum;

/* =====================================================  LPIT0_SETTEN  ====================================================== */
/* =========================================  LPIT0 LPIT0_SETTEN SET_T_EN_0 [0..0]  ========================================== */
typedef enum {                                  /*!< LPIT0_SETTEN_SET_T_EN_0                                                   */
  LPIT0_SETTEN_SET_T_EN_0_0            = 0,     /*!< 0 : No effect                                                             */
  LPIT0_SETTEN_SET_T_EN_0_1            = 1,     /*!< 1 : Enables the Timer Channel 0                                           */
} LPIT0_SETTEN_SET_T_EN_0_Enum;

/* =========================================  LPIT0 LPIT0_SETTEN SET_T_EN_1 [1..1]  ========================================== */
typedef enum {                                  /*!< LPIT0_SETTEN_SET_T_EN_1                                                   */
  LPIT0_SETTEN_SET_T_EN_1_0            = 0,     /*!< 0 : No Effect                                                             */
  LPIT0_SETTEN_SET_T_EN_1_1            = 1,     /*!< 1 : Enables the Timer Channel 1                                           */
} LPIT0_SETTEN_SET_T_EN_1_Enum;

/* =========================================  LPIT0 LPIT0_SETTEN SET_T_EN_2 [2..2]  ========================================== */
typedef enum {                                  /*!< LPIT0_SETTEN_SET_T_EN_2                                                   */
  LPIT0_SETTEN_SET_T_EN_2_0            = 0,     /*!< 0 : No Effect                                                             */
  LPIT0_SETTEN_SET_T_EN_2_1            = 1,     /*!< 1 : Enables the Timer Channel 2                                           */
} LPIT0_SETTEN_SET_T_EN_2_Enum;

/* =========================================  LPIT0 LPIT0_SETTEN SET_T_EN_3 [3..3]  ========================================== */
typedef enum {                                  /*!< LPIT0_SETTEN_SET_T_EN_3                                                   */
  LPIT0_SETTEN_SET_T_EN_3_0            = 0,     /*!< 0 : No effect                                                             */
  LPIT0_SETTEN_SET_T_EN_3_1            = 1,     /*!< 1 : Enables the Timer Channel 3                                           */
} LPIT0_SETTEN_SET_T_EN_3_Enum;

/* =====================================================  LPIT0_CLRTEN  ====================================================== */
/* =========================================  LPIT0 LPIT0_CLRTEN CLR_T_EN_0 [0..0]  ========================================== */
typedef enum {                                  /*!< LPIT0_CLRTEN_CLR_T_EN_0                                                   */
  LPIT0_CLRTEN_CLR_T_EN_0_0            = 0,     /*!< 0 : No action                                                             */
  LPIT0_CLRTEN_CLR_T_EN_0_1            = 1,     /*!< 1 : Clear T_EN bit for Timer Channel 0                                    */
} LPIT0_CLRTEN_CLR_T_EN_0_Enum;

/* =========================================  LPIT0 LPIT0_CLRTEN CLR_T_EN_1 [1..1]  ========================================== */
typedef enum {                                  /*!< LPIT0_CLRTEN_CLR_T_EN_1                                                   */
  LPIT0_CLRTEN_CLR_T_EN_1_0            = 0,     /*!< 0 : No Action                                                             */
  LPIT0_CLRTEN_CLR_T_EN_1_1            = 1,     /*!< 1 : Clear T_EN bit for Timer Channel 1                                    */
} LPIT0_CLRTEN_CLR_T_EN_1_Enum;

/* =========================================  LPIT0 LPIT0_CLRTEN CLR_T_EN_2 [2..2]  ========================================== */
typedef enum {                                  /*!< LPIT0_CLRTEN_CLR_T_EN_2                                                   */
  LPIT0_CLRTEN_CLR_T_EN_2_0            = 0,     /*!< 0 : No Action                                                             */
  LPIT0_CLRTEN_CLR_T_EN_2_1            = 1,     /*!< 1 : Clear T_EN bit for Timer Channel 2                                    */
} LPIT0_CLRTEN_CLR_T_EN_2_Enum;

/* =========================================  LPIT0 LPIT0_CLRTEN CLR_T_EN_3 [3..3]  ========================================== */
typedef enum {                                  /*!< LPIT0_CLRTEN_CLR_T_EN_3                                                   */
  LPIT0_CLRTEN_CLR_T_EN_3_0            = 0,     /*!< 0 : No Action                                                             */
  LPIT0_CLRTEN_CLR_T_EN_3_1            = 1,     /*!< 1 : Clear T_EN bit for Timer Channel 3                                    */
} LPIT0_CLRTEN_CLR_T_EN_3_Enum;

/* ======================================================  LPIT0_TVAL0  ====================================================== */
/* ===========================================  LPIT0 LPIT0_TVAL0 TMR_VAL [0..31]  =========================================== */
typedef enum {                                  /*!< LPIT0_TVAL0_TMR_VAL                                                       */
  LPIT0_TVAL0_TMR_VAL_0                = 0,     /*!< 0 : Invalid load value in compare modes.                                  */
  LPIT0_TVAL0_TMR_VAL_1                = 1,     /*!< 1 : Invalid load value in compare modes.                                  */
} LPIT0_TVAL0_TMR_VAL_Enum;

/* ======================================================  LPIT0_CVAL0  ====================================================== */
/* =====================================================  LPIT0_TCTRL0  ====================================================== */
/* ============================================  LPIT0 LPIT0_TCTRL0 T_EN [0..0]  ============================================= */
typedef enum {                                  /*!< LPIT0_TCTRL0_T_EN                                                         */
  LPIT0_TCTRL0_T_EN_0                  = 0,     /*!< 0 : Timer Channel is disabled                                             */
  LPIT0_TCTRL0_T_EN_1                  = 1,     /*!< 1 : Timer Channel is enabled                                              */
} LPIT0_TCTRL0_T_EN_Enum;

/* ============================================  LPIT0 LPIT0_TCTRL0 CHAIN [1..1]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL0_CHAIN                                                        */
  LPIT0_TCTRL0_CHAIN_0                 = 0,     /*!< 0 : Channel Chaining is disabled. Channel Timer runs independently.       */
  LPIT0_TCTRL0_CHAIN_1                 = 1,     /*!< 1 : Channel Chaining is enabled. Timer decrements on previous
                                                     channels timeout                                                          */
} LPIT0_TCTRL0_CHAIN_Enum;

/* ============================================  LPIT0 LPIT0_TCTRL0 MODE [2..3]  ============================================= */
typedef enum {                                  /*!< LPIT0_TCTRL0_MODE                                                         */
  LPIT0_TCTRL0_MODE_0                  = 0,     /*!< 0 : 32-bit Periodic Counter                                               */
  LPIT0_TCTRL0_MODE_1                  = 1,     /*!< 1 : Dual 16-bit Periodic Counter                                          */
  LPIT0_TCTRL0_MODE_10                 = 2,     /*!< 10 : 32-bit Trigger Accumulator                                           */
  LPIT0_TCTRL0_MODE_11                 = 3,     /*!< 11 : 32-bit Trigger Input Capture                                         */
} LPIT0_TCTRL0_MODE_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL0 TSOT [16..16]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL0_TSOT                                                         */
  LPIT0_TCTRL0_TSOT_0                  = 0,     /*!< 0 : Timer starts to decrement immediately based on restart condition
                                                     (controlled by TSOI bit)                                                  */
  LPIT0_TCTRL0_TSOT_1                  = 1,     /*!< 1 : Timer starts to decrement when rising edge on selected trigger
                                                     is detected                                                               */
} LPIT0_TCTRL0_TSOT_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL0 TSOI [17..17]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL0_TSOI                                                         */
  LPIT0_TCTRL0_TSOI_0                  = 0,     /*!< 0 : The channel timer does not stop after timeout.                        */
  LPIT0_TCTRL0_TSOI_1                  = 1,     /*!< 1 : The channel timer will stop after a timeout, and the channel
                                                     timer will restart based on TSOT. When TSOT = 0, the channel
                                                     timer will restart after a rising edge on the T_EN bit
                                                     is detected (which means that the timer channel is disabled
                                                     and then enabled); when TSOT = 1, the channel timer will
                                                     restart after a rising edge on the selected trigger is
                                                     detected.                                                                 */
} LPIT0_TCTRL0_TSOI_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL0 TROT [18..18]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL0_TROT                                                         */
  LPIT0_TCTRL0_TROT_0                  = 0,     /*!< 0 : Timer will not reload on selected trigger                             */
  LPIT0_TCTRL0_TROT_1                  = 1,     /*!< 1 : Timer will reload on selected trigger                                 */
} LPIT0_TCTRL0_TROT_Enum;

/* ==========================================  LPIT0 LPIT0_TCTRL0 TRG_SRC [23..23]  ========================================== */
typedef enum {                                  /*!< LPIT0_TCTRL0_TRG_SRC                                                      */
  LPIT0_TCTRL0_TRG_SRC_0               = 0,     /*!< 0 : Trigger source selected in external                                   */
  LPIT0_TCTRL0_TRG_SRC_1               = 1,     /*!< 1 : Trigger source selected is the internal trigger                       */
} LPIT0_TCTRL0_TRG_SRC_Enum;

/* ======================================================  LPIT0_TVAL1  ====================================================== */
/* ===========================================  LPIT0 LPIT0_TVAL1 TMR_VAL [0..31]  =========================================== */
typedef enum {                                  /*!< LPIT0_TVAL1_TMR_VAL                                                       */
  LPIT0_TVAL1_TMR_VAL_0                = 0,     /*!< 0 : Invalid load value in compare modes.                                  */
  LPIT0_TVAL1_TMR_VAL_1                = 1,     /*!< 1 : Invalid load value in compare modes.                                  */
} LPIT0_TVAL1_TMR_VAL_Enum;

/* ======================================================  LPIT0_CVAL1  ====================================================== */
/* =====================================================  LPIT0_TCTRL1  ====================================================== */
/* ============================================  LPIT0 LPIT0_TCTRL1 T_EN [0..0]  ============================================= */
typedef enum {                                  /*!< LPIT0_TCTRL1_T_EN                                                         */
  LPIT0_TCTRL1_T_EN_0                  = 0,     /*!< 0 : Timer Channel is disabled                                             */
  LPIT0_TCTRL1_T_EN_1                  = 1,     /*!< 1 : Timer Channel is enabled                                              */
} LPIT0_TCTRL1_T_EN_Enum;

/* ============================================  LPIT0 LPIT0_TCTRL1 CHAIN [1..1]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL1_CHAIN                                                        */
  LPIT0_TCTRL1_CHAIN_0                 = 0,     /*!< 0 : Channel Chaining is disabled. Channel Timer runs independently.       */
  LPIT0_TCTRL1_CHAIN_1                 = 1,     /*!< 1 : Channel Chaining is enabled. Timer decrements on previous
                                                     channels timeout                                                          */
} LPIT0_TCTRL1_CHAIN_Enum;

/* ============================================  LPIT0 LPIT0_TCTRL1 MODE [2..3]  ============================================= */
typedef enum {                                  /*!< LPIT0_TCTRL1_MODE                                                         */
  LPIT0_TCTRL1_MODE_0                  = 0,     /*!< 0 : 32-bit Periodic Counter                                               */
  LPIT0_TCTRL1_MODE_1                  = 1,     /*!< 1 : Dual 16-bit Periodic Counter                                          */
  LPIT0_TCTRL1_MODE_10                 = 2,     /*!< 10 : 32-bit Trigger Accumulator                                           */
  LPIT0_TCTRL1_MODE_11                 = 3,     /*!< 11 : 32-bit Trigger Input Capture                                         */
} LPIT0_TCTRL1_MODE_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL1 TSOT [16..16]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL1_TSOT                                                         */
  LPIT0_TCTRL1_TSOT_0                  = 0,     /*!< 0 : Timer starts to decrement immediately based on restart condition
                                                     (controlled by TSOI bit)                                                  */
  LPIT0_TCTRL1_TSOT_1                  = 1,     /*!< 1 : Timer starts to decrement when rising edge on selected trigger
                                                     is detected                                                               */
} LPIT0_TCTRL1_TSOT_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL1 TSOI [17..17]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL1_TSOI                                                         */
  LPIT0_TCTRL1_TSOI_0                  = 0,     /*!< 0 : The channel timer does not stop after timeout.                        */
  LPIT0_TCTRL1_TSOI_1                  = 1,     /*!< 1 : The channel timer will stop after a timeout, and the channel
                                                     timer will restart based on TSOT. When TSOT = 0, the channel
                                                     timer will restart after a rising edge on the T_EN bit
                                                     is detected (which means that the timer channel is disabled
                                                     and then enabled); when TSOT = 1, the channel timer will
                                                     restart after a rising edge on the selected trigger is
                                                     detected.                                                                 */
} LPIT0_TCTRL1_TSOI_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL1 TROT [18..18]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL1_TROT                                                         */
  LPIT0_TCTRL1_TROT_0                  = 0,     /*!< 0 : Timer will not reload on selected trigger                             */
  LPIT0_TCTRL1_TROT_1                  = 1,     /*!< 1 : Timer will reload on selected trigger                                 */
} LPIT0_TCTRL1_TROT_Enum;

/* ==========================================  LPIT0 LPIT0_TCTRL1 TRG_SRC [23..23]  ========================================== */
typedef enum {                                  /*!< LPIT0_TCTRL1_TRG_SRC                                                      */
  LPIT0_TCTRL1_TRG_SRC_0               = 0,     /*!< 0 : Trigger source selected in external                                   */
  LPIT0_TCTRL1_TRG_SRC_1               = 1,     /*!< 1 : Trigger source selected is the internal trigger                       */
} LPIT0_TCTRL1_TRG_SRC_Enum;

/* ======================================================  LPIT0_TVAL2  ====================================================== */
/* ===========================================  LPIT0 LPIT0_TVAL2 TMR_VAL [0..31]  =========================================== */
typedef enum {                                  /*!< LPIT0_TVAL2_TMR_VAL                                                       */
  LPIT0_TVAL2_TMR_VAL_0                = 0,     /*!< 0 : Invalid load value in compare modes.                                  */
  LPIT0_TVAL2_TMR_VAL_1                = 1,     /*!< 1 : Invalid load value in compare modes.                                  */
} LPIT0_TVAL2_TMR_VAL_Enum;

/* ======================================================  LPIT0_CVAL2  ====================================================== */
/* =====================================================  LPIT0_TCTRL2  ====================================================== */
/* ============================================  LPIT0 LPIT0_TCTRL2 T_EN [0..0]  ============================================= */
typedef enum {                                  /*!< LPIT0_TCTRL2_T_EN                                                         */
  LPIT0_TCTRL2_T_EN_0                  = 0,     /*!< 0 : Timer Channel is disabled                                             */
  LPIT0_TCTRL2_T_EN_1                  = 1,     /*!< 1 : Timer Channel is enabled                                              */
} LPIT0_TCTRL2_T_EN_Enum;

/* ============================================  LPIT0 LPIT0_TCTRL2 CHAIN [1..1]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL2_CHAIN                                                        */
  LPIT0_TCTRL2_CHAIN_0                 = 0,     /*!< 0 : Channel Chaining is disabled. Channel Timer runs independently.       */
  LPIT0_TCTRL2_CHAIN_1                 = 1,     /*!< 1 : Channel Chaining is enabled. Timer decrements on previous
                                                     channels timeout                                                          */
} LPIT0_TCTRL2_CHAIN_Enum;

/* ============================================  LPIT0 LPIT0_TCTRL2 MODE [2..3]  ============================================= */
typedef enum {                                  /*!< LPIT0_TCTRL2_MODE                                                         */
  LPIT0_TCTRL2_MODE_0                  = 0,     /*!< 0 : 32-bit Periodic Counter                                               */
  LPIT0_TCTRL2_MODE_1                  = 1,     /*!< 1 : Dual 16-bit Periodic Counter                                          */
  LPIT0_TCTRL2_MODE_10                 = 2,     /*!< 10 : 32-bit Trigger Accumulator                                           */
  LPIT0_TCTRL2_MODE_11                 = 3,     /*!< 11 : 32-bit Trigger Input Capture                                         */
} LPIT0_TCTRL2_MODE_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL2 TSOT [16..16]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL2_TSOT                                                         */
  LPIT0_TCTRL2_TSOT_0                  = 0,     /*!< 0 : Timer starts to decrement immediately based on restart condition
                                                     (controlled by TSOI bit)                                                  */
  LPIT0_TCTRL2_TSOT_1                  = 1,     /*!< 1 : Timer starts to decrement when rising edge on selected trigger
                                                     is detected                                                               */
} LPIT0_TCTRL2_TSOT_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL2 TSOI [17..17]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL2_TSOI                                                         */
  LPIT0_TCTRL2_TSOI_0                  = 0,     /*!< 0 : The channel timer does not stop after timeout.                        */
  LPIT0_TCTRL2_TSOI_1                  = 1,     /*!< 1 : The channel timer will stop after a timeout, and the channel
                                                     timer will restart based on TSOT. When TSOT = 0, the channel
                                                     timer will restart after a rising edge on the T_EN bit
                                                     is detected (which means that the timer channel is disabled
                                                     and then enabled); when TSOT = 1, the channel timer will
                                                     restart after a rising edge on the selected trigger is
                                                     detected.                                                                 */
} LPIT0_TCTRL2_TSOI_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL2 TROT [18..18]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL2_TROT                                                         */
  LPIT0_TCTRL2_TROT_0                  = 0,     /*!< 0 : Timer will not reload on selected trigger                             */
  LPIT0_TCTRL2_TROT_1                  = 1,     /*!< 1 : Timer will reload on selected trigger                                 */
} LPIT0_TCTRL2_TROT_Enum;

/* ==========================================  LPIT0 LPIT0_TCTRL2 TRG_SRC [23..23]  ========================================== */
typedef enum {                                  /*!< LPIT0_TCTRL2_TRG_SRC                                                      */
  LPIT0_TCTRL2_TRG_SRC_0               = 0,     /*!< 0 : Trigger source selected in external                                   */
  LPIT0_TCTRL2_TRG_SRC_1               = 1,     /*!< 1 : Trigger source selected is the internal trigger                       */
} LPIT0_TCTRL2_TRG_SRC_Enum;

/* ======================================================  LPIT0_TVAL3  ====================================================== */
/* ===========================================  LPIT0 LPIT0_TVAL3 TMR_VAL [0..31]  =========================================== */
typedef enum {                                  /*!< LPIT0_TVAL3_TMR_VAL                                                       */
  LPIT0_TVAL3_TMR_VAL_0                = 0,     /*!< 0 : Invalid load value in compare modes.                                  */
  LPIT0_TVAL3_TMR_VAL_1                = 1,     /*!< 1 : Invalid load value in compare modes.                                  */
} LPIT0_TVAL3_TMR_VAL_Enum;

/* ======================================================  LPIT0_CVAL3  ====================================================== */
/* =====================================================  LPIT0_TCTRL3  ====================================================== */
/* ============================================  LPIT0 LPIT0_TCTRL3 T_EN [0..0]  ============================================= */
typedef enum {                                  /*!< LPIT0_TCTRL3_T_EN                                                         */
  LPIT0_TCTRL3_T_EN_0                  = 0,     /*!< 0 : Timer Channel is disabled                                             */
  LPIT0_TCTRL3_T_EN_1                  = 1,     /*!< 1 : Timer Channel is enabled                                              */
} LPIT0_TCTRL3_T_EN_Enum;

/* ============================================  LPIT0 LPIT0_TCTRL3 CHAIN [1..1]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL3_CHAIN                                                        */
  LPIT0_TCTRL3_CHAIN_0                 = 0,     /*!< 0 : Channel Chaining is disabled. Channel Timer runs independently.       */
  LPIT0_TCTRL3_CHAIN_1                 = 1,     /*!< 1 : Channel Chaining is enabled. Timer decrements on previous
                                                     channels timeout                                                          */
} LPIT0_TCTRL3_CHAIN_Enum;

/* ============================================  LPIT0 LPIT0_TCTRL3 MODE [2..3]  ============================================= */
typedef enum {                                  /*!< LPIT0_TCTRL3_MODE                                                         */
  LPIT0_TCTRL3_MODE_0                  = 0,     /*!< 0 : 32-bit Periodic Counter                                               */
  LPIT0_TCTRL3_MODE_1                  = 1,     /*!< 1 : Dual 16-bit Periodic Counter                                          */
  LPIT0_TCTRL3_MODE_10                 = 2,     /*!< 10 : 32-bit Trigger Accumulator                                           */
  LPIT0_TCTRL3_MODE_11                 = 3,     /*!< 11 : 32-bit Trigger Input Capture                                         */
} LPIT0_TCTRL3_MODE_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL3 TSOT [16..16]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL3_TSOT                                                         */
  LPIT0_TCTRL3_TSOT_0                  = 0,     /*!< 0 : Timer starts to decrement immediately based on restart condition
                                                     (controlled by TSOI bit)                                                  */
  LPIT0_TCTRL3_TSOT_1                  = 1,     /*!< 1 : Timer starts to decrement when rising edge on selected trigger
                                                     is detected                                                               */
} LPIT0_TCTRL3_TSOT_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL3 TSOI [17..17]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL3_TSOI                                                         */
  LPIT0_TCTRL3_TSOI_0                  = 0,     /*!< 0 : The channel timer does not stop after timeout.                        */
  LPIT0_TCTRL3_TSOI_1                  = 1,     /*!< 1 : The channel timer will stop after a timeout, and the channel
                                                     timer will restart based on TSOT. When TSOT = 0, the channel
                                                     timer will restart after a rising edge on the T_EN bit
                                                     is detected (which means that the timer channel is disabled
                                                     and then enabled); when TSOT = 1, the channel timer will
                                                     restart after a rising edge on the selected trigger is
                                                     detected.                                                                 */
} LPIT0_TCTRL3_TSOI_Enum;

/* ===========================================  LPIT0 LPIT0_TCTRL3 TROT [18..18]  ============================================ */
typedef enum {                                  /*!< LPIT0_TCTRL3_TROT                                                         */
  LPIT0_TCTRL3_TROT_0                  = 0,     /*!< 0 : Timer will not reload on selected trigger                             */
  LPIT0_TCTRL3_TROT_1                  = 1,     /*!< 1 : Timer will reload on selected trigger                                 */
} LPIT0_TCTRL3_TROT_Enum;

/* ==========================================  LPIT0 LPIT0_TCTRL3 TRG_SRC [23..23]  ========================================== */
typedef enum {                                  /*!< LPIT0_TCTRL3_TRG_SRC                                                      */
  LPIT0_TCTRL3_TRG_SRC_0               = 0,     /*!< 0 : Trigger source selected in external                                   */
  LPIT0_TCTRL3_TRG_SRC_1               = 1,     /*!< 1 : Trigger source selected is the internal trigger                       */
} LPIT0_TCTRL3_TRG_SRC_Enum;



/* =========================================================================================================================== */
/* ================                                           FTM0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  FTM0_SC  ======================================================== */
/* ================================================  FTM0 FTM0_SC PS [0..2]  ================================================= */
typedef enum {                                  /*!< FTM0_SC_PS                                                                */
  FTM0_SC_PS_000                       = 0,     /*!< 000 : Divide by 1                                                         */
  FTM0_SC_PS_001                       = 1,     /*!< 001 : Divide by 2                                                         */
  FTM0_SC_PS_010                       = 2,     /*!< 010 : Divide by 4                                                         */
  FTM0_SC_PS_011                       = 3,     /*!< 011 : Divide by 8                                                         */
  FTM0_SC_PS_100                       = 4,     /*!< 100 : Divide by 16                                                        */
  FTM0_SC_PS_101                       = 5,     /*!< 101 : Divide by 32                                                        */
  FTM0_SC_PS_110                       = 6,     /*!< 110 : Divide by 64                                                        */
  FTM0_SC_PS_111                       = 7,     /*!< 111 : Divide by 128                                                       */
} FTM0_SC_PS_Enum;

/* ===============================================  FTM0 FTM0_SC CLKS [3..4]  ================================================ */
typedef enum {                                  /*!< FTM0_SC_CLKS                                                              */
  FTM0_SC_CLKS_00                      = 0,     /*!< 00 : No clock selected. This in effect disables the FTM counter.          */
  FTM0_SC_CLKS_01                      = 1,     /*!< 01 : FTM input clock                                                      */
  FTM0_SC_CLKS_10                      = 2,     /*!< 10 : Fixed frequency clock                                                */
  FTM0_SC_CLKS_11                      = 3,     /*!< 11 : External clock                                                       */
} FTM0_SC_CLKS_Enum;

/* ===============================================  FTM0 FTM0_SC CPWMS [5..5]  =============================================== */
typedef enum {                                  /*!< FTM0_SC_CPWMS                                                             */
  FTM0_SC_CPWMS_0                      = 0,     /*!< 0 : FTM counter operates in Up Counting mode.                             */
  FTM0_SC_CPWMS_1                      = 1,     /*!< 1 : FTM counter operates in Up-Down Counting mode.                        */
} FTM0_SC_CPWMS_Enum;

/* ================================================  FTM0 FTM0_SC RIE [6..6]  ================================================ */
typedef enum {                                  /*!< FTM0_SC_RIE                                                               */
  FTM0_SC_RIE_0                        = 0,     /*!< 0 : Reload point interrupt is disabled.                                   */
  FTM0_SC_RIE_1                        = 1,     /*!< 1 : Reload point interrupt is enabled.                                    */
} FTM0_SC_RIE_Enum;

/* ================================================  FTM0 FTM0_SC RF [7..7]  ================================================= */
typedef enum {                                  /*!< FTM0_SC_RF                                                                */
  FTM0_SC_RF_0                         = 0,     /*!< 0 : A selected reload point did not happen.                               */
  FTM0_SC_RF_1                         = 1,     /*!< 1 : A selected reload point happened.                                     */
} FTM0_SC_RF_Enum;

/* ===============================================  FTM0 FTM0_SC TOIE [8..8]  ================================================ */
typedef enum {                                  /*!< FTM0_SC_TOIE                                                              */
  FTM0_SC_TOIE_0                       = 0,     /*!< 0 : Disable TOF interrupts. Use software polling.                         */
  FTM0_SC_TOIE_1                       = 1,     /*!< 1 : Enable TOF interrupts. An interrupt is generated when TOF
                                                     equals one.                                                               */
} FTM0_SC_TOIE_Enum;

/* ================================================  FTM0 FTM0_SC TOF [9..9]  ================================================ */
typedef enum {                                  /*!< FTM0_SC_TOF                                                               */
  FTM0_SC_TOF_0                        = 0,     /*!< 0 : FTM counter has not overflowed.                                       */
  FTM0_SC_TOF_1                        = 1,     /*!< 1 : FTM counter has overflowed.                                           */
} FTM0_SC_TOF_Enum;

/* =============================================  FTM0 FTM0_SC PWMEN0 [16..16]  ============================================== */
typedef enum {                                  /*!< FTM0_SC_PWMEN0                                                            */
  FTM0_SC_PWMEN0_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM0_SC_PWMEN0_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM0_SC_PWMEN0_Enum;

/* =============================================  FTM0 FTM0_SC PWMEN1 [17..17]  ============================================== */
typedef enum {                                  /*!< FTM0_SC_PWMEN1                                                            */
  FTM0_SC_PWMEN1_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM0_SC_PWMEN1_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM0_SC_PWMEN1_Enum;

/* =============================================  FTM0 FTM0_SC PWMEN2 [18..18]  ============================================== */
typedef enum {                                  /*!< FTM0_SC_PWMEN2                                                            */
  FTM0_SC_PWMEN2_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM0_SC_PWMEN2_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM0_SC_PWMEN2_Enum;

/* =============================================  FTM0 FTM0_SC PWMEN3 [19..19]  ============================================== */
typedef enum {                                  /*!< FTM0_SC_PWMEN3                                                            */
  FTM0_SC_PWMEN3_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM0_SC_PWMEN3_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM0_SC_PWMEN3_Enum;

/* =============================================  FTM0 FTM0_SC PWMEN4 [20..20]  ============================================== */
typedef enum {                                  /*!< FTM0_SC_PWMEN4                                                            */
  FTM0_SC_PWMEN4_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM0_SC_PWMEN4_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM0_SC_PWMEN4_Enum;

/* =============================================  FTM0 FTM0_SC PWMEN5 [21..21]  ============================================== */
typedef enum {                                  /*!< FTM0_SC_PWMEN5                                                            */
  FTM0_SC_PWMEN5_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM0_SC_PWMEN5_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM0_SC_PWMEN5_Enum;

/* =============================================  FTM0 FTM0_SC PWMEN6 [22..22]  ============================================== */
typedef enum {                                  /*!< FTM0_SC_PWMEN6                                                            */
  FTM0_SC_PWMEN6_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM0_SC_PWMEN6_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM0_SC_PWMEN6_Enum;

/* =============================================  FTM0 FTM0_SC PWMEN7 [23..23]  ============================================== */
typedef enum {                                  /*!< FTM0_SC_PWMEN7                                                            */
  FTM0_SC_PWMEN7_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM0_SC_PWMEN7_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM0_SC_PWMEN7_Enum;

/* ==============================================  FTM0 FTM0_SC FLTPS [24..27]  ============================================== */
typedef enum {                                  /*!< FTM0_SC_FLTPS                                                             */
  FTM0_SC_FLTPS_0000                   = 0,     /*!< 0000 : Divide by 1                                                        */
  FTM0_SC_FLTPS_0001                   = 1,     /*!< 0001 : Divide by 2                                                        */
  FTM0_SC_FLTPS_0010                   = 2,     /*!< 0010 : Divide by 3                                                        */
  FTM0_SC_FLTPS_0011                   = 3,     /*!< 0011 : Divide by 4                                                        */
  FTM0_SC_FLTPS_0100                   = 4,     /*!< 0100 : Divide by 5                                                        */
  FTM0_SC_FLTPS_0101                   = 5,     /*!< 0101 : Divide by 6                                                        */
  FTM0_SC_FLTPS_0110                   = 6,     /*!< 0110 : Divide by 7                                                        */
  FTM0_SC_FLTPS_0111                   = 7,     /*!< 0111 : Divide by 8                                                        */
  FTM0_SC_FLTPS_1000                   = 8,     /*!< 1000 : Divide by 9                                                        */
  FTM0_SC_FLTPS_1001                   = 9,     /*!< 1001 : Divide by 10                                                       */
  FTM0_SC_FLTPS_1010                   = 10,    /*!< 1010 : Divide by 11                                                       */
  FTM0_SC_FLTPS_1011                   = 11,    /*!< 1011 : Divide by 12                                                       */
  FTM0_SC_FLTPS_1100                   = 12,    /*!< 1100 : Divide by 13                                                       */
  FTM0_SC_FLTPS_1101                   = 13,    /*!< 1101 : Divide by 14                                                       */
  FTM0_SC_FLTPS_1110                   = 14,    /*!< 1110 : Divide by 15                                                       */
  FTM0_SC_FLTPS_1111                   = 15,    /*!< 1111 : Divide by 16                                                       */
} FTM0_SC_FLTPS_Enum;

/* =======================================================  FTM0_CNT  ======================================================== */
/* =======================================================  FTM0_MOD  ======================================================== */
/* =======================================================  FTM0_C0SC  ======================================================= */
/* ===============================================  FTM0 FTM0_C0SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM0_C0SC_DMA                                                             */
  FTM0_C0SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM0_C0SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM0_C0SC_DMA_Enum;

/* ==============================================  FTM0 FTM0_C0SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_C0SC_ICRST                                                           */
  FTM0_C0SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM0_C0SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM0_C0SC_ICRST_Enum;

/* ==============================================  FTM0 FTM0_C0SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM0_C0SC_CHIE                                                            */
  FTM0_C0SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM0_C0SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM0_C0SC_CHIE_Enum;

/* ===============================================  FTM0 FTM0_C0SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM0_C0SC_CHF                                                             */
  FTM0_C0SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM0_C0SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM0_C0SC_CHF_Enum;

/* ============================================  FTM0 FTM0_C0SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM0_C0SC_TRIGMODE                                                        */
  FTM0_C0SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM0_C0SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM0_C0SC_TRIGMODE_Enum;

/* ==============================================  FTM0 FTM0_C0SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM0_C0SC_CHIS                                                            */
  FTM0_C0SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM0_C0SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM0_C0SC_CHIS_Enum;

/* =============================================  FTM0 FTM0_C0SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM0_C0SC_CHOV                                                            */
  FTM0_C0SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM0_C0SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM0_C0SC_CHOV_Enum;

/* =======================================================  FTM0_C0V  ======================================================== */
/* =======================================================  FTM0_C1SC  ======================================================= */
/* ===============================================  FTM0 FTM0_C1SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM0_C1SC_DMA                                                             */
  FTM0_C1SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM0_C1SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM0_C1SC_DMA_Enum;

/* ==============================================  FTM0 FTM0_C1SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_C1SC_ICRST                                                           */
  FTM0_C1SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM0_C1SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM0_C1SC_ICRST_Enum;

/* ==============================================  FTM0 FTM0_C1SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM0_C1SC_CHIE                                                            */
  FTM0_C1SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM0_C1SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM0_C1SC_CHIE_Enum;

/* ===============================================  FTM0 FTM0_C1SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM0_C1SC_CHF                                                             */
  FTM0_C1SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM0_C1SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM0_C1SC_CHF_Enum;

/* ============================================  FTM0 FTM0_C1SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM0_C1SC_TRIGMODE                                                        */
  FTM0_C1SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM0_C1SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM0_C1SC_TRIGMODE_Enum;

/* ==============================================  FTM0 FTM0_C1SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM0_C1SC_CHIS                                                            */
  FTM0_C1SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM0_C1SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM0_C1SC_CHIS_Enum;

/* =============================================  FTM0 FTM0_C1SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM0_C1SC_CHOV                                                            */
  FTM0_C1SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM0_C1SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM0_C1SC_CHOV_Enum;

/* =======================================================  FTM0_C1V  ======================================================== */
/* =======================================================  FTM0_C2SC  ======================================================= */
/* ===============================================  FTM0 FTM0_C2SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM0_C2SC_DMA                                                             */
  FTM0_C2SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM0_C2SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM0_C2SC_DMA_Enum;

/* ==============================================  FTM0 FTM0_C2SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_C2SC_ICRST                                                           */
  FTM0_C2SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM0_C2SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM0_C2SC_ICRST_Enum;

/* ==============================================  FTM0 FTM0_C2SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM0_C2SC_CHIE                                                            */
  FTM0_C2SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM0_C2SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM0_C2SC_CHIE_Enum;

/* ===============================================  FTM0 FTM0_C2SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM0_C2SC_CHF                                                             */
  FTM0_C2SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM0_C2SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM0_C2SC_CHF_Enum;

/* ============================================  FTM0 FTM0_C2SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM0_C2SC_TRIGMODE                                                        */
  FTM0_C2SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM0_C2SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM0_C2SC_TRIGMODE_Enum;

/* ==============================================  FTM0 FTM0_C2SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM0_C2SC_CHIS                                                            */
  FTM0_C2SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM0_C2SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM0_C2SC_CHIS_Enum;

/* =============================================  FTM0 FTM0_C2SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM0_C2SC_CHOV                                                            */
  FTM0_C2SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM0_C2SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM0_C2SC_CHOV_Enum;

/* =======================================================  FTM0_C2V  ======================================================== */
/* =======================================================  FTM0_C3SC  ======================================================= */
/* ===============================================  FTM0 FTM0_C3SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM0_C3SC_DMA                                                             */
  FTM0_C3SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM0_C3SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM0_C3SC_DMA_Enum;

/* ==============================================  FTM0 FTM0_C3SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_C3SC_ICRST                                                           */
  FTM0_C3SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM0_C3SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM0_C3SC_ICRST_Enum;

/* ==============================================  FTM0 FTM0_C3SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM0_C3SC_CHIE                                                            */
  FTM0_C3SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM0_C3SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM0_C3SC_CHIE_Enum;

/* ===============================================  FTM0 FTM0_C3SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM0_C3SC_CHF                                                             */
  FTM0_C3SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM0_C3SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM0_C3SC_CHF_Enum;

/* ============================================  FTM0 FTM0_C3SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM0_C3SC_TRIGMODE                                                        */
  FTM0_C3SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM0_C3SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM0_C3SC_TRIGMODE_Enum;

/* ==============================================  FTM0 FTM0_C3SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM0_C3SC_CHIS                                                            */
  FTM0_C3SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM0_C3SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM0_C3SC_CHIS_Enum;

/* =============================================  FTM0 FTM0_C3SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM0_C3SC_CHOV                                                            */
  FTM0_C3SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM0_C3SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM0_C3SC_CHOV_Enum;

/* =======================================================  FTM0_C3V  ======================================================== */
/* =======================================================  FTM0_C4SC  ======================================================= */
/* ===============================================  FTM0 FTM0_C4SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM0_C4SC_DMA                                                             */
  FTM0_C4SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM0_C4SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM0_C4SC_DMA_Enum;

/* ==============================================  FTM0 FTM0_C4SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_C4SC_ICRST                                                           */
  FTM0_C4SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM0_C4SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM0_C4SC_ICRST_Enum;

/* ==============================================  FTM0 FTM0_C4SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM0_C4SC_CHIE                                                            */
  FTM0_C4SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM0_C4SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM0_C4SC_CHIE_Enum;

/* ===============================================  FTM0 FTM0_C4SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM0_C4SC_CHF                                                             */
  FTM0_C4SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM0_C4SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM0_C4SC_CHF_Enum;

/* ============================================  FTM0 FTM0_C4SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM0_C4SC_TRIGMODE                                                        */
  FTM0_C4SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM0_C4SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM0_C4SC_TRIGMODE_Enum;

/* ==============================================  FTM0 FTM0_C4SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM0_C4SC_CHIS                                                            */
  FTM0_C4SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM0_C4SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM0_C4SC_CHIS_Enum;

/* =============================================  FTM0 FTM0_C4SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM0_C4SC_CHOV                                                            */
  FTM0_C4SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM0_C4SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM0_C4SC_CHOV_Enum;

/* =======================================================  FTM0_C4V  ======================================================== */
/* =======================================================  FTM0_C5SC  ======================================================= */
/* ===============================================  FTM0 FTM0_C5SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM0_C5SC_DMA                                                             */
  FTM0_C5SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM0_C5SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM0_C5SC_DMA_Enum;

/* ==============================================  FTM0 FTM0_C5SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_C5SC_ICRST                                                           */
  FTM0_C5SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM0_C5SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM0_C5SC_ICRST_Enum;

/* ==============================================  FTM0 FTM0_C5SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM0_C5SC_CHIE                                                            */
  FTM0_C5SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM0_C5SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM0_C5SC_CHIE_Enum;

/* ===============================================  FTM0 FTM0_C5SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM0_C5SC_CHF                                                             */
  FTM0_C5SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM0_C5SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM0_C5SC_CHF_Enum;

/* ============================================  FTM0 FTM0_C5SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM0_C5SC_TRIGMODE                                                        */
  FTM0_C5SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM0_C5SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM0_C5SC_TRIGMODE_Enum;

/* ==============================================  FTM0 FTM0_C5SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM0_C5SC_CHIS                                                            */
  FTM0_C5SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM0_C5SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM0_C5SC_CHIS_Enum;

/* =============================================  FTM0 FTM0_C5SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM0_C5SC_CHOV                                                            */
  FTM0_C5SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM0_C5SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM0_C5SC_CHOV_Enum;

/* =======================================================  FTM0_C5V  ======================================================== */
/* =======================================================  FTM0_C6SC  ======================================================= */
/* ===============================================  FTM0 FTM0_C6SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM0_C6SC_DMA                                                             */
  FTM0_C6SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM0_C6SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM0_C6SC_DMA_Enum;

/* ==============================================  FTM0 FTM0_C6SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_C6SC_ICRST                                                           */
  FTM0_C6SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM0_C6SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM0_C6SC_ICRST_Enum;

/* ==============================================  FTM0 FTM0_C6SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM0_C6SC_CHIE                                                            */
  FTM0_C6SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM0_C6SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM0_C6SC_CHIE_Enum;

/* ===============================================  FTM0 FTM0_C6SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM0_C6SC_CHF                                                             */
  FTM0_C6SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM0_C6SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM0_C6SC_CHF_Enum;

/* ============================================  FTM0 FTM0_C6SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM0_C6SC_TRIGMODE                                                        */
  FTM0_C6SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM0_C6SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM0_C6SC_TRIGMODE_Enum;

/* ==============================================  FTM0 FTM0_C6SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM0_C6SC_CHIS                                                            */
  FTM0_C6SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM0_C6SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM0_C6SC_CHIS_Enum;

/* =============================================  FTM0 FTM0_C6SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM0_C6SC_CHOV                                                            */
  FTM0_C6SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM0_C6SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM0_C6SC_CHOV_Enum;

/* =======================================================  FTM0_C6V  ======================================================== */
/* =======================================================  FTM0_C7SC  ======================================================= */
/* ===============================================  FTM0 FTM0_C7SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM0_C7SC_DMA                                                             */
  FTM0_C7SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM0_C7SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM0_C7SC_DMA_Enum;

/* ==============================================  FTM0 FTM0_C7SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_C7SC_ICRST                                                           */
  FTM0_C7SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM0_C7SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM0_C7SC_ICRST_Enum;

/* ==============================================  FTM0 FTM0_C7SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM0_C7SC_CHIE                                                            */
  FTM0_C7SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM0_C7SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM0_C7SC_CHIE_Enum;

/* ===============================================  FTM0 FTM0_C7SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM0_C7SC_CHF                                                             */
  FTM0_C7SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM0_C7SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM0_C7SC_CHF_Enum;

/* ============================================  FTM0 FTM0_C7SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM0_C7SC_TRIGMODE                                                        */
  FTM0_C7SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM0_C7SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM0_C7SC_TRIGMODE_Enum;

/* ==============================================  FTM0 FTM0_C7SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM0_C7SC_CHIS                                                            */
  FTM0_C7SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM0_C7SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM0_C7SC_CHIS_Enum;

/* =============================================  FTM0 FTM0_C7SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM0_C7SC_CHOV                                                            */
  FTM0_C7SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM0_C7SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM0_C7SC_CHOV_Enum;

/* =======================================================  FTM0_C7V  ======================================================== */
/* ======================================================  FTM0_CNTIN  ======================================================= */
/* ======================================================  FTM0_STATUS  ====================================================== */
/* =============================================  FTM0 FTM0_STATUS CH0F [0..0]  ============================================== */
typedef enum {                                  /*!< FTM0_STATUS_CH0F                                                          */
  FTM0_STATUS_CH0F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM0_STATUS_CH0F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM0_STATUS_CH0F_Enum;

/* =============================================  FTM0 FTM0_STATUS CH1F [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_STATUS_CH1F                                                          */
  FTM0_STATUS_CH1F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM0_STATUS_CH1F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM0_STATUS_CH1F_Enum;

/* =============================================  FTM0 FTM0_STATUS CH2F [2..2]  ============================================== */
typedef enum {                                  /*!< FTM0_STATUS_CH2F                                                          */
  FTM0_STATUS_CH2F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM0_STATUS_CH2F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM0_STATUS_CH2F_Enum;

/* =============================================  FTM0 FTM0_STATUS CH3F [3..3]  ============================================== */
typedef enum {                                  /*!< FTM0_STATUS_CH3F                                                          */
  FTM0_STATUS_CH3F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM0_STATUS_CH3F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM0_STATUS_CH3F_Enum;

/* =============================================  FTM0 FTM0_STATUS CH4F [4..4]  ============================================== */
typedef enum {                                  /*!< FTM0_STATUS_CH4F                                                          */
  FTM0_STATUS_CH4F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM0_STATUS_CH4F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM0_STATUS_CH4F_Enum;

/* =============================================  FTM0 FTM0_STATUS CH5F [5..5]  ============================================== */
typedef enum {                                  /*!< FTM0_STATUS_CH5F                                                          */
  FTM0_STATUS_CH5F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM0_STATUS_CH5F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM0_STATUS_CH5F_Enum;

/* =============================================  FTM0 FTM0_STATUS CH6F [6..6]  ============================================== */
typedef enum {                                  /*!< FTM0_STATUS_CH6F                                                          */
  FTM0_STATUS_CH6F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM0_STATUS_CH6F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM0_STATUS_CH6F_Enum;

/* =============================================  FTM0 FTM0_STATUS CH7F [7..7]  ============================================== */
typedef enum {                                  /*!< FTM0_STATUS_CH7F                                                          */
  FTM0_STATUS_CH7F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM0_STATUS_CH7F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM0_STATUS_CH7F_Enum;

/* =======================================================  FTM0_MODE  ======================================================= */
/* ==============================================  FTM0 FTM0_MODE FTMEN [0..0]  ============================================== */
typedef enum {                                  /*!< FTM0_MODE_FTMEN                                                           */
  FTM0_MODE_FTMEN_0                    = 0,     /*!< 0 : TPM compatibility. Free running counter and synchronization
                                                     compatible with TPM.                                                      */
  FTM0_MODE_FTMEN_1                    = 1,     /*!< 1 : Free running counter and synchronization are different from
                                                     TPM behavior.                                                             */
} FTM0_MODE_FTMEN_Enum;

/* ==============================================  FTM0 FTM0_MODE WPDIS [2..2]  ============================================== */
typedef enum {                                  /*!< FTM0_MODE_WPDIS                                                           */
  FTM0_MODE_WPDIS_0                    = 0,     /*!< 0 : Write protection is enabled.                                          */
  FTM0_MODE_WPDIS_1                    = 1,     /*!< 1 : Write protection is disabled.                                         */
} FTM0_MODE_WPDIS_Enum;

/* =============================================  FTM0 FTM0_MODE PWMSYNC [3..3]  ============================================= */
typedef enum {                                  /*!< FTM0_MODE_PWMSYNC                                                         */
  FTM0_MODE_PWMSYNC_0                  = 0,     /*!< 0 : No restrictions. Software and hardware triggers can be used
                                                     by MOD, CnV, OUTMASK, and FTM counter synchronization.                    */
  FTM0_MODE_PWMSYNC_1                  = 1,     /*!< 1 : Software trigger can only be used by MOD and CnV synchronization,
                                                     and hardware triggers can only be used by OUTMASK and FTM
                                                     counter synchronization.                                                  */
} FTM0_MODE_PWMSYNC_Enum;

/* =============================================  FTM0 FTM0_MODE CAPTEST [4..4]  ============================================= */
typedef enum {                                  /*!< FTM0_MODE_CAPTEST                                                         */
  FTM0_MODE_CAPTEST_0                  = 0,     /*!< 0 : Capture test mode is disabled.                                        */
  FTM0_MODE_CAPTEST_1                  = 1,     /*!< 1 : Capture test mode is enabled.                                         */
} FTM0_MODE_CAPTEST_Enum;

/* =============================================  FTM0 FTM0_MODE FAULTM [5..6]  ============================================== */
typedef enum {                                  /*!< FTM0_MODE_FAULTM                                                          */
  FTM0_MODE_FAULTM_00                  = 0,     /*!< 00 : Fault control is disabled for all channels.                          */
  FTM0_MODE_FAULTM_01                  = 1,     /*!< 01 : Fault control is enabled for even channels only (channels
                                                     0, 2, 4, and 6), and the selected mode is the manual fault
                                                     clearing.                                                                 */
  FTM0_MODE_FAULTM_10                  = 2,     /*!< 10 : Fault control is enabled for all channels, and the selected
                                                     mode is the manual fault clearing.                                        */
  FTM0_MODE_FAULTM_11                  = 3,     /*!< 11 : Fault control is enabled for all channels, and the selected
                                                     mode is the automatic fault clearing.                                     */
} FTM0_MODE_FAULTM_Enum;

/* =============================================  FTM0 FTM0_MODE FAULTIE [7..7]  ============================================= */
typedef enum {                                  /*!< FTM0_MODE_FAULTIE                                                         */
  FTM0_MODE_FAULTIE_0                  = 0,     /*!< 0 : Fault control interrupt is disabled.                                  */
  FTM0_MODE_FAULTIE_1                  = 1,     /*!< 1 : Fault control interrupt is enabled.                                   */
} FTM0_MODE_FAULTIE_Enum;

/* =======================================================  FTM0_SYNC  ======================================================= */
/* =============================================  FTM0 FTM0_SYNC CNTMIN [0..0]  ============================================== */
typedef enum {                                  /*!< FTM0_SYNC_CNTMIN                                                          */
  FTM0_SYNC_CNTMIN_0                   = 0,     /*!< 0 : The minimum loading point is disabled.                                */
  FTM0_SYNC_CNTMIN_1                   = 1,     /*!< 1 : The minimum loading point is enabled.                                 */
} FTM0_SYNC_CNTMIN_Enum;

/* =============================================  FTM0 FTM0_SYNC CNTMAX [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_SYNC_CNTMAX                                                          */
  FTM0_SYNC_CNTMAX_0                   = 0,     /*!< 0 : The maximum loading point is disabled.                                */
  FTM0_SYNC_CNTMAX_1                   = 1,     /*!< 1 : The maximum loading point is enabled.                                 */
} FTM0_SYNC_CNTMAX_Enum;

/* =============================================  FTM0 FTM0_SYNC REINIT [2..2]  ============================================== */
typedef enum {                                  /*!< FTM0_SYNC_REINIT                                                          */
  FTM0_SYNC_REINIT_0                   = 0,     /*!< 0 : FTM counter continues to count normally.                              */
  FTM0_SYNC_REINIT_1                   = 1,     /*!< 1 : FTM counter is updated with its initial value when the selected
                                                     trigger is detected.                                                      */
} FTM0_SYNC_REINIT_Enum;

/* =============================================  FTM0 FTM0_SYNC SYNCHOM [3..3]  ============================================= */
typedef enum {                                  /*!< FTM0_SYNC_SYNCHOM                                                         */
  FTM0_SYNC_SYNCHOM_0                  = 0,     /*!< 0 : OUTMASK register is updated with the value of its buffer
                                                     in all rising edges of the FTM input clock.                               */
  FTM0_SYNC_SYNCHOM_1                  = 1,     /*!< 1 : OUTMASK register is updated with the value of its buffer
                                                     only by the PWM synchronization.                                          */
} FTM0_SYNC_SYNCHOM_Enum;

/* ==============================================  FTM0 FTM0_SYNC TRIG0 [4..4]  ============================================== */
typedef enum {                                  /*!< FTM0_SYNC_TRIG0                                                           */
  FTM0_SYNC_TRIG0_0                    = 0,     /*!< 0 : Trigger is disabled.                                                  */
  FTM0_SYNC_TRIG0_1                    = 1,     /*!< 1 : Trigger is enabled.                                                   */
} FTM0_SYNC_TRIG0_Enum;

/* ==============================================  FTM0 FTM0_SYNC TRIG1 [5..5]  ============================================== */
typedef enum {                                  /*!< FTM0_SYNC_TRIG1                                                           */
  FTM0_SYNC_TRIG1_0                    = 0,     /*!< 0 : Trigger is disabled.                                                  */
  FTM0_SYNC_TRIG1_1                    = 1,     /*!< 1 : Trigger is enabled.                                                   */
} FTM0_SYNC_TRIG1_Enum;

/* ==============================================  FTM0 FTM0_SYNC TRIG2 [6..6]  ============================================== */
typedef enum {                                  /*!< FTM0_SYNC_TRIG2                                                           */
  FTM0_SYNC_TRIG2_0                    = 0,     /*!< 0 : Trigger is disabled.                                                  */
  FTM0_SYNC_TRIG2_1                    = 1,     /*!< 1 : Trigger is enabled.                                                   */
} FTM0_SYNC_TRIG2_Enum;

/* =============================================  FTM0 FTM0_SYNC SWSYNC [7..7]  ============================================== */
typedef enum {                                  /*!< FTM0_SYNC_SWSYNC                                                          */
  FTM0_SYNC_SWSYNC_0                   = 0,     /*!< 0 : Software trigger is not selected.                                     */
  FTM0_SYNC_SWSYNC_1                   = 1,     /*!< 1 : Software trigger is selected.                                         */
} FTM0_SYNC_SWSYNC_Enum;

/* =====================================================  FTM0_OUTINIT  ====================================================== */
/* ============================================  FTM0 FTM0_OUTINIT CH0OI [0..0]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTINIT_CH0OI                                                        */
  FTM0_OUTINIT_CH0OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM0_OUTINIT_CH0OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM0_OUTINIT_CH0OI_Enum;

/* ============================================  FTM0 FTM0_OUTINIT CH1OI [1..1]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTINIT_CH1OI                                                        */
  FTM0_OUTINIT_CH1OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM0_OUTINIT_CH1OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM0_OUTINIT_CH1OI_Enum;

/* ============================================  FTM0 FTM0_OUTINIT CH2OI [2..2]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTINIT_CH2OI                                                        */
  FTM0_OUTINIT_CH2OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM0_OUTINIT_CH2OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM0_OUTINIT_CH2OI_Enum;

/* ============================================  FTM0 FTM0_OUTINIT CH3OI [3..3]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTINIT_CH3OI                                                        */
  FTM0_OUTINIT_CH3OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM0_OUTINIT_CH3OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM0_OUTINIT_CH3OI_Enum;

/* ============================================  FTM0 FTM0_OUTINIT CH4OI [4..4]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTINIT_CH4OI                                                        */
  FTM0_OUTINIT_CH4OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM0_OUTINIT_CH4OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM0_OUTINIT_CH4OI_Enum;

/* ============================================  FTM0 FTM0_OUTINIT CH5OI [5..5]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTINIT_CH5OI                                                        */
  FTM0_OUTINIT_CH5OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM0_OUTINIT_CH5OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM0_OUTINIT_CH5OI_Enum;

/* ============================================  FTM0 FTM0_OUTINIT CH6OI [6..6]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTINIT_CH6OI                                                        */
  FTM0_OUTINIT_CH6OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM0_OUTINIT_CH6OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM0_OUTINIT_CH6OI_Enum;

/* ============================================  FTM0 FTM0_OUTINIT CH7OI [7..7]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTINIT_CH7OI                                                        */
  FTM0_OUTINIT_CH7OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM0_OUTINIT_CH7OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM0_OUTINIT_CH7OI_Enum;

/* =====================================================  FTM0_OUTMASK  ====================================================== */
/* ============================================  FTM0 FTM0_OUTMASK CH0OM [0..0]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTMASK_CH0OM                                                        */
  FTM0_OUTMASK_CH0OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM0_OUTMASK_CH0OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM0_OUTMASK_CH0OM_Enum;

/* ============================================  FTM0 FTM0_OUTMASK CH1OM [1..1]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTMASK_CH1OM                                                        */
  FTM0_OUTMASK_CH1OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM0_OUTMASK_CH1OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM0_OUTMASK_CH1OM_Enum;

/* ============================================  FTM0 FTM0_OUTMASK CH2OM [2..2]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTMASK_CH2OM                                                        */
  FTM0_OUTMASK_CH2OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM0_OUTMASK_CH2OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM0_OUTMASK_CH2OM_Enum;

/* ============================================  FTM0 FTM0_OUTMASK CH3OM [3..3]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTMASK_CH3OM                                                        */
  FTM0_OUTMASK_CH3OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM0_OUTMASK_CH3OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM0_OUTMASK_CH3OM_Enum;

/* ============================================  FTM0 FTM0_OUTMASK CH4OM [4..4]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTMASK_CH4OM                                                        */
  FTM0_OUTMASK_CH4OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM0_OUTMASK_CH4OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM0_OUTMASK_CH4OM_Enum;

/* ============================================  FTM0 FTM0_OUTMASK CH5OM [5..5]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTMASK_CH5OM                                                        */
  FTM0_OUTMASK_CH5OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM0_OUTMASK_CH5OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM0_OUTMASK_CH5OM_Enum;

/* ============================================  FTM0 FTM0_OUTMASK CH6OM [6..6]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTMASK_CH6OM                                                        */
  FTM0_OUTMASK_CH6OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM0_OUTMASK_CH6OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM0_OUTMASK_CH6OM_Enum;

/* ============================================  FTM0 FTM0_OUTMASK CH7OM [7..7]  ============================================= */
typedef enum {                                  /*!< FTM0_OUTMASK_CH7OM                                                        */
  FTM0_OUTMASK_CH7OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM0_OUTMASK_CH7OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM0_OUTMASK_CH7OM_Enum;

/* =====================================================  FTM0_COMBINE  ====================================================== */
/* ============================================  FTM0 FTM0_COMBINE COMP0 [1..1]  ============================================= */
typedef enum {                                  /*!< FTM0_COMBINE_COMP0                                                        */
  FTM0_COMBINE_COMP0_0                 = 0,     /*!< 0 : The channel (n+1) output is the same as the channel (n)
                                                     output.                                                                   */
  FTM0_COMBINE_COMP0_1                 = 1,     /*!< 1 : The channel (n+1) output is the complement of the channel
                                                     (n) output.                                                               */
} FTM0_COMBINE_COMP0_Enum;

/* ============================================  FTM0 FTM0_COMBINE DECAP0 [3..3]  ============================================ */
typedef enum {                                  /*!< FTM0_COMBINE_DECAP0                                                       */
  FTM0_COMBINE_DECAP0_0                = 0,     /*!< 0 : The dual edge captures are inactive.                                  */
  FTM0_COMBINE_DECAP0_1                = 1,     /*!< 1 : The dual edge captures are active.                                    */
} FTM0_COMBINE_DECAP0_Enum;

/* ============================================  FTM0 FTM0_COMBINE DTEN0 [4..4]  ============================================= */
typedef enum {                                  /*!< FTM0_COMBINE_DTEN0                                                        */
  FTM0_COMBINE_DTEN0_0                 = 0,     /*!< 0 : The deadtime insertion in this pair of channels is disabled.          */
  FTM0_COMBINE_DTEN0_1                 = 1,     /*!< 1 : The deadtime insertion in this pair of channels is enabled.           */
} FTM0_COMBINE_DTEN0_Enum;

/* ===========================================  FTM0 FTM0_COMBINE SYNCEN0 [5..5]  ============================================ */
typedef enum {                                  /*!< FTM0_COMBINE_SYNCEN0                                                      */
  FTM0_COMBINE_SYNCEN0_0               = 0,     /*!< 0 : The PWM synchronization in this pair of channels is disabled.         */
  FTM0_COMBINE_SYNCEN0_1               = 1,     /*!< 1 : The PWM synchronization in this pair of channels is enabled.          */
} FTM0_COMBINE_SYNCEN0_Enum;

/* ===========================================  FTM0 FTM0_COMBINE FAULTEN0 [6..6]  =========================================== */
typedef enum {                                  /*!< FTM0_COMBINE_FAULTEN0                                                     */
  FTM0_COMBINE_FAULTEN0_0              = 0,     /*!< 0 : The fault control in this pair of channels is disabled.               */
  FTM0_COMBINE_FAULTEN0_1              = 1,     /*!< 1 : The fault control in this pair of channels is enabled.                */
} FTM0_COMBINE_FAULTEN0_Enum;

/* ============================================  FTM0 FTM0_COMBINE COMP1 [9..9]  ============================================= */
typedef enum {                                  /*!< FTM0_COMBINE_COMP1                                                        */
  FTM0_COMBINE_COMP1_0                 = 0,     /*!< 0 : The channel (n+1) output is the same as the channel (n)
                                                     output.                                                                   */
  FTM0_COMBINE_COMP1_1                 = 1,     /*!< 1 : The channel (n+1) output is the complement of the channel
                                                     (n) output.                                                               */
} FTM0_COMBINE_COMP1_Enum;

/* ===========================================  FTM0 FTM0_COMBINE DECAP1 [11..11]  =========================================== */
typedef enum {                                  /*!< FTM0_COMBINE_DECAP1                                                       */
  FTM0_COMBINE_DECAP1_0                = 0,     /*!< 0 : The dual edge captures are inactive.                                  */
  FTM0_COMBINE_DECAP1_1                = 1,     /*!< 1 : The dual edge captures are active.                                    */
} FTM0_COMBINE_DECAP1_Enum;

/* ===========================================  FTM0 FTM0_COMBINE DTEN1 [12..12]  ============================================ */
typedef enum {                                  /*!< FTM0_COMBINE_DTEN1                                                        */
  FTM0_COMBINE_DTEN1_0                 = 0,     /*!< 0 : The deadtime insertion in this pair of channels is disabled.          */
  FTM0_COMBINE_DTEN1_1                 = 1,     /*!< 1 : The deadtime insertion in this pair of channels is enabled.           */
} FTM0_COMBINE_DTEN1_Enum;

/* ==========================================  FTM0 FTM0_COMBINE SYNCEN1 [13..13]  =========================================== */
typedef enum {                                  /*!< FTM0_COMBINE_SYNCEN1                                                      */
  FTM0_COMBINE_SYNCEN1_0               = 0,     /*!< 0 : The PWM synchronization in this pair of channels is disabled.         */
  FTM0_COMBINE_SYNCEN1_1               = 1,     /*!< 1 : The PWM synchronization in this pair of channels is enabled.          */
} FTM0_COMBINE_SYNCEN1_Enum;

/* ==========================================  FTM0 FTM0_COMBINE FAULTEN1 [14..14]  ========================================== */
typedef enum {                                  /*!< FTM0_COMBINE_FAULTEN1                                                     */
  FTM0_COMBINE_FAULTEN1_0              = 0,     /*!< 0 : The fault control in this pair of channels is disabled.               */
  FTM0_COMBINE_FAULTEN1_1              = 1,     /*!< 1 : The fault control in this pair of channels is enabled.                */
} FTM0_COMBINE_FAULTEN1_Enum;

/* ===========================================  FTM0 FTM0_COMBINE COMP2 [17..17]  ============================================ */
typedef enum {                                  /*!< FTM0_COMBINE_COMP2                                                        */
  FTM0_COMBINE_COMP2_0                 = 0,     /*!< 0 : The channel (n+1) output is the same as the channel (n)
                                                     output.                                                                   */
  FTM0_COMBINE_COMP2_1                 = 1,     /*!< 1 : The channel (n+1) output is the complement of the channel
                                                     (n) output.                                                               */
} FTM0_COMBINE_COMP2_Enum;

/* ===========================================  FTM0 FTM0_COMBINE DECAP2 [19..19]  =========================================== */
typedef enum {                                  /*!< FTM0_COMBINE_DECAP2                                                       */
  FTM0_COMBINE_DECAP2_0                = 0,     /*!< 0 : The dual edge captures are inactive.                                  */
  FTM0_COMBINE_DECAP2_1                = 1,     /*!< 1 : The dual edge captures are active.                                    */
} FTM0_COMBINE_DECAP2_Enum;

/* ===========================================  FTM0 FTM0_COMBINE DTEN2 [20..20]  ============================================ */
typedef enum {                                  /*!< FTM0_COMBINE_DTEN2                                                        */
  FTM0_COMBINE_DTEN2_0                 = 0,     /*!< 0 : The deadtime insertion in this pair of channels is disabled.          */
  FTM0_COMBINE_DTEN2_1                 = 1,     /*!< 1 : The deadtime insertion in this pair of channels is enabled.           */
} FTM0_COMBINE_DTEN2_Enum;

/* ==========================================  FTM0 FTM0_COMBINE SYNCEN2 [21..21]  =========================================== */
typedef enum {                                  /*!< FTM0_COMBINE_SYNCEN2                                                      */
  FTM0_COMBINE_SYNCEN2_0               = 0,     /*!< 0 : The PWM synchronization in this pair of channels is disabled.         */
  FTM0_COMBINE_SYNCEN2_1               = 1,     /*!< 1 : The PWM synchronization in this pair of channels is enabled.          */
} FTM0_COMBINE_SYNCEN2_Enum;

/* ==========================================  FTM0 FTM0_COMBINE FAULTEN2 [22..22]  ========================================== */
typedef enum {                                  /*!< FTM0_COMBINE_FAULTEN2                                                     */
  FTM0_COMBINE_FAULTEN2_0              = 0,     /*!< 0 : The fault control in this pair of channels is disabled.               */
  FTM0_COMBINE_FAULTEN2_1              = 1,     /*!< 1 : The fault control in this pair of channels is enabled.                */
} FTM0_COMBINE_FAULTEN2_Enum;

/* ===========================================  FTM0 FTM0_COMBINE COMP3 [25..25]  ============================================ */
typedef enum {                                  /*!< FTM0_COMBINE_COMP3                                                        */
  FTM0_COMBINE_COMP3_0                 = 0,     /*!< 0 : The channel (n+1) output is the same as the channel (n)
                                                     output.                                                                   */
  FTM0_COMBINE_COMP3_1                 = 1,     /*!< 1 : The channel (n+1) output is the complement of the channel
                                                     (n) output.                                                               */
} FTM0_COMBINE_COMP3_Enum;

/* ===========================================  FTM0 FTM0_COMBINE DECAP3 [27..27]  =========================================== */
typedef enum {                                  /*!< FTM0_COMBINE_DECAP3                                                       */
  FTM0_COMBINE_DECAP3_0                = 0,     /*!< 0 : The dual edge captures are inactive.                                  */
  FTM0_COMBINE_DECAP3_1                = 1,     /*!< 1 : The dual edge captures are active.                                    */
} FTM0_COMBINE_DECAP3_Enum;

/* ===========================================  FTM0 FTM0_COMBINE DTEN3 [28..28]  ============================================ */
typedef enum {                                  /*!< FTM0_COMBINE_DTEN3                                                        */
  FTM0_COMBINE_DTEN3_0                 = 0,     /*!< 0 : The deadtime insertion in this pair of channels is disabled.          */
  FTM0_COMBINE_DTEN3_1                 = 1,     /*!< 1 : The deadtime insertion in this pair of channels is enabled.           */
} FTM0_COMBINE_DTEN3_Enum;

/* ==========================================  FTM0 FTM0_COMBINE SYNCEN3 [29..29]  =========================================== */
typedef enum {                                  /*!< FTM0_COMBINE_SYNCEN3                                                      */
  FTM0_COMBINE_SYNCEN3_0               = 0,     /*!< 0 : The PWM synchronization in this pair of channels is disabled.         */
  FTM0_COMBINE_SYNCEN3_1               = 1,     /*!< 1 : The PWM synchronization in this pair of channels is enabled.          */
} FTM0_COMBINE_SYNCEN3_Enum;

/* ==========================================  FTM0 FTM0_COMBINE FAULTEN3 [30..30]  ========================================== */
typedef enum {                                  /*!< FTM0_COMBINE_FAULTEN3                                                     */
  FTM0_COMBINE_FAULTEN3_0              = 0,     /*!< 0 : The fault control in this pair of channels is disabled.               */
  FTM0_COMBINE_FAULTEN3_1              = 1,     /*!< 1 : The fault control in this pair of channels is enabled.                */
} FTM0_COMBINE_FAULTEN3_Enum;

/* =====================================================  FTM0_DEADTIME  ===================================================== */
/* ============================================  FTM0 FTM0_DEADTIME DTPS [6..7]  ============================================= */
typedef enum {                                  /*!< FTM0_DEADTIME_DTPS                                                        */
  FTM0_DEADTIME_DTPS_0x_0              = 0,     /*!< 0x_0 : Divide the FTM input clock by 1.                                   */
  FTM0_DEADTIME_DTPS_0x_1              = 1,     /*!< 0x_1 : Divide the FTM input clock by 1.                                   */
  FTM0_DEADTIME_DTPS_10                = 2,     /*!< 10 : Divide the FTM input clock by 4.                                     */
  FTM0_DEADTIME_DTPS_11                = 3,     /*!< 11 : Divide the FTM input clock by 16.                                    */
} FTM0_DEADTIME_DTPS_Enum;

/* =====================================================  FTM0_EXTTRIG  ====================================================== */
/* ===========================================  FTM0 FTM0_EXTTRIG CH2TRIG [0..0]  ============================================ */
typedef enum {                                  /*!< FTM0_EXTTRIG_CH2TRIG                                                      */
  FTM0_EXTTRIG_CH2TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM0_EXTTRIG_CH2TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM0_EXTTRIG_CH2TRIG_Enum;

/* ===========================================  FTM0 FTM0_EXTTRIG CH3TRIG [1..1]  ============================================ */
typedef enum {                                  /*!< FTM0_EXTTRIG_CH3TRIG                                                      */
  FTM0_EXTTRIG_CH3TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM0_EXTTRIG_CH3TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM0_EXTTRIG_CH3TRIG_Enum;

/* ===========================================  FTM0 FTM0_EXTTRIG CH4TRIG [2..2]  ============================================ */
typedef enum {                                  /*!< FTM0_EXTTRIG_CH4TRIG                                                      */
  FTM0_EXTTRIG_CH4TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM0_EXTTRIG_CH4TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM0_EXTTRIG_CH4TRIG_Enum;

/* ===========================================  FTM0 FTM0_EXTTRIG CH5TRIG [3..3]  ============================================ */
typedef enum {                                  /*!< FTM0_EXTTRIG_CH5TRIG                                                      */
  FTM0_EXTTRIG_CH5TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM0_EXTTRIG_CH5TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM0_EXTTRIG_CH5TRIG_Enum;

/* ===========================================  FTM0 FTM0_EXTTRIG CH0TRIG [4..4]  ============================================ */
typedef enum {                                  /*!< FTM0_EXTTRIG_CH0TRIG                                                      */
  FTM0_EXTTRIG_CH0TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM0_EXTTRIG_CH0TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM0_EXTTRIG_CH0TRIG_Enum;

/* ===========================================  FTM0 FTM0_EXTTRIG CH1TRIG [5..5]  ============================================ */
typedef enum {                                  /*!< FTM0_EXTTRIG_CH1TRIG                                                      */
  FTM0_EXTTRIG_CH1TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM0_EXTTRIG_CH1TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM0_EXTTRIG_CH1TRIG_Enum;

/* ==========================================  FTM0 FTM0_EXTTRIG INITTRIGEN [6..6]  ========================================== */
typedef enum {                                  /*!< FTM0_EXTTRIG_INITTRIGEN                                                   */
  FTM0_EXTTRIG_INITTRIGEN_0            = 0,     /*!< 0 : The generation of initialization trigger is disabled.                 */
  FTM0_EXTTRIG_INITTRIGEN_1            = 1,     /*!< 1 : The generation of initialization trigger is enabled.                  */
} FTM0_EXTTRIG_INITTRIGEN_Enum;

/* ============================================  FTM0 FTM0_EXTTRIG TRIGF [7..7]  ============================================= */
typedef enum {                                  /*!< FTM0_EXTTRIG_TRIGF                                                        */
  FTM0_EXTTRIG_TRIGF_0                 = 0,     /*!< 0 : No channel trigger was generated.                                     */
  FTM0_EXTTRIG_TRIGF_1                 = 1,     /*!< 1 : A channel trigger was generated.                                      */
} FTM0_EXTTRIG_TRIGF_Enum;

/* ===========================================  FTM0 FTM0_EXTTRIG CH6TRIG [8..8]  ============================================ */
typedef enum {                                  /*!< FTM0_EXTTRIG_CH6TRIG                                                      */
  FTM0_EXTTRIG_CH6TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM0_EXTTRIG_CH6TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM0_EXTTRIG_CH6TRIG_Enum;

/* ===========================================  FTM0 FTM0_EXTTRIG CH7TRIG [9..9]  ============================================ */
typedef enum {                                  /*!< FTM0_EXTTRIG_CH7TRIG                                                      */
  FTM0_EXTTRIG_CH7TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM0_EXTTRIG_CH7TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM0_EXTTRIG_CH7TRIG_Enum;

/* =======================================================  FTM0_POL  ======================================================== */
/* ===============================================  FTM0 FTM0_POL POL0 [0..0]  =============================================== */
typedef enum {                                  /*!< FTM0_POL_POL0                                                             */
  FTM0_POL_POL0_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM0_POL_POL0_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM0_POL_POL0_Enum;

/* ===============================================  FTM0 FTM0_POL POL1 [1..1]  =============================================== */
typedef enum {                                  /*!< FTM0_POL_POL1                                                             */
  FTM0_POL_POL1_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM0_POL_POL1_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM0_POL_POL1_Enum;

/* ===============================================  FTM0 FTM0_POL POL2 [2..2]  =============================================== */
typedef enum {                                  /*!< FTM0_POL_POL2                                                             */
  FTM0_POL_POL2_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM0_POL_POL2_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM0_POL_POL2_Enum;

/* ===============================================  FTM0 FTM0_POL POL3 [3..3]  =============================================== */
typedef enum {                                  /*!< FTM0_POL_POL3                                                             */
  FTM0_POL_POL3_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM0_POL_POL3_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM0_POL_POL3_Enum;

/* ===============================================  FTM0 FTM0_POL POL4 [4..4]  =============================================== */
typedef enum {                                  /*!< FTM0_POL_POL4                                                             */
  FTM0_POL_POL4_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM0_POL_POL4_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM0_POL_POL4_Enum;

/* ===============================================  FTM0 FTM0_POL POL5 [5..5]  =============================================== */
typedef enum {                                  /*!< FTM0_POL_POL5                                                             */
  FTM0_POL_POL5_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM0_POL_POL5_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM0_POL_POL5_Enum;

/* ===============================================  FTM0 FTM0_POL POL6 [6..6]  =============================================== */
typedef enum {                                  /*!< FTM0_POL_POL6                                                             */
  FTM0_POL_POL6_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM0_POL_POL6_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM0_POL_POL6_Enum;

/* ===============================================  FTM0 FTM0_POL POL7 [7..7]  =============================================== */
typedef enum {                                  /*!< FTM0_POL_POL7                                                             */
  FTM0_POL_POL7_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM0_POL_POL7_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM0_POL_POL7_Enum;

/* =======================================================  FTM0_FMS  ======================================================== */
/* =============================================  FTM0 FTM0_FMS FAULTF0 [0..0]  ============================================== */
typedef enum {                                  /*!< FTM0_FMS_FAULTF0                                                          */
  FTM0_FMS_FAULTF0_0                   = 0,     /*!< 0 : No fault condition was detected at the fault input.                   */
  FTM0_FMS_FAULTF0_1                   = 1,     /*!< 1 : A fault condition was detected at the fault input.                    */
} FTM0_FMS_FAULTF0_Enum;

/* =============================================  FTM0 FTM0_FMS FAULTF1 [1..1]  ============================================== */
typedef enum {                                  /*!< FTM0_FMS_FAULTF1                                                          */
  FTM0_FMS_FAULTF1_0                   = 0,     /*!< 0 : No fault condition was detected at the fault input.                   */
  FTM0_FMS_FAULTF1_1                   = 1,     /*!< 1 : A fault condition was detected at the fault input.                    */
} FTM0_FMS_FAULTF1_Enum;

/* =============================================  FTM0 FTM0_FMS FAULTF2 [2..2]  ============================================== */
typedef enum {                                  /*!< FTM0_FMS_FAULTF2                                                          */
  FTM0_FMS_FAULTF2_0                   = 0,     /*!< 0 : No fault condition was detected at the fault input.                   */
  FTM0_FMS_FAULTF2_1                   = 1,     /*!< 1 : A fault condition was detected at the fault input.                    */
} FTM0_FMS_FAULTF2_Enum;

/* =============================================  FTM0 FTM0_FMS FAULTF3 [3..3]  ============================================== */
typedef enum {                                  /*!< FTM0_FMS_FAULTF3                                                          */
  FTM0_FMS_FAULTF3_0                   = 0,     /*!< 0 : No fault condition was detected at the fault input.                   */
  FTM0_FMS_FAULTF3_1                   = 1,     /*!< 1 : A fault condition was detected at the fault input.                    */
} FTM0_FMS_FAULTF3_Enum;

/* =============================================  FTM0 FTM0_FMS FAULTIN [5..5]  ============================================== */
typedef enum {                                  /*!< FTM0_FMS_FAULTIN                                                          */
  FTM0_FMS_FAULTIN_0                   = 0,     /*!< 0 : The logic OR of the enabled fault inputs is 0.                        */
  FTM0_FMS_FAULTIN_1                   = 1,     /*!< 1 : The logic OR of the enabled fault inputs is 1.                        */
} FTM0_FMS_FAULTIN_Enum;

/* ===============================================  FTM0 FTM0_FMS WPEN [6..6]  =============================================== */
typedef enum {                                  /*!< FTM0_FMS_WPEN                                                             */
  FTM0_FMS_WPEN_0                      = 0,     /*!< 0 : Write protection is disabled. Write protected bits can be
                                                     written.                                                                  */
  FTM0_FMS_WPEN_1                      = 1,     /*!< 1 : Write protection is enabled. Write protected bits cannot
                                                     be written.                                                               */
} FTM0_FMS_WPEN_Enum;

/* ==============================================  FTM0 FTM0_FMS FAULTF [7..7]  ============================================== */
typedef enum {                                  /*!< FTM0_FMS_FAULTF                                                           */
  FTM0_FMS_FAULTF_0                    = 0,     /*!< 0 : No fault condition was detected.                                      */
  FTM0_FMS_FAULTF_1                    = 1,     /*!< 1 : A fault condition was detected.                                       */
} FTM0_FMS_FAULTF_Enum;

/* ======================================================  FTM0_FILTER  ====================================================== */
/* =====================================================  FTM0_FLTCTRL  ====================================================== */
/* ===========================================  FTM0 FTM0_FLTCTRL FAULT0EN [0..0]  =========================================== */
typedef enum {                                  /*!< FTM0_FLTCTRL_FAULT0EN                                                     */
  FTM0_FLTCTRL_FAULT0EN_0              = 0,     /*!< 0 : Fault input is disabled.                                              */
  FTM0_FLTCTRL_FAULT0EN_1              = 1,     /*!< 1 : Fault input is enabled.                                               */
} FTM0_FLTCTRL_FAULT0EN_Enum;

/* ===========================================  FTM0 FTM0_FLTCTRL FAULT1EN [1..1]  =========================================== */
typedef enum {                                  /*!< FTM0_FLTCTRL_FAULT1EN                                                     */
  FTM0_FLTCTRL_FAULT1EN_0              = 0,     /*!< 0 : Fault input is disabled.                                              */
  FTM0_FLTCTRL_FAULT1EN_1              = 1,     /*!< 1 : Fault input is enabled.                                               */
} FTM0_FLTCTRL_FAULT1EN_Enum;

/* ===========================================  FTM0 FTM0_FLTCTRL FAULT2EN [2..2]  =========================================== */
typedef enum {                                  /*!< FTM0_FLTCTRL_FAULT2EN                                                     */
  FTM0_FLTCTRL_FAULT2EN_0              = 0,     /*!< 0 : Fault input is disabled.                                              */
  FTM0_FLTCTRL_FAULT2EN_1              = 1,     /*!< 1 : Fault input is enabled.                                               */
} FTM0_FLTCTRL_FAULT2EN_Enum;

/* ===========================================  FTM0 FTM0_FLTCTRL FAULT3EN [3..3]  =========================================== */
typedef enum {                                  /*!< FTM0_FLTCTRL_FAULT3EN                                                     */
  FTM0_FLTCTRL_FAULT3EN_0              = 0,     /*!< 0 : Fault input is disabled.                                              */
  FTM0_FLTCTRL_FAULT3EN_1              = 1,     /*!< 1 : Fault input is enabled.                                               */
} FTM0_FLTCTRL_FAULT3EN_Enum;

/* ===========================================  FTM0 FTM0_FLTCTRL FFLTR0EN [4..4]  =========================================== */
typedef enum {                                  /*!< FTM0_FLTCTRL_FFLTR0EN                                                     */
  FTM0_FLTCTRL_FFLTR0EN_0              = 0,     /*!< 0 : Fault input filter is disabled.                                       */
  FTM0_FLTCTRL_FFLTR0EN_1              = 1,     /*!< 1 : Fault input filter is enabled.                                        */
} FTM0_FLTCTRL_FFLTR0EN_Enum;

/* ===========================================  FTM0 FTM0_FLTCTRL FFLTR1EN [5..5]  =========================================== */
typedef enum {                                  /*!< FTM0_FLTCTRL_FFLTR1EN                                                     */
  FTM0_FLTCTRL_FFLTR1EN_0              = 0,     /*!< 0 : Fault input filter is disabled.                                       */
  FTM0_FLTCTRL_FFLTR1EN_1              = 1,     /*!< 1 : Fault input filter is enabled.                                        */
} FTM0_FLTCTRL_FFLTR1EN_Enum;

/* ===========================================  FTM0 FTM0_FLTCTRL FFLTR2EN [6..6]  =========================================== */
typedef enum {                                  /*!< FTM0_FLTCTRL_FFLTR2EN                                                     */
  FTM0_FLTCTRL_FFLTR2EN_0              = 0,     /*!< 0 : Fault input filter is disabled.                                       */
  FTM0_FLTCTRL_FFLTR2EN_1              = 1,     /*!< 1 : Fault input filter is enabled.                                        */
} FTM0_FLTCTRL_FFLTR2EN_Enum;

/* ===========================================  FTM0 FTM0_FLTCTRL FFLTR3EN [7..7]  =========================================== */
typedef enum {                                  /*!< FTM0_FLTCTRL_FFLTR3EN                                                     */
  FTM0_FLTCTRL_FFLTR3EN_0              = 0,     /*!< 0 : Fault input filter is disabled.                                       */
  FTM0_FLTCTRL_FFLTR3EN_1              = 1,     /*!< 1 : Fault input filter is enabled.                                        */
} FTM0_FLTCTRL_FFLTR3EN_Enum;

/* ===========================================  FTM0 FTM0_FLTCTRL FSTATE [15..15]  =========================================== */
typedef enum {                                  /*!< FTM0_FLTCTRL_FSTATE                                                       */
  FTM0_FLTCTRL_FSTATE_0                = 0,     /*!< 0 : FTM outputs will be placed into safe values when fault events
                                                     in ongoing (defined by POL bits).                                         */
  FTM0_FLTCTRL_FSTATE_1                = 1,     /*!< 1 : FTM outputs will be tri-stated when fault event is ongoing            */
} FTM0_FLTCTRL_FSTATE_Enum;

/* ======================================================  FTM0_QDCTRL  ====================================================== */
/* ============================================  FTM0 FTM0_QDCTRL QUADEN [0..0]  ============================================= */
typedef enum {                                  /*!< FTM0_QDCTRL_QUADEN                                                        */
  FTM0_QDCTRL_QUADEN_0                 = 0,     /*!< 0 : Quadrature Decoder mode is disabled.                                  */
  FTM0_QDCTRL_QUADEN_1                 = 1,     /*!< 1 : Quadrature Decoder mode is enabled.                                   */
} FTM0_QDCTRL_QUADEN_Enum;

/* ============================================  FTM0 FTM0_QDCTRL TOFDIR [1..1]  ============================================= */
typedef enum {                                  /*!< FTM0_QDCTRL_TOFDIR                                                        */
  FTM0_QDCTRL_TOFDIR_0                 = 0,     /*!< 0 : TOF bit was set on the bottom of counting. There was an
                                                     FTM counter decrement and FTM counter changes from its
                                                     minimum value (CNTIN register) to its maximum value (MOD
                                                     register).                                                                */
  FTM0_QDCTRL_TOFDIR_1                 = 1,     /*!< 1 : TOF bit was set on the top of counting. There was an FTM
                                                     counter increment and FTM counter changes from its maximum
                                                     value (MOD register) to its minimum value (CNTIN register).               */
} FTM0_QDCTRL_TOFDIR_Enum;

/* ============================================  FTM0 FTM0_QDCTRL QUADIR [2..2]  ============================================= */
typedef enum {                                  /*!< FTM0_QDCTRL_QUADIR                                                        */
  FTM0_QDCTRL_QUADIR_0                 = 0,     /*!< 0 : Counting direction is decreasing (FTM counter decrement).             */
  FTM0_QDCTRL_QUADIR_1                 = 1,     /*!< 1 : Counting direction is increasing (FTM counter increment).             */
} FTM0_QDCTRL_QUADIR_Enum;

/* ===========================================  FTM0 FTM0_QDCTRL QUADMODE [3..3]  ============================================ */
typedef enum {                                  /*!< FTM0_QDCTRL_QUADMODE                                                      */
  FTM0_QDCTRL_QUADMODE_0               = 0,     /*!< 0 : Phase A and phase B encoding mode.                                    */
  FTM0_QDCTRL_QUADMODE_1               = 1,     /*!< 1 : Count and direction encoding mode.                                    */
} FTM0_QDCTRL_QUADMODE_Enum;

/* ============================================  FTM0 FTM0_QDCTRL PHBPOL [4..4]  ============================================= */
typedef enum {                                  /*!< FTM0_QDCTRL_PHBPOL                                                        */
  FTM0_QDCTRL_PHBPOL_0                 = 0,     /*!< 0 : Normal polarity. Phase B input signal is not inverted before
                                                     identifying the rising and falling edges of this signal.                  */
  FTM0_QDCTRL_PHBPOL_1                 = 1,     /*!< 1 : Inverted polarity. Phase B input signal is inverted before
                                                     identifying the rising and falling edges of this signal.                  */
} FTM0_QDCTRL_PHBPOL_Enum;

/* ============================================  FTM0 FTM0_QDCTRL PHAPOL [5..5]  ============================================= */
typedef enum {                                  /*!< FTM0_QDCTRL_PHAPOL                                                        */
  FTM0_QDCTRL_PHAPOL_0                 = 0,     /*!< 0 : Normal polarity. Phase A input signal is not inverted before
                                                     identifying the rising and falling edges of this signal.                  */
  FTM0_QDCTRL_PHAPOL_1                 = 1,     /*!< 1 : Inverted polarity. Phase A input signal is inverted before
                                                     identifying the rising and falling edges of this signal.                  */
} FTM0_QDCTRL_PHAPOL_Enum;

/* ===========================================  FTM0 FTM0_QDCTRL PHBFLTREN [6..6]  =========================================== */
typedef enum {                                  /*!< FTM0_QDCTRL_PHBFLTREN                                                     */
  FTM0_QDCTRL_PHBFLTREN_0              = 0,     /*!< 0 : Phase B input filter is disabled.                                     */
  FTM0_QDCTRL_PHBFLTREN_1              = 1,     /*!< 1 : Phase B input filter is enabled.                                      */
} FTM0_QDCTRL_PHBFLTREN_Enum;

/* ===========================================  FTM0 FTM0_QDCTRL PHAFLTREN [7..7]  =========================================== */
typedef enum {                                  /*!< FTM0_QDCTRL_PHAFLTREN                                                     */
  FTM0_QDCTRL_PHAFLTREN_0              = 0,     /*!< 0 : Phase A input filter is disabled.                                     */
  FTM0_QDCTRL_PHAFLTREN_1              = 1,     /*!< 1 : Phase A input filter is enabled.                                      */
} FTM0_QDCTRL_PHAFLTREN_Enum;

/* =======================================================  FTM0_CONF  ======================================================= */
/* ============================================  FTM0 FTM0_CONF ITRIGR [11..11]  ============================================= */
typedef enum {                                  /*!< FTM0_CONF_ITRIGR                                                          */
  FTM0_CONF_ITRIGR_0                   = 0,     /*!< 0 : Initialization trigger is generated on counter wrap events.           */
  FTM0_CONF_ITRIGR_1                   = 1,     /*!< 1 : Initialization trigger is generated when a reload point
                                                     is reached.                                                               */
} FTM0_CONF_ITRIGR_Enum;

/* ======================================================  FTM0_FLTPOL  ====================================================== */
/* ============================================  FTM0 FTM0_FLTPOL FLT0POL [0..0]  ============================================ */
typedef enum {                                  /*!< FTM0_FLTPOL_FLT0POL                                                       */
  FTM0_FLTPOL_FLT0POL_0                = 0,     /*!< 0 : The fault input polarity is active high. A 1 at the fault
                                                     input indicates a fault.                                                  */
  FTM0_FLTPOL_FLT0POL_1                = 1,     /*!< 1 : The fault input polarity is active low. A 0 at the fault
                                                     input indicates a fault.                                                  */
} FTM0_FLTPOL_FLT0POL_Enum;

/* ============================================  FTM0 FTM0_FLTPOL FLT1POL [1..1]  ============================================ */
typedef enum {                                  /*!< FTM0_FLTPOL_FLT1POL                                                       */
  FTM0_FLTPOL_FLT1POL_0                = 0,     /*!< 0 : The fault input polarity is active high. A 1 at the fault
                                                     input indicates a fault.                                                  */
  FTM0_FLTPOL_FLT1POL_1                = 1,     /*!< 1 : The fault input polarity is active low. A 0 at the fault
                                                     input indicates a fault.                                                  */
} FTM0_FLTPOL_FLT1POL_Enum;

/* ============================================  FTM0 FTM0_FLTPOL FLT2POL [2..2]  ============================================ */
typedef enum {                                  /*!< FTM0_FLTPOL_FLT2POL                                                       */
  FTM0_FLTPOL_FLT2POL_0                = 0,     /*!< 0 : The fault input polarity is active high. A 1 at the fault
                                                     input indicates a fault.                                                  */
  FTM0_FLTPOL_FLT2POL_1                = 1,     /*!< 1 : The fault input polarity is active low. A 0 at the fault
                                                     input indicates a fault.                                                  */
} FTM0_FLTPOL_FLT2POL_Enum;

/* ============================================  FTM0 FTM0_FLTPOL FLT3POL [3..3]  ============================================ */
typedef enum {                                  /*!< FTM0_FLTPOL_FLT3POL                                                       */
  FTM0_FLTPOL_FLT3POL_0                = 0,     /*!< 0 : The fault input polarity is active high. A 1 at the fault
                                                     input indicates a fault.                                                  */
  FTM0_FLTPOL_FLT3POL_1                = 1,     /*!< 1 : The fault input polarity is active low. A 0 at the fault
                                                     input indicates a fault.                                                  */
} FTM0_FLTPOL_FLT3POL_Enum;

/* =====================================================  FTM0_SYNCONF  ====================================================== */
/* ==========================================  FTM0 FTM0_SYNCONF HWTRIGMODE [0..0]  ========================================== */
typedef enum {                                  /*!< FTM0_SYNCONF_HWTRIGMODE                                                   */
  FTM0_SYNCONF_HWTRIGMODE_0            = 0,     /*!< 0 : FTM clears the TRIGj bit when the hardware trigger j is
                                                     detected, where j = 0, 1,2.                                               */
  FTM0_SYNCONF_HWTRIGMODE_1            = 1,     /*!< 1 : FTM does not clear the TRIGj bit when the hardware trigger
                                                     j is detected, where j = 0, 1,2.                                          */
} FTM0_SYNCONF_HWTRIGMODE_Enum;

/* ============================================  FTM0 FTM0_SYNCONF CNTINC [2..2]  ============================================ */
typedef enum {                                  /*!< FTM0_SYNCONF_CNTINC                                                       */
  FTM0_SYNCONF_CNTINC_0                = 0,     /*!< 0 : CNTIN register is updated with its buffer value at all rising
                                                     edges of FTM input clock.                                                 */
  FTM0_SYNCONF_CNTINC_1                = 1,     /*!< 1 : CNTIN register is updated with its buffer value by the PWM
                                                     synchronization.                                                          */
} FTM0_SYNCONF_CNTINC_Enum;

/* =============================================  FTM0 FTM0_SYNCONF INVC [4..4]  ============================================= */
typedef enum {                                  /*!< FTM0_SYNCONF_INVC                                                         */
  FTM0_SYNCONF_INVC_0                  = 0,     /*!< 0 : INVCTRL register is updated with its buffer value at all
                                                     rising edges of FTM input clock.                                          */
  FTM0_SYNCONF_INVC_1                  = 1,     /*!< 1 : INVCTRL register is updated with its buffer value by the
                                                     PWM synchronization.                                                      */
} FTM0_SYNCONF_INVC_Enum;

/* =============================================  FTM0 FTM0_SYNCONF SWOC [5..5]  ============================================= */
typedef enum {                                  /*!< FTM0_SYNCONF_SWOC                                                         */
  FTM0_SYNCONF_SWOC_0                  = 0,     /*!< 0 : SWOCTRL register is updated with its buffer value at all
                                                     rising edges of FTM input clock.                                          */
  FTM0_SYNCONF_SWOC_1                  = 1,     /*!< 1 : SWOCTRL register is updated with its buffer value by the
                                                     PWM synchronization.                                                      */
} FTM0_SYNCONF_SWOC_Enum;

/* ===========================================  FTM0 FTM0_SYNCONF SYNCMODE [7..7]  =========================================== */
typedef enum {                                  /*!< FTM0_SYNCONF_SYNCMODE                                                     */
  FTM0_SYNCONF_SYNCMODE_0              = 0,     /*!< 0 : Legacy PWM synchronization is selected.                               */
  FTM0_SYNCONF_SYNCMODE_1              = 1,     /*!< 1 : Enhanced PWM synchronization is selected.                             */
} FTM0_SYNCONF_SYNCMODE_Enum;

/* ===========================================  FTM0 FTM0_SYNCONF SWRSTCNT [8..8]  =========================================== */
typedef enum {                                  /*!< FTM0_SYNCONF_SWRSTCNT                                                     */
  FTM0_SYNCONF_SWRSTCNT_0              = 0,     /*!< 0 : The software trigger does not activate the FTM counter synchronization. */
  FTM0_SYNCONF_SWRSTCNT_1              = 1,     /*!< 1 : The software trigger activates the FTM counter synchronization.       */
} FTM0_SYNCONF_SWRSTCNT_Enum;

/* ===========================================  FTM0 FTM0_SYNCONF SWWRBUF [9..9]  ============================================ */
typedef enum {                                  /*!< FTM0_SYNCONF_SWWRBUF                                                      */
  FTM0_SYNCONF_SWWRBUF_0               = 0,     /*!< 0 : The software trigger does not activate MOD, HCR, CNTIN,
                                                     and CV registers synchronization.                                         */
  FTM0_SYNCONF_SWWRBUF_1               = 1,     /*!< 1 : The software trigger activates MOD, HCR, CNTIN, and CV registers
                                                     synchronization.                                                          */
} FTM0_SYNCONF_SWWRBUF_Enum;

/* ============================================  FTM0 FTM0_SYNCONF SWOM [10..10]  ============================================ */
typedef enum {                                  /*!< FTM0_SYNCONF_SWOM                                                         */
  FTM0_SYNCONF_SWOM_0                  = 0,     /*!< 0 : The software trigger does not activate the OUTMASK register
                                                     synchronization.                                                          */
  FTM0_SYNCONF_SWOM_1                  = 1,     /*!< 1 : The software trigger activates the OUTMASK register synchronization.  */
} FTM0_SYNCONF_SWOM_Enum;

/* ===========================================  FTM0 FTM0_SYNCONF SWINVC [11..11]  =========================================== */
typedef enum {                                  /*!< FTM0_SYNCONF_SWINVC                                                       */
  FTM0_SYNCONF_SWINVC_0                = 0,     /*!< 0 : The software trigger does not activate the INVCTRL register
                                                     synchronization.                                                          */
  FTM0_SYNCONF_SWINVC_1                = 1,     /*!< 1 : The software trigger activates the INVCTRL register synchronization.  */
} FTM0_SYNCONF_SWINVC_Enum;

/* ===========================================  FTM0 FTM0_SYNCONF SWSOC [12..12]  ============================================ */
typedef enum {                                  /*!< FTM0_SYNCONF_SWSOC                                                        */
  FTM0_SYNCONF_SWSOC_0                 = 0,     /*!< 0 : The software trigger does not activate the SWOCTRL register
                                                     synchronization.                                                          */
  FTM0_SYNCONF_SWSOC_1                 = 1,     /*!< 1 : The software trigger activates the SWOCTRL register synchronization.  */
} FTM0_SYNCONF_SWSOC_Enum;

/* ==========================================  FTM0 FTM0_SYNCONF HWRSTCNT [16..16]  ========================================== */
typedef enum {                                  /*!< FTM0_SYNCONF_HWRSTCNT                                                     */
  FTM0_SYNCONF_HWRSTCNT_0              = 0,     /*!< 0 : A hardware trigger does not activate the FTM counter synchronization. */
  FTM0_SYNCONF_HWRSTCNT_1              = 1,     /*!< 1 : A hardware trigger activates the FTM counter synchronization.         */
} FTM0_SYNCONF_HWRSTCNT_Enum;

/* ==========================================  FTM0 FTM0_SYNCONF HWWRBUF [17..17]  =========================================== */
typedef enum {                                  /*!< FTM0_SYNCONF_HWWRBUF                                                      */
  FTM0_SYNCONF_HWWRBUF_0               = 0,     /*!< 0 : A hardware trigger does not activate MOD, HCR, CNTIN, and
                                                     CV registers synchronization.                                             */
  FTM0_SYNCONF_HWWRBUF_1               = 1,     /*!< 1 : A hardware trigger activates MOD, HCR, CNTIN, and CV registers
                                                     synchronization.                                                          */
} FTM0_SYNCONF_HWWRBUF_Enum;

/* ============================================  FTM0 FTM0_SYNCONF HWOM [18..18]  ============================================ */
typedef enum {                                  /*!< FTM0_SYNCONF_HWOM                                                         */
  FTM0_SYNCONF_HWOM_0                  = 0,     /*!< 0 : A hardware trigger does not activate the OUTMASK register
                                                     synchronization.                                                          */
  FTM0_SYNCONF_HWOM_1                  = 1,     /*!< 1 : A hardware trigger activates the OUTMASK register synchronization.    */
} FTM0_SYNCONF_HWOM_Enum;

/* ===========================================  FTM0 FTM0_SYNCONF HWINVC [19..19]  =========================================== */
typedef enum {                                  /*!< FTM0_SYNCONF_HWINVC                                                       */
  FTM0_SYNCONF_HWINVC_0                = 0,     /*!< 0 : A hardware trigger does not activate the INVCTRL register
                                                     synchronization.                                                          */
  FTM0_SYNCONF_HWINVC_1                = 1,     /*!< 1 : A hardware trigger activates the INVCTRL register synchronization.    */
} FTM0_SYNCONF_HWINVC_Enum;

/* ===========================================  FTM0 FTM0_SYNCONF HWSOC [20..20]  ============================================ */
typedef enum {                                  /*!< FTM0_SYNCONF_HWSOC                                                        */
  FTM0_SYNCONF_HWSOC_0                 = 0,     /*!< 0 : A hardware trigger does not activate the SWOCTRL register
                                                     synchronization.                                                          */
  FTM0_SYNCONF_HWSOC_1                 = 1,     /*!< 1 : A hardware trigger activates the SWOCTRL register synchronization.    */
} FTM0_SYNCONF_HWSOC_Enum;

/* =====================================================  FTM0_INVCTRL  ====================================================== */
/* ============================================  FTM0 FTM0_INVCTRL INV0EN [0..0]  ============================================ */
typedef enum {                                  /*!< FTM0_INVCTRL_INV0EN                                                       */
  FTM0_INVCTRL_INV0EN_0                = 0,     /*!< 0 : Inverting is disabled.                                                */
  FTM0_INVCTRL_INV0EN_1                = 1,     /*!< 1 : Inverting is enabled.                                                 */
} FTM0_INVCTRL_INV0EN_Enum;

/* ============================================  FTM0 FTM0_INVCTRL INV1EN [1..1]  ============================================ */
typedef enum {                                  /*!< FTM0_INVCTRL_INV1EN                                                       */
  FTM0_INVCTRL_INV1EN_0                = 0,     /*!< 0 : Inverting is disabled.                                                */
  FTM0_INVCTRL_INV1EN_1                = 1,     /*!< 1 : Inverting is enabled.                                                 */
} FTM0_INVCTRL_INV1EN_Enum;

/* ============================================  FTM0 FTM0_INVCTRL INV2EN [2..2]  ============================================ */
typedef enum {                                  /*!< FTM0_INVCTRL_INV2EN                                                       */
  FTM0_INVCTRL_INV2EN_0                = 0,     /*!< 0 : Inverting is disabled.                                                */
  FTM0_INVCTRL_INV2EN_1                = 1,     /*!< 1 : Inverting is enabled.                                                 */
} FTM0_INVCTRL_INV2EN_Enum;

/* ============================================  FTM0 FTM0_INVCTRL INV3EN [3..3]  ============================================ */
typedef enum {                                  /*!< FTM0_INVCTRL_INV3EN                                                       */
  FTM0_INVCTRL_INV3EN_0                = 0,     /*!< 0 : Inverting is disabled.                                                */
  FTM0_INVCTRL_INV3EN_1                = 1,     /*!< 1 : Inverting is enabled.                                                 */
} FTM0_INVCTRL_INV3EN_Enum;

/* =====================================================  FTM0_SWOCTRL  ====================================================== */
/* ============================================  FTM0 FTM0_SWOCTRL CH0OC [0..0]  ============================================= */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH0OC                                                        */
  FTM0_SWOCTRL_CH0OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM0_SWOCTRL_CH0OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM0_SWOCTRL_CH0OC_Enum;

/* ============================================  FTM0 FTM0_SWOCTRL CH1OC [1..1]  ============================================= */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH1OC                                                        */
  FTM0_SWOCTRL_CH1OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM0_SWOCTRL_CH1OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM0_SWOCTRL_CH1OC_Enum;

/* ============================================  FTM0 FTM0_SWOCTRL CH2OC [2..2]  ============================================= */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH2OC                                                        */
  FTM0_SWOCTRL_CH2OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM0_SWOCTRL_CH2OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM0_SWOCTRL_CH2OC_Enum;

/* ============================================  FTM0 FTM0_SWOCTRL CH3OC [3..3]  ============================================= */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH3OC                                                        */
  FTM0_SWOCTRL_CH3OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM0_SWOCTRL_CH3OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM0_SWOCTRL_CH3OC_Enum;

/* ============================================  FTM0 FTM0_SWOCTRL CH4OC [4..4]  ============================================= */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH4OC                                                        */
  FTM0_SWOCTRL_CH4OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM0_SWOCTRL_CH4OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM0_SWOCTRL_CH4OC_Enum;

/* ============================================  FTM0 FTM0_SWOCTRL CH5OC [5..5]  ============================================= */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH5OC                                                        */
  FTM0_SWOCTRL_CH5OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM0_SWOCTRL_CH5OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM0_SWOCTRL_CH5OC_Enum;

/* ============================================  FTM0 FTM0_SWOCTRL CH6OC [6..6]  ============================================= */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH6OC                                                        */
  FTM0_SWOCTRL_CH6OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM0_SWOCTRL_CH6OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM0_SWOCTRL_CH6OC_Enum;

/* ============================================  FTM0 FTM0_SWOCTRL CH7OC [7..7]  ============================================= */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH7OC                                                        */
  FTM0_SWOCTRL_CH7OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM0_SWOCTRL_CH7OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM0_SWOCTRL_CH7OC_Enum;

/* ============================================  FTM0 FTM0_SWOCTRL CH0OCV [8..8]  ============================================ */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH0OCV                                                       */
  FTM0_SWOCTRL_CH0OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM0_SWOCTRL_CH0OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM0_SWOCTRL_CH0OCV_Enum;

/* ============================================  FTM0 FTM0_SWOCTRL CH1OCV [9..9]  ============================================ */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH1OCV                                                       */
  FTM0_SWOCTRL_CH1OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM0_SWOCTRL_CH1OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM0_SWOCTRL_CH1OCV_Enum;

/* ===========================================  FTM0 FTM0_SWOCTRL CH2OCV [10..10]  =========================================== */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH2OCV                                                       */
  FTM0_SWOCTRL_CH2OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM0_SWOCTRL_CH2OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM0_SWOCTRL_CH2OCV_Enum;

/* ===========================================  FTM0 FTM0_SWOCTRL CH3OCV [11..11]  =========================================== */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH3OCV                                                       */
  FTM0_SWOCTRL_CH3OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM0_SWOCTRL_CH3OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM0_SWOCTRL_CH3OCV_Enum;

/* ===========================================  FTM0 FTM0_SWOCTRL CH4OCV [12..12]  =========================================== */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH4OCV                                                       */
  FTM0_SWOCTRL_CH4OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM0_SWOCTRL_CH4OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM0_SWOCTRL_CH4OCV_Enum;

/* ===========================================  FTM0 FTM0_SWOCTRL CH5OCV [13..13]  =========================================== */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH5OCV                                                       */
  FTM0_SWOCTRL_CH5OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM0_SWOCTRL_CH5OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM0_SWOCTRL_CH5OCV_Enum;

/* ===========================================  FTM0 FTM0_SWOCTRL CH6OCV [14..14]  =========================================== */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH6OCV                                                       */
  FTM0_SWOCTRL_CH6OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM0_SWOCTRL_CH6OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM0_SWOCTRL_CH6OCV_Enum;

/* ===========================================  FTM0 FTM0_SWOCTRL CH7OCV [15..15]  =========================================== */
typedef enum {                                  /*!< FTM0_SWOCTRL_CH7OCV                                                       */
  FTM0_SWOCTRL_CH7OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM0_SWOCTRL_CH7OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM0_SWOCTRL_CH7OCV_Enum;

/* =====================================================  FTM0_PWMLOAD  ====================================================== */
/* ============================================  FTM0 FTM0_PWMLOAD CH0SEL [0..0]  ============================================ */
typedef enum {                                  /*!< FTM0_PWMLOAD_CH0SEL                                                       */
  FTM0_PWMLOAD_CH0SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM0_PWMLOAD_CH0SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM0_PWMLOAD_CH0SEL_Enum;

/* ============================================  FTM0 FTM0_PWMLOAD CH1SEL [1..1]  ============================================ */
typedef enum {                                  /*!< FTM0_PWMLOAD_CH1SEL                                                       */
  FTM0_PWMLOAD_CH1SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM0_PWMLOAD_CH1SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM0_PWMLOAD_CH1SEL_Enum;

/* ============================================  FTM0 FTM0_PWMLOAD CH2SEL [2..2]  ============================================ */
typedef enum {                                  /*!< FTM0_PWMLOAD_CH2SEL                                                       */
  FTM0_PWMLOAD_CH2SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM0_PWMLOAD_CH2SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM0_PWMLOAD_CH2SEL_Enum;

/* ============================================  FTM0 FTM0_PWMLOAD CH3SEL [3..3]  ============================================ */
typedef enum {                                  /*!< FTM0_PWMLOAD_CH3SEL                                                       */
  FTM0_PWMLOAD_CH3SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM0_PWMLOAD_CH3SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM0_PWMLOAD_CH3SEL_Enum;

/* ============================================  FTM0 FTM0_PWMLOAD CH4SEL [4..4]  ============================================ */
typedef enum {                                  /*!< FTM0_PWMLOAD_CH4SEL                                                       */
  FTM0_PWMLOAD_CH4SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM0_PWMLOAD_CH4SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM0_PWMLOAD_CH4SEL_Enum;

/* ============================================  FTM0 FTM0_PWMLOAD CH5SEL [5..5]  ============================================ */
typedef enum {                                  /*!< FTM0_PWMLOAD_CH5SEL                                                       */
  FTM0_PWMLOAD_CH5SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM0_PWMLOAD_CH5SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM0_PWMLOAD_CH5SEL_Enum;

/* ============================================  FTM0 FTM0_PWMLOAD CH6SEL [6..6]  ============================================ */
typedef enum {                                  /*!< FTM0_PWMLOAD_CH6SEL                                                       */
  FTM0_PWMLOAD_CH6SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM0_PWMLOAD_CH6SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM0_PWMLOAD_CH6SEL_Enum;

/* ============================================  FTM0 FTM0_PWMLOAD CH7SEL [7..7]  ============================================ */
typedef enum {                                  /*!< FTM0_PWMLOAD_CH7SEL                                                       */
  FTM0_PWMLOAD_CH7SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM0_PWMLOAD_CH7SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM0_PWMLOAD_CH7SEL_Enum;

/* ============================================  FTM0 FTM0_PWMLOAD HCSEL [8..8]  ============================================= */
typedef enum {                                  /*!< FTM0_PWMLOAD_HCSEL                                                        */
  FTM0_PWMLOAD_HCSEL_0                 = 0,     /*!< 0 : Half cycle reload is disabled and it is not considered as
                                                     a reload opportunity.                                                     */
  FTM0_PWMLOAD_HCSEL_1                 = 1,     /*!< 1 : Half cycle reload is enabled and it is considered as a reload
                                                     opportunity.                                                              */
} FTM0_PWMLOAD_HCSEL_Enum;

/* =============================================  FTM0 FTM0_PWMLOAD LDOK [9..9]  ============================================= */
typedef enum {                                  /*!< FTM0_PWMLOAD_LDOK                                                         */
  FTM0_PWMLOAD_LDOK_0                  = 0,     /*!< 0 : Loading updated values is disabled.                                   */
  FTM0_PWMLOAD_LDOK_1                  = 1,     /*!< 1 : Loading updated values is enabled.                                    */
} FTM0_PWMLOAD_LDOK_Enum;

/* ============================================  FTM0 FTM0_PWMLOAD GLEN [10..10]  ============================================ */
typedef enum {                                  /*!< FTM0_PWMLOAD_GLEN                                                         */
  FTM0_PWMLOAD_GLEN_0                  = 0,     /*!< 0 : Global Load Ok disabled.                                              */
  FTM0_PWMLOAD_GLEN_1                  = 1,     /*!< 1 : Global Load OK enabled. A pulse event on the module global
                                                     load input sets the LDOK bit.                                             */
} FTM0_PWMLOAD_GLEN_Enum;

/* ===========================================  FTM0 FTM0_PWMLOAD GLDOK [11..11]  ============================================ */
typedef enum {                                  /*!< FTM0_PWMLOAD_GLDOK                                                        */
  FTM0_PWMLOAD_GLDOK_0                 = 0,     /*!< 0 : No action.                                                            */
  FTM0_PWMLOAD_GLDOK_1                 = 1,     /*!< 1 : LDOK bit is set.                                                      */
} FTM0_PWMLOAD_GLDOK_Enum;

/* =======================================================  FTM0_HCR  ======================================================== */
/* ==================================================  FTM0_PAIR0DEADTIME  =================================================== */
/* ==========================================  FTM0 FTM0_PAIR0DEADTIME DTPS [6..7]  ========================================== */
typedef enum {                                  /*!< FTM0_PAIR0DEADTIME_DTPS                                                   */
  FTM0_PAIR0DEADTIME_DTPS_0x_0         = 0,     /*!< 0x_0 : Divide the FTM input clock by 1.                                   */
  FTM0_PAIR0DEADTIME_DTPS_0x_1         = 1,     /*!< 0x_1 : Divide the FTM input clock by 1.                                   */
  FTM0_PAIR0DEADTIME_DTPS_10           = 2,     /*!< 10 : Divide the FTM input clock by 4.                                     */
  FTM0_PAIR0DEADTIME_DTPS_11           = 3,     /*!< 11 : Divide the FTM input clock by 16.                                    */
} FTM0_PAIR0DEADTIME_DTPS_Enum;

/* ==================================================  FTM0_PAIR1DEADTIME  =================================================== */
/* ==========================================  FTM0 FTM0_PAIR1DEADTIME DTPS [6..7]  ========================================== */
typedef enum {                                  /*!< FTM0_PAIR1DEADTIME_DTPS                                                   */
  FTM0_PAIR1DEADTIME_DTPS_0x_0         = 0,     /*!< 0x_0 : Divide the FTM input clock by 1.                                   */
  FTM0_PAIR1DEADTIME_DTPS_0x_1         = 1,     /*!< 0x_1 : Divide the FTM input clock by 1.                                   */
  FTM0_PAIR1DEADTIME_DTPS_10           = 2,     /*!< 10 : Divide the FTM input clock by 4.                                     */
  FTM0_PAIR1DEADTIME_DTPS_11           = 3,     /*!< 11 : Divide the FTM input clock by 16.                                    */
} FTM0_PAIR1DEADTIME_DTPS_Enum;

/* ==================================================  FTM0_PAIR2DEADTIME  =================================================== */
/* ==========================================  FTM0 FTM0_PAIR2DEADTIME DTPS [6..7]  ========================================== */
typedef enum {                                  /*!< FTM0_PAIR2DEADTIME_DTPS                                                   */
  FTM0_PAIR2DEADTIME_DTPS_0x_0         = 0,     /*!< 0x_0 : Divide the FTM input clock by 1.                                   */
  FTM0_PAIR2DEADTIME_DTPS_0x_1         = 1,     /*!< 0x_1 : Divide the FTM input clock by 1.                                   */
  FTM0_PAIR2DEADTIME_DTPS_10           = 2,     /*!< 10 : Divide the FTM input clock by 4.                                     */
  FTM0_PAIR2DEADTIME_DTPS_11           = 3,     /*!< 11 : Divide the FTM input clock by 16.                                    */
} FTM0_PAIR2DEADTIME_DTPS_Enum;

/* ==================================================  FTM0_PAIR3DEADTIME  =================================================== */
/* ==========================================  FTM0 FTM0_PAIR3DEADTIME DTPS [6..7]  ========================================== */
typedef enum {                                  /*!< FTM0_PAIR3DEADTIME_DTPS                                                   */
  FTM0_PAIR3DEADTIME_DTPS_0x_0         = 0,     /*!< 0x_0 : Divide the FTM input clock by 1.                                   */
  FTM0_PAIR3DEADTIME_DTPS_0x_1         = 1,     /*!< 0x_1 : Divide the FTM input clock by 1.                                   */
  FTM0_PAIR3DEADTIME_DTPS_10           = 2,     /*!< 10 : Divide the FTM input clock by 4.                                     */
  FTM0_PAIR3DEADTIME_DTPS_11           = 3,     /*!< 11 : Divide the FTM input clock by 16.                                    */
} FTM0_PAIR3DEADTIME_DTPS_Enum;

/* ====================================================  FTM0_MOD_MIRROR  ==================================================== */
/* ====================================================  FTM0_C0V_MIRROR  ==================================================== */
/* ====================================================  FTM0_C1V_MIRROR  ==================================================== */
/* ====================================================  FTM0_C2V_MIRROR  ==================================================== */
/* ====================================================  FTM0_C3V_MIRROR  ==================================================== */
/* ====================================================  FTM0_C4V_MIRROR  ==================================================== */
/* ====================================================  FTM0_C5V_MIRROR  ==================================================== */
/* ====================================================  FTM0_C6V_MIRROR  ==================================================== */
/* ====================================================  FTM0_C7V_MIRROR  ==================================================== */


/* =========================================================================================================================== */
/* ================                                           FTM1                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  FTM1_SC  ======================================================== */
/* ================================================  FTM1 FTM1_SC PS [0..2]  ================================================= */
typedef enum {                                  /*!< FTM1_SC_PS                                                                */
  FTM1_SC_PS_000                       = 0,     /*!< 000 : Divide by 1                                                         */
  FTM1_SC_PS_001                       = 1,     /*!< 001 : Divide by 2                                                         */
  FTM1_SC_PS_010                       = 2,     /*!< 010 : Divide by 4                                                         */
  FTM1_SC_PS_011                       = 3,     /*!< 011 : Divide by 8                                                         */
  FTM1_SC_PS_100                       = 4,     /*!< 100 : Divide by 16                                                        */
  FTM1_SC_PS_101                       = 5,     /*!< 101 : Divide by 32                                                        */
  FTM1_SC_PS_110                       = 6,     /*!< 110 : Divide by 64                                                        */
  FTM1_SC_PS_111                       = 7,     /*!< 111 : Divide by 128                                                       */
} FTM1_SC_PS_Enum;

/* ===============================================  FTM1 FTM1_SC CLKS [3..4]  ================================================ */
typedef enum {                                  /*!< FTM1_SC_CLKS                                                              */
  FTM1_SC_CLKS_00                      = 0,     /*!< 00 : No clock selected. This in effect disables the FTM counter.          */
  FTM1_SC_CLKS_01                      = 1,     /*!< 01 : FTM input clock                                                      */
  FTM1_SC_CLKS_10                      = 2,     /*!< 10 : Fixed frequency clock                                                */
  FTM1_SC_CLKS_11                      = 3,     /*!< 11 : External clock                                                       */
} FTM1_SC_CLKS_Enum;

/* ===============================================  FTM1 FTM1_SC CPWMS [5..5]  =============================================== */
typedef enum {                                  /*!< FTM1_SC_CPWMS                                                             */
  FTM1_SC_CPWMS_0                      = 0,     /*!< 0 : FTM counter operates in Up Counting mode.                             */
  FTM1_SC_CPWMS_1                      = 1,     /*!< 1 : FTM counter operates in Up-Down Counting mode.                        */
} FTM1_SC_CPWMS_Enum;

/* ================================================  FTM1 FTM1_SC RIE [6..6]  ================================================ */
typedef enum {                                  /*!< FTM1_SC_RIE                                                               */
  FTM1_SC_RIE_0                        = 0,     /*!< 0 : Reload point interrupt is disabled.                                   */
  FTM1_SC_RIE_1                        = 1,     /*!< 1 : Reload point interrupt is enabled.                                    */
} FTM1_SC_RIE_Enum;

/* ================================================  FTM1 FTM1_SC RF [7..7]  ================================================= */
typedef enum {                                  /*!< FTM1_SC_RF                                                                */
  FTM1_SC_RF_0                         = 0,     /*!< 0 : A selected reload point did not happen.                               */
  FTM1_SC_RF_1                         = 1,     /*!< 1 : A selected reload point happened.                                     */
} FTM1_SC_RF_Enum;

/* ===============================================  FTM1 FTM1_SC TOIE [8..8]  ================================================ */
typedef enum {                                  /*!< FTM1_SC_TOIE                                                              */
  FTM1_SC_TOIE_0                       = 0,     /*!< 0 : Disable TOF interrupts. Use software polling.                         */
  FTM1_SC_TOIE_1                       = 1,     /*!< 1 : Enable TOF interrupts. An interrupt is generated when TOF
                                                     equals one.                                                               */
} FTM1_SC_TOIE_Enum;

/* ================================================  FTM1 FTM1_SC TOF [9..9]  ================================================ */
typedef enum {                                  /*!< FTM1_SC_TOF                                                               */
  FTM1_SC_TOF_0                        = 0,     /*!< 0 : FTM counter has not overflowed.                                       */
  FTM1_SC_TOF_1                        = 1,     /*!< 1 : FTM counter has overflowed.                                           */
} FTM1_SC_TOF_Enum;

/* =============================================  FTM1 FTM1_SC PWMEN0 [16..16]  ============================================== */
typedef enum {                                  /*!< FTM1_SC_PWMEN0                                                            */
  FTM1_SC_PWMEN0_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM1_SC_PWMEN0_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM1_SC_PWMEN0_Enum;

/* =============================================  FTM1 FTM1_SC PWMEN1 [17..17]  ============================================== */
typedef enum {                                  /*!< FTM1_SC_PWMEN1                                                            */
  FTM1_SC_PWMEN1_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM1_SC_PWMEN1_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM1_SC_PWMEN1_Enum;

/* =============================================  FTM1 FTM1_SC PWMEN2 [18..18]  ============================================== */
typedef enum {                                  /*!< FTM1_SC_PWMEN2                                                            */
  FTM1_SC_PWMEN2_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM1_SC_PWMEN2_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM1_SC_PWMEN2_Enum;

/* =============================================  FTM1 FTM1_SC PWMEN3 [19..19]  ============================================== */
typedef enum {                                  /*!< FTM1_SC_PWMEN3                                                            */
  FTM1_SC_PWMEN3_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM1_SC_PWMEN3_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM1_SC_PWMEN3_Enum;

/* =============================================  FTM1 FTM1_SC PWMEN4 [20..20]  ============================================== */
typedef enum {                                  /*!< FTM1_SC_PWMEN4                                                            */
  FTM1_SC_PWMEN4_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM1_SC_PWMEN4_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM1_SC_PWMEN4_Enum;

/* =============================================  FTM1 FTM1_SC PWMEN5 [21..21]  ============================================== */
typedef enum {                                  /*!< FTM1_SC_PWMEN5                                                            */
  FTM1_SC_PWMEN5_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM1_SC_PWMEN5_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM1_SC_PWMEN5_Enum;

/* =============================================  FTM1 FTM1_SC PWMEN6 [22..22]  ============================================== */
typedef enum {                                  /*!< FTM1_SC_PWMEN6                                                            */
  FTM1_SC_PWMEN6_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM1_SC_PWMEN6_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM1_SC_PWMEN6_Enum;

/* =============================================  FTM1 FTM1_SC PWMEN7 [23..23]  ============================================== */
typedef enum {                                  /*!< FTM1_SC_PWMEN7                                                            */
  FTM1_SC_PWMEN7_0                     = 0,     /*!< 0 : Channel output port is disabled                                       */
  FTM1_SC_PWMEN7_1                     = 1,     /*!< 1 : Channel output port is enabled                                        */
} FTM1_SC_PWMEN7_Enum;

/* ==============================================  FTM1 FTM1_SC FLTPS [24..27]  ============================================== */
typedef enum {                                  /*!< FTM1_SC_FLTPS                                                             */
  FTM1_SC_FLTPS_0000                   = 0,     /*!< 0000 : Divide by 1                                                        */
  FTM1_SC_FLTPS_0001                   = 1,     /*!< 0001 : Divide by 2                                                        */
  FTM1_SC_FLTPS_0010                   = 2,     /*!< 0010 : Divide by 3                                                        */
  FTM1_SC_FLTPS_0011                   = 3,     /*!< 0011 : Divide by 4                                                        */
  FTM1_SC_FLTPS_0100                   = 4,     /*!< 0100 : Divide by 5                                                        */
  FTM1_SC_FLTPS_0101                   = 5,     /*!< 0101 : Divide by 6                                                        */
  FTM1_SC_FLTPS_0110                   = 6,     /*!< 0110 : Divide by 7                                                        */
  FTM1_SC_FLTPS_0111                   = 7,     /*!< 0111 : Divide by 8                                                        */
  FTM1_SC_FLTPS_1000                   = 8,     /*!< 1000 : Divide by 9                                                        */
  FTM1_SC_FLTPS_1001                   = 9,     /*!< 1001 : Divide by 10                                                       */
  FTM1_SC_FLTPS_1010                   = 10,    /*!< 1010 : Divide by 11                                                       */
  FTM1_SC_FLTPS_1011                   = 11,    /*!< 1011 : Divide by 12                                                       */
  FTM1_SC_FLTPS_1100                   = 12,    /*!< 1100 : Divide by 13                                                       */
  FTM1_SC_FLTPS_1101                   = 13,    /*!< 1101 : Divide by 14                                                       */
  FTM1_SC_FLTPS_1110                   = 14,    /*!< 1110 : Divide by 15                                                       */
  FTM1_SC_FLTPS_1111                   = 15,    /*!< 1111 : Divide by 16                                                       */
} FTM1_SC_FLTPS_Enum;

/* =======================================================  FTM1_CNT  ======================================================== */
/* =======================================================  FTM1_MOD  ======================================================== */
/* =======================================================  FTM1_C0SC  ======================================================= */
/* ===============================================  FTM1 FTM1_C0SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM1_C0SC_DMA                                                             */
  FTM1_C0SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM1_C0SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM1_C0SC_DMA_Enum;

/* ==============================================  FTM1 FTM1_C0SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_C0SC_ICRST                                                           */
  FTM1_C0SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM1_C0SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM1_C0SC_ICRST_Enum;

/* ==============================================  FTM1 FTM1_C0SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM1_C0SC_CHIE                                                            */
  FTM1_C0SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM1_C0SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM1_C0SC_CHIE_Enum;

/* ===============================================  FTM1 FTM1_C0SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM1_C0SC_CHF                                                             */
  FTM1_C0SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM1_C0SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM1_C0SC_CHF_Enum;

/* ============================================  FTM1 FTM1_C0SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM1_C0SC_TRIGMODE                                                        */
  FTM1_C0SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM1_C0SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM1_C0SC_TRIGMODE_Enum;

/* ==============================================  FTM1 FTM1_C0SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM1_C0SC_CHIS                                                            */
  FTM1_C0SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM1_C0SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM1_C0SC_CHIS_Enum;

/* =============================================  FTM1 FTM1_C0SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM1_C0SC_CHOV                                                            */
  FTM1_C0SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM1_C0SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM1_C0SC_CHOV_Enum;

/* =======================================================  FTM1_C0V  ======================================================== */
/* =======================================================  FTM1_C1SC  ======================================================= */
/* ===============================================  FTM1 FTM1_C1SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM1_C1SC_DMA                                                             */
  FTM1_C1SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM1_C1SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM1_C1SC_DMA_Enum;

/* ==============================================  FTM1 FTM1_C1SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_C1SC_ICRST                                                           */
  FTM1_C1SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM1_C1SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM1_C1SC_ICRST_Enum;

/* ==============================================  FTM1 FTM1_C1SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM1_C1SC_CHIE                                                            */
  FTM1_C1SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM1_C1SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM1_C1SC_CHIE_Enum;

/* ===============================================  FTM1 FTM1_C1SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM1_C1SC_CHF                                                             */
  FTM1_C1SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM1_C1SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM1_C1SC_CHF_Enum;

/* ============================================  FTM1 FTM1_C1SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM1_C1SC_TRIGMODE                                                        */
  FTM1_C1SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM1_C1SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM1_C1SC_TRIGMODE_Enum;

/* ==============================================  FTM1 FTM1_C1SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM1_C1SC_CHIS                                                            */
  FTM1_C1SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM1_C1SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM1_C1SC_CHIS_Enum;

/* =============================================  FTM1 FTM1_C1SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM1_C1SC_CHOV                                                            */
  FTM1_C1SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM1_C1SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM1_C1SC_CHOV_Enum;

/* =======================================================  FTM1_C1V  ======================================================== */
/* =======================================================  FTM1_C2SC  ======================================================= */
/* ===============================================  FTM1 FTM1_C2SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM1_C2SC_DMA                                                             */
  FTM1_C2SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM1_C2SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM1_C2SC_DMA_Enum;

/* ==============================================  FTM1 FTM1_C2SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_C2SC_ICRST                                                           */
  FTM1_C2SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM1_C2SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM1_C2SC_ICRST_Enum;

/* ==============================================  FTM1 FTM1_C2SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM1_C2SC_CHIE                                                            */
  FTM1_C2SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM1_C2SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM1_C2SC_CHIE_Enum;

/* ===============================================  FTM1 FTM1_C2SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM1_C2SC_CHF                                                             */
  FTM1_C2SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM1_C2SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM1_C2SC_CHF_Enum;

/* ============================================  FTM1 FTM1_C2SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM1_C2SC_TRIGMODE                                                        */
  FTM1_C2SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM1_C2SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM1_C2SC_TRIGMODE_Enum;

/* ==============================================  FTM1 FTM1_C2SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM1_C2SC_CHIS                                                            */
  FTM1_C2SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM1_C2SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM1_C2SC_CHIS_Enum;

/* =============================================  FTM1 FTM1_C2SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM1_C2SC_CHOV                                                            */
  FTM1_C2SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM1_C2SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM1_C2SC_CHOV_Enum;

/* =======================================================  FTM1_C2V  ======================================================== */
/* =======================================================  FTM1_C3SC  ======================================================= */
/* ===============================================  FTM1 FTM1_C3SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM1_C3SC_DMA                                                             */
  FTM1_C3SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM1_C3SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM1_C3SC_DMA_Enum;

/* ==============================================  FTM1 FTM1_C3SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_C3SC_ICRST                                                           */
  FTM1_C3SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM1_C3SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM1_C3SC_ICRST_Enum;

/* ==============================================  FTM1 FTM1_C3SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM1_C3SC_CHIE                                                            */
  FTM1_C3SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM1_C3SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM1_C3SC_CHIE_Enum;

/* ===============================================  FTM1 FTM1_C3SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM1_C3SC_CHF                                                             */
  FTM1_C3SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM1_C3SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM1_C3SC_CHF_Enum;

/* ============================================  FTM1 FTM1_C3SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM1_C3SC_TRIGMODE                                                        */
  FTM1_C3SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM1_C3SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM1_C3SC_TRIGMODE_Enum;

/* ==============================================  FTM1 FTM1_C3SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM1_C3SC_CHIS                                                            */
  FTM1_C3SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM1_C3SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM1_C3SC_CHIS_Enum;

/* =============================================  FTM1 FTM1_C3SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM1_C3SC_CHOV                                                            */
  FTM1_C3SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM1_C3SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM1_C3SC_CHOV_Enum;

/* =======================================================  FTM1_C3V  ======================================================== */
/* =======================================================  FTM1_C4SC  ======================================================= */
/* ===============================================  FTM1 FTM1_C4SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM1_C4SC_DMA                                                             */
  FTM1_C4SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM1_C4SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM1_C4SC_DMA_Enum;

/* ==============================================  FTM1 FTM1_C4SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_C4SC_ICRST                                                           */
  FTM1_C4SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM1_C4SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM1_C4SC_ICRST_Enum;

/* ==============================================  FTM1 FTM1_C4SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM1_C4SC_CHIE                                                            */
  FTM1_C4SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM1_C4SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM1_C4SC_CHIE_Enum;

/* ===============================================  FTM1 FTM1_C4SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM1_C4SC_CHF                                                             */
  FTM1_C4SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM1_C4SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM1_C4SC_CHF_Enum;

/* ============================================  FTM1 FTM1_C4SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM1_C4SC_TRIGMODE                                                        */
  FTM1_C4SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM1_C4SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM1_C4SC_TRIGMODE_Enum;

/* ==============================================  FTM1 FTM1_C4SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM1_C4SC_CHIS                                                            */
  FTM1_C4SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM1_C4SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM1_C4SC_CHIS_Enum;

/* =============================================  FTM1 FTM1_C4SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM1_C4SC_CHOV                                                            */
  FTM1_C4SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM1_C4SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM1_C4SC_CHOV_Enum;

/* =======================================================  FTM1_C4V  ======================================================== */
/* =======================================================  FTM1_C5SC  ======================================================= */
/* ===============================================  FTM1 FTM1_C5SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM1_C5SC_DMA                                                             */
  FTM1_C5SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM1_C5SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM1_C5SC_DMA_Enum;

/* ==============================================  FTM1 FTM1_C5SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_C5SC_ICRST                                                           */
  FTM1_C5SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM1_C5SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM1_C5SC_ICRST_Enum;

/* ==============================================  FTM1 FTM1_C5SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM1_C5SC_CHIE                                                            */
  FTM1_C5SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM1_C5SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM1_C5SC_CHIE_Enum;

/* ===============================================  FTM1 FTM1_C5SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM1_C5SC_CHF                                                             */
  FTM1_C5SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM1_C5SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM1_C5SC_CHF_Enum;

/* ============================================  FTM1 FTM1_C5SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM1_C5SC_TRIGMODE                                                        */
  FTM1_C5SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM1_C5SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM1_C5SC_TRIGMODE_Enum;

/* ==============================================  FTM1 FTM1_C5SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM1_C5SC_CHIS                                                            */
  FTM1_C5SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM1_C5SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM1_C5SC_CHIS_Enum;

/* =============================================  FTM1 FTM1_C5SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM1_C5SC_CHOV                                                            */
  FTM1_C5SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM1_C5SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM1_C5SC_CHOV_Enum;

/* =======================================================  FTM1_C5V  ======================================================== */
/* =======================================================  FTM1_C6SC  ======================================================= */
/* ===============================================  FTM1 FTM1_C6SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM1_C6SC_DMA                                                             */
  FTM1_C6SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM1_C6SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM1_C6SC_DMA_Enum;

/* ==============================================  FTM1 FTM1_C6SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_C6SC_ICRST                                                           */
  FTM1_C6SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM1_C6SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM1_C6SC_ICRST_Enum;

/* ==============================================  FTM1 FTM1_C6SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM1_C6SC_CHIE                                                            */
  FTM1_C6SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM1_C6SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM1_C6SC_CHIE_Enum;

/* ===============================================  FTM1 FTM1_C6SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM1_C6SC_CHF                                                             */
  FTM1_C6SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM1_C6SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM1_C6SC_CHF_Enum;

/* ============================================  FTM1 FTM1_C6SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM1_C6SC_TRIGMODE                                                        */
  FTM1_C6SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM1_C6SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM1_C6SC_TRIGMODE_Enum;

/* ==============================================  FTM1 FTM1_C6SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM1_C6SC_CHIS                                                            */
  FTM1_C6SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM1_C6SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM1_C6SC_CHIS_Enum;

/* =============================================  FTM1 FTM1_C6SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM1_C6SC_CHOV                                                            */
  FTM1_C6SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM1_C6SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM1_C6SC_CHOV_Enum;

/* =======================================================  FTM1_C6V  ======================================================== */
/* =======================================================  FTM1_C7SC  ======================================================= */
/* ===============================================  FTM1 FTM1_C7SC DMA [0..0]  =============================================== */
typedef enum {                                  /*!< FTM1_C7SC_DMA                                                             */
  FTM1_C7SC_DMA_0                      = 0,     /*!< 0 : Disable DMA transfers.                                                */
  FTM1_C7SC_DMA_1                      = 1,     /*!< 1 : Enable DMA transfers.                                                 */
} FTM1_C7SC_DMA_Enum;

/* ==============================================  FTM1 FTM1_C7SC ICRST [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_C7SC_ICRST                                                           */
  FTM1_C7SC_ICRST_0                    = 0,     /*!< 0 : FTM counter is not reset when the selected channel (n) input
                                                     event is detected.                                                        */
  FTM1_C7SC_ICRST_1                    = 1,     /*!< 1 : FTM counter is reset when the selected channel (n) input
                                                     event is detected.                                                        */
} FTM1_C7SC_ICRST_Enum;

/* ==============================================  FTM1 FTM1_C7SC CHIE [6..6]  =============================================== */
typedef enum {                                  /*!< FTM1_C7SC_CHIE                                                            */
  FTM1_C7SC_CHIE_0                     = 0,     /*!< 0 : Disable channel (n) interrupt. Use software polling.                  */
  FTM1_C7SC_CHIE_1                     = 1,     /*!< 1 : Enable channel (n) interrupt.                                         */
} FTM1_C7SC_CHIE_Enum;

/* ===============================================  FTM1 FTM1_C7SC CHF [7..7]  =============================================== */
typedef enum {                                  /*!< FTM1_C7SC_CHF                                                             */
  FTM1_C7SC_CHF_0                      = 0,     /*!< 0 : No channel (n) event has occurred.                                    */
  FTM1_C7SC_CHF_1                      = 1,     /*!< 1 : A channel (n) event has occurred.                                     */
} FTM1_C7SC_CHF_Enum;

/* ============================================  FTM1 FTM1_C7SC TRIGMODE [8..8]  ============================================= */
typedef enum {                                  /*!< FTM1_C7SC_TRIGMODE                                                        */
  FTM1_C7SC_TRIGMODE_0                 = 0,     /*!< 0 : Channel outputs will generate the normal PWM outputs without
                                                     generating a pulse.                                                       */
  FTM1_C7SC_TRIGMODE_1                 = 1,     /*!< 1 : If a match in the channel occurs, a trigger generation on
                                                     channel output will happen. The trigger pulse width has
                                                     one FTM clock cycle.                                                      */
} FTM1_C7SC_TRIGMODE_Enum;

/* ==============================================  FTM1 FTM1_C7SC CHIS [9..9]  =============================================== */
typedef enum {                                  /*!< FTM1_C7SC_CHIS                                                            */
  FTM1_C7SC_CHIS_0                     = 0,     /*!< 0 : The channel (n) input is zero.                                        */
  FTM1_C7SC_CHIS_1                     = 1,     /*!< 1 : The channel (n) input is one.                                         */
} FTM1_C7SC_CHIS_Enum;

/* =============================================  FTM1 FTM1_C7SC CHOV [10..10]  ============================================== */
typedef enum {                                  /*!< FTM1_C7SC_CHOV                                                            */
  FTM1_C7SC_CHOV_0                     = 0,     /*!< 0 : The channel (n) output is zero.                                       */
  FTM1_C7SC_CHOV_1                     = 1,     /*!< 1 : The channel (n) output is one.                                        */
} FTM1_C7SC_CHOV_Enum;

/* =======================================================  FTM1_C7V  ======================================================== */
/* ======================================================  FTM1_CNTIN  ======================================================= */
/* ======================================================  FTM1_STATUS  ====================================================== */
/* =============================================  FTM1 FTM1_STATUS CH0F [0..0]  ============================================== */
typedef enum {                                  /*!< FTM1_STATUS_CH0F                                                          */
  FTM1_STATUS_CH0F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM1_STATUS_CH0F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM1_STATUS_CH0F_Enum;

/* =============================================  FTM1 FTM1_STATUS CH1F [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_STATUS_CH1F                                                          */
  FTM1_STATUS_CH1F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM1_STATUS_CH1F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM1_STATUS_CH1F_Enum;

/* =============================================  FTM1 FTM1_STATUS CH2F [2..2]  ============================================== */
typedef enum {                                  /*!< FTM1_STATUS_CH2F                                                          */
  FTM1_STATUS_CH2F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM1_STATUS_CH2F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM1_STATUS_CH2F_Enum;

/* =============================================  FTM1 FTM1_STATUS CH3F [3..3]  ============================================== */
typedef enum {                                  /*!< FTM1_STATUS_CH3F                                                          */
  FTM1_STATUS_CH3F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM1_STATUS_CH3F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM1_STATUS_CH3F_Enum;

/* =============================================  FTM1 FTM1_STATUS CH4F [4..4]  ============================================== */
typedef enum {                                  /*!< FTM1_STATUS_CH4F                                                          */
  FTM1_STATUS_CH4F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM1_STATUS_CH4F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM1_STATUS_CH4F_Enum;

/* =============================================  FTM1 FTM1_STATUS CH5F [5..5]  ============================================== */
typedef enum {                                  /*!< FTM1_STATUS_CH5F                                                          */
  FTM1_STATUS_CH5F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM1_STATUS_CH5F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM1_STATUS_CH5F_Enum;

/* =============================================  FTM1 FTM1_STATUS CH6F [6..6]  ============================================== */
typedef enum {                                  /*!< FTM1_STATUS_CH6F                                                          */
  FTM1_STATUS_CH6F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM1_STATUS_CH6F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM1_STATUS_CH6F_Enum;

/* =============================================  FTM1 FTM1_STATUS CH7F [7..7]  ============================================== */
typedef enum {                                  /*!< FTM1_STATUS_CH7F                                                          */
  FTM1_STATUS_CH7F_0                   = 0,     /*!< 0 : No channel event has occurred.                                        */
  FTM1_STATUS_CH7F_1                   = 1,     /*!< 1 : A channel event has occurred.                                         */
} FTM1_STATUS_CH7F_Enum;

/* =======================================================  FTM1_MODE  ======================================================= */
/* ==============================================  FTM1 FTM1_MODE FTMEN [0..0]  ============================================== */
typedef enum {                                  /*!< FTM1_MODE_FTMEN                                                           */
  FTM1_MODE_FTMEN_0                    = 0,     /*!< 0 : TPM compatibility. Free running counter and synchronization
                                                     compatible with TPM.                                                      */
  FTM1_MODE_FTMEN_1                    = 1,     /*!< 1 : Free running counter and synchronization are different from
                                                     TPM behavior.                                                             */
} FTM1_MODE_FTMEN_Enum;

/* ==============================================  FTM1 FTM1_MODE WPDIS [2..2]  ============================================== */
typedef enum {                                  /*!< FTM1_MODE_WPDIS                                                           */
  FTM1_MODE_WPDIS_0                    = 0,     /*!< 0 : Write protection is enabled.                                          */
  FTM1_MODE_WPDIS_1                    = 1,     /*!< 1 : Write protection is disabled.                                         */
} FTM1_MODE_WPDIS_Enum;

/* =============================================  FTM1 FTM1_MODE PWMSYNC [3..3]  ============================================= */
typedef enum {                                  /*!< FTM1_MODE_PWMSYNC                                                         */
  FTM1_MODE_PWMSYNC_0                  = 0,     /*!< 0 : No restrictions. Software and hardware triggers can be used
                                                     by MOD, CnV, OUTMASK, and FTM counter synchronization.                    */
  FTM1_MODE_PWMSYNC_1                  = 1,     /*!< 1 : Software trigger can only be used by MOD and CnV synchronization,
                                                     and hardware triggers can only be used by OUTMASK and FTM
                                                     counter synchronization.                                                  */
} FTM1_MODE_PWMSYNC_Enum;

/* =============================================  FTM1 FTM1_MODE CAPTEST [4..4]  ============================================= */
typedef enum {                                  /*!< FTM1_MODE_CAPTEST                                                         */
  FTM1_MODE_CAPTEST_0                  = 0,     /*!< 0 : Capture test mode is disabled.                                        */
  FTM1_MODE_CAPTEST_1                  = 1,     /*!< 1 : Capture test mode is enabled.                                         */
} FTM1_MODE_CAPTEST_Enum;

/* =============================================  FTM1 FTM1_MODE FAULTM [5..6]  ============================================== */
typedef enum {                                  /*!< FTM1_MODE_FAULTM                                                          */
  FTM1_MODE_FAULTM_00                  = 0,     /*!< 00 : Fault control is disabled for all channels.                          */
  FTM1_MODE_FAULTM_01                  = 1,     /*!< 01 : Fault control is enabled for even channels only (channels
                                                     0, 2, 4, and 6), and the selected mode is the manual fault
                                                     clearing.                                                                 */
  FTM1_MODE_FAULTM_10                  = 2,     /*!< 10 : Fault control is enabled for all channels, and the selected
                                                     mode is the manual fault clearing.                                        */
  FTM1_MODE_FAULTM_11                  = 3,     /*!< 11 : Fault control is enabled for all channels, and the selected
                                                     mode is the automatic fault clearing.                                     */
} FTM1_MODE_FAULTM_Enum;

/* =============================================  FTM1 FTM1_MODE FAULTIE [7..7]  ============================================= */
typedef enum {                                  /*!< FTM1_MODE_FAULTIE                                                         */
  FTM1_MODE_FAULTIE_0                  = 0,     /*!< 0 : Fault control interrupt is disabled.                                  */
  FTM1_MODE_FAULTIE_1                  = 1,     /*!< 1 : Fault control interrupt is enabled.                                   */
} FTM1_MODE_FAULTIE_Enum;

/* =======================================================  FTM1_SYNC  ======================================================= */
/* =============================================  FTM1 FTM1_SYNC CNTMIN [0..0]  ============================================== */
typedef enum {                                  /*!< FTM1_SYNC_CNTMIN                                                          */
  FTM1_SYNC_CNTMIN_0                   = 0,     /*!< 0 : The minimum loading point is disabled.                                */
  FTM1_SYNC_CNTMIN_1                   = 1,     /*!< 1 : The minimum loading point is enabled.                                 */
} FTM1_SYNC_CNTMIN_Enum;

/* =============================================  FTM1 FTM1_SYNC CNTMAX [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_SYNC_CNTMAX                                                          */
  FTM1_SYNC_CNTMAX_0                   = 0,     /*!< 0 : The maximum loading point is disabled.                                */
  FTM1_SYNC_CNTMAX_1                   = 1,     /*!< 1 : The maximum loading point is enabled.                                 */
} FTM1_SYNC_CNTMAX_Enum;

/* =============================================  FTM1 FTM1_SYNC REINIT [2..2]  ============================================== */
typedef enum {                                  /*!< FTM1_SYNC_REINIT                                                          */
  FTM1_SYNC_REINIT_0                   = 0,     /*!< 0 : FTM counter continues to count normally.                              */
  FTM1_SYNC_REINIT_1                   = 1,     /*!< 1 : FTM counter is updated with its initial value when the selected
                                                     trigger is detected.                                                      */
} FTM1_SYNC_REINIT_Enum;

/* =============================================  FTM1 FTM1_SYNC SYNCHOM [3..3]  ============================================= */
typedef enum {                                  /*!< FTM1_SYNC_SYNCHOM                                                         */
  FTM1_SYNC_SYNCHOM_0                  = 0,     /*!< 0 : OUTMASK register is updated with the value of its buffer
                                                     in all rising edges of the FTM input clock.                               */
  FTM1_SYNC_SYNCHOM_1                  = 1,     /*!< 1 : OUTMASK register is updated with the value of its buffer
                                                     only by the PWM synchronization.                                          */
} FTM1_SYNC_SYNCHOM_Enum;

/* ==============================================  FTM1 FTM1_SYNC TRIG0 [4..4]  ============================================== */
typedef enum {                                  /*!< FTM1_SYNC_TRIG0                                                           */
  FTM1_SYNC_TRIG0_0                    = 0,     /*!< 0 : Trigger is disabled.                                                  */
  FTM1_SYNC_TRIG0_1                    = 1,     /*!< 1 : Trigger is enabled.                                                   */
} FTM1_SYNC_TRIG0_Enum;

/* ==============================================  FTM1 FTM1_SYNC TRIG1 [5..5]  ============================================== */
typedef enum {                                  /*!< FTM1_SYNC_TRIG1                                                           */
  FTM1_SYNC_TRIG1_0                    = 0,     /*!< 0 : Trigger is disabled.                                                  */
  FTM1_SYNC_TRIG1_1                    = 1,     /*!< 1 : Trigger is enabled.                                                   */
} FTM1_SYNC_TRIG1_Enum;

/* ==============================================  FTM1 FTM1_SYNC TRIG2 [6..6]  ============================================== */
typedef enum {                                  /*!< FTM1_SYNC_TRIG2                                                           */
  FTM1_SYNC_TRIG2_0                    = 0,     /*!< 0 : Trigger is disabled.                                                  */
  FTM1_SYNC_TRIG2_1                    = 1,     /*!< 1 : Trigger is enabled.                                                   */
} FTM1_SYNC_TRIG2_Enum;

/* =============================================  FTM1 FTM1_SYNC SWSYNC [7..7]  ============================================== */
typedef enum {                                  /*!< FTM1_SYNC_SWSYNC                                                          */
  FTM1_SYNC_SWSYNC_0                   = 0,     /*!< 0 : Software trigger is not selected.                                     */
  FTM1_SYNC_SWSYNC_1                   = 1,     /*!< 1 : Software trigger is selected.                                         */
} FTM1_SYNC_SWSYNC_Enum;

/* =====================================================  FTM1_OUTINIT  ====================================================== */
/* ============================================  FTM1 FTM1_OUTINIT CH0OI [0..0]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTINIT_CH0OI                                                        */
  FTM1_OUTINIT_CH0OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM1_OUTINIT_CH0OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM1_OUTINIT_CH0OI_Enum;

/* ============================================  FTM1 FTM1_OUTINIT CH1OI [1..1]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTINIT_CH1OI                                                        */
  FTM1_OUTINIT_CH1OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM1_OUTINIT_CH1OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM1_OUTINIT_CH1OI_Enum;

/* ============================================  FTM1 FTM1_OUTINIT CH2OI [2..2]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTINIT_CH2OI                                                        */
  FTM1_OUTINIT_CH2OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM1_OUTINIT_CH2OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM1_OUTINIT_CH2OI_Enum;

/* ============================================  FTM1 FTM1_OUTINIT CH3OI [3..3]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTINIT_CH3OI                                                        */
  FTM1_OUTINIT_CH3OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM1_OUTINIT_CH3OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM1_OUTINIT_CH3OI_Enum;

/* ============================================  FTM1 FTM1_OUTINIT CH4OI [4..4]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTINIT_CH4OI                                                        */
  FTM1_OUTINIT_CH4OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM1_OUTINIT_CH4OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM1_OUTINIT_CH4OI_Enum;

/* ============================================  FTM1 FTM1_OUTINIT CH5OI [5..5]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTINIT_CH5OI                                                        */
  FTM1_OUTINIT_CH5OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM1_OUTINIT_CH5OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM1_OUTINIT_CH5OI_Enum;

/* ============================================  FTM1 FTM1_OUTINIT CH6OI [6..6]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTINIT_CH6OI                                                        */
  FTM1_OUTINIT_CH6OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM1_OUTINIT_CH6OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM1_OUTINIT_CH6OI_Enum;

/* ============================================  FTM1 FTM1_OUTINIT CH7OI [7..7]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTINIT_CH7OI                                                        */
  FTM1_OUTINIT_CH7OI_0                 = 0,     /*!< 0 : The initialization value is 0.                                        */
  FTM1_OUTINIT_CH7OI_1                 = 1,     /*!< 1 : The initialization value is 1.                                        */
} FTM1_OUTINIT_CH7OI_Enum;

/* =====================================================  FTM1_OUTMASK  ====================================================== */
/* ============================================  FTM1 FTM1_OUTMASK CH0OM [0..0]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTMASK_CH0OM                                                        */
  FTM1_OUTMASK_CH0OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM1_OUTMASK_CH0OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM1_OUTMASK_CH0OM_Enum;

/* ============================================  FTM1 FTM1_OUTMASK CH1OM [1..1]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTMASK_CH1OM                                                        */
  FTM1_OUTMASK_CH1OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM1_OUTMASK_CH1OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM1_OUTMASK_CH1OM_Enum;

/* ============================================  FTM1 FTM1_OUTMASK CH2OM [2..2]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTMASK_CH2OM                                                        */
  FTM1_OUTMASK_CH2OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM1_OUTMASK_CH2OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM1_OUTMASK_CH2OM_Enum;

/* ============================================  FTM1 FTM1_OUTMASK CH3OM [3..3]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTMASK_CH3OM                                                        */
  FTM1_OUTMASK_CH3OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM1_OUTMASK_CH3OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM1_OUTMASK_CH3OM_Enum;

/* ============================================  FTM1 FTM1_OUTMASK CH4OM [4..4]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTMASK_CH4OM                                                        */
  FTM1_OUTMASK_CH4OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM1_OUTMASK_CH4OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM1_OUTMASK_CH4OM_Enum;

/* ============================================  FTM1 FTM1_OUTMASK CH5OM [5..5]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTMASK_CH5OM                                                        */
  FTM1_OUTMASK_CH5OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM1_OUTMASK_CH5OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM1_OUTMASK_CH5OM_Enum;

/* ============================================  FTM1 FTM1_OUTMASK CH6OM [6..6]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTMASK_CH6OM                                                        */
  FTM1_OUTMASK_CH6OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM1_OUTMASK_CH6OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM1_OUTMASK_CH6OM_Enum;

/* ============================================  FTM1 FTM1_OUTMASK CH7OM [7..7]  ============================================= */
typedef enum {                                  /*!< FTM1_OUTMASK_CH7OM                                                        */
  FTM1_OUTMASK_CH7OM_0                 = 0,     /*!< 0 : Channel output is not masked. It continues to operate normally.       */
  FTM1_OUTMASK_CH7OM_1                 = 1,     /*!< 1 : Channel output is masked. It is forced to its inactive state.         */
} FTM1_OUTMASK_CH7OM_Enum;

/* =====================================================  FTM1_COMBINE  ====================================================== */
/* ============================================  FTM1 FTM1_COMBINE COMP0 [1..1]  ============================================= */
typedef enum {                                  /*!< FTM1_COMBINE_COMP0                                                        */
  FTM1_COMBINE_COMP0_0                 = 0,     /*!< 0 : The channel (n+1) output is the same as the channel (n)
                                                     output.                                                                   */
  FTM1_COMBINE_COMP0_1                 = 1,     /*!< 1 : The channel (n+1) output is the complement of the channel
                                                     (n) output.                                                               */
} FTM1_COMBINE_COMP0_Enum;

/* ============================================  FTM1 FTM1_COMBINE DECAP0 [3..3]  ============================================ */
typedef enum {                                  /*!< FTM1_COMBINE_DECAP0                                                       */
  FTM1_COMBINE_DECAP0_0                = 0,     /*!< 0 : The dual edge captures are inactive.                                  */
  FTM1_COMBINE_DECAP0_1                = 1,     /*!< 1 : The dual edge captures are active.                                    */
} FTM1_COMBINE_DECAP0_Enum;

/* ============================================  FTM1 FTM1_COMBINE DTEN0 [4..4]  ============================================= */
typedef enum {                                  /*!< FTM1_COMBINE_DTEN0                                                        */
  FTM1_COMBINE_DTEN0_0                 = 0,     /*!< 0 : The deadtime insertion in this pair of channels is disabled.          */
  FTM1_COMBINE_DTEN0_1                 = 1,     /*!< 1 : The deadtime insertion in this pair of channels is enabled.           */
} FTM1_COMBINE_DTEN0_Enum;

/* ===========================================  FTM1 FTM1_COMBINE SYNCEN0 [5..5]  ============================================ */
typedef enum {                                  /*!< FTM1_COMBINE_SYNCEN0                                                      */
  FTM1_COMBINE_SYNCEN0_0               = 0,     /*!< 0 : The PWM synchronization in this pair of channels is disabled.         */
  FTM1_COMBINE_SYNCEN0_1               = 1,     /*!< 1 : The PWM synchronization in this pair of channels is enabled.          */
} FTM1_COMBINE_SYNCEN0_Enum;

/* ===========================================  FTM1 FTM1_COMBINE FAULTEN0 [6..6]  =========================================== */
typedef enum {                                  /*!< FTM1_COMBINE_FAULTEN0                                                     */
  FTM1_COMBINE_FAULTEN0_0              = 0,     /*!< 0 : The fault control in this pair of channels is disabled.               */
  FTM1_COMBINE_FAULTEN0_1              = 1,     /*!< 1 : The fault control in this pair of channels is enabled.                */
} FTM1_COMBINE_FAULTEN0_Enum;

/* ============================================  FTM1 FTM1_COMBINE COMP1 [9..9]  ============================================= */
typedef enum {                                  /*!< FTM1_COMBINE_COMP1                                                        */
  FTM1_COMBINE_COMP1_0                 = 0,     /*!< 0 : The channel (n+1) output is the same as the channel (n)
                                                     output.                                                                   */
  FTM1_COMBINE_COMP1_1                 = 1,     /*!< 1 : The channel (n+1) output is the complement of the channel
                                                     (n) output.                                                               */
} FTM1_COMBINE_COMP1_Enum;

/* ===========================================  FTM1 FTM1_COMBINE DECAP1 [11..11]  =========================================== */
typedef enum {                                  /*!< FTM1_COMBINE_DECAP1                                                       */
  FTM1_COMBINE_DECAP1_0                = 0,     /*!< 0 : The dual edge captures are inactive.                                  */
  FTM1_COMBINE_DECAP1_1                = 1,     /*!< 1 : The dual edge captures are active.                                    */
} FTM1_COMBINE_DECAP1_Enum;

/* ===========================================  FTM1 FTM1_COMBINE DTEN1 [12..12]  ============================================ */
typedef enum {                                  /*!< FTM1_COMBINE_DTEN1                                                        */
  FTM1_COMBINE_DTEN1_0                 = 0,     /*!< 0 : The deadtime insertion in this pair of channels is disabled.          */
  FTM1_COMBINE_DTEN1_1                 = 1,     /*!< 1 : The deadtime insertion in this pair of channels is enabled.           */
} FTM1_COMBINE_DTEN1_Enum;

/* ==========================================  FTM1 FTM1_COMBINE SYNCEN1 [13..13]  =========================================== */
typedef enum {                                  /*!< FTM1_COMBINE_SYNCEN1                                                      */
  FTM1_COMBINE_SYNCEN1_0               = 0,     /*!< 0 : The PWM synchronization in this pair of channels is disabled.         */
  FTM1_COMBINE_SYNCEN1_1               = 1,     /*!< 1 : The PWM synchronization in this pair of channels is enabled.          */
} FTM1_COMBINE_SYNCEN1_Enum;

/* ==========================================  FTM1 FTM1_COMBINE FAULTEN1 [14..14]  ========================================== */
typedef enum {                                  /*!< FTM1_COMBINE_FAULTEN1                                                     */
  FTM1_COMBINE_FAULTEN1_0              = 0,     /*!< 0 : The fault control in this pair of channels is disabled.               */
  FTM1_COMBINE_FAULTEN1_1              = 1,     /*!< 1 : The fault control in this pair of channels is enabled.                */
} FTM1_COMBINE_FAULTEN1_Enum;

/* ===========================================  FTM1 FTM1_COMBINE COMP2 [17..17]  ============================================ */
typedef enum {                                  /*!< FTM1_COMBINE_COMP2                                                        */
  FTM1_COMBINE_COMP2_0                 = 0,     /*!< 0 : The channel (n+1) output is the same as the channel (n)
                                                     output.                                                                   */
  FTM1_COMBINE_COMP2_1                 = 1,     /*!< 1 : The channel (n+1) output is the complement of the channel
                                                     (n) output.                                                               */
} FTM1_COMBINE_COMP2_Enum;

/* ===========================================  FTM1 FTM1_COMBINE DECAP2 [19..19]  =========================================== */
typedef enum {                                  /*!< FTM1_COMBINE_DECAP2                                                       */
  FTM1_COMBINE_DECAP2_0                = 0,     /*!< 0 : The dual edge captures are inactive.                                  */
  FTM1_COMBINE_DECAP2_1                = 1,     /*!< 1 : The dual edge captures are active.                                    */
} FTM1_COMBINE_DECAP2_Enum;

/* ===========================================  FTM1 FTM1_COMBINE DTEN2 [20..20]  ============================================ */
typedef enum {                                  /*!< FTM1_COMBINE_DTEN2                                                        */
  FTM1_COMBINE_DTEN2_0                 = 0,     /*!< 0 : The deadtime insertion in this pair of channels is disabled.          */
  FTM1_COMBINE_DTEN2_1                 = 1,     /*!< 1 : The deadtime insertion in this pair of channels is enabled.           */
} FTM1_COMBINE_DTEN2_Enum;

/* ==========================================  FTM1 FTM1_COMBINE SYNCEN2 [21..21]  =========================================== */
typedef enum {                                  /*!< FTM1_COMBINE_SYNCEN2                                                      */
  FTM1_COMBINE_SYNCEN2_0               = 0,     /*!< 0 : The PWM synchronization in this pair of channels is disabled.         */
  FTM1_COMBINE_SYNCEN2_1               = 1,     /*!< 1 : The PWM synchronization in this pair of channels is enabled.          */
} FTM1_COMBINE_SYNCEN2_Enum;

/* ==========================================  FTM1 FTM1_COMBINE FAULTEN2 [22..22]  ========================================== */
typedef enum {                                  /*!< FTM1_COMBINE_FAULTEN2                                                     */
  FTM1_COMBINE_FAULTEN2_0              = 0,     /*!< 0 : The fault control in this pair of channels is disabled.               */
  FTM1_COMBINE_FAULTEN2_1              = 1,     /*!< 1 : The fault control in this pair of channels is enabled.                */
} FTM1_COMBINE_FAULTEN2_Enum;

/* ===========================================  FTM1 FTM1_COMBINE COMP3 [25..25]  ============================================ */
typedef enum {                                  /*!< FTM1_COMBINE_COMP3                                                        */
  FTM1_COMBINE_COMP3_0                 = 0,     /*!< 0 : The channel (n+1) output is the same as the channel (n)
                                                     output.                                                                   */
  FTM1_COMBINE_COMP3_1                 = 1,     /*!< 1 : The channel (n+1) output is the complement of the channel
                                                     (n) output.                                                               */
} FTM1_COMBINE_COMP3_Enum;

/* ===========================================  FTM1 FTM1_COMBINE DECAP3 [27..27]  =========================================== */
typedef enum {                                  /*!< FTM1_COMBINE_DECAP3                                                       */
  FTM1_COMBINE_DECAP3_0                = 0,     /*!< 0 : The dual edge captures are inactive.                                  */
  FTM1_COMBINE_DECAP3_1                = 1,     /*!< 1 : The dual edge captures are active.                                    */
} FTM1_COMBINE_DECAP3_Enum;

/* ===========================================  FTM1 FTM1_COMBINE DTEN3 [28..28]  ============================================ */
typedef enum {                                  /*!< FTM1_COMBINE_DTEN3                                                        */
  FTM1_COMBINE_DTEN3_0                 = 0,     /*!< 0 : The deadtime insertion in this pair of channels is disabled.          */
  FTM1_COMBINE_DTEN3_1                 = 1,     /*!< 1 : The deadtime insertion in this pair of channels is enabled.           */
} FTM1_COMBINE_DTEN3_Enum;

/* ==========================================  FTM1 FTM1_COMBINE SYNCEN3 [29..29]  =========================================== */
typedef enum {                                  /*!< FTM1_COMBINE_SYNCEN3                                                      */
  FTM1_COMBINE_SYNCEN3_0               = 0,     /*!< 0 : The PWM synchronization in this pair of channels is disabled.         */
  FTM1_COMBINE_SYNCEN3_1               = 1,     /*!< 1 : The PWM synchronization in this pair of channels is enabled.          */
} FTM1_COMBINE_SYNCEN3_Enum;

/* ==========================================  FTM1 FTM1_COMBINE FAULTEN3 [30..30]  ========================================== */
typedef enum {                                  /*!< FTM1_COMBINE_FAULTEN3                                                     */
  FTM1_COMBINE_FAULTEN3_0              = 0,     /*!< 0 : The fault control in this pair of channels is disabled.               */
  FTM1_COMBINE_FAULTEN3_1              = 1,     /*!< 1 : The fault control in this pair of channels is enabled.                */
} FTM1_COMBINE_FAULTEN3_Enum;

/* =====================================================  FTM1_DEADTIME  ===================================================== */
/* ============================================  FTM1 FTM1_DEADTIME DTPS [6..7]  ============================================= */
typedef enum {                                  /*!< FTM1_DEADTIME_DTPS                                                        */
  FTM1_DEADTIME_DTPS_0x_0              = 0,     /*!< 0x_0 : Divide the FTM input clock by 1.                                   */
  FTM1_DEADTIME_DTPS_0x_1              = 1,     /*!< 0x_1 : Divide the FTM input clock by 1.                                   */
  FTM1_DEADTIME_DTPS_10                = 2,     /*!< 10 : Divide the FTM input clock by 4.                                     */
  FTM1_DEADTIME_DTPS_11                = 3,     /*!< 11 : Divide the FTM input clock by 16.                                    */
} FTM1_DEADTIME_DTPS_Enum;

/* =====================================================  FTM1_EXTTRIG  ====================================================== */
/* ===========================================  FTM1 FTM1_EXTTRIG CH2TRIG [0..0]  ============================================ */
typedef enum {                                  /*!< FTM1_EXTTRIG_CH2TRIG                                                      */
  FTM1_EXTTRIG_CH2TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM1_EXTTRIG_CH2TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM1_EXTTRIG_CH2TRIG_Enum;

/* ===========================================  FTM1 FTM1_EXTTRIG CH3TRIG [1..1]  ============================================ */
typedef enum {                                  /*!< FTM1_EXTTRIG_CH3TRIG                                                      */
  FTM1_EXTTRIG_CH3TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM1_EXTTRIG_CH3TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM1_EXTTRIG_CH3TRIG_Enum;

/* ===========================================  FTM1 FTM1_EXTTRIG CH4TRIG [2..2]  ============================================ */
typedef enum {                                  /*!< FTM1_EXTTRIG_CH4TRIG                                                      */
  FTM1_EXTTRIG_CH4TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM1_EXTTRIG_CH4TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM1_EXTTRIG_CH4TRIG_Enum;

/* ===========================================  FTM1 FTM1_EXTTRIG CH5TRIG [3..3]  ============================================ */
typedef enum {                                  /*!< FTM1_EXTTRIG_CH5TRIG                                                      */
  FTM1_EXTTRIG_CH5TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM1_EXTTRIG_CH5TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM1_EXTTRIG_CH5TRIG_Enum;

/* ===========================================  FTM1 FTM1_EXTTRIG CH0TRIG [4..4]  ============================================ */
typedef enum {                                  /*!< FTM1_EXTTRIG_CH0TRIG                                                      */
  FTM1_EXTTRIG_CH0TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM1_EXTTRIG_CH0TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM1_EXTTRIG_CH0TRIG_Enum;

/* ===========================================  FTM1 FTM1_EXTTRIG CH1TRIG [5..5]  ============================================ */
typedef enum {                                  /*!< FTM1_EXTTRIG_CH1TRIG                                                      */
  FTM1_EXTTRIG_CH1TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM1_EXTTRIG_CH1TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM1_EXTTRIG_CH1TRIG_Enum;

/* ==========================================  FTM1 FTM1_EXTTRIG INITTRIGEN [6..6]  ========================================== */
typedef enum {                                  /*!< FTM1_EXTTRIG_INITTRIGEN                                                   */
  FTM1_EXTTRIG_INITTRIGEN_0            = 0,     /*!< 0 : The generation of initialization trigger is disabled.                 */
  FTM1_EXTTRIG_INITTRIGEN_1            = 1,     /*!< 1 : The generation of initialization trigger is enabled.                  */
} FTM1_EXTTRIG_INITTRIGEN_Enum;

/* ============================================  FTM1 FTM1_EXTTRIG TRIGF [7..7]  ============================================= */
typedef enum {                                  /*!< FTM1_EXTTRIG_TRIGF                                                        */
  FTM1_EXTTRIG_TRIGF_0                 = 0,     /*!< 0 : No channel trigger was generated.                                     */
  FTM1_EXTTRIG_TRIGF_1                 = 1,     /*!< 1 : A channel trigger was generated.                                      */
} FTM1_EXTTRIG_TRIGF_Enum;

/* ===========================================  FTM1 FTM1_EXTTRIG CH6TRIG [8..8]  ============================================ */
typedef enum {                                  /*!< FTM1_EXTTRIG_CH6TRIG                                                      */
  FTM1_EXTTRIG_CH6TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM1_EXTTRIG_CH6TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM1_EXTTRIG_CH6TRIG_Enum;

/* ===========================================  FTM1 FTM1_EXTTRIG CH7TRIG [9..9]  ============================================ */
typedef enum {                                  /*!< FTM1_EXTTRIG_CH7TRIG                                                      */
  FTM1_EXTTRIG_CH7TRIG_0               = 0,     /*!< 0 : The generation of this external trigger is disabled.                  */
  FTM1_EXTTRIG_CH7TRIG_1               = 1,     /*!< 1 : The generation of this external trigger is enabled.                   */
} FTM1_EXTTRIG_CH7TRIG_Enum;

/* =======================================================  FTM1_POL  ======================================================== */
/* ===============================================  FTM1 FTM1_POL POL0 [0..0]  =============================================== */
typedef enum {                                  /*!< FTM1_POL_POL0                                                             */
  FTM1_POL_POL0_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM1_POL_POL0_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM1_POL_POL0_Enum;

/* ===============================================  FTM1 FTM1_POL POL1 [1..1]  =============================================== */
typedef enum {                                  /*!< FTM1_POL_POL1                                                             */
  FTM1_POL_POL1_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM1_POL_POL1_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM1_POL_POL1_Enum;

/* ===============================================  FTM1 FTM1_POL POL2 [2..2]  =============================================== */
typedef enum {                                  /*!< FTM1_POL_POL2                                                             */
  FTM1_POL_POL2_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM1_POL_POL2_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM1_POL_POL2_Enum;

/* ===============================================  FTM1 FTM1_POL POL3 [3..3]  =============================================== */
typedef enum {                                  /*!< FTM1_POL_POL3                                                             */
  FTM1_POL_POL3_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM1_POL_POL3_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM1_POL_POL3_Enum;

/* ===============================================  FTM1 FTM1_POL POL4 [4..4]  =============================================== */
typedef enum {                                  /*!< FTM1_POL_POL4                                                             */
  FTM1_POL_POL4_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM1_POL_POL4_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM1_POL_POL4_Enum;

/* ===============================================  FTM1 FTM1_POL POL5 [5..5]  =============================================== */
typedef enum {                                  /*!< FTM1_POL_POL5                                                             */
  FTM1_POL_POL5_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM1_POL_POL5_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM1_POL_POL5_Enum;

/* ===============================================  FTM1 FTM1_POL POL6 [6..6]  =============================================== */
typedef enum {                                  /*!< FTM1_POL_POL6                                                             */
  FTM1_POL_POL6_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM1_POL_POL6_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM1_POL_POL6_Enum;

/* ===============================================  FTM1 FTM1_POL POL7 [7..7]  =============================================== */
typedef enum {                                  /*!< FTM1_POL_POL7                                                             */
  FTM1_POL_POL7_0                      = 0,     /*!< 0 : The channel polarity is active high.                                  */
  FTM1_POL_POL7_1                      = 1,     /*!< 1 : The channel polarity is active low.                                   */
} FTM1_POL_POL7_Enum;

/* =======================================================  FTM1_FMS  ======================================================== */
/* =============================================  FTM1 FTM1_FMS FAULTF0 [0..0]  ============================================== */
typedef enum {                                  /*!< FTM1_FMS_FAULTF0                                                          */
  FTM1_FMS_FAULTF0_0                   = 0,     /*!< 0 : No fault condition was detected at the fault input.                   */
  FTM1_FMS_FAULTF0_1                   = 1,     /*!< 1 : A fault condition was detected at the fault input.                    */
} FTM1_FMS_FAULTF0_Enum;

/* =============================================  FTM1 FTM1_FMS FAULTF1 [1..1]  ============================================== */
typedef enum {                                  /*!< FTM1_FMS_FAULTF1                                                          */
  FTM1_FMS_FAULTF1_0                   = 0,     /*!< 0 : No fault condition was detected at the fault input.                   */
  FTM1_FMS_FAULTF1_1                   = 1,     /*!< 1 : A fault condition was detected at the fault input.                    */
} FTM1_FMS_FAULTF1_Enum;

/* =============================================  FTM1 FTM1_FMS FAULTF2 [2..2]  ============================================== */
typedef enum {                                  /*!< FTM1_FMS_FAULTF2                                                          */
  FTM1_FMS_FAULTF2_0                   = 0,     /*!< 0 : No fault condition was detected at the fault input.                   */
  FTM1_FMS_FAULTF2_1                   = 1,     /*!< 1 : A fault condition was detected at the fault input.                    */
} FTM1_FMS_FAULTF2_Enum;

/* =============================================  FTM1 FTM1_FMS FAULTF3 [3..3]  ============================================== */
typedef enum {                                  /*!< FTM1_FMS_FAULTF3                                                          */
  FTM1_FMS_FAULTF3_0                   = 0,     /*!< 0 : No fault condition was detected at the fault input.                   */
  FTM1_FMS_FAULTF3_1                   = 1,     /*!< 1 : A fault condition was detected at the fault input.                    */
} FTM1_FMS_FAULTF3_Enum;

/* =============================================  FTM1 FTM1_FMS FAULTIN [5..5]  ============================================== */
typedef enum {                                  /*!< FTM1_FMS_FAULTIN                                                          */
  FTM1_FMS_FAULTIN_0                   = 0,     /*!< 0 : The logic OR of the enabled fault inputs is 0.                        */
  FTM1_FMS_FAULTIN_1                   = 1,     /*!< 1 : The logic OR of the enabled fault inputs is 1.                        */
} FTM1_FMS_FAULTIN_Enum;

/* ===============================================  FTM1 FTM1_FMS WPEN [6..6]  =============================================== */
typedef enum {                                  /*!< FTM1_FMS_WPEN                                                             */
  FTM1_FMS_WPEN_0                      = 0,     /*!< 0 : Write protection is disabled. Write protected bits can be
                                                     written.                                                                  */
  FTM1_FMS_WPEN_1                      = 1,     /*!< 1 : Write protection is enabled. Write protected bits cannot
                                                     be written.                                                               */
} FTM1_FMS_WPEN_Enum;

/* ==============================================  FTM1 FTM1_FMS FAULTF [7..7]  ============================================== */
typedef enum {                                  /*!< FTM1_FMS_FAULTF                                                           */
  FTM1_FMS_FAULTF_0                    = 0,     /*!< 0 : No fault condition was detected.                                      */
  FTM1_FMS_FAULTF_1                    = 1,     /*!< 1 : A fault condition was detected.                                       */
} FTM1_FMS_FAULTF_Enum;

/* ======================================================  FTM1_FILTER  ====================================================== */
/* =====================================================  FTM1_FLTCTRL  ====================================================== */
/* ===========================================  FTM1 FTM1_FLTCTRL FAULT0EN [0..0]  =========================================== */
typedef enum {                                  /*!< FTM1_FLTCTRL_FAULT0EN                                                     */
  FTM1_FLTCTRL_FAULT0EN_0              = 0,     /*!< 0 : Fault input is disabled.                                              */
  FTM1_FLTCTRL_FAULT0EN_1              = 1,     /*!< 1 : Fault input is enabled.                                               */
} FTM1_FLTCTRL_FAULT0EN_Enum;

/* ===========================================  FTM1 FTM1_FLTCTRL FAULT1EN [1..1]  =========================================== */
typedef enum {                                  /*!< FTM1_FLTCTRL_FAULT1EN                                                     */
  FTM1_FLTCTRL_FAULT1EN_0              = 0,     /*!< 0 : Fault input is disabled.                                              */
  FTM1_FLTCTRL_FAULT1EN_1              = 1,     /*!< 1 : Fault input is enabled.                                               */
} FTM1_FLTCTRL_FAULT1EN_Enum;

/* ===========================================  FTM1 FTM1_FLTCTRL FAULT2EN [2..2]  =========================================== */
typedef enum {                                  /*!< FTM1_FLTCTRL_FAULT2EN                                                     */
  FTM1_FLTCTRL_FAULT2EN_0              = 0,     /*!< 0 : Fault input is disabled.                                              */
  FTM1_FLTCTRL_FAULT2EN_1              = 1,     /*!< 1 : Fault input is enabled.                                               */
} FTM1_FLTCTRL_FAULT2EN_Enum;

/* ===========================================  FTM1 FTM1_FLTCTRL FAULT3EN [3..3]  =========================================== */
typedef enum {                                  /*!< FTM1_FLTCTRL_FAULT3EN                                                     */
  FTM1_FLTCTRL_FAULT3EN_0              = 0,     /*!< 0 : Fault input is disabled.                                              */
  FTM1_FLTCTRL_FAULT3EN_1              = 1,     /*!< 1 : Fault input is enabled.                                               */
} FTM1_FLTCTRL_FAULT3EN_Enum;

/* ===========================================  FTM1 FTM1_FLTCTRL FFLTR0EN [4..4]  =========================================== */
typedef enum {                                  /*!< FTM1_FLTCTRL_FFLTR0EN                                                     */
  FTM1_FLTCTRL_FFLTR0EN_0              = 0,     /*!< 0 : Fault input filter is disabled.                                       */
  FTM1_FLTCTRL_FFLTR0EN_1              = 1,     /*!< 1 : Fault input filter is enabled.                                        */
} FTM1_FLTCTRL_FFLTR0EN_Enum;

/* ===========================================  FTM1 FTM1_FLTCTRL FFLTR1EN [5..5]  =========================================== */
typedef enum {                                  /*!< FTM1_FLTCTRL_FFLTR1EN                                                     */
  FTM1_FLTCTRL_FFLTR1EN_0              = 0,     /*!< 0 : Fault input filter is disabled.                                       */
  FTM1_FLTCTRL_FFLTR1EN_1              = 1,     /*!< 1 : Fault input filter is enabled.                                        */
} FTM1_FLTCTRL_FFLTR1EN_Enum;

/* ===========================================  FTM1 FTM1_FLTCTRL FFLTR2EN [6..6]  =========================================== */
typedef enum {                                  /*!< FTM1_FLTCTRL_FFLTR2EN                                                     */
  FTM1_FLTCTRL_FFLTR2EN_0              = 0,     /*!< 0 : Fault input filter is disabled.                                       */
  FTM1_FLTCTRL_FFLTR2EN_1              = 1,     /*!< 1 : Fault input filter is enabled.                                        */
} FTM1_FLTCTRL_FFLTR2EN_Enum;

/* ===========================================  FTM1 FTM1_FLTCTRL FFLTR3EN [7..7]  =========================================== */
typedef enum {                                  /*!< FTM1_FLTCTRL_FFLTR3EN                                                     */
  FTM1_FLTCTRL_FFLTR3EN_0              = 0,     /*!< 0 : Fault input filter is disabled.                                       */
  FTM1_FLTCTRL_FFLTR3EN_1              = 1,     /*!< 1 : Fault input filter is enabled.                                        */
} FTM1_FLTCTRL_FFLTR3EN_Enum;

/* ===========================================  FTM1 FTM1_FLTCTRL FSTATE [15..15]  =========================================== */
typedef enum {                                  /*!< FTM1_FLTCTRL_FSTATE                                                       */
  FTM1_FLTCTRL_FSTATE_0                = 0,     /*!< 0 : FTM outputs will be placed into safe values when fault events
                                                     in ongoing (defined by POL bits).                                         */
  FTM1_FLTCTRL_FSTATE_1                = 1,     /*!< 1 : FTM outputs will be tri-stated when fault event is ongoing            */
} FTM1_FLTCTRL_FSTATE_Enum;

/* ======================================================  FTM1_QDCTRL  ====================================================== */
/* ============================================  FTM1 FTM1_QDCTRL QUADEN [0..0]  ============================================= */
typedef enum {                                  /*!< FTM1_QDCTRL_QUADEN                                                        */
  FTM1_QDCTRL_QUADEN_0                 = 0,     /*!< 0 : Quadrature Decoder mode is disabled.                                  */
  FTM1_QDCTRL_QUADEN_1                 = 1,     /*!< 1 : Quadrature Decoder mode is enabled.                                   */
} FTM1_QDCTRL_QUADEN_Enum;

/* ============================================  FTM1 FTM1_QDCTRL TOFDIR [1..1]  ============================================= */
typedef enum {                                  /*!< FTM1_QDCTRL_TOFDIR                                                        */
  FTM1_QDCTRL_TOFDIR_0                 = 0,     /*!< 0 : TOF bit was set on the bottom of counting. There was an
                                                     FTM counter decrement and FTM counter changes from its
                                                     minimum value (CNTIN register) to its maximum value (MOD
                                                     register).                                                                */
  FTM1_QDCTRL_TOFDIR_1                 = 1,     /*!< 1 : TOF bit was set on the top of counting. There was an FTM
                                                     counter increment and FTM counter changes from its maximum
                                                     value (MOD register) to its minimum value (CNTIN register).               */
} FTM1_QDCTRL_TOFDIR_Enum;

/* ============================================  FTM1 FTM1_QDCTRL QUADIR [2..2]  ============================================= */
typedef enum {                                  /*!< FTM1_QDCTRL_QUADIR                                                        */
  FTM1_QDCTRL_QUADIR_0                 = 0,     /*!< 0 : Counting direction is decreasing (FTM counter decrement).             */
  FTM1_QDCTRL_QUADIR_1                 = 1,     /*!< 1 : Counting direction is increasing (FTM counter increment).             */
} FTM1_QDCTRL_QUADIR_Enum;

/* ===========================================  FTM1 FTM1_QDCTRL QUADMODE [3..3]  ============================================ */
typedef enum {                                  /*!< FTM1_QDCTRL_QUADMODE                                                      */
  FTM1_QDCTRL_QUADMODE_0               = 0,     /*!< 0 : Phase A and phase B encoding mode.                                    */
  FTM1_QDCTRL_QUADMODE_1               = 1,     /*!< 1 : Count and direction encoding mode.                                    */
} FTM1_QDCTRL_QUADMODE_Enum;

/* ============================================  FTM1 FTM1_QDCTRL PHBPOL [4..4]  ============================================= */
typedef enum {                                  /*!< FTM1_QDCTRL_PHBPOL                                                        */
  FTM1_QDCTRL_PHBPOL_0                 = 0,     /*!< 0 : Normal polarity. Phase B input signal is not inverted before
                                                     identifying the rising and falling edges of this signal.                  */
  FTM1_QDCTRL_PHBPOL_1                 = 1,     /*!< 1 : Inverted polarity. Phase B input signal is inverted before
                                                     identifying the rising and falling edges of this signal.                  */
} FTM1_QDCTRL_PHBPOL_Enum;

/* ============================================  FTM1 FTM1_QDCTRL PHAPOL [5..5]  ============================================= */
typedef enum {                                  /*!< FTM1_QDCTRL_PHAPOL                                                        */
  FTM1_QDCTRL_PHAPOL_0                 = 0,     /*!< 0 : Normal polarity. Phase A input signal is not inverted before
                                                     identifying the rising and falling edges of this signal.                  */
  FTM1_QDCTRL_PHAPOL_1                 = 1,     /*!< 1 : Inverted polarity. Phase A input signal is inverted before
                                                     identifying the rising and falling edges of this signal.                  */
} FTM1_QDCTRL_PHAPOL_Enum;

/* ===========================================  FTM1 FTM1_QDCTRL PHBFLTREN [6..6]  =========================================== */
typedef enum {                                  /*!< FTM1_QDCTRL_PHBFLTREN                                                     */
  FTM1_QDCTRL_PHBFLTREN_0              = 0,     /*!< 0 : Phase B input filter is disabled.                                     */
  FTM1_QDCTRL_PHBFLTREN_1              = 1,     /*!< 1 : Phase B input filter is enabled.                                      */
} FTM1_QDCTRL_PHBFLTREN_Enum;

/* ===========================================  FTM1 FTM1_QDCTRL PHAFLTREN [7..7]  =========================================== */
typedef enum {                                  /*!< FTM1_QDCTRL_PHAFLTREN                                                     */
  FTM1_QDCTRL_PHAFLTREN_0              = 0,     /*!< 0 : Phase A input filter is disabled.                                     */
  FTM1_QDCTRL_PHAFLTREN_1              = 1,     /*!< 1 : Phase A input filter is enabled.                                      */
} FTM1_QDCTRL_PHAFLTREN_Enum;

/* =======================================================  FTM1_CONF  ======================================================= */
/* ============================================  FTM1 FTM1_CONF ITRIGR [11..11]  ============================================= */
typedef enum {                                  /*!< FTM1_CONF_ITRIGR                                                          */
  FTM1_CONF_ITRIGR_0                   = 0,     /*!< 0 : Initialization trigger is generated on counter wrap events.           */
  FTM1_CONF_ITRIGR_1                   = 1,     /*!< 1 : Initialization trigger is generated when a reload point
                                                     is reached.                                                               */
} FTM1_CONF_ITRIGR_Enum;

/* ======================================================  FTM1_FLTPOL  ====================================================== */
/* ============================================  FTM1 FTM1_FLTPOL FLT0POL [0..0]  ============================================ */
typedef enum {                                  /*!< FTM1_FLTPOL_FLT0POL                                                       */
  FTM1_FLTPOL_FLT0POL_0                = 0,     /*!< 0 : The fault input polarity is active high. A 1 at the fault
                                                     input indicates a fault.                                                  */
  FTM1_FLTPOL_FLT0POL_1                = 1,     /*!< 1 : The fault input polarity is active low. A 0 at the fault
                                                     input indicates a fault.                                                  */
} FTM1_FLTPOL_FLT0POL_Enum;

/* ============================================  FTM1 FTM1_FLTPOL FLT1POL [1..1]  ============================================ */
typedef enum {                                  /*!< FTM1_FLTPOL_FLT1POL                                                       */
  FTM1_FLTPOL_FLT1POL_0                = 0,     /*!< 0 : The fault input polarity is active high. A 1 at the fault
                                                     input indicates a fault.                                                  */
  FTM1_FLTPOL_FLT1POL_1                = 1,     /*!< 1 : The fault input polarity is active low. A 0 at the fault
                                                     input indicates a fault.                                                  */
} FTM1_FLTPOL_FLT1POL_Enum;

/* ============================================  FTM1 FTM1_FLTPOL FLT2POL [2..2]  ============================================ */
typedef enum {                                  /*!< FTM1_FLTPOL_FLT2POL                                                       */
  FTM1_FLTPOL_FLT2POL_0                = 0,     /*!< 0 : The fault input polarity is active high. A 1 at the fault
                                                     input indicates a fault.                                                  */
  FTM1_FLTPOL_FLT2POL_1                = 1,     /*!< 1 : The fault input polarity is active low. A 0 at the fault
                                                     input indicates a fault.                                                  */
} FTM1_FLTPOL_FLT2POL_Enum;

/* ============================================  FTM1 FTM1_FLTPOL FLT3POL [3..3]  ============================================ */
typedef enum {                                  /*!< FTM1_FLTPOL_FLT3POL                                                       */
  FTM1_FLTPOL_FLT3POL_0                = 0,     /*!< 0 : The fault input polarity is active high. A 1 at the fault
                                                     input indicates a fault.                                                  */
  FTM1_FLTPOL_FLT3POL_1                = 1,     /*!< 1 : The fault input polarity is active low. A 0 at the fault
                                                     input indicates a fault.                                                  */
} FTM1_FLTPOL_FLT3POL_Enum;

/* =====================================================  FTM1_SYNCONF  ====================================================== */
/* ==========================================  FTM1 FTM1_SYNCONF HWTRIGMODE [0..0]  ========================================== */
typedef enum {                                  /*!< FTM1_SYNCONF_HWTRIGMODE                                                   */
  FTM1_SYNCONF_HWTRIGMODE_0            = 0,     /*!< 0 : FTM clears the TRIGj bit when the hardware trigger j is
                                                     detected, where j = 0, 1,2.                                               */
  FTM1_SYNCONF_HWTRIGMODE_1            = 1,     /*!< 1 : FTM does not clear the TRIGj bit when the hardware trigger
                                                     j is detected, where j = 0, 1,2.                                          */
} FTM1_SYNCONF_HWTRIGMODE_Enum;

/* ============================================  FTM1 FTM1_SYNCONF CNTINC [2..2]  ============================================ */
typedef enum {                                  /*!< FTM1_SYNCONF_CNTINC                                                       */
  FTM1_SYNCONF_CNTINC_0                = 0,     /*!< 0 : CNTIN register is updated with its buffer value at all rising
                                                     edges of FTM input clock.                                                 */
  FTM1_SYNCONF_CNTINC_1                = 1,     /*!< 1 : CNTIN register is updated with its buffer value by the PWM
                                                     synchronization.                                                          */
} FTM1_SYNCONF_CNTINC_Enum;

/* =============================================  FTM1 FTM1_SYNCONF INVC [4..4]  ============================================= */
typedef enum {                                  /*!< FTM1_SYNCONF_INVC                                                         */
  FTM1_SYNCONF_INVC_0                  = 0,     /*!< 0 : INVCTRL register is updated with its buffer value at all
                                                     rising edges of FTM input clock.                                          */
  FTM1_SYNCONF_INVC_1                  = 1,     /*!< 1 : INVCTRL register is updated with its buffer value by the
                                                     PWM synchronization.                                                      */
} FTM1_SYNCONF_INVC_Enum;

/* =============================================  FTM1 FTM1_SYNCONF SWOC [5..5]  ============================================= */
typedef enum {                                  /*!< FTM1_SYNCONF_SWOC                                                         */
  FTM1_SYNCONF_SWOC_0                  = 0,     /*!< 0 : SWOCTRL register is updated with its buffer value at all
                                                     rising edges of FTM input clock.                                          */
  FTM1_SYNCONF_SWOC_1                  = 1,     /*!< 1 : SWOCTRL register is updated with its buffer value by the
                                                     PWM synchronization.                                                      */
} FTM1_SYNCONF_SWOC_Enum;

/* ===========================================  FTM1 FTM1_SYNCONF SYNCMODE [7..7]  =========================================== */
typedef enum {                                  /*!< FTM1_SYNCONF_SYNCMODE                                                     */
  FTM1_SYNCONF_SYNCMODE_0              = 0,     /*!< 0 : Legacy PWM synchronization is selected.                               */
  FTM1_SYNCONF_SYNCMODE_1              = 1,     /*!< 1 : Enhanced PWM synchronization is selected.                             */
} FTM1_SYNCONF_SYNCMODE_Enum;

/* ===========================================  FTM1 FTM1_SYNCONF SWRSTCNT [8..8]  =========================================== */
typedef enum {                                  /*!< FTM1_SYNCONF_SWRSTCNT                                                     */
  FTM1_SYNCONF_SWRSTCNT_0              = 0,     /*!< 0 : The software trigger does not activate the FTM counter synchronization. */
  FTM1_SYNCONF_SWRSTCNT_1              = 1,     /*!< 1 : The software trigger activates the FTM counter synchronization.       */
} FTM1_SYNCONF_SWRSTCNT_Enum;

/* ===========================================  FTM1 FTM1_SYNCONF SWWRBUF [9..9]  ============================================ */
typedef enum {                                  /*!< FTM1_SYNCONF_SWWRBUF                                                      */
  FTM1_SYNCONF_SWWRBUF_0               = 0,     /*!< 0 : The software trigger does not activate MOD, HCR, CNTIN,
                                                     and CV registers synchronization.                                         */
  FTM1_SYNCONF_SWWRBUF_1               = 1,     /*!< 1 : The software trigger activates MOD, HCR, CNTIN, and CV registers
                                                     synchronization.                                                          */
} FTM1_SYNCONF_SWWRBUF_Enum;

/* ============================================  FTM1 FTM1_SYNCONF SWOM [10..10]  ============================================ */
typedef enum {                                  /*!< FTM1_SYNCONF_SWOM                                                         */
  FTM1_SYNCONF_SWOM_0                  = 0,     /*!< 0 : The software trigger does not activate the OUTMASK register
                                                     synchronization.                                                          */
  FTM1_SYNCONF_SWOM_1                  = 1,     /*!< 1 : The software trigger activates the OUTMASK register synchronization.  */
} FTM1_SYNCONF_SWOM_Enum;

/* ===========================================  FTM1 FTM1_SYNCONF SWINVC [11..11]  =========================================== */
typedef enum {                                  /*!< FTM1_SYNCONF_SWINVC                                                       */
  FTM1_SYNCONF_SWINVC_0                = 0,     /*!< 0 : The software trigger does not activate the INVCTRL register
                                                     synchronization.                                                          */
  FTM1_SYNCONF_SWINVC_1                = 1,     /*!< 1 : The software trigger activates the INVCTRL register synchronization.  */
} FTM1_SYNCONF_SWINVC_Enum;

/* ===========================================  FTM1 FTM1_SYNCONF SWSOC [12..12]  ============================================ */
typedef enum {                                  /*!< FTM1_SYNCONF_SWSOC                                                        */
  FTM1_SYNCONF_SWSOC_0                 = 0,     /*!< 0 : The software trigger does not activate the SWOCTRL register
                                                     synchronization.                                                          */
  FTM1_SYNCONF_SWSOC_1                 = 1,     /*!< 1 : The software trigger activates the SWOCTRL register synchronization.  */
} FTM1_SYNCONF_SWSOC_Enum;

/* ==========================================  FTM1 FTM1_SYNCONF HWRSTCNT [16..16]  ========================================== */
typedef enum {                                  /*!< FTM1_SYNCONF_HWRSTCNT                                                     */
  FTM1_SYNCONF_HWRSTCNT_0              = 0,     /*!< 0 : A hardware trigger does not activate the FTM counter synchronization. */
  FTM1_SYNCONF_HWRSTCNT_1              = 1,     /*!< 1 : A hardware trigger activates the FTM counter synchronization.         */
} FTM1_SYNCONF_HWRSTCNT_Enum;

/* ==========================================  FTM1 FTM1_SYNCONF HWWRBUF [17..17]  =========================================== */
typedef enum {                                  /*!< FTM1_SYNCONF_HWWRBUF                                                      */
  FTM1_SYNCONF_HWWRBUF_0               = 0,     /*!< 0 : A hardware trigger does not activate MOD, HCR, CNTIN, and
                                                     CV registers synchronization.                                             */
  FTM1_SYNCONF_HWWRBUF_1               = 1,     /*!< 1 : A hardware trigger activates MOD, HCR, CNTIN, and CV registers
                                                     synchronization.                                                          */
} FTM1_SYNCONF_HWWRBUF_Enum;

/* ============================================  FTM1 FTM1_SYNCONF HWOM [18..18]  ============================================ */
typedef enum {                                  /*!< FTM1_SYNCONF_HWOM                                                         */
  FTM1_SYNCONF_HWOM_0                  = 0,     /*!< 0 : A hardware trigger does not activate the OUTMASK register
                                                     synchronization.                                                          */
  FTM1_SYNCONF_HWOM_1                  = 1,     /*!< 1 : A hardware trigger activates the OUTMASK register synchronization.    */
} FTM1_SYNCONF_HWOM_Enum;

/* ===========================================  FTM1 FTM1_SYNCONF HWINVC [19..19]  =========================================== */
typedef enum {                                  /*!< FTM1_SYNCONF_HWINVC                                                       */
  FTM1_SYNCONF_HWINVC_0                = 0,     /*!< 0 : A hardware trigger does not activate the INVCTRL register
                                                     synchronization.                                                          */
  FTM1_SYNCONF_HWINVC_1                = 1,     /*!< 1 : A hardware trigger activates the INVCTRL register synchronization.    */
} FTM1_SYNCONF_HWINVC_Enum;

/* ===========================================  FTM1 FTM1_SYNCONF HWSOC [20..20]  ============================================ */
typedef enum {                                  /*!< FTM1_SYNCONF_HWSOC                                                        */
  FTM1_SYNCONF_HWSOC_0                 = 0,     /*!< 0 : A hardware trigger does not activate the SWOCTRL register
                                                     synchronization.                                                          */
  FTM1_SYNCONF_HWSOC_1                 = 1,     /*!< 1 : A hardware trigger activates the SWOCTRL register synchronization.    */
} FTM1_SYNCONF_HWSOC_Enum;

/* =====================================================  FTM1_INVCTRL  ====================================================== */
/* ============================================  FTM1 FTM1_INVCTRL INV0EN [0..0]  ============================================ */
typedef enum {                                  /*!< FTM1_INVCTRL_INV0EN                                                       */
  FTM1_INVCTRL_INV0EN_0                = 0,     /*!< 0 : Inverting is disabled.                                                */
  FTM1_INVCTRL_INV0EN_1                = 1,     /*!< 1 : Inverting is enabled.                                                 */
} FTM1_INVCTRL_INV0EN_Enum;

/* ============================================  FTM1 FTM1_INVCTRL INV1EN [1..1]  ============================================ */
typedef enum {                                  /*!< FTM1_INVCTRL_INV1EN                                                       */
  FTM1_INVCTRL_INV1EN_0                = 0,     /*!< 0 : Inverting is disabled.                                                */
  FTM1_INVCTRL_INV1EN_1                = 1,     /*!< 1 : Inverting is enabled.                                                 */
} FTM1_INVCTRL_INV1EN_Enum;

/* ============================================  FTM1 FTM1_INVCTRL INV2EN [2..2]  ============================================ */
typedef enum {                                  /*!< FTM1_INVCTRL_INV2EN                                                       */
  FTM1_INVCTRL_INV2EN_0                = 0,     /*!< 0 : Inverting is disabled.                                                */
  FTM1_INVCTRL_INV2EN_1                = 1,     /*!< 1 : Inverting is enabled.                                                 */
} FTM1_INVCTRL_INV2EN_Enum;

/* ============================================  FTM1 FTM1_INVCTRL INV3EN [3..3]  ============================================ */
typedef enum {                                  /*!< FTM1_INVCTRL_INV3EN                                                       */
  FTM1_INVCTRL_INV3EN_0                = 0,     /*!< 0 : Inverting is disabled.                                                */
  FTM1_INVCTRL_INV3EN_1                = 1,     /*!< 1 : Inverting is enabled.                                                 */
} FTM1_INVCTRL_INV3EN_Enum;

/* =====================================================  FTM1_SWOCTRL  ====================================================== */
/* ============================================  FTM1 FTM1_SWOCTRL CH0OC [0..0]  ============================================= */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH0OC                                                        */
  FTM1_SWOCTRL_CH0OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM1_SWOCTRL_CH0OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM1_SWOCTRL_CH0OC_Enum;

/* ============================================  FTM1 FTM1_SWOCTRL CH1OC [1..1]  ============================================= */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH1OC                                                        */
  FTM1_SWOCTRL_CH1OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM1_SWOCTRL_CH1OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM1_SWOCTRL_CH1OC_Enum;

/* ============================================  FTM1 FTM1_SWOCTRL CH2OC [2..2]  ============================================= */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH2OC                                                        */
  FTM1_SWOCTRL_CH2OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM1_SWOCTRL_CH2OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM1_SWOCTRL_CH2OC_Enum;

/* ============================================  FTM1 FTM1_SWOCTRL CH3OC [3..3]  ============================================= */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH3OC                                                        */
  FTM1_SWOCTRL_CH3OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM1_SWOCTRL_CH3OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM1_SWOCTRL_CH3OC_Enum;

/* ============================================  FTM1 FTM1_SWOCTRL CH4OC [4..4]  ============================================= */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH4OC                                                        */
  FTM1_SWOCTRL_CH4OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM1_SWOCTRL_CH4OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM1_SWOCTRL_CH4OC_Enum;

/* ============================================  FTM1 FTM1_SWOCTRL CH5OC [5..5]  ============================================= */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH5OC                                                        */
  FTM1_SWOCTRL_CH5OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM1_SWOCTRL_CH5OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM1_SWOCTRL_CH5OC_Enum;

/* ============================================  FTM1 FTM1_SWOCTRL CH6OC [6..6]  ============================================= */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH6OC                                                        */
  FTM1_SWOCTRL_CH6OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM1_SWOCTRL_CH6OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM1_SWOCTRL_CH6OC_Enum;

/* ============================================  FTM1 FTM1_SWOCTRL CH7OC [7..7]  ============================================= */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH7OC                                                        */
  FTM1_SWOCTRL_CH7OC_0                 = 0,     /*!< 0 : The channel output is not affected by software output control.        */
  FTM1_SWOCTRL_CH7OC_1                 = 1,     /*!< 1 : The channel output is affected by software output control.            */
} FTM1_SWOCTRL_CH7OC_Enum;

/* ============================================  FTM1 FTM1_SWOCTRL CH0OCV [8..8]  ============================================ */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH0OCV                                                       */
  FTM1_SWOCTRL_CH0OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM1_SWOCTRL_CH0OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM1_SWOCTRL_CH0OCV_Enum;

/* ============================================  FTM1 FTM1_SWOCTRL CH1OCV [9..9]  ============================================ */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH1OCV                                                       */
  FTM1_SWOCTRL_CH1OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM1_SWOCTRL_CH1OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM1_SWOCTRL_CH1OCV_Enum;

/* ===========================================  FTM1 FTM1_SWOCTRL CH2OCV [10..10]  =========================================== */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH2OCV                                                       */
  FTM1_SWOCTRL_CH2OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM1_SWOCTRL_CH2OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM1_SWOCTRL_CH2OCV_Enum;

/* ===========================================  FTM1 FTM1_SWOCTRL CH3OCV [11..11]  =========================================== */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH3OCV                                                       */
  FTM1_SWOCTRL_CH3OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM1_SWOCTRL_CH3OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM1_SWOCTRL_CH3OCV_Enum;

/* ===========================================  FTM1 FTM1_SWOCTRL CH4OCV [12..12]  =========================================== */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH4OCV                                                       */
  FTM1_SWOCTRL_CH4OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM1_SWOCTRL_CH4OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM1_SWOCTRL_CH4OCV_Enum;

/* ===========================================  FTM1 FTM1_SWOCTRL CH5OCV [13..13]  =========================================== */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH5OCV                                                       */
  FTM1_SWOCTRL_CH5OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM1_SWOCTRL_CH5OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM1_SWOCTRL_CH5OCV_Enum;

/* ===========================================  FTM1 FTM1_SWOCTRL CH6OCV [14..14]  =========================================== */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH6OCV                                                       */
  FTM1_SWOCTRL_CH6OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM1_SWOCTRL_CH6OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM1_SWOCTRL_CH6OCV_Enum;

/* ===========================================  FTM1 FTM1_SWOCTRL CH7OCV [15..15]  =========================================== */
typedef enum {                                  /*!< FTM1_SWOCTRL_CH7OCV                                                       */
  FTM1_SWOCTRL_CH7OCV_0                = 0,     /*!< 0 : The software output control forces 0 to the channel output.           */
  FTM1_SWOCTRL_CH7OCV_1                = 1,     /*!< 1 : The software output control forces 1 to the channel output.           */
} FTM1_SWOCTRL_CH7OCV_Enum;

/* =====================================================  FTM1_PWMLOAD  ====================================================== */
/* ============================================  FTM1 FTM1_PWMLOAD CH0SEL [0..0]  ============================================ */
typedef enum {                                  /*!< FTM1_PWMLOAD_CH0SEL                                                       */
  FTM1_PWMLOAD_CH0SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM1_PWMLOAD_CH0SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM1_PWMLOAD_CH0SEL_Enum;

/* ============================================  FTM1 FTM1_PWMLOAD CH1SEL [1..1]  ============================================ */
typedef enum {                                  /*!< FTM1_PWMLOAD_CH1SEL                                                       */
  FTM1_PWMLOAD_CH1SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM1_PWMLOAD_CH1SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM1_PWMLOAD_CH1SEL_Enum;

/* ============================================  FTM1 FTM1_PWMLOAD CH2SEL [2..2]  ============================================ */
typedef enum {                                  /*!< FTM1_PWMLOAD_CH2SEL                                                       */
  FTM1_PWMLOAD_CH2SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM1_PWMLOAD_CH2SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM1_PWMLOAD_CH2SEL_Enum;

/* ============================================  FTM1 FTM1_PWMLOAD CH3SEL [3..3]  ============================================ */
typedef enum {                                  /*!< FTM1_PWMLOAD_CH3SEL                                                       */
  FTM1_PWMLOAD_CH3SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM1_PWMLOAD_CH3SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM1_PWMLOAD_CH3SEL_Enum;

/* ============================================  FTM1 FTM1_PWMLOAD CH4SEL [4..4]  ============================================ */
typedef enum {                                  /*!< FTM1_PWMLOAD_CH4SEL                                                       */
  FTM1_PWMLOAD_CH4SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM1_PWMLOAD_CH4SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM1_PWMLOAD_CH4SEL_Enum;

/* ============================================  FTM1 FTM1_PWMLOAD CH5SEL [5..5]  ============================================ */
typedef enum {                                  /*!< FTM1_PWMLOAD_CH5SEL                                                       */
  FTM1_PWMLOAD_CH5SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM1_PWMLOAD_CH5SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM1_PWMLOAD_CH5SEL_Enum;

/* ============================================  FTM1 FTM1_PWMLOAD CH6SEL [6..6]  ============================================ */
typedef enum {                                  /*!< FTM1_PWMLOAD_CH6SEL                                                       */
  FTM1_PWMLOAD_CH6SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM1_PWMLOAD_CH6SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM1_PWMLOAD_CH6SEL_Enum;

/* ============================================  FTM1 FTM1_PWMLOAD CH7SEL [7..7]  ============================================ */
typedef enum {                                  /*!< FTM1_PWMLOAD_CH7SEL                                                       */
  FTM1_PWMLOAD_CH7SEL_0                = 0,     /*!< 0 : Channel match is not included as a reload opportunity.                */
  FTM1_PWMLOAD_CH7SEL_1                = 1,     /*!< 1 : Channel match is included as a reload opportunity.                    */
} FTM1_PWMLOAD_CH7SEL_Enum;

/* ============================================  FTM1 FTM1_PWMLOAD HCSEL [8..8]  ============================================= */
typedef enum {                                  /*!< FTM1_PWMLOAD_HCSEL                                                        */
  FTM1_PWMLOAD_HCSEL_0                 = 0,     /*!< 0 : Half cycle reload is disabled and it is not considered as
                                                     a reload opportunity.                                                     */
  FTM1_PWMLOAD_HCSEL_1                 = 1,     /*!< 1 : Half cycle reload is enabled and it is considered as a reload
                                                     opportunity.                                                              */
} FTM1_PWMLOAD_HCSEL_Enum;

/* =============================================  FTM1 FTM1_PWMLOAD LDOK [9..9]  ============================================= */
typedef enum {                                  /*!< FTM1_PWMLOAD_LDOK                                                         */
  FTM1_PWMLOAD_LDOK_0                  = 0,     /*!< 0 : Loading updated values is disabled.                                   */
  FTM1_PWMLOAD_LDOK_1                  = 1,     /*!< 1 : Loading updated values is enabled.                                    */
} FTM1_PWMLOAD_LDOK_Enum;

/* ============================================  FTM1 FTM1_PWMLOAD GLEN [10..10]  ============================================ */
typedef enum {                                  /*!< FTM1_PWMLOAD_GLEN                                                         */
  FTM1_PWMLOAD_GLEN_0                  = 0,     /*!< 0 : Global Load Ok disabled.                                              */
  FTM1_PWMLOAD_GLEN_1                  = 1,     /*!< 1 : Global Load OK enabled. A pulse event on the module global
                                                     load input sets the LDOK bit.                                             */
} FTM1_PWMLOAD_GLEN_Enum;

/* ===========================================  FTM1 FTM1_PWMLOAD GLDOK [11..11]  ============================================ */
typedef enum {                                  /*!< FTM1_PWMLOAD_GLDOK                                                        */
  FTM1_PWMLOAD_GLDOK_0                 = 0,     /*!< 0 : No action.                                                            */
  FTM1_PWMLOAD_GLDOK_1                 = 1,     /*!< 1 : LDOK bit is set.                                                      */
} FTM1_PWMLOAD_GLDOK_Enum;

/* =======================================================  FTM1_HCR  ======================================================== */
/* ==================================================  FTM1_PAIR0DEADTIME  =================================================== */
/* ==========================================  FTM1 FTM1_PAIR0DEADTIME DTPS [6..7]  ========================================== */
typedef enum {                                  /*!< FTM1_PAIR0DEADTIME_DTPS                                                   */
  FTM1_PAIR0DEADTIME_DTPS_0x_0         = 0,     /*!< 0x_0 : Divide the FTM input clock by 1.                                   */
  FTM1_PAIR0DEADTIME_DTPS_0x_1         = 1,     /*!< 0x_1 : Divide the FTM input clock by 1.                                   */
  FTM1_PAIR0DEADTIME_DTPS_10           = 2,     /*!< 10 : Divide the FTM input clock by 4.                                     */
  FTM1_PAIR0DEADTIME_DTPS_11           = 3,     /*!< 11 : Divide the FTM input clock by 16.                                    */
} FTM1_PAIR0DEADTIME_DTPS_Enum;

/* ==================================================  FTM1_PAIR1DEADTIME  =================================================== */
/* ==========================================  FTM1 FTM1_PAIR1DEADTIME DTPS [6..7]  ========================================== */
typedef enum {                                  /*!< FTM1_PAIR1DEADTIME_DTPS                                                   */
  FTM1_PAIR1DEADTIME_DTPS_0x_0         = 0,     /*!< 0x_0 : Divide the FTM input clock by 1.                                   */
  FTM1_PAIR1DEADTIME_DTPS_0x_1         = 1,     /*!< 0x_1 : Divide the FTM input clock by 1.                                   */
  FTM1_PAIR1DEADTIME_DTPS_10           = 2,     /*!< 10 : Divide the FTM input clock by 4.                                     */
  FTM1_PAIR1DEADTIME_DTPS_11           = 3,     /*!< 11 : Divide the FTM input clock by 16.                                    */
} FTM1_PAIR1DEADTIME_DTPS_Enum;

/* ==================================================  FTM1_PAIR2DEADTIME  =================================================== */
/* ==========================================  FTM1 FTM1_PAIR2DEADTIME DTPS [6..7]  ========================================== */
typedef enum {                                  /*!< FTM1_PAIR2DEADTIME_DTPS                                                   */
  FTM1_PAIR2DEADTIME_DTPS_0x_0         = 0,     /*!< 0x_0 : Divide the FTM input clock by 1.                                   */
  FTM1_PAIR2DEADTIME_DTPS_0x_1         = 1,     /*!< 0x_1 : Divide the FTM input clock by 1.                                   */
  FTM1_PAIR2DEADTIME_DTPS_10           = 2,     /*!< 10 : Divide the FTM input clock by 4.                                     */
  FTM1_PAIR2DEADTIME_DTPS_11           = 3,     /*!< 11 : Divide the FTM input clock by 16.                                    */
} FTM1_PAIR2DEADTIME_DTPS_Enum;

/* ==================================================  FTM1_PAIR3DEADTIME  =================================================== */
/* ==========================================  FTM1 FTM1_PAIR3DEADTIME DTPS [6..7]  ========================================== */
typedef enum {                                  /*!< FTM1_PAIR3DEADTIME_DTPS                                                   */
  FTM1_PAIR3DEADTIME_DTPS_0x_0         = 0,     /*!< 0x_0 : Divide the FTM input clock by 1.                                   */
  FTM1_PAIR3DEADTIME_DTPS_0x_1         = 1,     /*!< 0x_1 : Divide the FTM input clock by 1.                                   */
  FTM1_PAIR3DEADTIME_DTPS_10           = 2,     /*!< 10 : Divide the FTM input clock by 4.                                     */
  FTM1_PAIR3DEADTIME_DTPS_11           = 3,     /*!< 11 : Divide the FTM input clock by 16.                                    */
} FTM1_PAIR3DEADTIME_DTPS_Enum;

/* ====================================================  FTM1_MOD_MIRROR  ==================================================== */
/* ====================================================  FTM1_C0V_MIRROR  ==================================================== */
/* ====================================================  FTM1_C1V_MIRROR  ==================================================== */
/* ====================================================  FTM1_C2V_MIRROR  ==================================================== */
/* ====================================================  FTM1_C3V_MIRROR  ==================================================== */
/* ====================================================  FTM1_C4V_MIRROR  ==================================================== */
/* ====================================================  FTM1_C5V_MIRROR  ==================================================== */
/* ====================================================  FTM1_C6V_MIRROR  ==================================================== */
/* ====================================================  FTM1_C7V_MIRROR  ==================================================== */


/* =========================================================================================================================== */
/* ================                                           ADC0                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  ADC0_SC1A  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1A ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1A_ADCH                                                    */
  ADC0_SC1_SC1_SC1A_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1A_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1A_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1A_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1A_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1A_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1A_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1A_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1A_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1A_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1A_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1A_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1A_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1A_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1A_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1A_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1A_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1A AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1A_AIEN                                                    */
  ADC0_SC1_SC1_SC1A_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1A_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1A_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1A COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1A_COCO                                                    */
  ADC0_SC1_SC1_SC1A_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1A_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1A_COCO_Enum;

/* =======================================================  ADC0_SC1B  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1B ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1B_ADCH                                                    */
  ADC0_SC1_SC1_SC1B_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1B_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1B_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1B_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1B_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1B_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1B_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1B_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1B_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1B_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1B_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1B_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1B_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1B_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1B_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1B_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1B_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1B AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1B_AIEN                                                    */
  ADC0_SC1_SC1_SC1B_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1B_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1B_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1B COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1B_COCO                                                    */
  ADC0_SC1_SC1_SC1B_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1B_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1B_COCO_Enum;

/* =======================================================  ADC0_SC1C  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1C ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1C_ADCH                                                    */
  ADC0_SC1_SC1_SC1C_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1C_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1C_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1C_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1C_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1C_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1C_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1C_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1C_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1C_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1C_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1C_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1C_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1C_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1C_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1C_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1C_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1C AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1C_AIEN                                                    */
  ADC0_SC1_SC1_SC1C_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1C_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1C_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1C COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1C_COCO                                                    */
  ADC0_SC1_SC1_SC1C_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1C_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1C_COCO_Enum;

/* =======================================================  ADC0_SC1D  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1D ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1D_ADCH                                                    */
  ADC0_SC1_SC1_SC1D_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1D_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1D_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1D_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1D_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1D_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1D_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1D_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1D_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1D_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1D_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1D_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1D_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1D_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1D_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1D_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1D_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1D AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1D_AIEN                                                    */
  ADC0_SC1_SC1_SC1D_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1D_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1D_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1D COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1D_COCO                                                    */
  ADC0_SC1_SC1_SC1D_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1D_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1D_COCO_Enum;

/* =======================================================  ADC0_SC1E  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1E ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1E_ADCH                                                    */
  ADC0_SC1_SC1_SC1E_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1E_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1E_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1E_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1E_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1E_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1E_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1E_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1E_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1E_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1E_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1E_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1E_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1E_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1E_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1E_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1E_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1E AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1E_AIEN                                                    */
  ADC0_SC1_SC1_SC1E_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1E_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1E_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1E COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1E_COCO                                                    */
  ADC0_SC1_SC1_SC1E_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1E_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1E_COCO_Enum;

/* =======================================================  ADC0_SC1F  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1F ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1F_ADCH                                                    */
  ADC0_SC1_SC1_SC1F_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1F_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1F_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1F_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1F_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1F_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1F_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1F_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1F_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1F_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1F_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1F_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1F_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1F_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1F_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1F_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1F_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1F AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1F_AIEN                                                    */
  ADC0_SC1_SC1_SC1F_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1F_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1F_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1F COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1F_COCO                                                    */
  ADC0_SC1_SC1_SC1F_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1F_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1F_COCO_Enum;

/* =======================================================  ADC0_SC1G  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1G ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1G_ADCH                                                    */
  ADC0_SC1_SC1_SC1G_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1G_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1G_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1G_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1G_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1G_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1G_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1G_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1G_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1G_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1G_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1G_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1G_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1G_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1G_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1G_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1G_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1G AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1G_AIEN                                                    */
  ADC0_SC1_SC1_SC1G_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1G_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1G_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1G COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1G_COCO                                                    */
  ADC0_SC1_SC1_SC1G_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1G_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1G_COCO_Enum;

/* =======================================================  ADC0_SC1H  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1H ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1H_ADCH                                                    */
  ADC0_SC1_SC1_SC1H_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1H_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1H_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1H_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1H_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1H_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1H_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1H_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1H_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1H_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1H_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1H_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1H_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1H_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1H_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1H_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1H_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1H AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1H_AIEN                                                    */
  ADC0_SC1_SC1_SC1H_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1H_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1H_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1H COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1H_COCO                                                    */
  ADC0_SC1_SC1_SC1H_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1H_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1H_COCO_Enum;

/* =======================================================  ADC0_SC1I  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1I ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1I_ADCH                                                    */
  ADC0_SC1_SC1_SC1I_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1I_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1I_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1I_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1I_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1I_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1I_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1I_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1I_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1I_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1I_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1I_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1I_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1I_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1I_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1I_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1I_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1I AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1I_AIEN                                                    */
  ADC0_SC1_SC1_SC1I_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1I_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1I_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1I COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1I_COCO                                                    */
  ADC0_SC1_SC1_SC1I_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1I_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1I_COCO_Enum;

/* =======================================================  ADC0_SC1J  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1J ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1J_ADCH                                                    */
  ADC0_SC1_SC1_SC1J_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1J_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1J_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1J_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1J_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1J_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1J_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1J_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1J_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1J_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1J_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1J_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1J_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1J_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1J_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1J_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1J_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1J AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1J_AIEN                                                    */
  ADC0_SC1_SC1_SC1J_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1J_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1J_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1J COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1J_COCO                                                    */
  ADC0_SC1_SC1_SC1J_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1J_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1J_COCO_Enum;

/* =======================================================  ADC0_SC1K  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1K ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1K_ADCH                                                    */
  ADC0_SC1_SC1_SC1K_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1K_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1K_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1K_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1K_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1K_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1K_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1K_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1K_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1K_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1K_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1K_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1K_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1K_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1K_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1K_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1K_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1K AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1K_AIEN                                                    */
  ADC0_SC1_SC1_SC1K_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1K_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1K_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1K COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1K_COCO                                                    */
  ADC0_SC1_SC1_SC1K_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1K_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1K_COCO_Enum;

/* =======================================================  ADC0_SC1L  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1L ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1L_ADCH                                                    */
  ADC0_SC1_SC1_SC1L_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1L_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1L_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1L_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1L_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1L_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1L_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1L_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1L_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1L_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1L_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1L_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1L_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1L_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1L_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1L_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1L_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1L AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1L_AIEN                                                    */
  ADC0_SC1_SC1_SC1L_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1L_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1L_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1L COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1L_COCO                                                    */
  ADC0_SC1_SC1_SC1L_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1L_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1L_COCO_Enum;

/* =======================================================  ADC0_SC1M  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1M ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1M_ADCH                                                    */
  ADC0_SC1_SC1_SC1M_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1M_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1M_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1M_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1M_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1M_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1M_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1M_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1M_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1M_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1M_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1M_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1M_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1M_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1M_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1M_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1M_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1M AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1M_AIEN                                                    */
  ADC0_SC1_SC1_SC1M_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1M_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1M_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1M COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1M_COCO                                                    */
  ADC0_SC1_SC1_SC1M_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1M_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1M_COCO_Enum;

/* =======================================================  ADC0_SC1N  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1N ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1N_ADCH                                                    */
  ADC0_SC1_SC1_SC1N_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1N_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1N_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1N_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1N_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1N_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1N_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1N_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1N_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1N_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1N_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1N_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1N_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1N_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1N_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1N_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1N_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1N AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1N_AIEN                                                    */
  ADC0_SC1_SC1_SC1N_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1N_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1N_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1N COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1N_COCO                                                    */
  ADC0_SC1_SC1_SC1N_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1N_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1N_COCO_Enum;

/* =======================================================  ADC0_SC1O  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1O ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1O_ADCH                                                    */
  ADC0_SC1_SC1_SC1O_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1O_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1O_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1O_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1O_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1O_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1O_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1O_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1O_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1O_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1O_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1O_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1O_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1O_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1O_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1O_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1O_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1O AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1O_AIEN                                                    */
  ADC0_SC1_SC1_SC1O_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1O_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1O_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1O COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1O_COCO                                                    */
  ADC0_SC1_SC1_SC1O_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1O_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1O_COCO_Enum;

/* =======================================================  ADC0_SC1P  ======================================================= */
/* ==============================================  ADC0 ADC0_SC1P ADCH [0..4]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1P_ADCH                                                    */
  ADC0_SC1_SC1_SC1P_ADCH_00000         = 0,     /*!< 00000 : Exernal channel 0 is selected as input.                           */
  ADC0_SC1_SC1_SC1P_ADCH_00001         = 1,     /*!< 00001 : Exernal channel 1 is selected as input.                           */
  ADC0_SC1_SC1_SC1P_ADCH_00010         = 2,     /*!< 00010 : Exernal channel 2 is selected as input.                           */
  ADC0_SC1_SC1_SC1P_ADCH_00011         = 3,     /*!< 00011 : Exernal channel 3 is selected as input.                           */
  ADC0_SC1_SC1_SC1P_ADCH_00100         = 4,     /*!< 00100 : Exernal channel 4 is selected as input.                           */
  ADC0_SC1_SC1_SC1P_ADCH_00101         = 5,     /*!< 00101 : Exernal channel 5 is selected as input.                           */
  ADC0_SC1_SC1_SC1P_ADCH_00110         = 6,     /*!< 00110 : Exernal channel 6 is selected as input.                           */
  ADC0_SC1_SC1_SC1P_ADCH_00111         = 7,     /*!< 00111 : Exernal channel 7 is selected as input.                           */
  ADC0_SC1_SC1_SC1P_ADCH_01000         = 8,     /*!< 01000 : Exernal channel 8 is selected as input.                           */
  ADC0_SC1_SC1_SC1P_ADCH_01001         = 9,     /*!< 01001 : Exernal channel 9 is selected as input.                           */
  ADC0_SC1_SC1_SC1P_ADCH_01010         = 10,    /*!< 01010 : Exernal channel 10 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_01011         = 11,    /*!< 01011 : Exernal channel 11 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_01100         = 12,    /*!< 01100 : Exernal channel 12 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_01101         = 13,    /*!< 01101 : Exernal channel 13 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_01110         = 14,    /*!< 01110 : Exernal channel 14 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_01111         = 15,    /*!< 01111 : Exernal channel 15 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_10010         = 18,    /*!< 10010 : Exernal channel 18 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_10011         = 19,    /*!< 10011 : Exernal channel 19 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_10101         = 21,    /*!< 10101 : Internal channel 0 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_10110         = 22,    /*!< 10110 : Internal channel 1 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_10111         = 23,    /*!< 10111 : Internal channel 2 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_11010         = 26,    /*!< 11010 : Temp Sensor                                                       */
  ADC0_SC1_SC1_SC1P_ADCH_11011         = 27,    /*!< 11011 : Band Gap                                                          */
  ADC0_SC1_SC1_SC1P_ADCH_11100         = 28,    /*!< 11100 : Internal channel 3 is selected as input.                          */
  ADC0_SC1_SC1_SC1P_ADCH_11101         = 29,    /*!< 11101 : VREFSH is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1P_ADCH_11110         = 30,    /*!< 11110 : VREFSL is selected as input. Voltage reference selected
                                                     is determined by SC2[REFSEL].                                             */
  ADC0_SC1_SC1_SC1P_ADCH_11111         = 31,    /*!< 11111 : Module is disabled                                                */
} ADC0_SC1_SC1_SC1P_ADCH_Enum;

/* ==============================================  ADC0 ADC0_SC1P AIEN [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1P_AIEN                                                    */
  ADC0_SC1_SC1_SC1P_AIEN_0             = 0,     /*!< 0 : Conversion complete interrupt is disabled.                            */
  ADC0_SC1_SC1_SC1P_AIEN_1             = 1,     /*!< 1 : Conversion complete interrupt is enabled.                             */
} ADC0_SC1_SC1_SC1P_AIEN_Enum;

/* ==============================================  ADC0 ADC0_SC1P COCO [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC1_SC1_SC1P_COCO                                                    */
  ADC0_SC1_SC1_SC1P_COCO_0             = 0,     /*!< 0 : Conversion is not completed.                                          */
  ADC0_SC1_SC1_SC1P_COCO_1             = 1,     /*!< 1 : Conversion is completed.                                              */
} ADC0_SC1_SC1_SC1P_COCO_Enum;

/* =======================================================  ADC0_CFG1  ======================================================= */
/* =============================================  ADC0 ADC0_CFG1 ADICLK [0..1]  ============================================== */
typedef enum {                                  /*!< ADC0_CFG1_ADICLK                                                          */
  ADC0_CFG1_ADICLK_00                  = 0,     /*!< 00 : Alternate clock 1 (ADC_ALTCLK1)                                      */
  ADC0_CFG1_ADICLK_01                  = 1,     /*!< 01 : Alternate clock 2 (ADC_ALTCLK2)                                      */
  ADC0_CFG1_ADICLK_10                  = 2,     /*!< 10 : Alternate clock 3 (ADC_ALTCLK3)                                      */
  ADC0_CFG1_ADICLK_11                  = 3,     /*!< 11 : Alternate clock 4 (ADC_ALTCLK4)                                      */
} ADC0_CFG1_ADICLK_Enum;

/* ==============================================  ADC0 ADC0_CFG1 MODE [2..3]  =============================================== */
typedef enum {                                  /*!< ADC0_CFG1_MODE                                                            */
  ADC0_CFG1_MODE_00                    = 0,     /*!< 00 : 8-bit conversion.                                                    */
  ADC0_CFG1_MODE_01                    = 1,     /*!< 01 : 12-bit conversion.                                                   */
  ADC0_CFG1_MODE_10                    = 2,     /*!< 10 : 10-bit conversion.                                                   */
} ADC0_CFG1_MODE_Enum;

/* ==============================================  ADC0 ADC0_CFG1 ADIV [5..6]  =============================================== */
typedef enum {                                  /*!< ADC0_CFG1_ADIV                                                            */
  ADC0_CFG1_ADIV_00                    = 0,     /*!< 00 : The divide ratio is 1 and the clock rate is input clock.             */
  ADC0_CFG1_ADIV_01                    = 1,     /*!< 01 : The divide ratio is 2 and the clock rate is (input clock)/2.         */
  ADC0_CFG1_ADIV_10                    = 2,     /*!< 10 : The divide ratio is 4 and the clock rate is (input clock)/4.         */
  ADC0_CFG1_ADIV_11                    = 3,     /*!< 11 : The divide ratio is 8 and the clock rate is (input clock)/8.         */
} ADC0_CFG1_ADIV_Enum;

/* =======================================================  ADC0_CFG2  ======================================================= */
/* ========================================================  ADC0_RA  ======================================================== */
/* ========================================================  ADC0_RB  ======================================================== */
/* ========================================================  ADC0_RC  ======================================================== */
/* ========================================================  ADC0_RD  ======================================================== */
/* ========================================================  ADC0_RE  ======================================================== */
/* ========================================================  ADC0_RF  ======================================================== */
/* ========================================================  ADC0_RG  ======================================================== */
/* ========================================================  ADC0_RH  ======================================================== */
/* ========================================================  ADC0_RI  ======================================================== */
/* ========================================================  ADC0_RJ  ======================================================== */
/* ========================================================  ADC0_RK  ======================================================== */
/* ========================================================  ADC0_RL  ======================================================== */
/* ========================================================  ADC0_RM  ======================================================== */
/* ========================================================  ADC0_RN  ======================================================== */
/* ========================================================  ADC0_RO  ======================================================== */
/* ========================================================  ADC0_RP  ======================================================== */
/* =======================================================  ADC0_CV1  ======================================================== */
/* =======================================================  ADC0_CV2  ======================================================== */
/* =======================================================  ADC0_SC2  ======================================================== */
/* ==============================================  ADC0 ADC0_SC2 REFSEL [0..1]  ============================================== */
typedef enum {                                  /*!< ADC0_SC2_REFSEL                                                           */
  ADC0_SC2_REFSEL_00                   = 0,     /*!< 00 : Default voltage reference pin pair, that is, external pins
                                                     VREFH and VREFL                                                           */
  ADC0_SC2_REFSEL_01                   = 1,     /*!< 01 : Alternate reference voltage, that is, VALTH. This voltage
                                                     may be additional external pin or internal source depending
                                                     on the MCU configuration. See the chip configuration information
                                                     for details specific to this MCU.                                         */
} ADC0_SC2_REFSEL_Enum;

/* ==============================================  ADC0 ADC0_SC2 DMAEN [2..2]  =============================================== */
typedef enum {                                  /*!< ADC0_SC2_DMAEN                                                            */
  ADC0_SC2_DMAEN_0                     = 0,     /*!< 0 : DMA is disabled.                                                      */
  ADC0_SC2_DMAEN_1                     = 1,     /*!< 1 : DMA is enabled and will assert the ADC DMA request during
                                                     an ADC conversion complete event , which is indicated when
                                                     any SC1n[COCO] flag is asserted.                                          */
} ADC0_SC2_DMAEN_Enum;

/* ===============================================  ADC0 ADC0_SC2 ACFE [5..5]  =============================================== */
typedef enum {                                  /*!< ADC0_SC2_ACFE                                                             */
  ADC0_SC2_ACFE_0                      = 0,     /*!< 0 : Compare function disabled.                                            */
  ADC0_SC2_ACFE_1                      = 1,     /*!< 1 : Compare function enabled.                                             */
} ADC0_SC2_ACFE_Enum;

/* ==============================================  ADC0 ADC0_SC2 ADTRG [6..6]  =============================================== */
typedef enum {                                  /*!< ADC0_SC2_ADTRG                                                            */
  ADC0_SC2_ADTRG_0                     = 0,     /*!< 0 : Software trigger selected.                                            */
  ADC0_SC2_ADTRG_1                     = 1,     /*!< 1 : Hardware trigger selected.                                            */
} ADC0_SC2_ADTRG_Enum;

/* ==============================================  ADC0 ADC0_SC2 ADACT [7..7]  =============================================== */
typedef enum {                                  /*!< ADC0_SC2_ADACT                                                            */
  ADC0_SC2_ADACT_0                     = 0,     /*!< 0 : Conversion not in progress.                                           */
  ADC0_SC2_ADACT_1                     = 1,     /*!< 1 : Conversion in progress.                                               */
} ADC0_SC2_ADACT_Enum;

/* ============================================  ADC0 ADC0_SC2 TRGSTLAT [16..19]  ============================================ */
typedef enum {                                  /*!< ADC0_SC2_TRGSTLAT                                                         */
  ADC0_SC2_TRGSTLAT_0                  = 0,     /*!< 0 : No trigger request has been latched                                   */
  ADC0_SC2_TRGSTLAT_1                  = 1,     /*!< 1 : A trigger request has been latched                                    */
} ADC0_SC2_TRGSTLAT_Enum;

/* ============================================  ADC0 ADC0_SC2 TRGSTERR [24..27]  ============================================ */
typedef enum {                                  /*!< ADC0_SC2_TRGSTERR                                                         */
  ADC0_SC2_TRGSTERR_0                  = 0,     /*!< 0 : No error has occurred                                                 */
  ADC0_SC2_TRGSTERR_1                  = 1,     /*!< 1 : An error has occurred                                                 */
} ADC0_SC2_TRGSTERR_Enum;

/* =======================================================  ADC0_SC3  ======================================================== */
/* ===============================================  ADC0 ADC0_SC3 AVGS [0..1]  =============================================== */
typedef enum {                                  /*!< ADC0_SC3_AVGS                                                             */
  ADC0_SC3_AVGS_00                     = 0,     /*!< 00 : 4 samples averaged.                                                  */
  ADC0_SC3_AVGS_01                     = 1,     /*!< 01 : 8 samples averaged.                                                  */
  ADC0_SC3_AVGS_10                     = 2,     /*!< 10 : 16 samples averaged.                                                 */
  ADC0_SC3_AVGS_11                     = 3,     /*!< 11 : 32 samples averaged.                                                 */
} ADC0_SC3_AVGS_Enum;

/* ===============================================  ADC0 ADC0_SC3 AVGE [2..2]  =============================================== */
typedef enum {                                  /*!< ADC0_SC3_AVGE                                                             */
  ADC0_SC3_AVGE_0                      = 0,     /*!< 0 : Hardware average function disabled.                                   */
  ADC0_SC3_AVGE_1                      = 1,     /*!< 1 : Hardware average function enabled.                                    */
} ADC0_SC3_AVGE_Enum;

/* ===============================================  ADC0 ADC0_SC3 ADCO [3..3]  =============================================== */
typedef enum {                                  /*!< ADC0_SC3_ADCO                                                             */
  ADC0_SC3_ADCO_0                      = 0,     /*!< 0 : One conversion will be performed (or one set of conversions,
                                                     if AVGE is set) after a conversion is initiated.                          */
  ADC0_SC3_ADCO_1                      = 1,     /*!< 1 : Continuous conversions will be performed (or continuous
                                                     sets of conversions, if AVGE is set) after a conversion
                                                     is initiated.                                                             */
} ADC0_SC3_ADCO_Enum;

/* =====================================================  ADC0_BASE_OFS  ===================================================== */
/* =======================================================  ADC0_OFS  ======================================================== */
/* =====================================================  ADC0_USR_OFS  ====================================================== */
/* =======================================================  ADC0_XOFS  ======================================================= */
/* =======================================================  ADC0_YOFS  ======================================================= */
/* ========================================================  ADC0_G  ========================================================= */
/* ========================================================  ADC0_UG  ======================================================== */
/* =======================================================  ADC0_CLPS  ======================================================= */
/* =======================================================  ADC0_CLP3  ======================================================= */
/* =======================================================  ADC0_CLP2  ======================================================= */
/* =======================================================  ADC0_CLP1  ======================================================= */
/* =======================================================  ADC0_CLP0  ======================================================= */
/* =======================================================  ADC0_CLPX  ======================================================= */
/* =======================================================  ADC0_CLP9  ======================================================= */
/* =====================================================  ADC0_CLPS_OFS  ===================================================== */
/* =====================================================  ADC0_CLP3_OFS  ===================================================== */
/* =====================================================  ADC0_CLP2_OFS  ===================================================== */
/* =====================================================  ADC0_CLP1_OFS  ===================================================== */
/* =====================================================  ADC0_CLP0_OFS  ===================================================== */
/* =====================================================  ADC0_CLPX_OFS  ===================================================== */
/* =====================================================  ADC0_CLP9_OFS  ===================================================== */


/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  RTC_TSR  ======================================================== */
/* ========================================================  RTC_TPR  ======================================================== */
/* ========================================================  RTC_TAR  ======================================================== */
/* ========================================================  RTC_TCR  ======================================================== */
/* ================================================  RTC RTC_TCR TCR [0..7]  ================================================= */
typedef enum {                                  /*!< RTC_TCR_TCR                                                               */
  RTC_TCR_TCR_10000000                 = 128,   /*!< 10000000 : Time Prescaler Register overflows every 32896 clock
                                                     cycles.                                                                   */
  RTC_TCR_TCR_10000001                 = 129,   /*!< 10000001 : Time Prescaler Register overflows every 32895 clock
                                                     cycles.                                                                   */
  RTC_TCR_TCR_11111111                 = 255,   /*!< 11111111 : Time Prescaler Register overflows every 32769 clock
                                                     cycles.                                                                   */
  RTC_TCR_TCR_00000000                 = 0,     /*!< 00000000 : Time Prescaler Register overflows every 32768 clock
                                                     cycles.                                                                   */
  RTC_TCR_TCR_00000001                 = 1,     /*!< 00000001 : Time Prescaler Register overflows every 32767 clock
                                                     cycles.                                                                   */
  RTC_TCR_TCR_01111110                 = 126,   /*!< 01111110 : Time Prescaler Register overflows every 32642 clock
                                                     cycles.                                                                   */
  RTC_TCR_TCR_01111111                 = 127,   /*!< 01111111 : Time Prescaler Register overflows every 32641 clock
                                                     cycles.                                                                   */
} RTC_TCR_TCR_Enum;

/* ========================================================  RTC_CR  ========================================================= */
/* =================================================  RTC RTC_CR SWR [0..0]  ================================================= */
typedef enum {                                  /*!< RTC_CR_SWR                                                                */
  RTC_CR_SWR_0                         = 0,     /*!< 0 : No effect.                                                            */
} RTC_CR_SWR_Enum;

/* =================================================  RTC RTC_CR SUP [2..2]  ================================================= */
typedef enum {                                  /*!< RTC_CR_SUP                                                                */
  RTC_CR_SUP_0                         = 0,     /*!< 0 : Non-supervisor mode write accesses are not supported and
                                                     generate a bus error.                                                     */
  RTC_CR_SUP_1                         = 1,     /*!< 1 : Non-supervisor mode write accesses are supported.                     */
} RTC_CR_SUP_Enum;

/* =================================================  RTC RTC_CR UM [3..3]  ================================================== */
typedef enum {                                  /*!< RTC_CR_UM                                                                 */
  RTC_CR_UM_0                          = 0,     /*!< 0 : Registers cannot be written when locked.                              */
  RTC_CR_UM_1                          = 1,     /*!< 1 : Registers can be written when locked under limited conditions.        */
} RTC_CR_UM_Enum;

/* =================================================  RTC RTC_CR CPS [5..5]  ================================================= */
typedef enum {                                  /*!< RTC_CR_CPS                                                                */
  RTC_CR_CPS_0                         = 0,     /*!< 0 : The prescaler output clock (as configured by TSIC) is output
                                                     on RTC_CLKOUT.                                                            */
  RTC_CR_CPS_1                         = 1,     /*!< 1 : The RTC 32.768 kHz clock is output on RTC_CLKOUT, provided
                                                     it is output to other peripherals.                                        */
} RTC_CR_CPS_Enum;

/* ================================================  RTC RTC_CR LPOS [7..7]  ================================================= */
typedef enum {                                  /*!< RTC_CR_LPOS                                                               */
  RTC_CR_LPOS_0                        = 0,     /*!< 0 : RTC prescaler increments using 32.768 kHz clock.                      */
  RTC_CR_LPOS_1                        = 1,     /*!< 1 : RTC prescaler increments using 1 kHz LPO, bits [4:0] of
                                                     the prescaler are ignored.                                                */
} RTC_CR_LPOS_Enum;

/* ================================================  RTC RTC_CR CLKO [9..9]  ================================================= */
typedef enum {                                  /*!< RTC_CR_CLKO                                                               */
  RTC_CR_CLKO_0                        = 0,     /*!< 0 : The 32 kHz clock is output to other peripherals.                      */
  RTC_CR_CLKO_1                        = 1,     /*!< 1 : The 32 kHz clock is not output to other peripherals.                  */
} RTC_CR_CLKO_Enum;

/* ================================================  RTC RTC_CR CPE [24..24]  ================================================ */
typedef enum {                                  /*!< RTC_CR_CPE                                                                */
  RTC_CR_CPE_0                         = 0,     /*!< 0 : The RTC_CLKOUT function is disabled.                                  */
  RTC_CR_CPE_1                         = 1,     /*!< 1 : Enable RTC_CLKOUT function.                                           */
} RTC_CR_CPE_Enum;

/* ========================================================  RTC_SR  ========================================================= */
/* =================================================  RTC RTC_SR TIF [0..0]  ================================================= */
typedef enum {                                  /*!< RTC_SR_TIF                                                                */
  RTC_SR_TIF_0                         = 0,     /*!< 0 : Time is valid.                                                        */
  RTC_SR_TIF_1                         = 1,     /*!< 1 : Time is invalid and time counter is read as zero.                     */
} RTC_SR_TIF_Enum;

/* =================================================  RTC RTC_SR TOF [1..1]  ================================================= */
typedef enum {                                  /*!< RTC_SR_TOF                                                                */
  RTC_SR_TOF_0                         = 0,     /*!< 0 : Time overflow has not occurred.                                       */
  RTC_SR_TOF_1                         = 1,     /*!< 1 : Time overflow has occurred and time counter is read as zero.          */
} RTC_SR_TOF_Enum;

/* =================================================  RTC RTC_SR TAF [2..2]  ================================================= */
typedef enum {                                  /*!< RTC_SR_TAF                                                                */
  RTC_SR_TAF_0                         = 0,     /*!< 0 : Time alarm has not occurred.                                          */
  RTC_SR_TAF_1                         = 1,     /*!< 1 : Time alarm has occurred.                                              */
} RTC_SR_TAF_Enum;

/* =================================================  RTC RTC_SR TCE [4..4]  ================================================= */
typedef enum {                                  /*!< RTC_SR_TCE                                                                */
  RTC_SR_TCE_0                         = 0,     /*!< 0 : Time counter is disabled.                                             */
  RTC_SR_TCE_1                         = 1,     /*!< 1 : Time counter is enabled.                                              */
} RTC_SR_TCE_Enum;

/* ========================================================  RTC_LR  ========================================================= */
/* =================================================  RTC RTC_LR TCL [3..3]  ================================================= */
typedef enum {                                  /*!< RTC_LR_TCL                                                                */
  RTC_LR_TCL_0                         = 0,     /*!< 0 : Time Compensation Register is locked and writes are ignored.          */
  RTC_LR_TCL_1                         = 1,     /*!< 1 : Time Compensation Register is not locked and writes complete
                                                     as normal.                                                                */
} RTC_LR_TCL_Enum;

/* =================================================  RTC RTC_LR CRL [4..4]  ================================================= */
typedef enum {                                  /*!< RTC_LR_CRL                                                                */
  RTC_LR_CRL_0                         = 0,     /*!< 0 : Control Register is locked and writes are ignored.                    */
  RTC_LR_CRL_1                         = 1,     /*!< 1 : Control Register is not locked and writes complete as normal.         */
} RTC_LR_CRL_Enum;

/* =================================================  RTC RTC_LR SRL [5..5]  ================================================= */
typedef enum {                                  /*!< RTC_LR_SRL                                                                */
  RTC_LR_SRL_0                         = 0,     /*!< 0 : Status Register is locked and writes are ignored.                     */
  RTC_LR_SRL_1                         = 1,     /*!< 1 : Status Register is not locked and writes complete as normal.          */
} RTC_LR_SRL_Enum;

/* =================================================  RTC RTC_LR LRL [6..6]  ================================================= */
typedef enum {                                  /*!< RTC_LR_LRL                                                                */
  RTC_LR_LRL_0                         = 0,     /*!< 0 : Lock Register is locked and writes are ignored.                       */
  RTC_LR_LRL_1                         = 1,     /*!< 1 : Lock Register is not locked and writes complete as normal.            */
} RTC_LR_LRL_Enum;

/* ========================================================  RTC_IER  ======================================================== */
/* ================================================  RTC RTC_IER TIIE [0..0]  ================================================ */
typedef enum {                                  /*!< RTC_IER_TIIE                                                              */
  RTC_IER_TIIE_0                       = 0,     /*!< 0 : Time invalid flag does not generate an interrupt.                     */
  RTC_IER_TIIE_1                       = 1,     /*!< 1 : Time invalid flag does generate an interrupt.                         */
} RTC_IER_TIIE_Enum;

/* ================================================  RTC RTC_IER TOIE [1..1]  ================================================ */
typedef enum {                                  /*!< RTC_IER_TOIE                                                              */
  RTC_IER_TOIE_0                       = 0,     /*!< 0 : Time overflow flag does not generate an interrupt.                    */
  RTC_IER_TOIE_1                       = 1,     /*!< 1 : Time overflow flag does generate an interrupt.                        */
} RTC_IER_TOIE_Enum;

/* ================================================  RTC RTC_IER TAIE [2..2]  ================================================ */
typedef enum {                                  /*!< RTC_IER_TAIE                                                              */
  RTC_IER_TAIE_0                       = 0,     /*!< 0 : Time alarm flag does not generate an interrupt.                       */
  RTC_IER_TAIE_1                       = 1,     /*!< 1 : Time alarm flag does generate an interrupt.                           */
} RTC_IER_TAIE_Enum;

/* ================================================  RTC RTC_IER TSIE [4..4]  ================================================ */
typedef enum {                                  /*!< RTC_IER_TSIE                                                              */
  RTC_IER_TSIE_0                       = 0,     /*!< 0 : Seconds interrupt is disabled.                                        */
  RTC_IER_TSIE_1                       = 1,     /*!< 1 : Seconds interrupt is enabled.                                         */
} RTC_IER_TSIE_Enum;

/* ===============================================  RTC RTC_IER TSIC [16..18]  =============================================== */
typedef enum {                                  /*!< RTC_IER_TSIC                                                              */
  RTC_IER_TSIC_000                     = 0,     /*!< 000 : 1 Hz.                                                               */
  RTC_IER_TSIC_001                     = 1,     /*!< 001 : 2 Hz.                                                               */
  RTC_IER_TSIC_010                     = 2,     /*!< 010 : 4 Hz.                                                               */
  RTC_IER_TSIC_011                     = 3,     /*!< 011 : 8 Hz.                                                               */
  RTC_IER_TSIC_100                     = 4,     /*!< 100 : 16 Hz.                                                              */
  RTC_IER_TSIC_101                     = 5,     /*!< 101 : 32 Hz.                                                              */
  RTC_IER_TSIC_110                     = 6,     /*!< 110 : 64 Hz.                                                              */
  RTC_IER_TSIC_111                     = 7,     /*!< 111 : 128 Hz.                                                             */
} RTC_IER_TSIC_Enum;



/* =========================================================================================================================== */
/* ================                                         CMU_FC_0                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  CMU_FC_0_GCR  ====================================================== */
/* ===========================================  CMU_FC_0 CMU_FC_0_GCR FCE [0..0]  ============================================ */
typedef enum {                                  /*!< CMU_FC_0_GCR_FCE                                                          */
  CMU_FC_0_GCR_FCE_0                   = 0,     /*!< 0 : Frequency Check Disabled                                              */
  CMU_FC_0_GCR_FCE_1                   = 1,     /*!< 1 : Frequency Check Enabled                                               */
} CMU_FC_0_GCR_FCE_Enum;

/* =====================================================  CMU_FC_0_RCCR  ===================================================== */
/* =====================================================  CMU_FC_0_HTCR  ===================================================== */
/* =====================================================  CMU_FC_0_LTCR  ===================================================== */
/* ======================================================  CMU_FC_0_SR  ====================================================== */
/* ============================================  CMU_FC_0 CMU_FC_0_SR FLL [0..0]  ============================================ */
typedef enum {                                  /*!< CMU_FC_0_SR_FLL                                                           */
  CMU_FC_0_SR_FLL_0                    = 0,     /*!< 0 : No FLL Event                                                          */
  CMU_FC_0_SR_FLL_1                    = 1,     /*!< 1 : FLL Event Occured                                                     */
} CMU_FC_0_SR_FLL_Enum;

/* ============================================  CMU_FC_0 CMU_FC_0_SR FHH [1..1]  ============================================ */
typedef enum {                                  /*!< CMU_FC_0_SR_FHH                                                           */
  CMU_FC_0_SR_FHH_0                    = 0,     /*!< 0 : No FHH Event                                                          */
  CMU_FC_0_SR_FHH_1                    = 1,     /*!< 1 : FHH Event Occured                                                     */
} CMU_FC_0_SR_FHH_Enum;

/* ===========================================  CMU_FC_0 CMU_FC_0_SR STATE [2..3]  =========================================== */
typedef enum {                                  /*!< CMU_FC_0_SR_STATE                                                         */
  CMU_FC_0_SR_STATE_00                 = 0,     /*!< 00 : Configure State- Configuration registers and CMU_FC_IER
                                                     programming is getting done                                               */
  CMU_FC_0_SR_STATE_01                 = 1,     /*!< 01 : Initialization State- Register configurations are getting
                                                     loaded internally.                                                        */
  CMU_FC_0_SR_STATE_10                 = 2,     /*!< 10 : Initialization Wait State- The module stays in this state
                                                     for 1 bus clock cycle.                                                    */
  CMU_FC_0_SR_STATE_11                 = 3,     /*!< 11 : Frequency Check State- The module is ready to start frequency
                                                     check operation in this state.                                            */
} CMU_FC_0_SR_STATE_Enum;

/* ============================================  CMU_FC_0 CMU_FC_0_SR RS [4..4]  ============================================= */
typedef enum {                                  /*!< CMU_FC_0_SR_RS                                                            */
  CMU_FC_0_SR_RS_0                     = 0,     /*!< 0 : Frequency Check Stopped                                               */
  CMU_FC_0_SR_RS_1                     = 1,     /*!< 1 : Frequency Check Running                                               */
} CMU_FC_0_SR_RS_Enum;

/* =====================================================  CMU_FC_0_IER  ====================================================== */
/* ==========================================  CMU_FC_0 CMU_FC_0_IER FLLIE [0..0]  =========================================== */
typedef enum {                                  /*!< CMU_FC_0_IER_FLLIE                                                        */
  CMU_FC_0_IER_FLLIE_0                 = 0,     /*!< 0 : FLL Interrupt is Disabled                                             */
  CMU_FC_0_IER_FLLIE_1                 = 1,     /*!< 1 : FLL Interrupt is Enabled                                              */
} CMU_FC_0_IER_FLLIE_Enum;

/* ==========================================  CMU_FC_0 CMU_FC_0_IER FHHIE [1..1]  =========================================== */
typedef enum {                                  /*!< CMU_FC_0_IER_FHHIE                                                        */
  CMU_FC_0_IER_FHHIE_0                 = 0,     /*!< 0 : FHH Interrupt is Disabled                                             */
  CMU_FC_0_IER_FHHIE_1                 = 1,     /*!< 1 : FHH Interrupt is Enabled                                              */
} CMU_FC_0_IER_FHHIE_Enum;

/* ==========================================  CMU_FC_0 CMU_FC_0_IER FLLAEE [2..2]  ========================================== */
typedef enum {                                  /*!< CMU_FC_0_IER_FLLAEE                                                       */
  CMU_FC_0_IER_FLLAEE_0                = 0,     /*!< 0 : Asynchronous FLL Event is Disabled                                    */
  CMU_FC_0_IER_FLLAEE_1                = 1,     /*!< 1 : Asynchronous FLL Event is Enabled                                     */
} CMU_FC_0_IER_FLLAEE_Enum;

/* ==========================================  CMU_FC_0 CMU_FC_0_IER FHHAEE [3..3]  ========================================== */
typedef enum {                                  /*!< CMU_FC_0_IER_FHHAEE                                                       */
  CMU_FC_0_IER_FHHAEE_0                = 0,     /*!< 0 : Asynchronous FHH Event is Disabled                                    */
  CMU_FC_0_IER_FHHAEE_1                = 1,     /*!< 1 : Asynchronous FHH Event is Enabled                                     */
} CMU_FC_0_IER_FHHAEE_Enum;



/* =========================================================================================================================== */
/* ================                                         CMU_FC_1                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  CMU_FC_1_GCR  ====================================================== */
/* ===========================================  CMU_FC_1 CMU_FC_1_GCR FCE [0..0]  ============================================ */
typedef enum {                                  /*!< CMU_FC_1_GCR_FCE                                                          */
  CMU_FC_1_GCR_FCE_0                   = 0,     /*!< 0 : Frequency Check Disabled                                              */
  CMU_FC_1_GCR_FCE_1                   = 1,     /*!< 1 : Frequency Check Enabled                                               */
} CMU_FC_1_GCR_FCE_Enum;

/* =====================================================  CMU_FC_1_RCCR  ===================================================== */
/* =====================================================  CMU_FC_1_HTCR  ===================================================== */
/* =====================================================  CMU_FC_1_LTCR  ===================================================== */
/* ======================================================  CMU_FC_1_SR  ====================================================== */
/* ============================================  CMU_FC_1 CMU_FC_1_SR FLL [0..0]  ============================================ */
typedef enum {                                  /*!< CMU_FC_1_SR_FLL                                                           */
  CMU_FC_1_SR_FLL_0                    = 0,     /*!< 0 : No FLL Event                                                          */
  CMU_FC_1_SR_FLL_1                    = 1,     /*!< 1 : FLL Event Occured                                                     */
} CMU_FC_1_SR_FLL_Enum;

/* ============================================  CMU_FC_1 CMU_FC_1_SR FHH [1..1]  ============================================ */
typedef enum {                                  /*!< CMU_FC_1_SR_FHH                                                           */
  CMU_FC_1_SR_FHH_0                    = 0,     /*!< 0 : No FHH Event                                                          */
  CMU_FC_1_SR_FHH_1                    = 1,     /*!< 1 : FHH Event Occured                                                     */
} CMU_FC_1_SR_FHH_Enum;

/* ===========================================  CMU_FC_1 CMU_FC_1_SR STATE [2..3]  =========================================== */
typedef enum {                                  /*!< CMU_FC_1_SR_STATE                                                         */
  CMU_FC_1_SR_STATE_00                 = 0,     /*!< 00 : Configure State- Configuration registers and CMU_FC_IER
                                                     programming is getting done                                               */
  CMU_FC_1_SR_STATE_01                 = 1,     /*!< 01 : Initialization State- Register configurations are getting
                                                     loaded internally.                                                        */
  CMU_FC_1_SR_STATE_10                 = 2,     /*!< 10 : Initialization Wait State- The module stays in this state
                                                     for 1 bus clock cycle.                                                    */
  CMU_FC_1_SR_STATE_11                 = 3,     /*!< 11 : Frequency Check State- The module is ready to start frequency
                                                     check operation in this state.                                            */
} CMU_FC_1_SR_STATE_Enum;

/* ============================================  CMU_FC_1 CMU_FC_1_SR RS [4..4]  ============================================= */
typedef enum {                                  /*!< CMU_FC_1_SR_RS                                                            */
  CMU_FC_1_SR_RS_0                     = 0,     /*!< 0 : Frequency Check Stopped                                               */
  CMU_FC_1_SR_RS_1                     = 1,     /*!< 1 : Frequency Check Running                                               */
} CMU_FC_1_SR_RS_Enum;

/* =====================================================  CMU_FC_1_IER  ====================================================== */
/* ==========================================  CMU_FC_1 CMU_FC_1_IER FLLIE [0..0]  =========================================== */
typedef enum {                                  /*!< CMU_FC_1_IER_FLLIE                                                        */
  CMU_FC_1_IER_FLLIE_0                 = 0,     /*!< 0 : FLL Interrupt is Disabled                                             */
  CMU_FC_1_IER_FLLIE_1                 = 1,     /*!< 1 : FLL Interrupt is Enabled                                              */
} CMU_FC_1_IER_FLLIE_Enum;

/* ==========================================  CMU_FC_1 CMU_FC_1_IER FHHIE [1..1]  =========================================== */
typedef enum {                                  /*!< CMU_FC_1_IER_FHHIE                                                        */
  CMU_FC_1_IER_FHHIE_0                 = 0,     /*!< 0 : FHH Interrupt is Disabled                                             */
  CMU_FC_1_IER_FHHIE_1                 = 1,     /*!< 1 : FHH Interrupt is Enabled                                              */
} CMU_FC_1_IER_FHHIE_Enum;

/* ==========================================  CMU_FC_1 CMU_FC_1_IER FLLAEE [2..2]  ========================================== */
typedef enum {                                  /*!< CMU_FC_1_IER_FLLAEE                                                       */
  CMU_FC_1_IER_FLLAEE_0                = 0,     /*!< 0 : Asynchronous FLL Event is Disabled                                    */
  CMU_FC_1_IER_FLLAEE_1                = 1,     /*!< 1 : Asynchronous FLL Event is Enabled                                     */
} CMU_FC_1_IER_FLLAEE_Enum;

/* ==========================================  CMU_FC_1 CMU_FC_1_IER FHHAEE [3..3]  ========================================== */
typedef enum {                                  /*!< CMU_FC_1_IER_FHHAEE                                                       */
  CMU_FC_1_IER_FHHAEE_0                = 0,     /*!< 0 : Asynchronous FHH Event is Disabled                                    */
  CMU_FC_1_IER_FHHAEE_1                = 1,     /*!< 1 : Asynchronous FHH Event is Enabled                                     */
} CMU_FC_1_IER_FHHAEE_Enum;



/* =========================================================================================================================== */
/* ================                                          LPTMR0                                           ================ */
/* =========================================================================================================================== */

/* ======================================================  LPTMR0_CSR  ======================================================= */
/* =============================================  LPTMR0 LPTMR0_CSR TEN [0..0]  ============================================== */
typedef enum {                                  /*!< LPTMR0_CSR_TEN                                                            */
  LPTMR0_CSR_TEN_0                     = 0,     /*!< 0 : LPTMR is disabled and internal logic is reset.                        */
  LPTMR0_CSR_TEN_1                     = 1,     /*!< 1 : LPTMR is enabled.                                                     */
} LPTMR0_CSR_TEN_Enum;

/* =============================================  LPTMR0 LPTMR0_CSR TMS [1..1]  ============================================== */
typedef enum {                                  /*!< LPTMR0_CSR_TMS                                                            */
  LPTMR0_CSR_TMS_0                     = 0,     /*!< 0 : Time Counter mode.                                                    */
  LPTMR0_CSR_TMS_1                     = 1,     /*!< 1 : Pulse Counter mode.                                                   */
} LPTMR0_CSR_TMS_Enum;

/* =============================================  LPTMR0 LPTMR0_CSR TFC [2..2]  ============================================== */
typedef enum {                                  /*!< LPTMR0_CSR_TFC                                                            */
  LPTMR0_CSR_TFC_0                     = 0,     /*!< 0 : CNR is reset whenever TCF is set.                                     */
  LPTMR0_CSR_TFC_1                     = 1,     /*!< 1 : CNR is reset on overflow.                                             */
} LPTMR0_CSR_TFC_Enum;

/* =============================================  LPTMR0 LPTMR0_CSR TPP [3..3]  ============================================== */
typedef enum {                                  /*!< LPTMR0_CSR_TPP                                                            */
  LPTMR0_CSR_TPP_0                     = 0,     /*!< 0 : Pulse Counter input source is active-high, and the CNR will
                                                     increment on the rising-edge.                                             */
  LPTMR0_CSR_TPP_1                     = 1,     /*!< 1 : Pulse Counter input source is active-low, and the CNR will
                                                     increment on the falling-edge.                                            */
} LPTMR0_CSR_TPP_Enum;

/* =============================================  LPTMR0 LPTMR0_CSR TPS [4..5]  ============================================== */
typedef enum {                                  /*!< LPTMR0_CSR_TPS                                                            */
  LPTMR0_CSR_TPS_00                    = 0,     /*!< 00 : Pulse counter input 0 is selected.                                   */
  LPTMR0_CSR_TPS_01                    = 1,     /*!< 01 : Pulse counter input 1 is selected.                                   */
  LPTMR0_CSR_TPS_10                    = 2,     /*!< 10 : Pulse counter input 2 is selected.                                   */
  LPTMR0_CSR_TPS_11                    = 3,     /*!< 11 : Pulse counter input 3 is selected.                                   */
} LPTMR0_CSR_TPS_Enum;

/* =============================================  LPTMR0 LPTMR0_CSR TIE [6..6]  ============================================== */
typedef enum {                                  /*!< LPTMR0_CSR_TIE                                                            */
  LPTMR0_CSR_TIE_0                     = 0,     /*!< 0 : Timer interrupt disabled.                                             */
  LPTMR0_CSR_TIE_1                     = 1,     /*!< 1 : Timer interrupt enabled.                                              */
} LPTMR0_CSR_TIE_Enum;

/* =============================================  LPTMR0 LPTMR0_CSR TCF [7..7]  ============================================== */
typedef enum {                                  /*!< LPTMR0_CSR_TCF                                                            */
  LPTMR0_CSR_TCF_0                     = 0,     /*!< 0 : The value of CNR is not equal to CMR and increments.                  */
  LPTMR0_CSR_TCF_1                     = 1,     /*!< 1 : The value of CNR is equal to CMR and increments.                      */
} LPTMR0_CSR_TCF_Enum;

/* =============================================  LPTMR0 LPTMR0_CSR TDRE [8..8]  ============================================= */
typedef enum {                                  /*!< LPTMR0_CSR_TDRE                                                           */
  LPTMR0_CSR_TDRE_0                    = 0,     /*!< 0 : Timer DMA Request disabled.                                           */
  LPTMR0_CSR_TDRE_1                    = 1,     /*!< 1 : Timer DMA Request enabled.                                            */
} LPTMR0_CSR_TDRE_Enum;

/* ======================================================  LPTMR0_PSR  ======================================================= */
/* =============================================  LPTMR0 LPTMR0_PSR PCS [0..1]  ============================================== */
typedef enum {                                  /*!< LPTMR0_PSR_PCS                                                            */
  LPTMR0_PSR_PCS_00                    = 0,     /*!< 00 : Prescaler/glitch filter clock 0 selected.                            */
  LPTMR0_PSR_PCS_01                    = 1,     /*!< 01 : Prescaler/glitch filter clock 1 selected.                            */
  LPTMR0_PSR_PCS_10                    = 2,     /*!< 10 : Prescaler/glitch filter clock 2 selected.                            */
  LPTMR0_PSR_PCS_11                    = 3,     /*!< 11 : Prescaler/glitch filter clock 3 selected.                            */
} LPTMR0_PSR_PCS_Enum;

/* =============================================  LPTMR0 LPTMR0_PSR PBYP [2..2]  ============================================= */
typedef enum {                                  /*!< LPTMR0_PSR_PBYP                                                           */
  LPTMR0_PSR_PBYP_0                    = 0,     /*!< 0 : Prescaler/glitch filter is enabled.                                   */
  LPTMR0_PSR_PBYP_1                    = 1,     /*!< 1 : Prescaler/glitch filter is bypassed.                                  */
} LPTMR0_PSR_PBYP_Enum;

/* ===========================================  LPTMR0 LPTMR0_PSR PRESCALE [3..6]  =========================================== */
typedef enum {                                  /*!< LPTMR0_PSR_PRESCALE                                                       */
  LPTMR0_PSR_PRESCALE_0000             = 0,     /*!< 0000 : Prescaler divides the prescaler clock by 2; glitch filter
                                                     does not support this configuration.                                      */
  LPTMR0_PSR_PRESCALE_0001             = 1,     /*!< 0001 : Prescaler divides the prescaler clock by 4; glitch filter
                                                     recognizes change on input pin after 2 rising clock edges.                */
  LPTMR0_PSR_PRESCALE_0010             = 2,     /*!< 0010 : Prescaler divides the prescaler clock by 8; glitch filter
                                                     recognizes change on input pin after 4 rising clock edges.                */
  LPTMR0_PSR_PRESCALE_0011             = 3,     /*!< 0011 : Prescaler divides the prescaler clock by 16; glitch filter
                                                     recognizes change on input pin after 8 rising clock edges.                */
  LPTMR0_PSR_PRESCALE_0100             = 4,     /*!< 0100 : Prescaler divides the prescaler clock by 32; glitch filter
                                                     recognizes change on input pin after 16 rising clock edges.               */
  LPTMR0_PSR_PRESCALE_0101             = 5,     /*!< 0101 : Prescaler divides the prescaler clock by 64; glitch filter
                                                     recognizes change on input pin after 32 rising clock edges.               */
  LPTMR0_PSR_PRESCALE_0110             = 6,     /*!< 0110 : Prescaler divides the prescaler clock by 128; glitch
                                                     filter recognizes change on input pin after 64 rising clock
                                                     edges.                                                                    */
  LPTMR0_PSR_PRESCALE_0111             = 7,     /*!< 0111 : Prescaler divides the prescaler clock by 256; glitch
                                                     filter recognizes change on input pin after 128 rising
                                                     clock edges.                                                              */
  LPTMR0_PSR_PRESCALE_1000             = 8,     /*!< 1000 : Prescaler divides the prescaler clock by 512; glitch
                                                     filter recognizes change on input pin after 256 rising
                                                     clock edges.                                                              */
  LPTMR0_PSR_PRESCALE_1001             = 9,     /*!< 1001 : Prescaler divides the prescaler clock by 1024; glitch
                                                     filter recognizes change on input pin after 512 rising
                                                     clock edges.                                                              */
  LPTMR0_PSR_PRESCALE_1010             = 10,    /*!< 1010 : Prescaler divides the prescaler clock by 2048; glitch
                                                     filter recognizes change on input pin after 1024 rising
                                                     clock edges.                                                              */
  LPTMR0_PSR_PRESCALE_1011             = 11,    /*!< 1011 : Prescaler divides the prescaler clock by 4096; glitch
                                                     filter recognizes change on input pin after 2048 rising
                                                     clock edges.                                                              */
  LPTMR0_PSR_PRESCALE_1100             = 12,    /*!< 1100 : Prescaler divides the prescaler clock by 8192; glitch
                                                     filter recognizes change on input pin after 4096 rising
                                                     clock edges.                                                              */
  LPTMR0_PSR_PRESCALE_1101             = 13,    /*!< 1101 : Prescaler divides the prescaler clock by 16,384; glitch
                                                     filter recognizes change on input pin after 8192 rising
                                                     clock edges.                                                              */
  LPTMR0_PSR_PRESCALE_1110             = 14,    /*!< 1110 : Prescaler divides the prescaler clock by 32,768; glitch
                                                     filter recognizes change on input pin after 16,384 rising
                                                     clock edges.                                                              */
  LPTMR0_PSR_PRESCALE_1111             = 15,    /*!< 1111 : Prescaler divides the prescaler clock by 65,536; glitch
                                                     filter recognizes change on input pin after 32,768 rising
                                                     clock edges.                                                              */
} LPTMR0_PSR_PRESCALE_Enum;

/* ======================================================  LPTMR0_CMR  ======================================================= */
/* ======================================================  LPTMR0_CNR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            SIM                                            ================ */
/* =========================================================================================================================== */

/* ======================================================  SIM_CHIPCTL  ====================================================== */
/* =======================================  SIM SIM_CHIPCTL ADC_INTERLEAVE_EN [0..3]  ======================================== */
typedef enum {                                  /*!< SIM_CHIPCTL_ADC_INTERLEAVE_EN                                             */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_0000   = 0,     /*!< 0000 : Interleaving disabled. No channel pair interleaved. Interleaved
                                                     channels are individually connected to pins. PTC0 is connected
                                                     to ADC0_SE8. PTC1 is connected to ADC0_SE9. PTB15 is connected
                                                     to ADC1_SE14. PTB16 is connected to ADC1_SE15. PTB0 is
                                                     connected to ADC0_SE4. PTB1 is connected to ADC0_SE5. PTB13
                                                     is connected to ADC1_SE8. PTB14 is connected to ADC1_SE9.                 */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_1xxx_8 = 8,     /*!< 1xxx_8 : PTB14 to ADC1_SE9 and ADC0_SE9                                   */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_1xxx_9 = 9,     /*!< 1xxx_9 : PTB14 to ADC1_SE9 and ADC0_SE9                                   */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_1xxx_10 = 10,   /*!< 1xxx_10 : PTB14 to ADC1_SE9 and ADC0_SE9                                  */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_1xxx_11 = 11,   /*!< 1xxx_11 : PTB14 to ADC1_SE9 and ADC0_SE9                                  */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_1xxx_12 = 12,   /*!< 1xxx_12 : PTB14 to ADC1_SE9 and ADC0_SE9                                  */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_1xxx_13 = 13,   /*!< 1xxx_13 : PTB14 to ADC1_SE9 and ADC0_SE9                                  */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_1xxx_14 = 14,   /*!< 1xxx_14 : PTB14 to ADC1_SE9 and ADC0_SE9                                  */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_1xxx_15 = 15,   /*!< 1xxx_15 : PTB14 to ADC1_SE9 and ADC0_SE9                                  */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_x1xx_4 = 4,     /*!< x1xx_4 : PTB13 to ADC1_SE8 and ADC0_SE8                                   */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_x1xx_5 = 5,     /*!< x1xx_5 : PTB13 to ADC1_SE8 and ADC0_SE8                                   */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_x1xx_6 = 6,     /*!< x1xx_6 : PTB13 to ADC1_SE8 and ADC0_SE8                                   */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_x1xx_7 = 7,     /*!< x1xx_7 : PTB13 to ADC1_SE8 and ADC0_SE8                                   */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_xx1x_2 = 2,     /*!< xx1x_2 : PTB1 to ADC0_SE5 and ADC1_SE15                                   */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_xx1x_3 = 3,     /*!< xx1x_3 : PTB1 to ADC0_SE5 and ADC1_SE15                                   */
  SIM_CHIPCTL_ADC_INTERLEAVE_EN_xxx1_1 = 1,     /*!< xxx1_1 : PTB0 to ADC0_SE4 and ADC1_SE14                                   */
} SIM_CHIPCTL_ADC_INTERLEAVE_EN_Enum;

/* ===========================================  SIM SIM_CHIPCTL CLKOUTSEL [4..7]  ============================================ */
typedef enum {                                  /*!< SIM_CHIPCTL_CLKOUTSEL                                                     */
  SIM_CHIPCTL_CLKOUTSEL_0000           = 0,     /*!< 0000 : SCG CLKOUT                                                         */
  SIM_CHIPCTL_CLKOUTSEL_0010           = 2,     /*!< 0010 : SOSC DIV2 CLK                                                      */
  SIM_CHIPCTL_CLKOUTSEL_0100           = 4,     /*!< 0100 : SIRC DIV2 CLK                                                      */
  SIM_CHIPCTL_CLKOUTSEL_0101           = 5,     /*!< 0101 : For S32K148: QSPI SFIF_CLK_HYP: Divide by 2 clock (configured
                                                     through SCLKCONFIG[5]) for HyperRAM going to sfif clock
                                                     to QSPI; For others: Reserved                                             */
  SIM_CHIPCTL_CLKOUTSEL_0110           = 6,     /*!< 0110 : FIRC DIV2 CLK                                                      */
  SIM_CHIPCTL_CLKOUTSEL_0111           = 7,     /*!< 0111 : HCLK                                                               */
  SIM_CHIPCTL_CLKOUTSEL_1000           = 8,     /*!< 1000 : SPLL DIV2 CLK                                                      */
  SIM_CHIPCTL_CLKOUTSEL_1001           = 9,     /*!< 1001 : BUS_CLK                                                            */
  SIM_CHIPCTL_CLKOUTSEL_1010           = 10,    /*!< 1010 : LPO128K_CLK                                                        */
  SIM_CHIPCTL_CLKOUTSEL_1011           = 11,    /*!< 1011 : For S32K148: QSPI IPG_CLK; For others: Reserved                    */
  SIM_CHIPCTL_CLKOUTSEL_1100           = 12,    /*!< 1100 : LPO_CLK as selected by SIM_LPOCLKS[LPOCLKSEL]                      */
  SIM_CHIPCTL_CLKOUTSEL_1101           = 13,    /*!< 1101 : For S32K148: QSPI IPG_CLK_SFIF; For others: Reserved               */
  SIM_CHIPCTL_CLKOUTSEL_1110           = 14,    /*!< 1110 : RTC_CLK as selected by SIM_LPOCLKS[RTCCLKSEL]                      */
  SIM_CHIPCTL_CLKOUTSEL_1111           = 15,    /*!< 1111 : For S32K148: QSPI IPG_CLK_2XSFIF; For others: Reserved             */
} SIM_CHIPCTL_CLKOUTSEL_Enum;

/* ===========================================  SIM SIM_CHIPCTL CLKOUTDIV [8..10]  =========================================== */
typedef enum {                                  /*!< SIM_CHIPCTL_CLKOUTDIV                                                     */
  SIM_CHIPCTL_CLKOUTDIV_000            = 0,     /*!< 000 : Divide by 1                                                         */
  SIM_CHIPCTL_CLKOUTDIV_001            = 1,     /*!< 001 : Divide by 2                                                         */
  SIM_CHIPCTL_CLKOUTDIV_010            = 2,     /*!< 010 : Divide by 3                                                         */
  SIM_CHIPCTL_CLKOUTDIV_011            = 3,     /*!< 011 : Divide by 4                                                         */
  SIM_CHIPCTL_CLKOUTDIV_100            = 4,     /*!< 100 : Divide by 5                                                         */
  SIM_CHIPCTL_CLKOUTDIV_101            = 5,     /*!< 101 : Divide by 6                                                         */
  SIM_CHIPCTL_CLKOUTDIV_110            = 6,     /*!< 110 : Divide by 7                                                         */
  SIM_CHIPCTL_CLKOUTDIV_111            = 7,     /*!< 111 : Divide by 8                                                         */
} SIM_CHIPCTL_CLKOUTDIV_Enum;

/* ===========================================  SIM SIM_CHIPCTL CLKOUTEN [11..11]  =========================================== */
typedef enum {                                  /*!< SIM_CHIPCTL_CLKOUTEN                                                      */
  SIM_CHIPCTL_CLKOUTEN_0               = 0,     /*!< 0 : Clockout disable                                                      */
  SIM_CHIPCTL_CLKOUTEN_1               = 1,     /*!< 1 : Clockout enable                                                       */
} SIM_CHIPCTL_CLKOUTEN_Enum;

/* =========================================  SIM SIM_CHIPCTL TRACECLK_SEL [12..12]  ========================================= */
typedef enum {                                  /*!< SIM_CHIPCTL_TRACECLK_SEL                                                  */
  SIM_CHIPCTL_TRACECLK_SEL_0           = 0,     /*!< 0 : Core clock                                                            */
  SIM_CHIPCTL_TRACECLK_SEL_1           = 1,     /*!< 1 : Platform clock                                                        */
} SIM_CHIPCTL_TRACECLK_SEL_Enum;

/* ==========================================  SIM SIM_CHIPCTL PDB_BB_SEL [13..13]  ========================================== */
typedef enum {                                  /*!< SIM_CHIPCTL_PDB_BB_SEL                                                    */
  SIM_CHIPCTL_PDB_BB_SEL_0             = 0,     /*!< 0 : PDB0 channel 0 back-to-back operation with ADC0 COCO[7:0]
                                                     and PDB1 channel 0 back-to-back operation with ADC1 COCO[7:0]             */
  SIM_CHIPCTL_PDB_BB_SEL_1             = 1,     /*!< 1 : Channel 0 of PDB0 and PDB1 back-to-back operation with COCO[7:0]
                                                     of ADC0 and ADC1.                                                         */
} SIM_CHIPCTL_PDB_BB_SEL_Enum;

/* ==========================================  SIM SIM_CHIPCTL ADC_SUPPLY [16..18]  ========================================== */
typedef enum {                                  /*!< SIM_CHIPCTL_ADC_SUPPLY                                                    */
  SIM_CHIPCTL_ADC_SUPPLY_000           = 0,     /*!< 000 : 5 V input VDD supply (VDD)                                          */
  SIM_CHIPCTL_ADC_SUPPLY_001           = 1,     /*!< 001 : 5 V input analog supply (VDDA)                                      */
  SIM_CHIPCTL_ADC_SUPPLY_010           = 2,     /*!< 010 : ADC Reference Supply (VREFH)                                        */
  SIM_CHIPCTL_ADC_SUPPLY_011           = 3,     /*!< 011 : 3.3 V Oscillator Regulator Output (VDD_3V)                          */
  SIM_CHIPCTL_ADC_SUPPLY_100           = 4,     /*!< 100 : 3.3 V flash regulator output (VDD_flash_3V)                         */
  SIM_CHIPCTL_ADC_SUPPLY_101           = 5,     /*!< 101 : 1.2 V core regulator output (VDD_LV)                                */
} SIM_CHIPCTL_ADC_SUPPLY_Enum;

/* =========================================  SIM SIM_CHIPCTL ADC_SUPPLYEN [19..19]  ========================================= */
typedef enum {                                  /*!< SIM_CHIPCTL_ADC_SUPPLYEN                                                  */
  SIM_CHIPCTL_ADC_SUPPLYEN_0           = 0,     /*!< 0 : Disable internal supply monitoring                                    */
  SIM_CHIPCTL_ADC_SUPPLYEN_1           = 1,     /*!< 1 : Enable internal supply monitoring                                     */
} SIM_CHIPCTL_ADC_SUPPLYEN_Enum;

/* =========================================  SIM SIM_CHIPCTL SRAMU_RETEN [20..20]  ========================================== */
typedef enum {                                  /*!< SIM_CHIPCTL_SRAMU_RETEN                                                   */
  SIM_CHIPCTL_SRAMU_RETEN_0            = 0,     /*!< 0 : SRAMU contents are retained across resets                             */
  SIM_CHIPCTL_SRAMU_RETEN_1            = 1,     /*!< 1 : No SRAMU retention                                                    */
} SIM_CHIPCTL_SRAMU_RETEN_Enum;

/* =========================================  SIM SIM_CHIPCTL SRAML_RETEN [21..21]  ========================================== */
typedef enum {                                  /*!< SIM_CHIPCTL_SRAML_RETEN                                                   */
  SIM_CHIPCTL_SRAML_RETEN_0            = 0,     /*!< 0 : SRAML contents are retained across resets                             */
  SIM_CHIPCTL_SRAML_RETEN_1            = 1,     /*!< 1 : No SRAML retention                                                    */
} SIM_CHIPCTL_SRAML_RETEN_Enum;

/* ======================================================  SIM_FTMOPT0  ====================================================== */
/* ==========================================  SIM SIM_FTMOPT0 FTM0FLTxSEL [0..2]  =========================================== */
typedef enum {                                  /*!< SIM_FTMOPT0_FTM0FLTxSEL                                                   */
  SIM_FTMOPT0_FTM0FLTxSEL_000          = 0,     /*!< 000 : FTM0_FLTx pin                                                       */
  SIM_FTMOPT0_FTM0FLTxSEL_001          = 1,     /*!< 001 : TRGMUX_FTM0 out                                                     */
} SIM_FTMOPT0_FTM0FLTxSEL_Enum;

/* ==========================================  SIM SIM_FTMOPT0 FTM1FLTxSEL [4..6]  =========================================== */
typedef enum {                                  /*!< SIM_FTMOPT0_FTM1FLTxSEL                                                   */
  SIM_FTMOPT0_FTM1FLTxSEL_000          = 0,     /*!< 000 : FTM1_FLTx pin                                                       */
  SIM_FTMOPT0_FTM1FLTxSEL_001          = 1,     /*!< 001 : TRGMUX_FTM1 out                                                     */
} SIM_FTMOPT0_FTM1FLTxSEL_Enum;

/* ==========================================  SIM SIM_FTMOPT0 FTM2FLTxSEL [8..10]  ========================================== */
typedef enum {                                  /*!< SIM_FTMOPT0_FTM2FLTxSEL                                                   */
  SIM_FTMOPT0_FTM2FLTxSEL_000          = 0,     /*!< 000 : FTM2_FLTx pin                                                       */
  SIM_FTMOPT0_FTM2FLTxSEL_001          = 1,     /*!< 001 : TRGMUX_FTM2 out                                                     */
} SIM_FTMOPT0_FTM2FLTxSEL_Enum;

/* =========================================  SIM SIM_FTMOPT0 FTM3FLTxSEL [12..14]  ========================================== */
typedef enum {                                  /*!< SIM_FTMOPT0_FTM3FLTxSEL                                                   */
  SIM_FTMOPT0_FTM3FLTxSEL_000          = 0,     /*!< 000 : FTM3_FLTx pin                                                       */
  SIM_FTMOPT0_FTM3FLTxSEL_001          = 1,     /*!< 001 : TRGMUX_FTM3 out                                                     */
} SIM_FTMOPT0_FTM3FLTxSEL_Enum;

/* ==========================================  SIM SIM_FTMOPT0 FTM0CLKSEL [24..25]  ========================================== */
typedef enum {                                  /*!< SIM_FTMOPT0_FTM0CLKSEL                                                    */
  SIM_FTMOPT0_FTM0CLKSEL_00            = 0,     /*!< 00 : FTM0 external clock driven by TCLK0 pin.                             */
  SIM_FTMOPT0_FTM0CLKSEL_01            = 1,     /*!< 01 : FTM0 external clock driven by TCLK1 pin.                             */
  SIM_FTMOPT0_FTM0CLKSEL_10            = 2,     /*!< 10 : FTM0 external clock driven by TCLK2 pin.                             */
  SIM_FTMOPT0_FTM0CLKSEL_11            = 3,     /*!< 11 : No clock input                                                       */
} SIM_FTMOPT0_FTM0CLKSEL_Enum;

/* ==========================================  SIM SIM_FTMOPT0 FTM1CLKSEL [26..27]  ========================================== */
typedef enum {                                  /*!< SIM_FTMOPT0_FTM1CLKSEL                                                    */
  SIM_FTMOPT0_FTM1CLKSEL_00            = 0,     /*!< 00 : FTM1 external clock driven by TCLK0 pin.                             */
  SIM_FTMOPT0_FTM1CLKSEL_01            = 1,     /*!< 01 : FTM1 external clock driven by TCLK1 pin.                             */
  SIM_FTMOPT0_FTM1CLKSEL_10            = 2,     /*!< 10 : FTM1 external clock driven by TCLK2 pin.                             */
  SIM_FTMOPT0_FTM1CLKSEL_11            = 3,     /*!< 11 : No clock input                                                       */
} SIM_FTMOPT0_FTM1CLKSEL_Enum;

/* ==========================================  SIM SIM_FTMOPT0 FTM2CLKSEL [28..29]  ========================================== */
typedef enum {                                  /*!< SIM_FTMOPT0_FTM2CLKSEL                                                    */
  SIM_FTMOPT0_FTM2CLKSEL_00            = 0,     /*!< 00 : FTM2 external clock driven by TCLK0 pin.                             */
  SIM_FTMOPT0_FTM2CLKSEL_01            = 1,     /*!< 01 : FTM2 external clock driven by TCLK1 pin.                             */
  SIM_FTMOPT0_FTM2CLKSEL_10            = 2,     /*!< 10 : FTM2 external clock driven by TCLK2 pin.                             */
  SIM_FTMOPT0_FTM2CLKSEL_11            = 3,     /*!< 11 : No clock input                                                       */
} SIM_FTMOPT0_FTM2CLKSEL_Enum;

/* ==========================================  SIM SIM_FTMOPT0 FTM3CLKSEL [30..31]  ========================================== */
typedef enum {                                  /*!< SIM_FTMOPT0_FTM3CLKSEL                                                    */
  SIM_FTMOPT0_FTM3CLKSEL_00            = 0,     /*!< 00 : FTM3 external clock driven by TCLK0 pin.                             */
  SIM_FTMOPT0_FTM3CLKSEL_01            = 1,     /*!< 01 : FTM3 external clock driven by TCLK1 pin.                             */
  SIM_FTMOPT0_FTM3CLKSEL_10            = 2,     /*!< 10 : FTM3 external clock driven by TCLK2 pin.                             */
  SIM_FTMOPT0_FTM3CLKSEL_11            = 3,     /*!< 11 : No clock input                                                       */
} SIM_FTMOPT0_FTM3CLKSEL_Enum;

/* ======================================================  SIM_LPOCLKS  ====================================================== */
/* ===========================================  SIM SIM_LPOCLKS LPO1KCLKEN [0..0]  =========================================== */
typedef enum {                                  /*!< SIM_LPOCLKS_LPO1KCLKEN                                                    */
  SIM_LPOCLKS_LPO1KCLKEN_0             = 0,     /*!< 0 : Disable 1 kHz LPO_CLK output                                          */
  SIM_LPOCLKS_LPO1KCLKEN_1             = 1,     /*!< 1 : Enable 1 kHz LPO_CLK output                                           */
} SIM_LPOCLKS_LPO1KCLKEN_Enum;

/* ==========================================  SIM SIM_LPOCLKS LPO32KCLKEN [1..1]  =========================================== */
typedef enum {                                  /*!< SIM_LPOCLKS_LPO32KCLKEN                                                   */
  SIM_LPOCLKS_LPO32KCLKEN_0            = 0,     /*!< 0 : Disable 32 kHz LPO_CLK output                                         */
  SIM_LPOCLKS_LPO32KCLKEN_1            = 1,     /*!< 1 : Enable 32 kHz LPO_CLK output                                          */
} SIM_LPOCLKS_LPO32KCLKEN_Enum;

/* ===========================================  SIM SIM_LPOCLKS LPOCLKSEL [2..3]  ============================================ */
typedef enum {                                  /*!< SIM_LPOCLKS_LPOCLKSEL                                                     */
  SIM_LPOCLKS_LPOCLKSEL_00             = 0,     /*!< 00 : 128 kHz LPO_CLK                                                      */
  SIM_LPOCLKS_LPOCLKSEL_01             = 1,     /*!< 01 : No clock                                                             */
  SIM_LPOCLKS_LPOCLKSEL_10             = 2,     /*!< 10 : 32 kHz LPO_CLK which is derived from the 128 kHz LPO_CLK             */
  SIM_LPOCLKS_LPOCLKSEL_11             = 3,     /*!< 11 : 1 kHz LPO_CLK which is derived from the 128 kHz LPO_CLK              */
} SIM_LPOCLKS_LPOCLKSEL_Enum;

/* ===========================================  SIM SIM_LPOCLKS RTCCLKSEL [4..5]  ============================================ */
typedef enum {                                  /*!< SIM_LPOCLKS_RTCCLKSEL                                                     */
  SIM_LPOCLKS_RTCCLKSEL_00             = 0,     /*!< 00 : SOSCDIV1_CLK                                                         */
  SIM_LPOCLKS_RTCCLKSEL_01             = 1,     /*!< 01 : 32 kHz LPO_CLK                                                       */
  SIM_LPOCLKS_RTCCLKSEL_10             = 2,     /*!< 10 : RTC_CLKIN clock                                                      */
  SIM_LPOCLKS_RTCCLKSEL_11             = 3,     /*!< 11 : FIRCDIV1_CLK                                                         */
} SIM_LPOCLKS_RTCCLKSEL_Enum;

/* ======================================================  SIM_ADCOPT  ======================================================= */
/* ===========================================  SIM SIM_ADCOPT ADC0TRGSEL [0..0]  ============================================ */
typedef enum {                                  /*!< SIM_ADCOPT_ADC0TRGSEL                                                     */
  SIM_ADCOPT_ADC0TRGSEL_0              = 0,     /*!< 0 : PDB output                                                            */
  SIM_ADCOPT_ADC0TRGSEL_1              = 1,     /*!< 1 : TRGMUX output                                                         */
} SIM_ADCOPT_ADC0TRGSEL_Enum;

/* ==========================================  SIM SIM_ADCOPT ADC0SWPRETRG [1..3]  =========================================== */
typedef enum {                                  /*!< SIM_ADCOPT_ADC0SWPRETRG                                                   */
  SIM_ADCOPT_ADC0SWPRETRG_000          = 0,     /*!< 000 : Software pretrigger disabled                                        */
  SIM_ADCOPT_ADC0SWPRETRG_001          = 1,     /*!< 001 : Reserved (do not use)                                               */
  SIM_ADCOPT_ADC0SWPRETRG_010          = 2,     /*!< 010 : Reserved (do not use)                                               */
  SIM_ADCOPT_ADC0SWPRETRG_011          = 3,     /*!< 011 : Reserved (do not use)                                               */
  SIM_ADCOPT_ADC0SWPRETRG_100          = 4,     /*!< 100 : Software pretrigger 0                                               */
  SIM_ADCOPT_ADC0SWPRETRG_101          = 5,     /*!< 101 : Software pretrigger 1                                               */
  SIM_ADCOPT_ADC0SWPRETRG_110          = 6,     /*!< 110 : Software pretrigger 2                                               */
  SIM_ADCOPT_ADC0SWPRETRG_111          = 7,     /*!< 111 : Software pretrigger 3                                               */
} SIM_ADCOPT_ADC0SWPRETRG_Enum;

/* ==========================================  SIM SIM_ADCOPT ADC0PRETRGSEL [4..5]  ========================================== */
typedef enum {                                  /*!< SIM_ADCOPT_ADC0PRETRGSEL                                                  */
  SIM_ADCOPT_ADC0PRETRGSEL_00          = 0,     /*!< 00 : PDB pretrigger (default)                                             */
  SIM_ADCOPT_ADC0PRETRGSEL_01          = 1,     /*!< 01 : TRGMUX pretrigger                                                    */
  SIM_ADCOPT_ADC0PRETRGSEL_10          = 2,     /*!< 10 : Software pretrigger                                                  */
} SIM_ADCOPT_ADC0PRETRGSEL_Enum;

/* ===========================================  SIM SIM_ADCOPT ADC1TRGSEL [8..8]  ============================================ */
typedef enum {                                  /*!< SIM_ADCOPT_ADC1TRGSEL                                                     */
  SIM_ADCOPT_ADC1TRGSEL_0              = 0,     /*!< 0 : PDB output                                                            */
  SIM_ADCOPT_ADC1TRGSEL_1              = 1,     /*!< 1 : TRGMUX output                                                         */
} SIM_ADCOPT_ADC1TRGSEL_Enum;

/* ==========================================  SIM SIM_ADCOPT ADC1SWPRETRG [9..11]  ========================================== */
typedef enum {                                  /*!< SIM_ADCOPT_ADC1SWPRETRG                                                   */
  SIM_ADCOPT_ADC1SWPRETRG_000          = 0,     /*!< 000 : Software pretrigger disabled                                        */
  SIM_ADCOPT_ADC1SWPRETRG_001          = 1,     /*!< 001 : Reserved (do not use)                                               */
  SIM_ADCOPT_ADC1SWPRETRG_010          = 2,     /*!< 010 : Reserved (do not use)                                               */
  SIM_ADCOPT_ADC1SWPRETRG_011          = 3,     /*!< 011 : Reserved (do not use)                                               */
  SIM_ADCOPT_ADC1SWPRETRG_100          = 4,     /*!< 100 : Software pretrigger 0                                               */
  SIM_ADCOPT_ADC1SWPRETRG_101          = 5,     /*!< 101 : Software pretrigger 1                                               */
  SIM_ADCOPT_ADC1SWPRETRG_110          = 6,     /*!< 110 : Software pretrigger 2                                               */
  SIM_ADCOPT_ADC1SWPRETRG_111          = 7,     /*!< 111 : Software pretrigger 3                                               */
} SIM_ADCOPT_ADC1SWPRETRG_Enum;

/* =========================================  SIM SIM_ADCOPT ADC1PRETRGSEL [12..13]  ========================================= */
typedef enum {                                  /*!< SIM_ADCOPT_ADC1PRETRGSEL                                                  */
  SIM_ADCOPT_ADC1PRETRGSEL_00          = 0,     /*!< 00 : PDB pretrigger (default)                                             */
  SIM_ADCOPT_ADC1PRETRGSEL_01          = 1,     /*!< 01 : TRGMUX pretrigger                                                    */
  SIM_ADCOPT_ADC1PRETRGSEL_10          = 2,     /*!< 10 : Software pretrigger                                                  */
} SIM_ADCOPT_ADC1PRETRGSEL_Enum;

/* ======================================================  SIM_FTMOPT1  ====================================================== */
/* ===========================================  SIM SIM_FTMOPT1 FTM1CH0SEL [4..5]  =========================================== */
typedef enum {                                  /*!< SIM_FTMOPT1_FTM1CH0SEL                                                    */
  SIM_FTMOPT1_FTM1CH0SEL_00            = 0,     /*!< 00 : FTM1_CH0 input                                                       */
  SIM_FTMOPT1_FTM1CH0SEL_01            = 1,     /*!< 01 : CMP0 output                                                          */
} SIM_FTMOPT1_FTM1CH0SEL_Enum;

/* ===========================================  SIM SIM_FTMOPT1 FTM2CH0SEL [6..7]  =========================================== */
typedef enum {                                  /*!< SIM_FTMOPT1_FTM2CH0SEL                                                    */
  SIM_FTMOPT1_FTM2CH0SEL_00            = 0,     /*!< 00 : FTM2_CH0 input                                                       */
  SIM_FTMOPT1_FTM2CH0SEL_01            = 1,     /*!< 01 : CMP0 output                                                          */
} SIM_FTMOPT1_FTM2CH0SEL_Enum;

/* ===========================================  SIM SIM_FTMOPT1 FTM2CH1SEL [8..8]  =========================================== */
typedef enum {                                  /*!< SIM_FTMOPT1_FTM2CH1SEL                                                    */
  SIM_FTMOPT1_FTM2CH1SEL_0             = 0,     /*!< 0 : FTM2_CH1 input                                                        */
  SIM_FTMOPT1_FTM2CH1SEL_1             = 1,     /*!< 1 : exclusive OR of FTM2_CH0,FTM2_CH1,and FTM1_CH1                        */
} SIM_FTMOPT1_FTM2CH1SEL_Enum;

/* ===========================================  SIM SIM_FTMOPT1 FTMGLDOK [15..15]  =========================================== */
typedef enum {                                  /*!< SIM_FTMOPT1_FTMGLDOK                                                      */
  SIM_FTMOPT1_FTMGLDOK_0               = 0,     /*!< 0 : FTM Global load mechanism disabled.                                   */
  SIM_FTMOPT1_FTMGLDOK_1               = 1,     /*!< 1 : FTM Global load mechanism enabled                                     */
} SIM_FTMOPT1_FTMGLDOK_Enum;

/* =========================================  SIM SIM_FTMOPT1 FTM0_OUTSEL [16..23]  ========================================== */
typedef enum {                                  /*!< SIM_FTMOPT1_FTM0_OUTSEL                                                   */
  SIM_FTMOPT1_FTM0_OUTSEL_00000000     = 0,     /*!< 00000000 : No modulation with FTM1_CH1                                    */
  SIM_FTMOPT1_FTM0_OUTSEL_00000001     = 1,     /*!< 00000001 : Modulation with FTM1_CH1                                       */
} SIM_FTMOPT1_FTM0_OUTSEL_Enum;

/* =========================================  SIM SIM_FTMOPT1 FTM3_OUTSEL [24..31]  ========================================== */
typedef enum {                                  /*!< SIM_FTMOPT1_FTM3_OUTSEL                                                   */
  SIM_FTMOPT1_FTM3_OUTSEL_00000000     = 0,     /*!< 00000000 : No modulation with FTM2_CH1                                    */
  SIM_FTMOPT1_FTM3_OUTSEL_00000001     = 1,     /*!< 00000001 : Modulation with FTM2_CH1                                       */
} SIM_FTMOPT1_FTM3_OUTSEL_Enum;

/* =====================================================  SIM_MISCTRL0  ====================================================== */
/* =========================================  SIM SIM_MISCTRL0 STOP1_MONITOR [9..9]  ========================================= */
typedef enum {                                  /*!< SIM_MISCTRL0_STOP1_MONITOR                                                */
  SIM_MISCTRL0_STOP1_MONITOR_0         = 0,     /*!< 0 : Bus clock enabled or STOP1 entry aborted                              */
  SIM_MISCTRL0_STOP1_MONITOR_1         = 1,     /*!< 1 : STOP1 entry successful                                                */
} SIM_MISCTRL0_STOP1_MONITOR_Enum;

/* ========================================  SIM SIM_MISCTRL0 STOP2_MONITOR [10..10]  ======================================== */
typedef enum {                                  /*!< SIM_MISCTRL0_STOP2_MONITOR                                                */
  SIM_MISCTRL0_STOP2_MONITOR_0         = 0,     /*!< 0 : System clock enabled or STOP2 entry aborted                           */
  SIM_MISCTRL0_STOP2_MONITOR_1         = 1,     /*!< 1 : STOP2 entry successful                                                */
} SIM_MISCTRL0_STOP2_MONITOR_Enum;

/* ========================================  SIM SIM_MISCTRL0 FTM0_OBE_CTRL [16..16]  ======================================== */
typedef enum {                                  /*!< SIM_MISCTRL0_FTM0_OBE_CTRL                                                */
  SIM_MISCTRL0_FTM0_OBE_CTRL_0         = 0,     /*!< 0 : The FTM channel output is put to safe state when the FTM
                                                     counter is enabled and the FTM channel output is enabled
                                                     by Fault Control (FTM_MODE[FAULTM]!=2b00 and FTM_FLTCTRL[FSTATE]=1b0)
                                                     and PWM is enabled (FTM_SC[PWMENn] = 1b1). Otherwise the
                                                     channel output is tristated.                                              */
  SIM_MISCTRL0_FTM0_OBE_CTRL_1         = 1,     /*!< 1 : The FTM channel output state is retained when the channel
                                                     is in output mode. The output channel is tristated when
                                                     the channel is in input capture [DECAPEN=1b0, COMBINE=1b0,
                                                     MSnB:MSnA=2b00] or dual edge capture mode [DECAPEN=1b1].                  */
} SIM_MISCTRL0_FTM0_OBE_CTRL_Enum;

/* ========================================  SIM SIM_MISCTRL0 FTM1_OBE_CTRL [17..17]  ======================================== */
typedef enum {                                  /*!< SIM_MISCTRL0_FTM1_OBE_CTRL                                                */
  SIM_MISCTRL0_FTM1_OBE_CTRL_0         = 0,     /*!< 0 : The FTM channel output is put to safe state when the FTM
                                                     counter is enabled and the FTM channel output is enabled
                                                     by Fault Control (FTM_MODE[FAULTM]!=2b00 and FTM_FLTCTRL[FSTATE]=1b0)
                                                     and PWM is enabled (FTM_SC[PWMENn] = 1b1). Otherwise the
                                                     channel output is tristated.                                              */
  SIM_MISCTRL0_FTM1_OBE_CTRL_1         = 1,     /*!< 1 : The FTM channel output state is retained when the channel
                                                     is in output mode. The output channel is tristated when
                                                     the channel is in input capture [DECAPEN=1b0, COMBINE=1b0,
                                                     MSnB:MSnA=2b00] or dual edge capture mode [DECAPEN=1b1].                  */
} SIM_MISCTRL0_FTM1_OBE_CTRL_Enum;

/* ========================================  SIM SIM_MISCTRL0 FTM2_OBE_CTRL [18..18]  ======================================== */
typedef enum {                                  /*!< SIM_MISCTRL0_FTM2_OBE_CTRL                                                */
  SIM_MISCTRL0_FTM2_OBE_CTRL_0         = 0,     /*!< 0 : The FTM channel output is put to safe state when the FTM
                                                     counter is enabled and the FTM channel output is enabled
                                                     by Fault Control (FTM_MODE[FAULTM]!=2b00 and FTM_FLTCTRL[FSTATE]=1b0)
                                                     and PWM is enabled (FTM_SC[PWMENn] = 1b1). Otherwise the
                                                     channel output is tristated.                                              */
  SIM_MISCTRL0_FTM2_OBE_CTRL_1         = 1,     /*!< 1 : The FTM channel output state is retained when the channel
                                                     is in output mode. The output channel is tristated when
                                                     the channel is in input capture [DECAPEN=1b0, COMBINE=1b0,
                                                     MSnB:MSnA=2b00] or dual edge capture mode [DECAPEN=1b1].                  */
} SIM_MISCTRL0_FTM2_OBE_CTRL_Enum;

/* ========================================  SIM SIM_MISCTRL0 FTM3_OBE_CTRL [19..19]  ======================================== */
typedef enum {                                  /*!< SIM_MISCTRL0_FTM3_OBE_CTRL                                                */
  SIM_MISCTRL0_FTM3_OBE_CTRL_0         = 0,     /*!< 0 : The FTM channel output is put to safe state when the FTM
                                                     counter is enabled and the FTM channel output is enabled
                                                     by Fault Control (FTM_MODE[FAULTM]!=2b00 and FTM_FLTCTRL[FSTATE]=1b0)
                                                     and PWM is enabled (FTM_SC[PWMENn] = 1b1). Otherwise the
                                                     channel output is tristated.                                              */
  SIM_MISCTRL0_FTM3_OBE_CTRL_1         = 1,     /*!< 1 : The FTM channel output state is retained when the channel
                                                     is in output mode. The output channel is tristated when
                                                     the channel is in input capture [DECAPEN=1b0, COMBINE=1b0,
                                                     MSnB:MSnA=2b00] or dual edge capture mode [DECAPEN=1b1].                  */
} SIM_MISCTRL0_FTM3_OBE_CTRL_Enum;

/* =======================================================  SIM_SDID  ======================================================== */
/* =============================================  SIM SIM_SDID PACKAGE [8..11]  ============================================== */
typedef enum {                                  /*!< SIM_SDID_PACKAGE                                                          */
  SIM_SDID_PACKAGE_0010                = 2,     /*!< 0010 : 48 LQFP                                                            */
  SIM_SDID_PACKAGE_0011                = 3,     /*!< 0011 : 64 LQFP                                                            */
  SIM_SDID_PACKAGE_0100                = 4,     /*!< 0100 : 100 LQFP                                                           */
  SIM_SDID_PACKAGE_0110                = 6,     /*!< 0110 : 144 LQFP                                                           */
  SIM_SDID_PACKAGE_0111                = 7,     /*!< 0111 : 176 LQFP                                                           */
  SIM_SDID_PACKAGE_1000                = 8,     /*!< 1000 : 100 MAP BGA                                                        */
} SIM_SDID_PACKAGE_Enum;

/* =============================================  SIM SIM_SDID RAMSIZE [16..19]  ============================================= */
typedef enum {                                  /*!< SIM_SDID_RAMSIZE                                                          */
  SIM_SDID_RAMSIZE_1011                = 11,    /*!< 1011 : 192 KB (S32K148), 96 KB (S32K146), Reserved (others)               */
  SIM_SDID_RAMSIZE_1101                = 13,    /*!< 1101 : 48 KB (S32K144), Reserved (others)                                 */
  SIM_SDID_RAMSIZE_1111                = 15,    /*!< 1111 : 256 KB (S32K148), 128 KB (S32K146), 64 KB (S32K144),
                                                     32 KB (S32K142), 25 KB (S32K118), 17 KB (S32K116)                         */
} SIM_SDID_RAMSIZE_Enum;

/* ======================================================  SIM_PLATCGC  ====================================================== */
/* ============================================  SIM SIM_PLATCGC CGCMSCM [0..0]  ============================================= */
typedef enum {                                  /*!< SIM_PLATCGC_CGCMSCM                                                       */
  SIM_PLATCGC_CGCMSCM_0                = 0,     /*!< 0 : Clock disabled                                                        */
  SIM_PLATCGC_CGCMSCM_1                = 1,     /*!< 1 : Clock enabled                                                         */
} SIM_PLATCGC_CGCMSCM_Enum;

/* =============================================  SIM SIM_PLATCGC CGCMPU [1..1]  ============================================= */
typedef enum {                                  /*!< SIM_PLATCGC_CGCMPU                                                        */
  SIM_PLATCGC_CGCMPU_0                 = 0,     /*!< 0 : Clock disabled                                                        */
  SIM_PLATCGC_CGCMPU_1                 = 1,     /*!< 1 : Clock enabled                                                         */
} SIM_PLATCGC_CGCMPU_Enum;

/* =============================================  SIM SIM_PLATCGC CGCDMA [2..2]  ============================================= */
typedef enum {                                  /*!< SIM_PLATCGC_CGCDMA                                                        */
  SIM_PLATCGC_CGCDMA_0                 = 0,     /*!< 0 : Clock disabled                                                        */
  SIM_PLATCGC_CGCDMA_1                 = 1,     /*!< 1 : Clock enabled                                                         */
} SIM_PLATCGC_CGCDMA_Enum;

/* =============================================  SIM SIM_PLATCGC CGCERM [3..3]  ============================================= */
typedef enum {                                  /*!< SIM_PLATCGC_CGCERM                                                        */
  SIM_PLATCGC_CGCERM_0                 = 0,     /*!< 0 : Clock disabled                                                        */
  SIM_PLATCGC_CGCERM_1                 = 1,     /*!< 1 : Clock enabled                                                         */
} SIM_PLATCGC_CGCERM_Enum;

/* =============================================  SIM SIM_PLATCGC CGCEIM [4..4]  ============================================= */
typedef enum {                                  /*!< SIM_PLATCGC_CGCEIM                                                        */
  SIM_PLATCGC_CGCEIM_0                 = 0,     /*!< 0 : Clock disabled                                                        */
  SIM_PLATCGC_CGCEIM_1                 = 1,     /*!< 1 : Clock enabled                                                         */
} SIM_PLATCGC_CGCEIM_Enum;

/* ============================================  SIM SIM_PLATCGC CGCGPIO [5..5]  ============================================= */
typedef enum {                                  /*!< SIM_PLATCGC_CGCGPIO                                                       */
  SIM_PLATCGC_CGCGPIO_0                = 0,     /*!< 0 : Clock disabled                                                        */
  SIM_PLATCGC_CGCGPIO_1                = 1,     /*!< 1 : Clock enabled                                                         */
} SIM_PLATCGC_CGCGPIO_Enum;

/* =======================================================  SIM_FCFG1  ======================================================= */
/* ===========================================  SIM SIM_FCFG1 EEERAMSIZE [16..19]  =========================================== */
typedef enum {                                  /*!< SIM_FCFG1_EEERAMSIZE                                                      */
  SIM_FCFG1_EEERAMSIZE_0010            = 2,     /*!< 0010 : 4 KB                                                               */
  SIM_FCFG1_EEERAMSIZE_0011            = 3,     /*!< 0011 : 2 KB                                                               */
  SIM_FCFG1_EEERAMSIZE_0100            = 4,     /*!< 0100 : 1 KB                                                               */
  SIM_FCFG1_EEERAMSIZE_0101            = 5,     /*!< 0101 : 512 Bytes                                                          */
  SIM_FCFG1_EEERAMSIZE_0110            = 6,     /*!< 0110 : 256 Bytes                                                          */
  SIM_FCFG1_EEERAMSIZE_0111            = 7,     /*!< 0111 : 128 Bytes                                                          */
  SIM_FCFG1_EEERAMSIZE_1000            = 8,     /*!< 1000 : 64 Bytes                                                           */
  SIM_FCFG1_EEERAMSIZE_1001            = 9,     /*!< 1001 : 32 Bytes                                                           */
  SIM_FCFG1_EEERAMSIZE_1111            = 15,    /*!< 1111 : 0 Bytes                                                            */
} SIM_FCFG1_EEERAMSIZE_Enum;

/* =======================================================  SIM_UIDH  ======================================================== */
/* =======================================================  SIM_UIDMH  ======================================================= */
/* =======================================================  SIM_UIDML  ======================================================= */
/* =======================================================  SIM_UIDL  ======================================================== */
/* ======================================================  SIM_CLKDIV4  ====================================================== */
/* ==========================================  SIM SIM_CLKDIV4 TRACEDIVEN [28..28]  ========================================== */
typedef enum {                                  /*!< SIM_CLKDIV4_TRACEDIVEN                                                    */
  SIM_CLKDIV4_TRACEDIVEN_0             = 0,     /*!< 0 : Debug trace divider disabled                                          */
  SIM_CLKDIV4_TRACEDIVEN_1             = 1,     /*!< 1 : Debug trace divider enabled                                           */
} SIM_CLKDIV4_TRACEDIVEN_Enum;

/* =====================================================  SIM_MISCTRL1  ====================================================== */


/* =========================================================================================================================== */
/* ================                                           PORTA                                           ================ */
/* =========================================================================================================================== */

/* ======================================================  PORTA_PCR0  ======================================================= */
/* ==============================================  PORTA PORTA_PCR0 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR0_PS                                                             */
  PORTA_PCR0_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR0_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR0_PS_Enum;

/* ==============================================  PORTA PORTA_PCR0 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR0_PE                                                             */
  PORTA_PCR0_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR0_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR0_PE_Enum;

/* =============================================  PORTA PORTA_PCR0 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR0_MUX                                                            */
  PORTA_PCR0_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR0_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR0_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR0_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR0_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR0_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR0_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR0_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR0_MUX_Enum;

/* =============================================  PORTA PORTA_PCR0 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR0_LK                                                             */
  PORTA_PCR0_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR0_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR0_LK_Enum;

/* ============================================  PORTA PORTA_PCR0 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR0_IRQC                                                           */
  PORTA_PCR0_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR0_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR0_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR0_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR0_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR0_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR0_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR0_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR0_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR0_IRQC_Enum;

/* =============================================  PORTA PORTA_PCR0 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR0_ISF                                                            */
  PORTA_PCR0_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR0_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR0_ISF_Enum;

/* ======================================================  PORTA_PCR1  ======================================================= */
/* ==============================================  PORTA PORTA_PCR1 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR1_PS                                                             */
  PORTA_PCR1_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR1_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR1_PS_Enum;

/* ==============================================  PORTA PORTA_PCR1 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR1_PE                                                             */
  PORTA_PCR1_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR1_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR1_PE_Enum;

/* =============================================  PORTA PORTA_PCR1 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR1_MUX                                                            */
  PORTA_PCR1_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR1_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR1_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR1_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR1_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR1_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR1_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR1_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR1_MUX_Enum;

/* =============================================  PORTA PORTA_PCR1 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR1_LK                                                             */
  PORTA_PCR1_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR1_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR1_LK_Enum;

/* ============================================  PORTA PORTA_PCR1 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR1_IRQC                                                           */
  PORTA_PCR1_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR1_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR1_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR1_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR1_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR1_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR1_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR1_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR1_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR1_IRQC_Enum;

/* =============================================  PORTA PORTA_PCR1 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR1_ISF                                                            */
  PORTA_PCR1_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR1_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR1_ISF_Enum;

/* ======================================================  PORTA_PCR2  ======================================================= */
/* ==============================================  PORTA PORTA_PCR2 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR2_PS                                                             */
  PORTA_PCR2_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR2_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR2_PS_Enum;

/* ==============================================  PORTA PORTA_PCR2 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR2_PE                                                             */
  PORTA_PCR2_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR2_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR2_PE_Enum;

/* =============================================  PORTA PORTA_PCR2 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR2_MUX                                                            */
  PORTA_PCR2_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR2_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR2_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR2_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR2_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR2_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR2_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR2_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR2_MUX_Enum;

/* =============================================  PORTA PORTA_PCR2 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR2_LK                                                             */
  PORTA_PCR2_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR2_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR2_LK_Enum;

/* ============================================  PORTA PORTA_PCR2 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR2_IRQC                                                           */
  PORTA_PCR2_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR2_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR2_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR2_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR2_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR2_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR2_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR2_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR2_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR2_IRQC_Enum;

/* =============================================  PORTA PORTA_PCR2 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR2_ISF                                                            */
  PORTA_PCR2_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR2_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR2_ISF_Enum;

/* ======================================================  PORTA_PCR3  ======================================================= */
/* ==============================================  PORTA PORTA_PCR3 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR3_PS                                                             */
  PORTA_PCR3_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR3_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR3_PS_Enum;

/* ==============================================  PORTA PORTA_PCR3 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR3_PE                                                             */
  PORTA_PCR3_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR3_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR3_PE_Enum;

/* =============================================  PORTA PORTA_PCR3 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR3_MUX                                                            */
  PORTA_PCR3_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR3_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR3_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR3_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR3_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR3_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR3_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR3_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR3_MUX_Enum;

/* =============================================  PORTA PORTA_PCR3 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR3_LK                                                             */
  PORTA_PCR3_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR3_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR3_LK_Enum;

/* ============================================  PORTA PORTA_PCR3 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR3_IRQC                                                           */
  PORTA_PCR3_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR3_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR3_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR3_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR3_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR3_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR3_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR3_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR3_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR3_IRQC_Enum;

/* =============================================  PORTA PORTA_PCR3 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR3_ISF                                                            */
  PORTA_PCR3_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR3_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR3_ISF_Enum;

/* ======================================================  PORTA_PCR4  ======================================================= */
/* ==============================================  PORTA PORTA_PCR4 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR4_PS                                                             */
  PORTA_PCR4_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR4_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR4_PS_Enum;

/* ==============================================  PORTA PORTA_PCR4 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR4_PE                                                             */
  PORTA_PCR4_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR4_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR4_PE_Enum;

/* =============================================  PORTA PORTA_PCR4 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR4_MUX                                                            */
  PORTA_PCR4_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR4_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR4_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR4_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR4_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR4_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR4_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR4_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR4_MUX_Enum;

/* =============================================  PORTA PORTA_PCR4 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR4_LK                                                             */
  PORTA_PCR4_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR4_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR4_LK_Enum;

/* ============================================  PORTA PORTA_PCR4 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR4_IRQC                                                           */
  PORTA_PCR4_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR4_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR4_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR4_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR4_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR4_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR4_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR4_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR4_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR4_IRQC_Enum;

/* =============================================  PORTA PORTA_PCR4 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR4_ISF                                                            */
  PORTA_PCR4_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR4_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR4_ISF_Enum;

/* ======================================================  PORTA_PCR5  ======================================================= */
/* ==============================================  PORTA PORTA_PCR5 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR5_PS                                                             */
  PORTA_PCR5_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR5_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR5_PS_Enum;

/* ==============================================  PORTA PORTA_PCR5 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR5_PE                                                             */
  PORTA_PCR5_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR5_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR5_PE_Enum;

/* ==============================================  PORTA PORTA_PCR5 PFE [4..4]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR5_PFE                                                            */
  PORTA_PCR5_PFE_0                     = 0,     /*!< 0 : Passive input filter is disabled on the corresponding pin.            */
  PORTA_PCR5_PFE_1                     = 1,     /*!< 1 : Passive input filter is enabled on the corresponding pin,
                                                     if the pin is configured as a digital input. Refer to the
                                                     device data sheet for filter characteristics.                             */
} PORTA_PCR5_PFE_Enum;

/* =============================================  PORTA PORTA_PCR5 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR5_MUX                                                            */
  PORTA_PCR5_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR5_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR5_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR5_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR5_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR5_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR5_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR5_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR5_MUX_Enum;

/* =============================================  PORTA PORTA_PCR5 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR5_LK                                                             */
  PORTA_PCR5_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR5_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR5_LK_Enum;

/* ============================================  PORTA PORTA_PCR5 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR5_IRQC                                                           */
  PORTA_PCR5_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR5_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR5_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR5_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR5_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR5_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR5_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR5_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR5_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR5_IRQC_Enum;

/* =============================================  PORTA PORTA_PCR5 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR5_ISF                                                            */
  PORTA_PCR5_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR5_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR5_ISF_Enum;

/* ======================================================  PORTA_PCR6  ======================================================= */
/* ==============================================  PORTA PORTA_PCR6 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR6_PS                                                             */
  PORTA_PCR6_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR6_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR6_PS_Enum;

/* ==============================================  PORTA PORTA_PCR6 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR6_PE                                                             */
  PORTA_PCR6_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR6_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR6_PE_Enum;

/* =============================================  PORTA PORTA_PCR6 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR6_MUX                                                            */
  PORTA_PCR6_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR6_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR6_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR6_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR6_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR6_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR6_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR6_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR6_MUX_Enum;

/* =============================================  PORTA PORTA_PCR6 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR6_LK                                                             */
  PORTA_PCR6_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR6_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR6_LK_Enum;

/* ============================================  PORTA PORTA_PCR6 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR6_IRQC                                                           */
  PORTA_PCR6_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR6_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR6_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR6_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR6_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR6_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR6_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR6_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR6_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR6_IRQC_Enum;

/* =============================================  PORTA PORTA_PCR6 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR6_ISF                                                            */
  PORTA_PCR6_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR6_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR6_ISF_Enum;

/* ======================================================  PORTA_PCR7  ======================================================= */
/* ==============================================  PORTA PORTA_PCR7 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR7_PS                                                             */
  PORTA_PCR7_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR7_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR7_PS_Enum;

/* ==============================================  PORTA PORTA_PCR7 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR7_PE                                                             */
  PORTA_PCR7_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR7_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR7_PE_Enum;

/* =============================================  PORTA PORTA_PCR7 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR7_MUX                                                            */
  PORTA_PCR7_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR7_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR7_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR7_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR7_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR7_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR7_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR7_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR7_MUX_Enum;

/* =============================================  PORTA PORTA_PCR7 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR7_LK                                                             */
  PORTA_PCR7_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR7_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR7_LK_Enum;

/* ============================================  PORTA PORTA_PCR7 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR7_IRQC                                                           */
  PORTA_PCR7_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR7_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR7_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR7_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR7_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR7_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR7_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR7_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR7_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR7_IRQC_Enum;

/* =============================================  PORTA PORTA_PCR7 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR7_ISF                                                            */
  PORTA_PCR7_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR7_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR7_ISF_Enum;

/* ======================================================  PORTA_PCR8  ======================================================= */
/* ==============================================  PORTA PORTA_PCR8 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR8_PS                                                             */
  PORTA_PCR8_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR8_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR8_PS_Enum;

/* ==============================================  PORTA PORTA_PCR8 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR8_PE                                                             */
  PORTA_PCR8_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR8_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR8_PE_Enum;

/* =============================================  PORTA PORTA_PCR8 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR8_MUX                                                            */
  PORTA_PCR8_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR8_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR8_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR8_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR8_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR8_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR8_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR8_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR8_MUX_Enum;

/* =============================================  PORTA PORTA_PCR8 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR8_LK                                                             */
  PORTA_PCR8_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR8_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR8_LK_Enum;

/* ============================================  PORTA PORTA_PCR8 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR8_IRQC                                                           */
  PORTA_PCR8_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR8_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR8_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR8_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR8_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR8_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR8_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR8_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR8_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR8_IRQC_Enum;

/* =============================================  PORTA PORTA_PCR8 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR8_ISF                                                            */
  PORTA_PCR8_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR8_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR8_ISF_Enum;

/* ======================================================  PORTA_PCR9  ======================================================= */
/* ==============================================  PORTA PORTA_PCR9 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR9_PS                                                             */
  PORTA_PCR9_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR9_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR9_PS_Enum;

/* ==============================================  PORTA PORTA_PCR9 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTA_PCR9_PE                                                             */
  PORTA_PCR9_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR9_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR9_PE_Enum;

/* =============================================  PORTA PORTA_PCR9 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR9_MUX                                                            */
  PORTA_PCR9_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR9_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR9_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR9_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR9_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR9_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR9_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR9_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR9_MUX_Enum;

/* =============================================  PORTA PORTA_PCR9 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR9_LK                                                             */
  PORTA_PCR9_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR9_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR9_LK_Enum;

/* ============================================  PORTA PORTA_PCR9 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR9_IRQC                                                           */
  PORTA_PCR9_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR9_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR9_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR9_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR9_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR9_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR9_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR9_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR9_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR9_IRQC_Enum;

/* =============================================  PORTA PORTA_PCR9 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR9_ISF                                                            */
  PORTA_PCR9_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR9_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR9_ISF_Enum;

/* ======================================================  PORTA_PCR10  ====================================================== */
/* ==============================================  PORTA PORTA_PCR10 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR10_PS                                                            */
  PORTA_PCR10_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR10_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR10_PS_Enum;

/* ==============================================  PORTA PORTA_PCR10 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR10_PE                                                            */
  PORTA_PCR10_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR10_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR10_PE_Enum;

/* =============================================  PORTA PORTA_PCR10 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR10_DSE                                                           */
  PORTA_PCR10_DSE_0                    = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTA_PCR10_DSE_1                    = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTA_PCR10_DSE_Enum;

/* =============================================  PORTA PORTA_PCR10 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR10_MUX                                                           */
  PORTA_PCR10_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR10_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR10_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR10_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR10_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR10_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR10_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR10_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR10_MUX_Enum;

/* =============================================  PORTA PORTA_PCR10 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR10_LK                                                            */
  PORTA_PCR10_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR10_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR10_LK_Enum;

/* ============================================  PORTA PORTA_PCR10 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR10_IRQC                                                          */
  PORTA_PCR10_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR10_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR10_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR10_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR10_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR10_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR10_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR10_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR10_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR10_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR10 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR10_ISF                                                           */
  PORTA_PCR10_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR10_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR10_ISF_Enum;

/* ======================================================  PORTA_PCR11  ====================================================== */
/* ==============================================  PORTA PORTA_PCR11 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR11_PS                                                            */
  PORTA_PCR11_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR11_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR11_PS_Enum;

/* ==============================================  PORTA PORTA_PCR11 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR11_PE                                                            */
  PORTA_PCR11_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR11_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR11_PE_Enum;

/* =============================================  PORTA PORTA_PCR11 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR11_MUX                                                           */
  PORTA_PCR11_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR11_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR11_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR11_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR11_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR11_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR11_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR11_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR11_MUX_Enum;

/* =============================================  PORTA PORTA_PCR11 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR11_LK                                                            */
  PORTA_PCR11_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR11_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR11_LK_Enum;

/* ============================================  PORTA PORTA_PCR11 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR11_IRQC                                                          */
  PORTA_PCR11_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR11_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR11_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR11_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR11_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR11_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR11_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR11_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR11_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR11_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR11 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR11_ISF                                                           */
  PORTA_PCR11_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR11_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR11_ISF_Enum;

/* ======================================================  PORTA_PCR12  ====================================================== */
/* ==============================================  PORTA PORTA_PCR12 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR12_PS                                                            */
  PORTA_PCR12_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR12_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR12_PS_Enum;

/* ==============================================  PORTA PORTA_PCR12 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR12_PE                                                            */
  PORTA_PCR12_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR12_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR12_PE_Enum;

/* =============================================  PORTA PORTA_PCR12 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR12_MUX                                                           */
  PORTA_PCR12_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR12_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR12_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR12_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR12_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR12_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR12_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR12_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR12_MUX_Enum;

/* =============================================  PORTA PORTA_PCR12 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR12_LK                                                            */
  PORTA_PCR12_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR12_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR12_LK_Enum;

/* ============================================  PORTA PORTA_PCR12 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR12_IRQC                                                          */
  PORTA_PCR12_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR12_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR12_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR12_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR12_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR12_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR12_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR12_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR12_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR12_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR12 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR12_ISF                                                           */
  PORTA_PCR12_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR12_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR12_ISF_Enum;

/* ======================================================  PORTA_PCR13  ====================================================== */
/* ==============================================  PORTA PORTA_PCR13 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR13_PS                                                            */
  PORTA_PCR13_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR13_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR13_PS_Enum;

/* ==============================================  PORTA PORTA_PCR13 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR13_PE                                                            */
  PORTA_PCR13_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR13_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR13_PE_Enum;

/* =============================================  PORTA PORTA_PCR13 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR13_MUX                                                           */
  PORTA_PCR13_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR13_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR13_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR13_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR13_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR13_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR13_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR13_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR13_MUX_Enum;

/* =============================================  PORTA PORTA_PCR13 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR13_LK                                                            */
  PORTA_PCR13_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR13_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR13_LK_Enum;

/* ============================================  PORTA PORTA_PCR13 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR13_IRQC                                                          */
  PORTA_PCR13_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR13_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR13_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR13_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR13_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR13_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR13_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR13_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR13_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR13_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR13 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR13_ISF                                                           */
  PORTA_PCR13_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR13_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR13_ISF_Enum;

/* ======================================================  PORTA_PCR14  ====================================================== */
/* ==============================================  PORTA PORTA_PCR14 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR14_PS                                                            */
  PORTA_PCR14_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR14_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR14_PS_Enum;

/* ==============================================  PORTA PORTA_PCR14 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR14_PE                                                            */
  PORTA_PCR14_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR14_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR14_PE_Enum;

/* =============================================  PORTA PORTA_PCR14 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR14_MUX                                                           */
  PORTA_PCR14_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR14_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR14_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR14_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR14_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR14_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR14_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR14_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR14_MUX_Enum;

/* =============================================  PORTA PORTA_PCR14 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR14_LK                                                            */
  PORTA_PCR14_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR14_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR14_LK_Enum;

/* ============================================  PORTA PORTA_PCR14 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR14_IRQC                                                          */
  PORTA_PCR14_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR14_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR14_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR14_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR14_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR14_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR14_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR14_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR14_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR14_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR14 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR14_ISF                                                           */
  PORTA_PCR14_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR14_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR14_ISF_Enum;

/* ======================================================  PORTA_PCR15  ====================================================== */
/* ==============================================  PORTA PORTA_PCR15 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR15_PS                                                            */
  PORTA_PCR15_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR15_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR15_PS_Enum;

/* ==============================================  PORTA PORTA_PCR15 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR15_PE                                                            */
  PORTA_PCR15_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR15_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR15_PE_Enum;

/* =============================================  PORTA PORTA_PCR15 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR15_MUX                                                           */
  PORTA_PCR15_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR15_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR15_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR15_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR15_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR15_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR15_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR15_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR15_MUX_Enum;

/* =============================================  PORTA PORTA_PCR15 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR15_LK                                                            */
  PORTA_PCR15_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR15_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR15_LK_Enum;

/* ============================================  PORTA PORTA_PCR15 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR15_IRQC                                                          */
  PORTA_PCR15_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR15_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR15_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR15_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR15_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR15_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR15_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR15_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR15_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR15_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR15 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR15_ISF                                                           */
  PORTA_PCR15_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR15_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR15_ISF_Enum;

/* ======================================================  PORTA_PCR16  ====================================================== */
/* ==============================================  PORTA PORTA_PCR16 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR16_PS                                                            */
  PORTA_PCR16_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR16_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR16_PS_Enum;

/* ==============================================  PORTA PORTA_PCR16 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR16_PE                                                            */
  PORTA_PCR16_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR16_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR16_PE_Enum;

/* =============================================  PORTA PORTA_PCR16 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR16_MUX                                                           */
  PORTA_PCR16_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR16_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR16_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR16_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR16_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR16_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR16_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR16_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR16_MUX_Enum;

/* =============================================  PORTA PORTA_PCR16 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR16_LK                                                            */
  PORTA_PCR16_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR16_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR16_LK_Enum;

/* ============================================  PORTA PORTA_PCR16 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR16_IRQC                                                          */
  PORTA_PCR16_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR16_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR16_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR16_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR16_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR16_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR16_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR16_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR16_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR16_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR16 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR16_ISF                                                           */
  PORTA_PCR16_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR16_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR16_ISF_Enum;

/* ======================================================  PORTA_PCR17  ====================================================== */
/* ==============================================  PORTA PORTA_PCR17 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR17_PS                                                            */
  PORTA_PCR17_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR17_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR17_PS_Enum;

/* ==============================================  PORTA PORTA_PCR17 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR17_PE                                                            */
  PORTA_PCR17_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR17_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR17_PE_Enum;

/* =============================================  PORTA PORTA_PCR17 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR17_MUX                                                           */
  PORTA_PCR17_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR17_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR17_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR17_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR17_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR17_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR17_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR17_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR17_MUX_Enum;

/* =============================================  PORTA PORTA_PCR17 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR17_LK                                                            */
  PORTA_PCR17_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR17_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR17_LK_Enum;

/* ============================================  PORTA PORTA_PCR17 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR17_IRQC                                                          */
  PORTA_PCR17_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR17_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR17_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR17_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR17_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR17_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR17_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR17_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR17_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR17_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR17 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR17_ISF                                                           */
  PORTA_PCR17_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR17_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR17_ISF_Enum;

/* ======================================================  PORTA_PCR18  ====================================================== */
/* ==============================================  PORTA PORTA_PCR18 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR18_PS                                                            */
  PORTA_PCR18_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR18_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR18_PS_Enum;

/* ==============================================  PORTA PORTA_PCR18 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR18_PE                                                            */
  PORTA_PCR18_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR18_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR18_PE_Enum;

/* =============================================  PORTA PORTA_PCR18 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR18_MUX                                                           */
  PORTA_PCR18_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR18_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR18_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR18_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR18_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR18_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR18_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR18_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR18_MUX_Enum;

/* =============================================  PORTA PORTA_PCR18 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR18_LK                                                            */
  PORTA_PCR18_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR18_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR18_LK_Enum;

/* ============================================  PORTA PORTA_PCR18 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR18_IRQC                                                          */
  PORTA_PCR18_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR18_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR18_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR18_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR18_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR18_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR18_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR18_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR18_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR18_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR18 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR18_ISF                                                           */
  PORTA_PCR18_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR18_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR18_ISF_Enum;

/* ======================================================  PORTA_PCR19  ====================================================== */
/* ==============================================  PORTA PORTA_PCR19 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR19_PS                                                            */
  PORTA_PCR19_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR19_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR19_PS_Enum;

/* ==============================================  PORTA PORTA_PCR19 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR19_PE                                                            */
  PORTA_PCR19_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR19_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR19_PE_Enum;

/* =============================================  PORTA PORTA_PCR19 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR19_MUX                                                           */
  PORTA_PCR19_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR19_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR19_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR19_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR19_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR19_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR19_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR19_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR19_MUX_Enum;

/* =============================================  PORTA PORTA_PCR19 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR19_LK                                                            */
  PORTA_PCR19_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR19_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR19_LK_Enum;

/* ============================================  PORTA PORTA_PCR19 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR19_IRQC                                                          */
  PORTA_PCR19_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR19_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR19_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR19_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR19_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR19_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR19_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR19_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR19_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR19_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR19 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR19_ISF                                                           */
  PORTA_PCR19_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR19_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR19_ISF_Enum;

/* ======================================================  PORTA_PCR20  ====================================================== */
/* ==============================================  PORTA PORTA_PCR20 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR20_PS                                                            */
  PORTA_PCR20_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR20_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR20_PS_Enum;

/* ==============================================  PORTA PORTA_PCR20 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR20_PE                                                            */
  PORTA_PCR20_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR20_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR20_PE_Enum;

/* =============================================  PORTA PORTA_PCR20 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR20_MUX                                                           */
  PORTA_PCR20_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR20_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR20_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR20_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR20_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR20_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR20_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR20_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR20_MUX_Enum;

/* =============================================  PORTA PORTA_PCR20 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR20_LK                                                            */
  PORTA_PCR20_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR20_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR20_LK_Enum;

/* ============================================  PORTA PORTA_PCR20 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR20_IRQC                                                          */
  PORTA_PCR20_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR20_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR20_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR20_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR20_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR20_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR20_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR20_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR20_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR20_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR20 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR20_ISF                                                           */
  PORTA_PCR20_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR20_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR20_ISF_Enum;

/* ======================================================  PORTA_PCR21  ====================================================== */
/* ==============================================  PORTA PORTA_PCR21 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR21_PS                                                            */
  PORTA_PCR21_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR21_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR21_PS_Enum;

/* ==============================================  PORTA PORTA_PCR21 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR21_PE                                                            */
  PORTA_PCR21_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR21_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR21_PE_Enum;

/* =============================================  PORTA PORTA_PCR21 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR21_MUX                                                           */
  PORTA_PCR21_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR21_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR21_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR21_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR21_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR21_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR21_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR21_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR21_MUX_Enum;

/* =============================================  PORTA PORTA_PCR21 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR21_LK                                                            */
  PORTA_PCR21_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR21_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR21_LK_Enum;

/* ============================================  PORTA PORTA_PCR21 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR21_IRQC                                                          */
  PORTA_PCR21_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR21_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR21_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR21_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR21_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR21_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR21_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR21_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR21_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR21_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR21 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR21_ISF                                                           */
  PORTA_PCR21_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR21_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR21_ISF_Enum;

/* ======================================================  PORTA_PCR22  ====================================================== */
/* ==============================================  PORTA PORTA_PCR22 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR22_PS                                                            */
  PORTA_PCR22_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR22_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR22_PS_Enum;

/* ==============================================  PORTA PORTA_PCR22 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR22_PE                                                            */
  PORTA_PCR22_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR22_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR22_PE_Enum;

/* =============================================  PORTA PORTA_PCR22 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR22_MUX                                                           */
  PORTA_PCR22_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR22_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR22_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR22_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR22_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR22_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR22_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR22_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR22_MUX_Enum;

/* =============================================  PORTA PORTA_PCR22 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR22_LK                                                            */
  PORTA_PCR22_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR22_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR22_LK_Enum;

/* ============================================  PORTA PORTA_PCR22 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR22_IRQC                                                          */
  PORTA_PCR22_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR22_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR22_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR22_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR22_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR22_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR22_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR22_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR22_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR22_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR22 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR22_ISF                                                           */
  PORTA_PCR22_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR22_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR22_ISF_Enum;

/* ======================================================  PORTA_PCR23  ====================================================== */
/* ==============================================  PORTA PORTA_PCR23 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR23_PS                                                            */
  PORTA_PCR23_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR23_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR23_PS_Enum;

/* ==============================================  PORTA PORTA_PCR23 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR23_PE                                                            */
  PORTA_PCR23_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR23_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR23_PE_Enum;

/* =============================================  PORTA PORTA_PCR23 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR23_MUX                                                           */
  PORTA_PCR23_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR23_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR23_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR23_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR23_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR23_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR23_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR23_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR23_MUX_Enum;

/* =============================================  PORTA PORTA_PCR23 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR23_LK                                                            */
  PORTA_PCR23_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR23_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR23_LK_Enum;

/* ============================================  PORTA PORTA_PCR23 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR23_IRQC                                                          */
  PORTA_PCR23_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR23_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR23_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR23_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR23_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR23_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR23_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR23_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR23_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR23_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR23 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR23_ISF                                                           */
  PORTA_PCR23_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR23_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR23_ISF_Enum;

/* ======================================================  PORTA_PCR24  ====================================================== */
/* ==============================================  PORTA PORTA_PCR24 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR24_PS                                                            */
  PORTA_PCR24_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR24_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR24_PS_Enum;

/* ==============================================  PORTA PORTA_PCR24 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR24_PE                                                            */
  PORTA_PCR24_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR24_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR24_PE_Enum;

/* =============================================  PORTA PORTA_PCR24 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR24_MUX                                                           */
  PORTA_PCR24_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR24_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR24_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR24_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR24_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR24_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR24_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR24_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR24_MUX_Enum;

/* =============================================  PORTA PORTA_PCR24 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR24_LK                                                            */
  PORTA_PCR24_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR24_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR24_LK_Enum;

/* ============================================  PORTA PORTA_PCR24 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR24_IRQC                                                          */
  PORTA_PCR24_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR24_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR24_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR24_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR24_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR24_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR24_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR24_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR24_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR24_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR24 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR24_ISF                                                           */
  PORTA_PCR24_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR24_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR24_ISF_Enum;

/* ======================================================  PORTA_PCR25  ====================================================== */
/* ==============================================  PORTA PORTA_PCR25 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR25_PS                                                            */
  PORTA_PCR25_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR25_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR25_PS_Enum;

/* ==============================================  PORTA PORTA_PCR25 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR25_PE                                                            */
  PORTA_PCR25_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR25_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR25_PE_Enum;

/* =============================================  PORTA PORTA_PCR25 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR25_MUX                                                           */
  PORTA_PCR25_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR25_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR25_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR25_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR25_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR25_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR25_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR25_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR25_MUX_Enum;

/* =============================================  PORTA PORTA_PCR25 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR25_LK                                                            */
  PORTA_PCR25_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR25_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR25_LK_Enum;

/* ============================================  PORTA PORTA_PCR25 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR25_IRQC                                                          */
  PORTA_PCR25_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR25_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR25_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR25_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR25_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR25_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR25_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR25_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR25_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR25_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR25 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR25_ISF                                                           */
  PORTA_PCR25_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR25_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR25_ISF_Enum;

/* ======================================================  PORTA_PCR26  ====================================================== */
/* ==============================================  PORTA PORTA_PCR26 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR26_PS                                                            */
  PORTA_PCR26_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR26_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR26_PS_Enum;

/* ==============================================  PORTA PORTA_PCR26 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR26_PE                                                            */
  PORTA_PCR26_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR26_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR26_PE_Enum;

/* =============================================  PORTA PORTA_PCR26 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR26_MUX                                                           */
  PORTA_PCR26_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR26_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR26_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR26_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR26_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR26_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR26_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR26_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR26_MUX_Enum;

/* =============================================  PORTA PORTA_PCR26 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR26_LK                                                            */
  PORTA_PCR26_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR26_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR26_LK_Enum;

/* ============================================  PORTA PORTA_PCR26 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR26_IRQC                                                          */
  PORTA_PCR26_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR26_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR26_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR26_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR26_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR26_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR26_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR26_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR26_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR26_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR26 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR26_ISF                                                           */
  PORTA_PCR26_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR26_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR26_ISF_Enum;

/* ======================================================  PORTA_PCR27  ====================================================== */
/* ==============================================  PORTA PORTA_PCR27 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR27_PS                                                            */
  PORTA_PCR27_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR27_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR27_PS_Enum;

/* ==============================================  PORTA PORTA_PCR27 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR27_PE                                                            */
  PORTA_PCR27_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR27_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR27_PE_Enum;

/* =============================================  PORTA PORTA_PCR27 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR27_MUX                                                           */
  PORTA_PCR27_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR27_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR27_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR27_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR27_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR27_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR27_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR27_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR27_MUX_Enum;

/* =============================================  PORTA PORTA_PCR27 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR27_LK                                                            */
  PORTA_PCR27_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR27_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR27_LK_Enum;

/* ============================================  PORTA PORTA_PCR27 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR27_IRQC                                                          */
  PORTA_PCR27_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR27_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR27_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR27_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR27_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR27_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR27_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR27_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR27_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR27_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR27 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR27_ISF                                                           */
  PORTA_PCR27_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR27_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR27_ISF_Enum;

/* ======================================================  PORTA_PCR28  ====================================================== */
/* ==============================================  PORTA PORTA_PCR28 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR28_PS                                                            */
  PORTA_PCR28_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR28_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR28_PS_Enum;

/* ==============================================  PORTA PORTA_PCR28 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR28_PE                                                            */
  PORTA_PCR28_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR28_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR28_PE_Enum;

/* =============================================  PORTA PORTA_PCR28 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR28_MUX                                                           */
  PORTA_PCR28_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR28_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR28_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR28_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR28_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR28_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR28_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR28_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR28_MUX_Enum;

/* =============================================  PORTA PORTA_PCR28 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR28_LK                                                            */
  PORTA_PCR28_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR28_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR28_LK_Enum;

/* ============================================  PORTA PORTA_PCR28 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR28_IRQC                                                          */
  PORTA_PCR28_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR28_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR28_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR28_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR28_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR28_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR28_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR28_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR28_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR28_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR28 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR28_ISF                                                           */
  PORTA_PCR28_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR28_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR28_ISF_Enum;

/* ======================================================  PORTA_PCR29  ====================================================== */
/* ==============================================  PORTA PORTA_PCR29 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR29_PS                                                            */
  PORTA_PCR29_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR29_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR29_PS_Enum;

/* ==============================================  PORTA PORTA_PCR29 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR29_PE                                                            */
  PORTA_PCR29_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR29_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR29_PE_Enum;

/* =============================================  PORTA PORTA_PCR29 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR29_MUX                                                           */
  PORTA_PCR29_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR29_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR29_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR29_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR29_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR29_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR29_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR29_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR29_MUX_Enum;

/* =============================================  PORTA PORTA_PCR29 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR29_LK                                                            */
  PORTA_PCR29_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR29_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR29_LK_Enum;

/* ============================================  PORTA PORTA_PCR29 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR29_IRQC                                                          */
  PORTA_PCR29_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR29_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR29_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR29_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR29_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR29_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR29_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR29_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR29_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR29_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR29 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR29_ISF                                                           */
  PORTA_PCR29_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR29_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR29_ISF_Enum;

/* ======================================================  PORTA_PCR30  ====================================================== */
/* ==============================================  PORTA PORTA_PCR30 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR30_PS                                                            */
  PORTA_PCR30_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR30_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR30_PS_Enum;

/* ==============================================  PORTA PORTA_PCR30 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR30_PE                                                            */
  PORTA_PCR30_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR30_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR30_PE_Enum;

/* =============================================  PORTA PORTA_PCR30 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR30_MUX                                                           */
  PORTA_PCR30_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR30_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR30_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR30_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR30_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR30_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR30_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR30_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR30_MUX_Enum;

/* =============================================  PORTA PORTA_PCR30 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR30_LK                                                            */
  PORTA_PCR30_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR30_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR30_LK_Enum;

/* ============================================  PORTA PORTA_PCR30 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR30_IRQC                                                          */
  PORTA_PCR30_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR30_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR30_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR30_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR30_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR30_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR30_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR30_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR30_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR30_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR30 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR30_ISF                                                           */
  PORTA_PCR30_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR30_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR30_ISF_Enum;

/* ======================================================  PORTA_PCR31  ====================================================== */
/* ==============================================  PORTA PORTA_PCR31 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR31_PS                                                            */
  PORTA_PCR31_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTA_PCR31_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTA_PCR31_PS_Enum;

/* ==============================================  PORTA PORTA_PCR31 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTA_PCR31_PE                                                            */
  PORTA_PCR31_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTA_PCR31_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTA_PCR31_PE_Enum;

/* =============================================  PORTA PORTA_PCR31 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR31_MUX                                                           */
  PORTA_PCR31_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTA_PCR31_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTA_PCR31_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTA_PCR31_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTA_PCR31_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTA_PCR31_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTA_PCR31_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTA_PCR31_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTA_PCR31_MUX_Enum;

/* =============================================  PORTA PORTA_PCR31 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR31_LK                                                            */
  PORTA_PCR31_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTA_PCR31_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTA_PCR31_LK_Enum;

/* ============================================  PORTA PORTA_PCR31 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTA_PCR31_IRQC                                                          */
  PORTA_PCR31_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTA_PCR31_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTA_PCR31_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTA_PCR31_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTA_PCR31_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTA_PCR31_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTA_PCR31_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTA_PCR31_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTA_PCR31_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTA_PCR31_IRQC_Enum;

/* ============================================  PORTA PORTA_PCR31 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTA_PCR31_ISF                                                           */
  PORTA_PCR31_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_PCR31_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_PCR31_ISF_Enum;

/* ======================================================  PORTA_GPCLR  ====================================================== */
/* ============================================  PORTA PORTA_GPCLR GPWE [16..31]  ============================================ */
typedef enum {                                  /*!< PORTA_GPCLR_GPWE                                                          */
  PORTA_GPCLR_GPWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTA_GPCLR_GPWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTA_GPCLR_GPWE_Enum;

/* ======================================================  PORTA_GPCHR  ====================================================== */
/* ============================================  PORTA PORTA_GPCHR GPWE [16..31]  ============================================ */
typedef enum {                                  /*!< PORTA_GPCHR_GPWE                                                          */
  PORTA_GPCHR_GPWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTA_GPCHR_GPWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTA_GPCHR_GPWE_Enum;

/* ======================================================  PORTA_GICLR  ====================================================== */
/* ============================================  PORTA PORTA_GICLR GIWE [0..15]  ============================================= */
typedef enum {                                  /*!< PORTA_GICLR_GIWE                                                          */
  PORTA_GICLR_GIWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTA_GICLR_GIWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTA_GICLR_GIWE_Enum;

/* ======================================================  PORTA_GICHR  ====================================================== */
/* ============================================  PORTA PORTA_GICHR GIWE [0..15]  ============================================= */
typedef enum {                                  /*!< PORTA_GICHR_GIWE                                                          */
  PORTA_GICHR_GIWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTA_GICHR_GIWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTA_GICHR_GIWE_Enum;

/* ======================================================  PORTA_ISFR  ======================================================= */
/* =============================================  PORTA PORTA_ISFR ISF [0..31]  ============================================== */
typedef enum {                                  /*!< PORTA_ISFR_ISF                                                            */
  PORTA_ISFR_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTA_ISFR_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTA_ISFR_ISF_Enum;

/* ======================================================  PORTA_DFER  ======================================================= */
/* =============================================  PORTA PORTA_DFER DFE [0..31]  ============================================== */
typedef enum {                                  /*!< PORTA_DFER_DFE                                                            */
  PORTA_DFER_DFE_0                     = 0,     /*!< 0 : Digital filter is disabled on the corresponding pin and
                                                     output of the digital filter is reset to zero.                            */
  PORTA_DFER_DFE_1                     = 1,     /*!< 1 : Digital filter is enabled on the corresponding pin, if the
                                                     pin is configured as a digital input.                                     */
} PORTA_DFER_DFE_Enum;

/* ======================================================  PORTA_DFCR  ======================================================= */
/* ==============================================  PORTA PORTA_DFCR CS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTA_DFCR_CS                                                             */
  PORTA_DFCR_CS_0                      = 0,     /*!< 0 : Digital filters are clocked by the bus clock.                         */
  PORTA_DFCR_CS_1                      = 1,     /*!< 1 : Digital filters are clocked by the LPO clock.                         */
} PORTA_DFCR_CS_Enum;

/* ======================================================  PORTA_DFWR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                           PORTB                                           ================ */
/* =========================================================================================================================== */

/* ======================================================  PORTB_PCR0  ======================================================= */
/* ==============================================  PORTB PORTB_PCR0 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR0_PS                                                             */
  PORTB_PCR0_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR0_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR0_PS_Enum;

/* ==============================================  PORTB PORTB_PCR0 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR0_PE                                                             */
  PORTB_PCR0_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR0_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR0_PE_Enum;

/* =============================================  PORTB PORTB_PCR0 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR0_MUX                                                            */
  PORTB_PCR0_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR0_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR0_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR0_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR0_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR0_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR0_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR0_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR0_MUX_Enum;

/* =============================================  PORTB PORTB_PCR0 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR0_LK                                                             */
  PORTB_PCR0_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR0_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR0_LK_Enum;

/* ============================================  PORTB PORTB_PCR0 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR0_IRQC                                                           */
  PORTB_PCR0_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR0_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR0_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR0_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR0_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR0_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR0_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR0_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR0_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR0_IRQC_Enum;

/* =============================================  PORTB PORTB_PCR0 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR0_ISF                                                            */
  PORTB_PCR0_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR0_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR0_ISF_Enum;

/* ======================================================  PORTB_PCR1  ======================================================= */
/* ==============================================  PORTB PORTB_PCR1 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR1_PS                                                             */
  PORTB_PCR1_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR1_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR1_PS_Enum;

/* ==============================================  PORTB PORTB_PCR1 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR1_PE                                                             */
  PORTB_PCR1_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR1_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR1_PE_Enum;

/* =============================================  PORTB PORTB_PCR1 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR1_MUX                                                            */
  PORTB_PCR1_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR1_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR1_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR1_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR1_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR1_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR1_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR1_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR1_MUX_Enum;

/* =============================================  PORTB PORTB_PCR1 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR1_LK                                                             */
  PORTB_PCR1_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR1_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR1_LK_Enum;

/* ============================================  PORTB PORTB_PCR1 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR1_IRQC                                                           */
  PORTB_PCR1_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR1_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR1_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR1_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR1_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR1_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR1_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR1_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR1_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR1_IRQC_Enum;

/* =============================================  PORTB PORTB_PCR1 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR1_ISF                                                            */
  PORTB_PCR1_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR1_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR1_ISF_Enum;

/* ======================================================  PORTB_PCR2  ======================================================= */
/* ==============================================  PORTB PORTB_PCR2 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR2_PS                                                             */
  PORTB_PCR2_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR2_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR2_PS_Enum;

/* ==============================================  PORTB PORTB_PCR2 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR2_PE                                                             */
  PORTB_PCR2_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR2_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR2_PE_Enum;

/* =============================================  PORTB PORTB_PCR2 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR2_MUX                                                            */
  PORTB_PCR2_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR2_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR2_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR2_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR2_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR2_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR2_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR2_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR2_MUX_Enum;

/* =============================================  PORTB PORTB_PCR2 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR2_LK                                                             */
  PORTB_PCR2_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR2_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR2_LK_Enum;

/* ============================================  PORTB PORTB_PCR2 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR2_IRQC                                                           */
  PORTB_PCR2_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR2_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR2_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR2_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR2_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR2_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR2_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR2_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR2_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR2_IRQC_Enum;

/* =============================================  PORTB PORTB_PCR2 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR2_ISF                                                            */
  PORTB_PCR2_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR2_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR2_ISF_Enum;

/* ======================================================  PORTB_PCR3  ======================================================= */
/* ==============================================  PORTB PORTB_PCR3 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR3_PS                                                             */
  PORTB_PCR3_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR3_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR3_PS_Enum;

/* ==============================================  PORTB PORTB_PCR3 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR3_PE                                                             */
  PORTB_PCR3_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR3_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR3_PE_Enum;

/* =============================================  PORTB PORTB_PCR3 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR3_MUX                                                            */
  PORTB_PCR3_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR3_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR3_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR3_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR3_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR3_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR3_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR3_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR3_MUX_Enum;

/* =============================================  PORTB PORTB_PCR3 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR3_LK                                                             */
  PORTB_PCR3_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR3_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR3_LK_Enum;

/* ============================================  PORTB PORTB_PCR3 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR3_IRQC                                                           */
  PORTB_PCR3_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR3_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR3_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR3_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR3_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR3_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR3_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR3_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR3_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR3_IRQC_Enum;

/* =============================================  PORTB PORTB_PCR3 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR3_ISF                                                            */
  PORTB_PCR3_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR3_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR3_ISF_Enum;

/* ======================================================  PORTB_PCR4  ======================================================= */
/* ==============================================  PORTB PORTB_PCR4 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR4_PS                                                             */
  PORTB_PCR4_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR4_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR4_PS_Enum;

/* ==============================================  PORTB PORTB_PCR4 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR4_PE                                                             */
  PORTB_PCR4_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR4_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR4_PE_Enum;

/* ==============================================  PORTB PORTB_PCR4 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR4_DSE                                                            */
  PORTB_PCR4_DSE_0                     = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTB_PCR4_DSE_1                     = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTB_PCR4_DSE_Enum;

/* =============================================  PORTB PORTB_PCR4 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR4_MUX                                                            */
  PORTB_PCR4_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR4_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR4_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR4_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR4_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR4_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR4_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR4_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR4_MUX_Enum;

/* =============================================  PORTB PORTB_PCR4 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR4_LK                                                             */
  PORTB_PCR4_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR4_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR4_LK_Enum;

/* ============================================  PORTB PORTB_PCR4 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR4_IRQC                                                           */
  PORTB_PCR4_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR4_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR4_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR4_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR4_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR4_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR4_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR4_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR4_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR4_IRQC_Enum;

/* =============================================  PORTB PORTB_PCR4 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR4_ISF                                                            */
  PORTB_PCR4_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR4_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR4_ISF_Enum;

/* ======================================================  PORTB_PCR5  ======================================================= */
/* ==============================================  PORTB PORTB_PCR5 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR5_PS                                                             */
  PORTB_PCR5_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR5_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR5_PS_Enum;

/* ==============================================  PORTB PORTB_PCR5 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR5_PE                                                             */
  PORTB_PCR5_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR5_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR5_PE_Enum;

/* ==============================================  PORTB PORTB_PCR5 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR5_DSE                                                            */
  PORTB_PCR5_DSE_0                     = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTB_PCR5_DSE_1                     = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTB_PCR5_DSE_Enum;

/* =============================================  PORTB PORTB_PCR5 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR5_MUX                                                            */
  PORTB_PCR5_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR5_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR5_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR5_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR5_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR5_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR5_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR5_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR5_MUX_Enum;

/* =============================================  PORTB PORTB_PCR5 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR5_LK                                                             */
  PORTB_PCR5_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR5_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR5_LK_Enum;

/* ============================================  PORTB PORTB_PCR5 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR5_IRQC                                                           */
  PORTB_PCR5_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR5_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR5_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR5_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR5_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR5_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR5_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR5_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR5_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR5_IRQC_Enum;

/* =============================================  PORTB PORTB_PCR5 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR5_ISF                                                            */
  PORTB_PCR5_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR5_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR5_ISF_Enum;

/* ======================================================  PORTB_PCR6  ======================================================= */
/* ==============================================  PORTB PORTB_PCR6 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR6_PS                                                             */
  PORTB_PCR6_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR6_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR6_PS_Enum;

/* ==============================================  PORTB PORTB_PCR6 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR6_PE                                                             */
  PORTB_PCR6_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR6_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR6_PE_Enum;

/* ==============================================  PORTB PORTB_PCR6 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR6_DSE                                                            */
  PORTB_PCR6_DSE_0                     = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTB_PCR6_DSE_1                     = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTB_PCR6_DSE_Enum;

/* =============================================  PORTB PORTB_PCR6 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR6_MUX                                                            */
  PORTB_PCR6_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR6_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR6_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR6_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR6_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR6_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR6_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR6_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR6_MUX_Enum;

/* =============================================  PORTB PORTB_PCR6 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR6_LK                                                             */
  PORTB_PCR6_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR6_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR6_LK_Enum;

/* ============================================  PORTB PORTB_PCR6 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR6_IRQC                                                           */
  PORTB_PCR6_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR6_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR6_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR6_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR6_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR6_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR6_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR6_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR6_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR6_IRQC_Enum;

/* =============================================  PORTB PORTB_PCR6 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR6_ISF                                                            */
  PORTB_PCR6_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR6_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR6_ISF_Enum;

/* ======================================================  PORTB_PCR7  ======================================================= */
/* ==============================================  PORTB PORTB_PCR7 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR7_PS                                                             */
  PORTB_PCR7_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR7_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR7_PS_Enum;

/* ==============================================  PORTB PORTB_PCR7 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR7_PE                                                             */
  PORTB_PCR7_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR7_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR7_PE_Enum;

/* =============================================  PORTB PORTB_PCR7 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR7_MUX                                                            */
  PORTB_PCR7_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR7_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR7_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR7_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR7_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR7_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR7_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR7_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR7_MUX_Enum;

/* =============================================  PORTB PORTB_PCR7 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR7_LK                                                             */
  PORTB_PCR7_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR7_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR7_LK_Enum;

/* ============================================  PORTB PORTB_PCR7 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR7_IRQC                                                           */
  PORTB_PCR7_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR7_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR7_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR7_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR7_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR7_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR7_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR7_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR7_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR7_IRQC_Enum;

/* =============================================  PORTB PORTB_PCR7 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR7_ISF                                                            */
  PORTB_PCR7_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR7_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR7_ISF_Enum;

/* ======================================================  PORTB_PCR8  ======================================================= */
/* ==============================================  PORTB PORTB_PCR8 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR8_PS                                                             */
  PORTB_PCR8_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR8_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR8_PS_Enum;

/* ==============================================  PORTB PORTB_PCR8 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR8_PE                                                             */
  PORTB_PCR8_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR8_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR8_PE_Enum;

/* =============================================  PORTB PORTB_PCR8 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR8_MUX                                                            */
  PORTB_PCR8_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR8_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR8_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR8_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR8_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR8_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR8_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR8_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR8_MUX_Enum;

/* =============================================  PORTB PORTB_PCR8 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR8_LK                                                             */
  PORTB_PCR8_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR8_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR8_LK_Enum;

/* ============================================  PORTB PORTB_PCR8 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR8_IRQC                                                           */
  PORTB_PCR8_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR8_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR8_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR8_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR8_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR8_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR8_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR8_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR8_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR8_IRQC_Enum;

/* =============================================  PORTB PORTB_PCR8 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR8_ISF                                                            */
  PORTB_PCR8_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR8_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR8_ISF_Enum;

/* ======================================================  PORTB_PCR9  ======================================================= */
/* ==============================================  PORTB PORTB_PCR9 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR9_PS                                                             */
  PORTB_PCR9_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR9_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR9_PS_Enum;

/* ==============================================  PORTB PORTB_PCR9 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTB_PCR9_PE                                                             */
  PORTB_PCR9_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR9_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR9_PE_Enum;

/* =============================================  PORTB PORTB_PCR9 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR9_MUX                                                            */
  PORTB_PCR9_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR9_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR9_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR9_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR9_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR9_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR9_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR9_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR9_MUX_Enum;

/* =============================================  PORTB PORTB_PCR9 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR9_LK                                                             */
  PORTB_PCR9_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR9_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR9_LK_Enum;

/* ============================================  PORTB PORTB_PCR9 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR9_IRQC                                                           */
  PORTB_PCR9_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR9_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR9_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR9_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR9_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR9_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR9_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR9_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR9_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR9_IRQC_Enum;

/* =============================================  PORTB PORTB_PCR9 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR9_ISF                                                            */
  PORTB_PCR9_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR9_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR9_ISF_Enum;

/* ======================================================  PORTB_PCR10  ====================================================== */
/* ==============================================  PORTB PORTB_PCR10 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR10_PS                                                            */
  PORTB_PCR10_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR10_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR10_PS_Enum;

/* ==============================================  PORTB PORTB_PCR10 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR10_PE                                                            */
  PORTB_PCR10_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR10_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR10_PE_Enum;

/* =============================================  PORTB PORTB_PCR10 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR10_MUX                                                           */
  PORTB_PCR10_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR10_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR10_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR10_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR10_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR10_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR10_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR10_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR10_MUX_Enum;

/* =============================================  PORTB PORTB_PCR10 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR10_LK                                                            */
  PORTB_PCR10_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR10_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR10_LK_Enum;

/* ============================================  PORTB PORTB_PCR10 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR10_IRQC                                                          */
  PORTB_PCR10_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR10_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR10_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR10_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR10_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR10_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR10_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR10_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR10_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR10_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR10 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR10_ISF                                                           */
  PORTB_PCR10_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR10_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR10_ISF_Enum;

/* ======================================================  PORTB_PCR11  ====================================================== */
/* ==============================================  PORTB PORTB_PCR11 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR11_PS                                                            */
  PORTB_PCR11_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR11_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR11_PS_Enum;

/* ==============================================  PORTB PORTB_PCR11 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR11_PE                                                            */
  PORTB_PCR11_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR11_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR11_PE_Enum;

/* =============================================  PORTB PORTB_PCR11 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR11_MUX                                                           */
  PORTB_PCR11_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR11_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR11_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR11_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR11_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR11_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR11_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR11_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR11_MUX_Enum;

/* =============================================  PORTB PORTB_PCR11 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR11_LK                                                            */
  PORTB_PCR11_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR11_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR11_LK_Enum;

/* ============================================  PORTB PORTB_PCR11 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR11_IRQC                                                          */
  PORTB_PCR11_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR11_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR11_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR11_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR11_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR11_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR11_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR11_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR11_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR11_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR11 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR11_ISF                                                           */
  PORTB_PCR11_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR11_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR11_ISF_Enum;

/* ======================================================  PORTB_PCR12  ====================================================== */
/* ==============================================  PORTB PORTB_PCR12 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR12_PS                                                            */
  PORTB_PCR12_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR12_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR12_PS_Enum;

/* ==============================================  PORTB PORTB_PCR12 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR12_PE                                                            */
  PORTB_PCR12_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR12_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR12_PE_Enum;

/* =============================================  PORTB PORTB_PCR12 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR12_MUX                                                           */
  PORTB_PCR12_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR12_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR12_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR12_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR12_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR12_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR12_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR12_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR12_MUX_Enum;

/* =============================================  PORTB PORTB_PCR12 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR12_LK                                                            */
  PORTB_PCR12_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR12_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR12_LK_Enum;

/* ============================================  PORTB PORTB_PCR12 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR12_IRQC                                                          */
  PORTB_PCR12_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR12_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR12_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR12_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR12_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR12_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR12_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR12_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR12_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR12_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR12 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR12_ISF                                                           */
  PORTB_PCR12_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR12_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR12_ISF_Enum;

/* ======================================================  PORTB_PCR13  ====================================================== */
/* ==============================================  PORTB PORTB_PCR13 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR13_PS                                                            */
  PORTB_PCR13_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR13_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR13_PS_Enum;

/* ==============================================  PORTB PORTB_PCR13 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR13_PE                                                            */
  PORTB_PCR13_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR13_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR13_PE_Enum;

/* =============================================  PORTB PORTB_PCR13 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR13_MUX                                                           */
  PORTB_PCR13_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR13_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR13_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR13_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR13_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR13_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR13_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR13_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR13_MUX_Enum;

/* =============================================  PORTB PORTB_PCR13 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR13_LK                                                            */
  PORTB_PCR13_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR13_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR13_LK_Enum;

/* ============================================  PORTB PORTB_PCR13 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR13_IRQC                                                          */
  PORTB_PCR13_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR13_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR13_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR13_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR13_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR13_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR13_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR13_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR13_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR13_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR13 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR13_ISF                                                           */
  PORTB_PCR13_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR13_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR13_ISF_Enum;

/* ======================================================  PORTB_PCR14  ====================================================== */
/* ==============================================  PORTB PORTB_PCR14 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR14_PS                                                            */
  PORTB_PCR14_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR14_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR14_PS_Enum;

/* ==============================================  PORTB PORTB_PCR14 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR14_PE                                                            */
  PORTB_PCR14_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR14_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR14_PE_Enum;

/* =============================================  PORTB PORTB_PCR14 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR14_MUX                                                           */
  PORTB_PCR14_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR14_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR14_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR14_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR14_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR14_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR14_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR14_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR14_MUX_Enum;

/* =============================================  PORTB PORTB_PCR14 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR14_LK                                                            */
  PORTB_PCR14_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR14_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR14_LK_Enum;

/* ============================================  PORTB PORTB_PCR14 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR14_IRQC                                                          */
  PORTB_PCR14_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR14_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR14_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR14_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR14_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR14_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR14_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR14_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR14_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR14_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR14 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR14_ISF                                                           */
  PORTB_PCR14_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR14_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR14_ISF_Enum;

/* ======================================================  PORTB_PCR15  ====================================================== */
/* ==============================================  PORTB PORTB_PCR15 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR15_PS                                                            */
  PORTB_PCR15_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR15_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR15_PS_Enum;

/* ==============================================  PORTB PORTB_PCR15 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR15_PE                                                            */
  PORTB_PCR15_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR15_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR15_PE_Enum;

/* =============================================  PORTB PORTB_PCR15 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR15_MUX                                                           */
  PORTB_PCR15_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR15_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR15_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR15_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR15_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR15_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR15_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR15_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR15_MUX_Enum;

/* =============================================  PORTB PORTB_PCR15 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR15_LK                                                            */
  PORTB_PCR15_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR15_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR15_LK_Enum;

/* ============================================  PORTB PORTB_PCR15 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR15_IRQC                                                          */
  PORTB_PCR15_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR15_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR15_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR15_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR15_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR15_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR15_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR15_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR15_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR15_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR15 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR15_ISF                                                           */
  PORTB_PCR15_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR15_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR15_ISF_Enum;

/* ======================================================  PORTB_PCR16  ====================================================== */
/* ==============================================  PORTB PORTB_PCR16 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR16_PS                                                            */
  PORTB_PCR16_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR16_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR16_PS_Enum;

/* ==============================================  PORTB PORTB_PCR16 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR16_PE                                                            */
  PORTB_PCR16_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR16_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR16_PE_Enum;

/* =============================================  PORTB PORTB_PCR16 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR16_MUX                                                           */
  PORTB_PCR16_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR16_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR16_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR16_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR16_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR16_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR16_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR16_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR16_MUX_Enum;

/* =============================================  PORTB PORTB_PCR16 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR16_LK                                                            */
  PORTB_PCR16_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR16_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR16_LK_Enum;

/* ============================================  PORTB PORTB_PCR16 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR16_IRQC                                                          */
  PORTB_PCR16_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR16_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR16_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR16_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR16_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR16_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR16_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR16_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR16_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR16_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR16 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR16_ISF                                                           */
  PORTB_PCR16_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR16_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR16_ISF_Enum;

/* ======================================================  PORTB_PCR17  ====================================================== */
/* ==============================================  PORTB PORTB_PCR17 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR17_PS                                                            */
  PORTB_PCR17_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR17_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR17_PS_Enum;

/* ==============================================  PORTB PORTB_PCR17 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR17_PE                                                            */
  PORTB_PCR17_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR17_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR17_PE_Enum;

/* =============================================  PORTB PORTB_PCR17 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR17_MUX                                                           */
  PORTB_PCR17_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR17_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR17_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR17_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR17_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR17_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR17_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR17_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR17_MUX_Enum;

/* =============================================  PORTB PORTB_PCR17 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR17_LK                                                            */
  PORTB_PCR17_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR17_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR17_LK_Enum;

/* ============================================  PORTB PORTB_PCR17 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR17_IRQC                                                          */
  PORTB_PCR17_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR17_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR17_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR17_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR17_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR17_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR17_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR17_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR17_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR17_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR17 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR17_ISF                                                           */
  PORTB_PCR17_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR17_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR17_ISF_Enum;

/* ======================================================  PORTB_PCR18  ====================================================== */
/* ==============================================  PORTB PORTB_PCR18 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR18_PS                                                            */
  PORTB_PCR18_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR18_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR18_PS_Enum;

/* ==============================================  PORTB PORTB_PCR18 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR18_PE                                                            */
  PORTB_PCR18_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR18_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR18_PE_Enum;

/* =============================================  PORTB PORTB_PCR18 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR18_MUX                                                           */
  PORTB_PCR18_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR18_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR18_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR18_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR18_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR18_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR18_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR18_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR18_MUX_Enum;

/* =============================================  PORTB PORTB_PCR18 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR18_LK                                                            */
  PORTB_PCR18_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR18_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR18_LK_Enum;

/* ============================================  PORTB PORTB_PCR18 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR18_IRQC                                                          */
  PORTB_PCR18_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR18_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR18_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR18_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR18_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR18_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR18_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR18_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR18_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR18_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR18 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR18_ISF                                                           */
  PORTB_PCR18_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR18_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR18_ISF_Enum;

/* ======================================================  PORTB_PCR19  ====================================================== */
/* ==============================================  PORTB PORTB_PCR19 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR19_PS                                                            */
  PORTB_PCR19_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR19_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR19_PS_Enum;

/* ==============================================  PORTB PORTB_PCR19 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR19_PE                                                            */
  PORTB_PCR19_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR19_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR19_PE_Enum;

/* =============================================  PORTB PORTB_PCR19 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR19_MUX                                                           */
  PORTB_PCR19_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR19_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR19_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR19_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR19_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR19_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR19_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR19_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR19_MUX_Enum;

/* =============================================  PORTB PORTB_PCR19 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR19_LK                                                            */
  PORTB_PCR19_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR19_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR19_LK_Enum;

/* ============================================  PORTB PORTB_PCR19 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR19_IRQC                                                          */
  PORTB_PCR19_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR19_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR19_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR19_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR19_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR19_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR19_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR19_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR19_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR19_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR19 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR19_ISF                                                           */
  PORTB_PCR19_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR19_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR19_ISF_Enum;

/* ======================================================  PORTB_PCR20  ====================================================== */
/* ==============================================  PORTB PORTB_PCR20 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR20_PS                                                            */
  PORTB_PCR20_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR20_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR20_PS_Enum;

/* ==============================================  PORTB PORTB_PCR20 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR20_PE                                                            */
  PORTB_PCR20_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR20_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR20_PE_Enum;

/* =============================================  PORTB PORTB_PCR20 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR20_MUX                                                           */
  PORTB_PCR20_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR20_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR20_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR20_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR20_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR20_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR20_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR20_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR20_MUX_Enum;

/* =============================================  PORTB PORTB_PCR20 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR20_LK                                                            */
  PORTB_PCR20_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR20_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR20_LK_Enum;

/* ============================================  PORTB PORTB_PCR20 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR20_IRQC                                                          */
  PORTB_PCR20_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR20_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR20_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR20_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR20_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR20_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR20_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR20_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR20_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR20_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR20 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR20_ISF                                                           */
  PORTB_PCR20_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR20_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR20_ISF_Enum;

/* ======================================================  PORTB_PCR21  ====================================================== */
/* ==============================================  PORTB PORTB_PCR21 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR21_PS                                                            */
  PORTB_PCR21_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR21_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR21_PS_Enum;

/* ==============================================  PORTB PORTB_PCR21 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR21_PE                                                            */
  PORTB_PCR21_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR21_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR21_PE_Enum;

/* =============================================  PORTB PORTB_PCR21 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR21_MUX                                                           */
  PORTB_PCR21_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR21_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR21_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR21_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR21_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR21_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR21_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR21_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR21_MUX_Enum;

/* =============================================  PORTB PORTB_PCR21 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR21_LK                                                            */
  PORTB_PCR21_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR21_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR21_LK_Enum;

/* ============================================  PORTB PORTB_PCR21 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR21_IRQC                                                          */
  PORTB_PCR21_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR21_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR21_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR21_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR21_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR21_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR21_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR21_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR21_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR21_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR21 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR21_ISF                                                           */
  PORTB_PCR21_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR21_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR21_ISF_Enum;

/* ======================================================  PORTB_PCR22  ====================================================== */
/* ==============================================  PORTB PORTB_PCR22 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR22_PS                                                            */
  PORTB_PCR22_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR22_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR22_PS_Enum;

/* ==============================================  PORTB PORTB_PCR22 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR22_PE                                                            */
  PORTB_PCR22_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR22_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR22_PE_Enum;

/* =============================================  PORTB PORTB_PCR22 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR22_MUX                                                           */
  PORTB_PCR22_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR22_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR22_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR22_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR22_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR22_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR22_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR22_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR22_MUX_Enum;

/* =============================================  PORTB PORTB_PCR22 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR22_LK                                                            */
  PORTB_PCR22_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR22_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR22_LK_Enum;

/* ============================================  PORTB PORTB_PCR22 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR22_IRQC                                                          */
  PORTB_PCR22_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR22_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR22_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR22_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR22_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR22_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR22_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR22_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR22_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR22_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR22 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR22_ISF                                                           */
  PORTB_PCR22_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR22_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR22_ISF_Enum;

/* ======================================================  PORTB_PCR23  ====================================================== */
/* ==============================================  PORTB PORTB_PCR23 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR23_PS                                                            */
  PORTB_PCR23_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR23_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR23_PS_Enum;

/* ==============================================  PORTB PORTB_PCR23 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR23_PE                                                            */
  PORTB_PCR23_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR23_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR23_PE_Enum;

/* =============================================  PORTB PORTB_PCR23 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR23_MUX                                                           */
  PORTB_PCR23_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR23_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR23_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR23_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR23_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR23_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR23_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR23_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR23_MUX_Enum;

/* =============================================  PORTB PORTB_PCR23 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR23_LK                                                            */
  PORTB_PCR23_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR23_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR23_LK_Enum;

/* ============================================  PORTB PORTB_PCR23 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR23_IRQC                                                          */
  PORTB_PCR23_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR23_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR23_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR23_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR23_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR23_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR23_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR23_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR23_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR23_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR23 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR23_ISF                                                           */
  PORTB_PCR23_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR23_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR23_ISF_Enum;

/* ======================================================  PORTB_PCR24  ====================================================== */
/* ==============================================  PORTB PORTB_PCR24 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR24_PS                                                            */
  PORTB_PCR24_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR24_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR24_PS_Enum;

/* ==============================================  PORTB PORTB_PCR24 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR24_PE                                                            */
  PORTB_PCR24_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR24_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR24_PE_Enum;

/* =============================================  PORTB PORTB_PCR24 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR24_MUX                                                           */
  PORTB_PCR24_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR24_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR24_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR24_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR24_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR24_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR24_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR24_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR24_MUX_Enum;

/* =============================================  PORTB PORTB_PCR24 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR24_LK                                                            */
  PORTB_PCR24_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR24_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR24_LK_Enum;

/* ============================================  PORTB PORTB_PCR24 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR24_IRQC                                                          */
  PORTB_PCR24_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR24_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR24_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR24_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR24_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR24_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR24_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR24_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR24_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR24_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR24 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR24_ISF                                                           */
  PORTB_PCR24_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR24_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR24_ISF_Enum;

/* ======================================================  PORTB_PCR25  ====================================================== */
/* ==============================================  PORTB PORTB_PCR25 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR25_PS                                                            */
  PORTB_PCR25_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR25_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR25_PS_Enum;

/* ==============================================  PORTB PORTB_PCR25 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR25_PE                                                            */
  PORTB_PCR25_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR25_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR25_PE_Enum;

/* =============================================  PORTB PORTB_PCR25 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR25_MUX                                                           */
  PORTB_PCR25_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR25_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR25_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR25_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR25_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR25_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR25_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR25_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR25_MUX_Enum;

/* =============================================  PORTB PORTB_PCR25 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR25_LK                                                            */
  PORTB_PCR25_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR25_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR25_LK_Enum;

/* ============================================  PORTB PORTB_PCR25 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR25_IRQC                                                          */
  PORTB_PCR25_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR25_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR25_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR25_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR25_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR25_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR25_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR25_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR25_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR25_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR25 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR25_ISF                                                           */
  PORTB_PCR25_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR25_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR25_ISF_Enum;

/* ======================================================  PORTB_PCR26  ====================================================== */
/* ==============================================  PORTB PORTB_PCR26 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR26_PS                                                            */
  PORTB_PCR26_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR26_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR26_PS_Enum;

/* ==============================================  PORTB PORTB_PCR26 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR26_PE                                                            */
  PORTB_PCR26_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR26_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR26_PE_Enum;

/* =============================================  PORTB PORTB_PCR26 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR26_MUX                                                           */
  PORTB_PCR26_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR26_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR26_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR26_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR26_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR26_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR26_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR26_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR26_MUX_Enum;

/* =============================================  PORTB PORTB_PCR26 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR26_LK                                                            */
  PORTB_PCR26_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR26_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR26_LK_Enum;

/* ============================================  PORTB PORTB_PCR26 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR26_IRQC                                                          */
  PORTB_PCR26_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR26_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR26_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR26_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR26_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR26_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR26_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR26_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR26_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR26_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR26 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR26_ISF                                                           */
  PORTB_PCR26_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR26_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR26_ISF_Enum;

/* ======================================================  PORTB_PCR27  ====================================================== */
/* ==============================================  PORTB PORTB_PCR27 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR27_PS                                                            */
  PORTB_PCR27_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR27_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR27_PS_Enum;

/* ==============================================  PORTB PORTB_PCR27 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR27_PE                                                            */
  PORTB_PCR27_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR27_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR27_PE_Enum;

/* =============================================  PORTB PORTB_PCR27 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR27_MUX                                                           */
  PORTB_PCR27_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR27_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR27_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR27_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR27_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR27_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR27_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR27_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR27_MUX_Enum;

/* =============================================  PORTB PORTB_PCR27 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR27_LK                                                            */
  PORTB_PCR27_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR27_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR27_LK_Enum;

/* ============================================  PORTB PORTB_PCR27 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR27_IRQC                                                          */
  PORTB_PCR27_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR27_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR27_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR27_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR27_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR27_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR27_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR27_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR27_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR27_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR27 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR27_ISF                                                           */
  PORTB_PCR27_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR27_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR27_ISF_Enum;

/* ======================================================  PORTB_PCR28  ====================================================== */
/* ==============================================  PORTB PORTB_PCR28 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR28_PS                                                            */
  PORTB_PCR28_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR28_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR28_PS_Enum;

/* ==============================================  PORTB PORTB_PCR28 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR28_PE                                                            */
  PORTB_PCR28_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR28_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR28_PE_Enum;

/* =============================================  PORTB PORTB_PCR28 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR28_MUX                                                           */
  PORTB_PCR28_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR28_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR28_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR28_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR28_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR28_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR28_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR28_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR28_MUX_Enum;

/* =============================================  PORTB PORTB_PCR28 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR28_LK                                                            */
  PORTB_PCR28_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR28_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR28_LK_Enum;

/* ============================================  PORTB PORTB_PCR28 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR28_IRQC                                                          */
  PORTB_PCR28_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR28_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR28_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR28_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR28_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR28_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR28_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR28_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR28_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR28_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR28 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR28_ISF                                                           */
  PORTB_PCR28_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR28_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR28_ISF_Enum;

/* ======================================================  PORTB_PCR29  ====================================================== */
/* ==============================================  PORTB PORTB_PCR29 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR29_PS                                                            */
  PORTB_PCR29_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR29_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR29_PS_Enum;

/* ==============================================  PORTB PORTB_PCR29 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR29_PE                                                            */
  PORTB_PCR29_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR29_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR29_PE_Enum;

/* =============================================  PORTB PORTB_PCR29 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR29_MUX                                                           */
  PORTB_PCR29_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR29_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR29_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR29_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR29_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR29_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR29_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR29_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR29_MUX_Enum;

/* =============================================  PORTB PORTB_PCR29 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR29_LK                                                            */
  PORTB_PCR29_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR29_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR29_LK_Enum;

/* ============================================  PORTB PORTB_PCR29 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR29_IRQC                                                          */
  PORTB_PCR29_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR29_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR29_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR29_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR29_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR29_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR29_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR29_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR29_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR29_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR29 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR29_ISF                                                           */
  PORTB_PCR29_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR29_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR29_ISF_Enum;

/* ======================================================  PORTB_PCR30  ====================================================== */
/* ==============================================  PORTB PORTB_PCR30 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR30_PS                                                            */
  PORTB_PCR30_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR30_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR30_PS_Enum;

/* ==============================================  PORTB PORTB_PCR30 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR30_PE                                                            */
  PORTB_PCR30_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR30_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR30_PE_Enum;

/* =============================================  PORTB PORTB_PCR30 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR30_MUX                                                           */
  PORTB_PCR30_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR30_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR30_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR30_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR30_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR30_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR30_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR30_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR30_MUX_Enum;

/* =============================================  PORTB PORTB_PCR30 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR30_LK                                                            */
  PORTB_PCR30_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR30_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR30_LK_Enum;

/* ============================================  PORTB PORTB_PCR30 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR30_IRQC                                                          */
  PORTB_PCR30_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR30_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR30_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR30_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR30_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR30_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR30_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR30_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR30_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR30_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR30 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR30_ISF                                                           */
  PORTB_PCR30_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR30_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR30_ISF_Enum;

/* ======================================================  PORTB_PCR31  ====================================================== */
/* ==============================================  PORTB PORTB_PCR31 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR31_PS                                                            */
  PORTB_PCR31_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTB_PCR31_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTB_PCR31_PS_Enum;

/* ==============================================  PORTB PORTB_PCR31 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTB_PCR31_PE                                                            */
  PORTB_PCR31_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTB_PCR31_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTB_PCR31_PE_Enum;

/* =============================================  PORTB PORTB_PCR31 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR31_MUX                                                           */
  PORTB_PCR31_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTB_PCR31_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTB_PCR31_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTB_PCR31_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTB_PCR31_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTB_PCR31_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTB_PCR31_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTB_PCR31_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTB_PCR31_MUX_Enum;

/* =============================================  PORTB PORTB_PCR31 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR31_LK                                                            */
  PORTB_PCR31_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTB_PCR31_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTB_PCR31_LK_Enum;

/* ============================================  PORTB PORTB_PCR31 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTB_PCR31_IRQC                                                          */
  PORTB_PCR31_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTB_PCR31_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTB_PCR31_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTB_PCR31_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTB_PCR31_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTB_PCR31_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTB_PCR31_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTB_PCR31_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTB_PCR31_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTB_PCR31_IRQC_Enum;

/* ============================================  PORTB PORTB_PCR31 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTB_PCR31_ISF                                                           */
  PORTB_PCR31_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_PCR31_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_PCR31_ISF_Enum;

/* ======================================================  PORTB_GPCLR  ====================================================== */
/* ============================================  PORTB PORTB_GPCLR GPWE [16..31]  ============================================ */
typedef enum {                                  /*!< PORTB_GPCLR_GPWE                                                          */
  PORTB_GPCLR_GPWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTB_GPCLR_GPWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTB_GPCLR_GPWE_Enum;

/* ======================================================  PORTB_GPCHR  ====================================================== */
/* ============================================  PORTB PORTB_GPCHR GPWE [16..31]  ============================================ */
typedef enum {                                  /*!< PORTB_GPCHR_GPWE                                                          */
  PORTB_GPCHR_GPWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTB_GPCHR_GPWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTB_GPCHR_GPWE_Enum;

/* ======================================================  PORTB_GICLR  ====================================================== */
/* ============================================  PORTB PORTB_GICLR GIWE [0..15]  ============================================= */
typedef enum {                                  /*!< PORTB_GICLR_GIWE                                                          */
  PORTB_GICLR_GIWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTB_GICLR_GIWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTB_GICLR_GIWE_Enum;

/* ======================================================  PORTB_GICHR  ====================================================== */
/* ============================================  PORTB PORTB_GICHR GIWE [0..15]  ============================================= */
typedef enum {                                  /*!< PORTB_GICHR_GIWE                                                          */
  PORTB_GICHR_GIWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTB_GICHR_GIWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTB_GICHR_GIWE_Enum;

/* ======================================================  PORTB_ISFR  ======================================================= */
/* =============================================  PORTB PORTB_ISFR ISF [0..31]  ============================================== */
typedef enum {                                  /*!< PORTB_ISFR_ISF                                                            */
  PORTB_ISFR_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTB_ISFR_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTB_ISFR_ISF_Enum;

/* ======================================================  PORTB_DFER  ======================================================= */
/* =============================================  PORTB PORTB_DFER DFE [0..31]  ============================================== */
typedef enum {                                  /*!< PORTB_DFER_DFE                                                            */
  PORTB_DFER_DFE_0                     = 0,     /*!< 0 : Digital filter is disabled on the corresponding pin and
                                                     output of the digital filter is reset to zero.                            */
  PORTB_DFER_DFE_1                     = 1,     /*!< 1 : Digital filter is enabled on the corresponding pin, if the
                                                     pin is configured as a digital input.                                     */
} PORTB_DFER_DFE_Enum;

/* ======================================================  PORTB_DFCR  ======================================================= */
/* ==============================================  PORTB PORTB_DFCR CS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTB_DFCR_CS                                                             */
  PORTB_DFCR_CS_0                      = 0,     /*!< 0 : Digital filters are clocked by the bus clock.                         */
  PORTB_DFCR_CS_1                      = 1,     /*!< 1 : Digital filters are clocked by the LPO clock.                         */
} PORTB_DFCR_CS_Enum;

/* ======================================================  PORTB_DFWR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                           PORTC                                           ================ */
/* =========================================================================================================================== */

/* ======================================================  PORTC_PCR0  ======================================================= */
/* ==============================================  PORTC PORTC_PCR0 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR0_PS                                                             */
  PORTC_PCR0_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR0_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR0_PS_Enum;

/* ==============================================  PORTC PORTC_PCR0 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR0_PE                                                             */
  PORTC_PCR0_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR0_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR0_PE_Enum;

/* =============================================  PORTC PORTC_PCR0 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR0_MUX                                                            */
  PORTC_PCR0_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR0_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR0_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR0_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR0_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR0_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR0_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR0_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR0_MUX_Enum;

/* =============================================  PORTC PORTC_PCR0 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR0_LK                                                             */
  PORTC_PCR0_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR0_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR0_LK_Enum;

/* ============================================  PORTC PORTC_PCR0 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR0_IRQC                                                           */
  PORTC_PCR0_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR0_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR0_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR0_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR0_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR0_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR0_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR0_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR0_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR0_IRQC_Enum;

/* =============================================  PORTC PORTC_PCR0 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR0_ISF                                                            */
  PORTC_PCR0_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR0_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR0_ISF_Enum;

/* ======================================================  PORTC_PCR1  ======================================================= */
/* ==============================================  PORTC PORTC_PCR1 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR1_PS                                                             */
  PORTC_PCR1_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR1_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR1_PS_Enum;

/* ==============================================  PORTC PORTC_PCR1 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR1_PE                                                             */
  PORTC_PCR1_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR1_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR1_PE_Enum;

/* =============================================  PORTC PORTC_PCR1 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR1_MUX                                                            */
  PORTC_PCR1_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR1_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR1_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR1_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR1_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR1_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR1_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR1_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR1_MUX_Enum;

/* =============================================  PORTC PORTC_PCR1 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR1_LK                                                             */
  PORTC_PCR1_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR1_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR1_LK_Enum;

/* ============================================  PORTC PORTC_PCR1 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR1_IRQC                                                           */
  PORTC_PCR1_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR1_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR1_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR1_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR1_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR1_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR1_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR1_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR1_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR1_IRQC_Enum;

/* =============================================  PORTC PORTC_PCR1 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR1_ISF                                                            */
  PORTC_PCR1_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR1_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR1_ISF_Enum;

/* ======================================================  PORTC_PCR2  ======================================================= */
/* ==============================================  PORTC PORTC_PCR2 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR2_PS                                                             */
  PORTC_PCR2_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR2_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR2_PS_Enum;

/* ==============================================  PORTC PORTC_PCR2 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR2_PE                                                             */
  PORTC_PCR2_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR2_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR2_PE_Enum;

/* =============================================  PORTC PORTC_PCR2 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR2_MUX                                                            */
  PORTC_PCR2_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR2_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR2_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR2_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR2_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR2_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR2_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR2_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR2_MUX_Enum;

/* =============================================  PORTC PORTC_PCR2 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR2_LK                                                             */
  PORTC_PCR2_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR2_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR2_LK_Enum;

/* ============================================  PORTC PORTC_PCR2 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR2_IRQC                                                           */
  PORTC_PCR2_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR2_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR2_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR2_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR2_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR2_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR2_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR2_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR2_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR2_IRQC_Enum;

/* =============================================  PORTC PORTC_PCR2 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR2_ISF                                                            */
  PORTC_PCR2_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR2_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR2_ISF_Enum;

/* ======================================================  PORTC_PCR3  ======================================================= */
/* ==============================================  PORTC PORTC_PCR3 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR3_PS                                                             */
  PORTC_PCR3_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR3_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR3_PS_Enum;

/* ==============================================  PORTC PORTC_PCR3 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR3_PE                                                             */
  PORTC_PCR3_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR3_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR3_PE_Enum;

/* =============================================  PORTC PORTC_PCR3 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR3_MUX                                                            */
  PORTC_PCR3_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR3_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR3_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR3_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR3_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR3_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR3_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR3_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR3_MUX_Enum;

/* =============================================  PORTC PORTC_PCR3 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR3_LK                                                             */
  PORTC_PCR3_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR3_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR3_LK_Enum;

/* ============================================  PORTC PORTC_PCR3 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR3_IRQC                                                           */
  PORTC_PCR3_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR3_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR3_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR3_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR3_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR3_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR3_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR3_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR3_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR3_IRQC_Enum;

/* =============================================  PORTC PORTC_PCR3 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR3_ISF                                                            */
  PORTC_PCR3_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR3_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR3_ISF_Enum;

/* ======================================================  PORTC_PCR4  ======================================================= */
/* ==============================================  PORTC PORTC_PCR4 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR4_PS                                                             */
  PORTC_PCR4_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR4_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR4_PS_Enum;

/* ==============================================  PORTC PORTC_PCR4 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR4_PE                                                             */
  PORTC_PCR4_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR4_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR4_PE_Enum;

/* =============================================  PORTC PORTC_PCR4 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR4_MUX                                                            */
  PORTC_PCR4_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR4_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR4_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR4_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR4_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR4_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR4_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR4_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR4_MUX_Enum;

/* =============================================  PORTC PORTC_PCR4 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR4_LK                                                             */
  PORTC_PCR4_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR4_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR4_LK_Enum;

/* ============================================  PORTC PORTC_PCR4 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR4_IRQC                                                           */
  PORTC_PCR4_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR4_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR4_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR4_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR4_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR4_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR4_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR4_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR4_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR4_IRQC_Enum;

/* =============================================  PORTC PORTC_PCR4 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR4_ISF                                                            */
  PORTC_PCR4_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR4_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR4_ISF_Enum;

/* ======================================================  PORTC_PCR5  ======================================================= */
/* ==============================================  PORTC PORTC_PCR5 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR5_PS                                                             */
  PORTC_PCR5_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR5_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR5_PS_Enum;

/* ==============================================  PORTC PORTC_PCR5 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR5_PE                                                             */
  PORTC_PCR5_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR5_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR5_PE_Enum;

/* =============================================  PORTC PORTC_PCR5 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR5_MUX                                                            */
  PORTC_PCR5_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR5_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR5_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR5_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR5_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR5_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR5_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR5_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR5_MUX_Enum;

/* =============================================  PORTC PORTC_PCR5 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR5_LK                                                             */
  PORTC_PCR5_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR5_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR5_LK_Enum;

/* ============================================  PORTC PORTC_PCR5 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR5_IRQC                                                           */
  PORTC_PCR5_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR5_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR5_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR5_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR5_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR5_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR5_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR5_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR5_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR5_IRQC_Enum;

/* =============================================  PORTC PORTC_PCR5 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR5_ISF                                                            */
  PORTC_PCR5_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR5_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR5_ISF_Enum;

/* ======================================================  PORTC_PCR6  ======================================================= */
/* ==============================================  PORTC PORTC_PCR6 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR6_PS                                                             */
  PORTC_PCR6_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR6_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR6_PS_Enum;

/* ==============================================  PORTC PORTC_PCR6 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR6_PE                                                             */
  PORTC_PCR6_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR6_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR6_PE_Enum;

/* =============================================  PORTC PORTC_PCR6 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR6_MUX                                                            */
  PORTC_PCR6_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR6_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR6_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR6_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR6_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR6_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR6_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR6_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR6_MUX_Enum;

/* =============================================  PORTC PORTC_PCR6 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR6_LK                                                             */
  PORTC_PCR6_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR6_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR6_LK_Enum;

/* ============================================  PORTC PORTC_PCR6 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR6_IRQC                                                           */
  PORTC_PCR6_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR6_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR6_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR6_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR6_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR6_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR6_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR6_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR6_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR6_IRQC_Enum;

/* =============================================  PORTC PORTC_PCR6 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR6_ISF                                                            */
  PORTC_PCR6_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR6_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR6_ISF_Enum;

/* ======================================================  PORTC_PCR7  ======================================================= */
/* ==============================================  PORTC PORTC_PCR7 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR7_PS                                                             */
  PORTC_PCR7_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR7_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR7_PS_Enum;

/* ==============================================  PORTC PORTC_PCR7 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR7_PE                                                             */
  PORTC_PCR7_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR7_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR7_PE_Enum;

/* =============================================  PORTC PORTC_PCR7 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR7_MUX                                                            */
  PORTC_PCR7_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR7_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR7_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR7_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR7_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR7_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR7_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR7_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR7_MUX_Enum;

/* =============================================  PORTC PORTC_PCR7 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR7_LK                                                             */
  PORTC_PCR7_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR7_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR7_LK_Enum;

/* ============================================  PORTC PORTC_PCR7 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR7_IRQC                                                           */
  PORTC_PCR7_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR7_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR7_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR7_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR7_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR7_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR7_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR7_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR7_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR7_IRQC_Enum;

/* =============================================  PORTC PORTC_PCR7 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR7_ISF                                                            */
  PORTC_PCR7_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR7_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR7_ISF_Enum;

/* ======================================================  PORTC_PCR8  ======================================================= */
/* ==============================================  PORTC PORTC_PCR8 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR8_PS                                                             */
  PORTC_PCR8_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR8_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR8_PS_Enum;

/* ==============================================  PORTC PORTC_PCR8 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR8_PE                                                             */
  PORTC_PCR8_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR8_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR8_PE_Enum;

/* =============================================  PORTC PORTC_PCR8 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR8_MUX                                                            */
  PORTC_PCR8_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR8_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR8_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR8_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR8_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR8_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR8_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR8_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR8_MUX_Enum;

/* =============================================  PORTC PORTC_PCR8 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR8_LK                                                             */
  PORTC_PCR8_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR8_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR8_LK_Enum;

/* ============================================  PORTC PORTC_PCR8 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR8_IRQC                                                           */
  PORTC_PCR8_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR8_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR8_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR8_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR8_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR8_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR8_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR8_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR8_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR8_IRQC_Enum;

/* =============================================  PORTC PORTC_PCR8 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR8_ISF                                                            */
  PORTC_PCR8_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR8_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR8_ISF_Enum;

/* ======================================================  PORTC_PCR9  ======================================================= */
/* ==============================================  PORTC PORTC_PCR9 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR9_PS                                                             */
  PORTC_PCR9_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR9_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR9_PS_Enum;

/* ==============================================  PORTC PORTC_PCR9 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTC_PCR9_PE                                                             */
  PORTC_PCR9_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR9_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR9_PE_Enum;

/* =============================================  PORTC PORTC_PCR9 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR9_MUX                                                            */
  PORTC_PCR9_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR9_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR9_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR9_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR9_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR9_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR9_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR9_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR9_MUX_Enum;

/* =============================================  PORTC PORTC_PCR9 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR9_LK                                                             */
  PORTC_PCR9_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR9_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR9_LK_Enum;

/* ============================================  PORTC PORTC_PCR9 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR9_IRQC                                                           */
  PORTC_PCR9_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR9_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR9_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR9_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR9_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR9_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR9_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR9_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR9_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR9_IRQC_Enum;

/* =============================================  PORTC PORTC_PCR9 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR9_ISF                                                            */
  PORTC_PCR9_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR9_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR9_ISF_Enum;

/* ======================================================  PORTC_PCR10  ====================================================== */
/* ==============================================  PORTC PORTC_PCR10 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR10_PS                                                            */
  PORTC_PCR10_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR10_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR10_PS_Enum;

/* ==============================================  PORTC PORTC_PCR10 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR10_PE                                                            */
  PORTC_PCR10_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR10_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR10_PE_Enum;

/* =============================================  PORTC PORTC_PCR10 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR10_MUX                                                           */
  PORTC_PCR10_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR10_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR10_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR10_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR10_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR10_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR10_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR10_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR10_MUX_Enum;

/* =============================================  PORTC PORTC_PCR10 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR10_LK                                                            */
  PORTC_PCR10_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR10_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR10_LK_Enum;

/* ============================================  PORTC PORTC_PCR10 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR10_IRQC                                                          */
  PORTC_PCR10_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR10_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR10_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR10_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR10_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR10_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR10_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR10_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR10_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR10_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR10 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR10_ISF                                                           */
  PORTC_PCR10_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR10_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR10_ISF_Enum;

/* ======================================================  PORTC_PCR11  ====================================================== */
/* ==============================================  PORTC PORTC_PCR11 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR11_PS                                                            */
  PORTC_PCR11_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR11_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR11_PS_Enum;

/* ==============================================  PORTC PORTC_PCR11 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR11_PE                                                            */
  PORTC_PCR11_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR11_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR11_PE_Enum;

/* =============================================  PORTC PORTC_PCR11 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR11_MUX                                                           */
  PORTC_PCR11_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR11_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR11_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR11_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR11_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR11_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR11_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR11_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR11_MUX_Enum;

/* =============================================  PORTC PORTC_PCR11 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR11_LK                                                            */
  PORTC_PCR11_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR11_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR11_LK_Enum;

/* ============================================  PORTC PORTC_PCR11 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR11_IRQC                                                          */
  PORTC_PCR11_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR11_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR11_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR11_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR11_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR11_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR11_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR11_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR11_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR11_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR11 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR11_ISF                                                           */
  PORTC_PCR11_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR11_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR11_ISF_Enum;

/* ======================================================  PORTC_PCR12  ====================================================== */
/* ==============================================  PORTC PORTC_PCR12 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR12_PS                                                            */
  PORTC_PCR12_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR12_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR12_PS_Enum;

/* ==============================================  PORTC PORTC_PCR12 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR12_PE                                                            */
  PORTC_PCR12_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR12_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR12_PE_Enum;

/* =============================================  PORTC PORTC_PCR12 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR12_MUX                                                           */
  PORTC_PCR12_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR12_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR12_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR12_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR12_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR12_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR12_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR12_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR12_MUX_Enum;

/* =============================================  PORTC PORTC_PCR12 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR12_LK                                                            */
  PORTC_PCR12_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR12_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR12_LK_Enum;

/* ============================================  PORTC PORTC_PCR12 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR12_IRQC                                                          */
  PORTC_PCR12_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR12_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR12_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR12_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR12_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR12_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR12_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR12_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR12_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR12_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR12 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR12_ISF                                                           */
  PORTC_PCR12_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR12_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR12_ISF_Enum;

/* ======================================================  PORTC_PCR13  ====================================================== */
/* ==============================================  PORTC PORTC_PCR13 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR13_PS                                                            */
  PORTC_PCR13_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR13_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR13_PS_Enum;

/* ==============================================  PORTC PORTC_PCR13 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR13_PE                                                            */
  PORTC_PCR13_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR13_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR13_PE_Enum;

/* =============================================  PORTC PORTC_PCR13 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR13_MUX                                                           */
  PORTC_PCR13_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR13_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR13_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR13_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR13_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR13_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR13_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR13_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR13_MUX_Enum;

/* =============================================  PORTC PORTC_PCR13 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR13_LK                                                            */
  PORTC_PCR13_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR13_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR13_LK_Enum;

/* ============================================  PORTC PORTC_PCR13 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR13_IRQC                                                          */
  PORTC_PCR13_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR13_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR13_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR13_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR13_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR13_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR13_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR13_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR13_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR13_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR13 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR13_ISF                                                           */
  PORTC_PCR13_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR13_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR13_ISF_Enum;

/* ======================================================  PORTC_PCR14  ====================================================== */
/* ==============================================  PORTC PORTC_PCR14 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR14_PS                                                            */
  PORTC_PCR14_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR14_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR14_PS_Enum;

/* ==============================================  PORTC PORTC_PCR14 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR14_PE                                                            */
  PORTC_PCR14_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR14_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR14_PE_Enum;

/* =============================================  PORTC PORTC_PCR14 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR14_MUX                                                           */
  PORTC_PCR14_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR14_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR14_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR14_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR14_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR14_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR14_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR14_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR14_MUX_Enum;

/* =============================================  PORTC PORTC_PCR14 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR14_LK                                                            */
  PORTC_PCR14_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR14_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR14_LK_Enum;

/* ============================================  PORTC PORTC_PCR14 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR14_IRQC                                                          */
  PORTC_PCR14_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR14_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR14_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR14_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR14_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR14_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR14_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR14_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR14_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR14_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR14 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR14_ISF                                                           */
  PORTC_PCR14_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR14_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR14_ISF_Enum;

/* ======================================================  PORTC_PCR15  ====================================================== */
/* ==============================================  PORTC PORTC_PCR15 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR15_PS                                                            */
  PORTC_PCR15_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR15_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR15_PS_Enum;

/* ==============================================  PORTC PORTC_PCR15 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR15_PE                                                            */
  PORTC_PCR15_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR15_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR15_PE_Enum;

/* =============================================  PORTC PORTC_PCR15 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR15_MUX                                                           */
  PORTC_PCR15_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR15_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR15_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR15_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR15_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR15_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR15_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR15_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR15_MUX_Enum;

/* =============================================  PORTC PORTC_PCR15 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR15_LK                                                            */
  PORTC_PCR15_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR15_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR15_LK_Enum;

/* ============================================  PORTC PORTC_PCR15 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR15_IRQC                                                          */
  PORTC_PCR15_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR15_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR15_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR15_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR15_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR15_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR15_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR15_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR15_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR15_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR15 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR15_ISF                                                           */
  PORTC_PCR15_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR15_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR15_ISF_Enum;

/* ======================================================  PORTC_PCR16  ====================================================== */
/* ==============================================  PORTC PORTC_PCR16 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR16_PS                                                            */
  PORTC_PCR16_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR16_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR16_PS_Enum;

/* ==============================================  PORTC PORTC_PCR16 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR16_PE                                                            */
  PORTC_PCR16_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR16_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR16_PE_Enum;

/* =============================================  PORTC PORTC_PCR16 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR16_MUX                                                           */
  PORTC_PCR16_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR16_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR16_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR16_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR16_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR16_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR16_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR16_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR16_MUX_Enum;

/* =============================================  PORTC PORTC_PCR16 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR16_LK                                                            */
  PORTC_PCR16_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR16_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR16_LK_Enum;

/* ============================================  PORTC PORTC_PCR16 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR16_IRQC                                                          */
  PORTC_PCR16_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR16_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR16_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR16_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR16_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR16_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR16_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR16_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR16_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR16_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR16 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR16_ISF                                                           */
  PORTC_PCR16_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR16_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR16_ISF_Enum;

/* ======================================================  PORTC_PCR17  ====================================================== */
/* ==============================================  PORTC PORTC_PCR17 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR17_PS                                                            */
  PORTC_PCR17_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR17_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR17_PS_Enum;

/* ==============================================  PORTC PORTC_PCR17 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR17_PE                                                            */
  PORTC_PCR17_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR17_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR17_PE_Enum;

/* =============================================  PORTC PORTC_PCR17 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR17_MUX                                                           */
  PORTC_PCR17_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR17_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR17_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR17_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR17_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR17_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR17_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR17_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR17_MUX_Enum;

/* =============================================  PORTC PORTC_PCR17 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR17_LK                                                            */
  PORTC_PCR17_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR17_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR17_LK_Enum;

/* ============================================  PORTC PORTC_PCR17 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR17_IRQC                                                          */
  PORTC_PCR17_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR17_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR17_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR17_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR17_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR17_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR17_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR17_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR17_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR17_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR17 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR17_ISF                                                           */
  PORTC_PCR17_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR17_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR17_ISF_Enum;

/* ======================================================  PORTC_PCR18  ====================================================== */
/* ==============================================  PORTC PORTC_PCR18 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR18_PS                                                            */
  PORTC_PCR18_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR18_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR18_PS_Enum;

/* ==============================================  PORTC PORTC_PCR18 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR18_PE                                                            */
  PORTC_PCR18_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR18_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR18_PE_Enum;

/* =============================================  PORTC PORTC_PCR18 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR18_MUX                                                           */
  PORTC_PCR18_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR18_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR18_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR18_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR18_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR18_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR18_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR18_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR18_MUX_Enum;

/* =============================================  PORTC PORTC_PCR18 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR18_LK                                                            */
  PORTC_PCR18_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR18_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR18_LK_Enum;

/* ============================================  PORTC PORTC_PCR18 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR18_IRQC                                                          */
  PORTC_PCR18_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR18_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR18_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR18_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR18_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR18_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR18_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR18_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR18_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR18_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR18 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR18_ISF                                                           */
  PORTC_PCR18_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR18_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR18_ISF_Enum;

/* ======================================================  PORTC_PCR19  ====================================================== */
/* ==============================================  PORTC PORTC_PCR19 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR19_PS                                                            */
  PORTC_PCR19_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR19_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR19_PS_Enum;

/* ==============================================  PORTC PORTC_PCR19 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR19_PE                                                            */
  PORTC_PCR19_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR19_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR19_PE_Enum;

/* =============================================  PORTC PORTC_PCR19 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR19_MUX                                                           */
  PORTC_PCR19_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR19_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR19_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR19_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR19_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR19_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR19_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR19_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR19_MUX_Enum;

/* =============================================  PORTC PORTC_PCR19 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR19_LK                                                            */
  PORTC_PCR19_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR19_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR19_LK_Enum;

/* ============================================  PORTC PORTC_PCR19 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR19_IRQC                                                          */
  PORTC_PCR19_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR19_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR19_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR19_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR19_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR19_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR19_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR19_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR19_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR19_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR19 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR19_ISF                                                           */
  PORTC_PCR19_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR19_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR19_ISF_Enum;

/* ======================================================  PORTC_PCR20  ====================================================== */
/* ==============================================  PORTC PORTC_PCR20 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR20_PS                                                            */
  PORTC_PCR20_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR20_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR20_PS_Enum;

/* ==============================================  PORTC PORTC_PCR20 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR20_PE                                                            */
  PORTC_PCR20_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR20_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR20_PE_Enum;

/* =============================================  PORTC PORTC_PCR20 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR20_MUX                                                           */
  PORTC_PCR20_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR20_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR20_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR20_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR20_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR20_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR20_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR20_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR20_MUX_Enum;

/* =============================================  PORTC PORTC_PCR20 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR20_LK                                                            */
  PORTC_PCR20_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR20_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR20_LK_Enum;

/* ============================================  PORTC PORTC_PCR20 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR20_IRQC                                                          */
  PORTC_PCR20_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR20_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR20_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR20_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR20_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR20_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR20_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR20_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR20_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR20_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR20 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR20_ISF                                                           */
  PORTC_PCR20_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR20_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR20_ISF_Enum;

/* ======================================================  PORTC_PCR21  ====================================================== */
/* ==============================================  PORTC PORTC_PCR21 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR21_PS                                                            */
  PORTC_PCR21_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR21_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR21_PS_Enum;

/* ==============================================  PORTC PORTC_PCR21 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR21_PE                                                            */
  PORTC_PCR21_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR21_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR21_PE_Enum;

/* =============================================  PORTC PORTC_PCR21 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR21_MUX                                                           */
  PORTC_PCR21_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR21_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR21_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR21_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR21_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR21_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR21_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR21_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR21_MUX_Enum;

/* =============================================  PORTC PORTC_PCR21 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR21_LK                                                            */
  PORTC_PCR21_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR21_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR21_LK_Enum;

/* ============================================  PORTC PORTC_PCR21 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR21_IRQC                                                          */
  PORTC_PCR21_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR21_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR21_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR21_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR21_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR21_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR21_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR21_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR21_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR21_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR21 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR21_ISF                                                           */
  PORTC_PCR21_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR21_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR21_ISF_Enum;

/* ======================================================  PORTC_PCR22  ====================================================== */
/* ==============================================  PORTC PORTC_PCR22 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR22_PS                                                            */
  PORTC_PCR22_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR22_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR22_PS_Enum;

/* ==============================================  PORTC PORTC_PCR22 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR22_PE                                                            */
  PORTC_PCR22_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR22_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR22_PE_Enum;

/* =============================================  PORTC PORTC_PCR22 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR22_MUX                                                           */
  PORTC_PCR22_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR22_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR22_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR22_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR22_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR22_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR22_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR22_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR22_MUX_Enum;

/* =============================================  PORTC PORTC_PCR22 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR22_LK                                                            */
  PORTC_PCR22_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR22_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR22_LK_Enum;

/* ============================================  PORTC PORTC_PCR22 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR22_IRQC                                                          */
  PORTC_PCR22_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR22_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR22_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR22_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR22_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR22_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR22_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR22_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR22_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR22_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR22 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR22_ISF                                                           */
  PORTC_PCR22_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR22_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR22_ISF_Enum;

/* ======================================================  PORTC_PCR23  ====================================================== */
/* ==============================================  PORTC PORTC_PCR23 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR23_PS                                                            */
  PORTC_PCR23_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR23_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR23_PS_Enum;

/* ==============================================  PORTC PORTC_PCR23 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR23_PE                                                            */
  PORTC_PCR23_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR23_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR23_PE_Enum;

/* =============================================  PORTC PORTC_PCR23 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR23_MUX                                                           */
  PORTC_PCR23_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR23_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR23_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR23_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR23_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR23_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR23_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR23_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR23_MUX_Enum;

/* =============================================  PORTC PORTC_PCR23 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR23_LK                                                            */
  PORTC_PCR23_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR23_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR23_LK_Enum;

/* ============================================  PORTC PORTC_PCR23 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR23_IRQC                                                          */
  PORTC_PCR23_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR23_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR23_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR23_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR23_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR23_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR23_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR23_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR23_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR23_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR23 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR23_ISF                                                           */
  PORTC_PCR23_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR23_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR23_ISF_Enum;

/* ======================================================  PORTC_PCR24  ====================================================== */
/* ==============================================  PORTC PORTC_PCR24 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR24_PS                                                            */
  PORTC_PCR24_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR24_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR24_PS_Enum;

/* ==============================================  PORTC PORTC_PCR24 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR24_PE                                                            */
  PORTC_PCR24_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR24_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR24_PE_Enum;

/* =============================================  PORTC PORTC_PCR24 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR24_MUX                                                           */
  PORTC_PCR24_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR24_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR24_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR24_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR24_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR24_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR24_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR24_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR24_MUX_Enum;

/* =============================================  PORTC PORTC_PCR24 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR24_LK                                                            */
  PORTC_PCR24_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR24_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR24_LK_Enum;

/* ============================================  PORTC PORTC_PCR24 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR24_IRQC                                                          */
  PORTC_PCR24_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR24_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR24_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR24_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR24_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR24_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR24_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR24_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR24_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR24_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR24 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR24_ISF                                                           */
  PORTC_PCR24_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR24_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR24_ISF_Enum;

/* ======================================================  PORTC_PCR25  ====================================================== */
/* ==============================================  PORTC PORTC_PCR25 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR25_PS                                                            */
  PORTC_PCR25_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR25_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR25_PS_Enum;

/* ==============================================  PORTC PORTC_PCR25 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR25_PE                                                            */
  PORTC_PCR25_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR25_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR25_PE_Enum;

/* =============================================  PORTC PORTC_PCR25 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR25_MUX                                                           */
  PORTC_PCR25_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR25_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR25_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR25_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR25_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR25_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR25_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR25_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR25_MUX_Enum;

/* =============================================  PORTC PORTC_PCR25 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR25_LK                                                            */
  PORTC_PCR25_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR25_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR25_LK_Enum;

/* ============================================  PORTC PORTC_PCR25 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR25_IRQC                                                          */
  PORTC_PCR25_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR25_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR25_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR25_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR25_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR25_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR25_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR25_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR25_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR25_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR25 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR25_ISF                                                           */
  PORTC_PCR25_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR25_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR25_ISF_Enum;

/* ======================================================  PORTC_PCR26  ====================================================== */
/* ==============================================  PORTC PORTC_PCR26 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR26_PS                                                            */
  PORTC_PCR26_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR26_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR26_PS_Enum;

/* ==============================================  PORTC PORTC_PCR26 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR26_PE                                                            */
  PORTC_PCR26_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR26_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR26_PE_Enum;

/* =============================================  PORTC PORTC_PCR26 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR26_MUX                                                           */
  PORTC_PCR26_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR26_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR26_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR26_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR26_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR26_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR26_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR26_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR26_MUX_Enum;

/* =============================================  PORTC PORTC_PCR26 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR26_LK                                                            */
  PORTC_PCR26_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR26_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR26_LK_Enum;

/* ============================================  PORTC PORTC_PCR26 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR26_IRQC                                                          */
  PORTC_PCR26_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR26_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR26_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR26_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR26_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR26_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR26_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR26_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR26_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR26_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR26 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR26_ISF                                                           */
  PORTC_PCR26_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR26_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR26_ISF_Enum;

/* ======================================================  PORTC_PCR27  ====================================================== */
/* ==============================================  PORTC PORTC_PCR27 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR27_PS                                                            */
  PORTC_PCR27_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR27_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR27_PS_Enum;

/* ==============================================  PORTC PORTC_PCR27 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR27_PE                                                            */
  PORTC_PCR27_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR27_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR27_PE_Enum;

/* =============================================  PORTC PORTC_PCR27 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR27_MUX                                                           */
  PORTC_PCR27_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR27_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR27_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR27_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR27_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR27_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR27_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR27_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR27_MUX_Enum;

/* =============================================  PORTC PORTC_PCR27 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR27_LK                                                            */
  PORTC_PCR27_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR27_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR27_LK_Enum;

/* ============================================  PORTC PORTC_PCR27 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR27_IRQC                                                          */
  PORTC_PCR27_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR27_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR27_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR27_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR27_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR27_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR27_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR27_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR27_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR27_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR27 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR27_ISF                                                           */
  PORTC_PCR27_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR27_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR27_ISF_Enum;

/* ======================================================  PORTC_PCR28  ====================================================== */
/* ==============================================  PORTC PORTC_PCR28 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR28_PS                                                            */
  PORTC_PCR28_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR28_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR28_PS_Enum;

/* ==============================================  PORTC PORTC_PCR28 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR28_PE                                                            */
  PORTC_PCR28_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR28_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR28_PE_Enum;

/* =============================================  PORTC PORTC_PCR28 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR28_MUX                                                           */
  PORTC_PCR28_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR28_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR28_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR28_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR28_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR28_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR28_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR28_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR28_MUX_Enum;

/* =============================================  PORTC PORTC_PCR28 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR28_LK                                                            */
  PORTC_PCR28_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR28_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR28_LK_Enum;

/* ============================================  PORTC PORTC_PCR28 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR28_IRQC                                                          */
  PORTC_PCR28_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR28_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR28_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR28_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR28_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR28_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR28_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR28_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR28_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR28_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR28 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR28_ISF                                                           */
  PORTC_PCR28_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR28_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR28_ISF_Enum;

/* ======================================================  PORTC_PCR29  ====================================================== */
/* ==============================================  PORTC PORTC_PCR29 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR29_PS                                                            */
  PORTC_PCR29_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR29_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR29_PS_Enum;

/* ==============================================  PORTC PORTC_PCR29 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR29_PE                                                            */
  PORTC_PCR29_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR29_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR29_PE_Enum;

/* =============================================  PORTC PORTC_PCR29 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR29_MUX                                                           */
  PORTC_PCR29_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR29_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR29_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR29_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR29_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR29_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR29_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR29_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR29_MUX_Enum;

/* =============================================  PORTC PORTC_PCR29 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR29_LK                                                            */
  PORTC_PCR29_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR29_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR29_LK_Enum;

/* ============================================  PORTC PORTC_PCR29 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR29_IRQC                                                          */
  PORTC_PCR29_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR29_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR29_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR29_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR29_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR29_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR29_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR29_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR29_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR29_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR29 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR29_ISF                                                           */
  PORTC_PCR29_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR29_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR29_ISF_Enum;

/* ======================================================  PORTC_PCR30  ====================================================== */
/* ==============================================  PORTC PORTC_PCR30 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR30_PS                                                            */
  PORTC_PCR30_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR30_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR30_PS_Enum;

/* ==============================================  PORTC PORTC_PCR30 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR30_PE                                                            */
  PORTC_PCR30_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR30_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR30_PE_Enum;

/* =============================================  PORTC PORTC_PCR30 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR30_MUX                                                           */
  PORTC_PCR30_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR30_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR30_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR30_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR30_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR30_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR30_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR30_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR30_MUX_Enum;

/* =============================================  PORTC PORTC_PCR30 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR30_LK                                                            */
  PORTC_PCR30_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR30_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR30_LK_Enum;

/* ============================================  PORTC PORTC_PCR30 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR30_IRQC                                                          */
  PORTC_PCR30_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR30_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR30_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR30_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR30_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR30_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR30_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR30_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR30_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR30_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR30 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR30_ISF                                                           */
  PORTC_PCR30_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR30_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR30_ISF_Enum;

/* ======================================================  PORTC_PCR31  ====================================================== */
/* ==============================================  PORTC PORTC_PCR31 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR31_PS                                                            */
  PORTC_PCR31_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTC_PCR31_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTC_PCR31_PS_Enum;

/* ==============================================  PORTC PORTC_PCR31 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTC_PCR31_PE                                                            */
  PORTC_PCR31_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTC_PCR31_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTC_PCR31_PE_Enum;

/* =============================================  PORTC PORTC_PCR31 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR31_MUX                                                           */
  PORTC_PCR31_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTC_PCR31_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTC_PCR31_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTC_PCR31_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTC_PCR31_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTC_PCR31_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTC_PCR31_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTC_PCR31_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTC_PCR31_MUX_Enum;

/* =============================================  PORTC PORTC_PCR31 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR31_LK                                                            */
  PORTC_PCR31_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTC_PCR31_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTC_PCR31_LK_Enum;

/* ============================================  PORTC PORTC_PCR31 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTC_PCR31_IRQC                                                          */
  PORTC_PCR31_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTC_PCR31_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTC_PCR31_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTC_PCR31_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTC_PCR31_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTC_PCR31_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTC_PCR31_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTC_PCR31_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTC_PCR31_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTC_PCR31_IRQC_Enum;

/* ============================================  PORTC PORTC_PCR31 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTC_PCR31_ISF                                                           */
  PORTC_PCR31_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_PCR31_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_PCR31_ISF_Enum;

/* ======================================================  PORTC_GPCLR  ====================================================== */
/* ============================================  PORTC PORTC_GPCLR GPWE [16..31]  ============================================ */
typedef enum {                                  /*!< PORTC_GPCLR_GPWE                                                          */
  PORTC_GPCLR_GPWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTC_GPCLR_GPWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTC_GPCLR_GPWE_Enum;

/* ======================================================  PORTC_GPCHR  ====================================================== */
/* ============================================  PORTC PORTC_GPCHR GPWE [16..31]  ============================================ */
typedef enum {                                  /*!< PORTC_GPCHR_GPWE                                                          */
  PORTC_GPCHR_GPWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTC_GPCHR_GPWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTC_GPCHR_GPWE_Enum;

/* ======================================================  PORTC_GICLR  ====================================================== */
/* ============================================  PORTC PORTC_GICLR GIWE [0..15]  ============================================= */
typedef enum {                                  /*!< PORTC_GICLR_GIWE                                                          */
  PORTC_GICLR_GIWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTC_GICLR_GIWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTC_GICLR_GIWE_Enum;

/* ======================================================  PORTC_GICHR  ====================================================== */
/* ============================================  PORTC PORTC_GICHR GIWE [0..15]  ============================================= */
typedef enum {                                  /*!< PORTC_GICHR_GIWE                                                          */
  PORTC_GICHR_GIWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTC_GICHR_GIWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTC_GICHR_GIWE_Enum;

/* ======================================================  PORTC_ISFR  ======================================================= */
/* =============================================  PORTC PORTC_ISFR ISF [0..31]  ============================================== */
typedef enum {                                  /*!< PORTC_ISFR_ISF                                                            */
  PORTC_ISFR_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTC_ISFR_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTC_ISFR_ISF_Enum;

/* ======================================================  PORTC_DFER  ======================================================= */
/* =============================================  PORTC PORTC_DFER DFE [0..31]  ============================================== */
typedef enum {                                  /*!< PORTC_DFER_DFE                                                            */
  PORTC_DFER_DFE_0                     = 0,     /*!< 0 : Digital filter is disabled on the corresponding pin and
                                                     output of the digital filter is reset to zero.                            */
  PORTC_DFER_DFE_1                     = 1,     /*!< 1 : Digital filter is enabled on the corresponding pin, if the
                                                     pin is configured as a digital input.                                     */
} PORTC_DFER_DFE_Enum;

/* ======================================================  PORTC_DFCR  ======================================================= */
/* ==============================================  PORTC PORTC_DFCR CS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTC_DFCR_CS                                                             */
  PORTC_DFCR_CS_0                      = 0,     /*!< 0 : Digital filters are clocked by the bus clock.                         */
  PORTC_DFCR_CS_1                      = 1,     /*!< 1 : Digital filters are clocked by the LPO clock.                         */
} PORTC_DFCR_CS_Enum;

/* ======================================================  PORTC_DFWR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                           PORTD                                           ================ */
/* =========================================================================================================================== */

/* ======================================================  PORTD_PCR0  ======================================================= */
/* ==============================================  PORTD PORTD_PCR0 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR0_PS                                                             */
  PORTD_PCR0_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR0_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR0_PS_Enum;

/* ==============================================  PORTD PORTD_PCR0 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR0_PE                                                             */
  PORTD_PCR0_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR0_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR0_PE_Enum;

/* ==============================================  PORTD PORTD_PCR0 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR0_DSE                                                            */
  PORTD_PCR0_DSE_0                     = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTD_PCR0_DSE_1                     = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTD_PCR0_DSE_Enum;

/* =============================================  PORTD PORTD_PCR0 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR0_MUX                                                            */
  PORTD_PCR0_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR0_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR0_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR0_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR0_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR0_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR0_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR0_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR0_MUX_Enum;

/* =============================================  PORTD PORTD_PCR0 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR0_LK                                                             */
  PORTD_PCR0_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR0_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR0_LK_Enum;

/* ============================================  PORTD PORTD_PCR0 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR0_IRQC                                                           */
  PORTD_PCR0_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR0_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR0_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR0_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR0_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR0_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR0_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR0_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR0_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR0_IRQC_Enum;

/* =============================================  PORTD PORTD_PCR0 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR0_ISF                                                            */
  PORTD_PCR0_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR0_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR0_ISF_Enum;

/* ======================================================  PORTD_PCR1  ======================================================= */
/* ==============================================  PORTD PORTD_PCR1 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR1_PS                                                             */
  PORTD_PCR1_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR1_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR1_PS_Enum;

/* ==============================================  PORTD PORTD_PCR1 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR1_PE                                                             */
  PORTD_PCR1_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR1_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR1_PE_Enum;

/* ==============================================  PORTD PORTD_PCR1 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR1_DSE                                                            */
  PORTD_PCR1_DSE_0                     = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTD_PCR1_DSE_1                     = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTD_PCR1_DSE_Enum;

/* =============================================  PORTD PORTD_PCR1 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR1_MUX                                                            */
  PORTD_PCR1_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR1_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR1_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR1_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR1_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR1_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR1_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR1_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR1_MUX_Enum;

/* =============================================  PORTD PORTD_PCR1 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR1_LK                                                             */
  PORTD_PCR1_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR1_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR1_LK_Enum;

/* ============================================  PORTD PORTD_PCR1 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR1_IRQC                                                           */
  PORTD_PCR1_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR1_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR1_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR1_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR1_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR1_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR1_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR1_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR1_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR1_IRQC_Enum;

/* =============================================  PORTD PORTD_PCR1 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR1_ISF                                                            */
  PORTD_PCR1_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR1_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR1_ISF_Enum;

/* ======================================================  PORTD_PCR2  ======================================================= */
/* ==============================================  PORTD PORTD_PCR2 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR2_PS                                                             */
  PORTD_PCR2_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR2_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR2_PS_Enum;

/* ==============================================  PORTD PORTD_PCR2 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR2_PE                                                             */
  PORTD_PCR2_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR2_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR2_PE_Enum;

/* =============================================  PORTD PORTD_PCR2 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR2_MUX                                                            */
  PORTD_PCR2_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR2_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR2_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR2_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR2_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR2_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR2_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR2_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR2_MUX_Enum;

/* =============================================  PORTD PORTD_PCR2 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR2_LK                                                             */
  PORTD_PCR2_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR2_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR2_LK_Enum;

/* ============================================  PORTD PORTD_PCR2 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR2_IRQC                                                           */
  PORTD_PCR2_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR2_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR2_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR2_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR2_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR2_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR2_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR2_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR2_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR2_IRQC_Enum;

/* =============================================  PORTD PORTD_PCR2 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR2_ISF                                                            */
  PORTD_PCR2_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR2_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR2_ISF_Enum;

/* ======================================================  PORTD_PCR3  ======================================================= */
/* ==============================================  PORTD PORTD_PCR3 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR3_PS                                                             */
  PORTD_PCR3_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR3_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR3_PS_Enum;

/* ==============================================  PORTD PORTD_PCR3 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR3_PE                                                             */
  PORTD_PCR3_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR3_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR3_PE_Enum;

/* ==============================================  PORTD PORTD_PCR3 PFE [4..4]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR3_PFE                                                            */
  PORTD_PCR3_PFE_0                     = 0,     /*!< 0 : Passive input filter is disabled on the corresponding pin.            */
  PORTD_PCR3_PFE_1                     = 1,     /*!< 1 : Passive input filter is enabled on the corresponding pin,
                                                     if the pin is configured as a digital input. Refer to the
                                                     device data sheet for filter characteristics.                             */
} PORTD_PCR3_PFE_Enum;

/* =============================================  PORTD PORTD_PCR3 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR3_MUX                                                            */
  PORTD_PCR3_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR3_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR3_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR3_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR3_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR3_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR3_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR3_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR3_MUX_Enum;

/* =============================================  PORTD PORTD_PCR3 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR3_LK                                                             */
  PORTD_PCR3_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR3_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR3_LK_Enum;

/* ============================================  PORTD PORTD_PCR3 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR3_IRQC                                                           */
  PORTD_PCR3_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR3_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR3_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR3_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR3_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR3_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR3_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR3_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR3_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR3_IRQC_Enum;

/* =============================================  PORTD PORTD_PCR3 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR3_ISF                                                            */
  PORTD_PCR3_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR3_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR3_ISF_Enum;

/* ======================================================  PORTD_PCR4  ======================================================= */
/* ==============================================  PORTD PORTD_PCR4 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR4_PS                                                             */
  PORTD_PCR4_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR4_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR4_PS_Enum;

/* ==============================================  PORTD PORTD_PCR4 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR4_PE                                                             */
  PORTD_PCR4_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR4_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR4_PE_Enum;

/* =============================================  PORTD PORTD_PCR4 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR4_MUX                                                            */
  PORTD_PCR4_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR4_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR4_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR4_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR4_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR4_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR4_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR4_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR4_MUX_Enum;

/* =============================================  PORTD PORTD_PCR4 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR4_LK                                                             */
  PORTD_PCR4_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR4_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR4_LK_Enum;

/* ============================================  PORTD PORTD_PCR4 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR4_IRQC                                                           */
  PORTD_PCR4_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR4_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR4_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR4_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR4_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR4_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR4_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR4_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR4_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR4_IRQC_Enum;

/* =============================================  PORTD PORTD_PCR4 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR4_ISF                                                            */
  PORTD_PCR4_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR4_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR4_ISF_Enum;

/* ======================================================  PORTD_PCR5  ======================================================= */
/* ==============================================  PORTD PORTD_PCR5 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR5_PS                                                             */
  PORTD_PCR5_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR5_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR5_PS_Enum;

/* ==============================================  PORTD PORTD_PCR5 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR5_PE                                                             */
  PORTD_PCR5_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR5_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR5_PE_Enum;

/* =============================================  PORTD PORTD_PCR5 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR5_MUX                                                            */
  PORTD_PCR5_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR5_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR5_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR5_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR5_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR5_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR5_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR5_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR5_MUX_Enum;

/* =============================================  PORTD PORTD_PCR5 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR5_LK                                                             */
  PORTD_PCR5_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR5_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR5_LK_Enum;

/* ============================================  PORTD PORTD_PCR5 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR5_IRQC                                                           */
  PORTD_PCR5_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR5_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR5_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR5_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR5_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR5_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR5_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR5_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR5_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR5_IRQC_Enum;

/* =============================================  PORTD PORTD_PCR5 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR5_ISF                                                            */
  PORTD_PCR5_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR5_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR5_ISF_Enum;

/* ======================================================  PORTD_PCR6  ======================================================= */
/* ==============================================  PORTD PORTD_PCR6 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR6_PS                                                             */
  PORTD_PCR6_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR6_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR6_PS_Enum;

/* ==============================================  PORTD PORTD_PCR6 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR6_PE                                                             */
  PORTD_PCR6_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR6_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR6_PE_Enum;

/* =============================================  PORTD PORTD_PCR6 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR6_MUX                                                            */
  PORTD_PCR6_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR6_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR6_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR6_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR6_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR6_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR6_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR6_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR6_MUX_Enum;

/* =============================================  PORTD PORTD_PCR6 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR6_LK                                                             */
  PORTD_PCR6_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR6_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR6_LK_Enum;

/* ============================================  PORTD PORTD_PCR6 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR6_IRQC                                                           */
  PORTD_PCR6_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR6_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR6_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR6_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR6_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR6_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR6_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR6_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR6_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR6_IRQC_Enum;

/* =============================================  PORTD PORTD_PCR6 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR6_ISF                                                            */
  PORTD_PCR6_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR6_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR6_ISF_Enum;

/* ======================================================  PORTD_PCR7  ======================================================= */
/* ==============================================  PORTD PORTD_PCR7 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR7_PS                                                             */
  PORTD_PCR7_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR7_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR7_PS_Enum;

/* ==============================================  PORTD PORTD_PCR7 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR7_PE                                                             */
  PORTD_PCR7_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR7_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR7_PE_Enum;

/* =============================================  PORTD PORTD_PCR7 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR7_MUX                                                            */
  PORTD_PCR7_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR7_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR7_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR7_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR7_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR7_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR7_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR7_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR7_MUX_Enum;

/* =============================================  PORTD PORTD_PCR7 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR7_LK                                                             */
  PORTD_PCR7_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR7_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR7_LK_Enum;

/* ============================================  PORTD PORTD_PCR7 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR7_IRQC                                                           */
  PORTD_PCR7_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR7_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR7_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR7_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR7_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR7_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR7_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR7_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR7_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR7_IRQC_Enum;

/* =============================================  PORTD PORTD_PCR7 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR7_ISF                                                            */
  PORTD_PCR7_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR7_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR7_ISF_Enum;

/* ======================================================  PORTD_PCR8  ======================================================= */
/* ==============================================  PORTD PORTD_PCR8 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR8_PS                                                             */
  PORTD_PCR8_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR8_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR8_PS_Enum;

/* ==============================================  PORTD PORTD_PCR8 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR8_PE                                                             */
  PORTD_PCR8_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR8_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR8_PE_Enum;

/* =============================================  PORTD PORTD_PCR8 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR8_MUX                                                            */
  PORTD_PCR8_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR8_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR8_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR8_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR8_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR8_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR8_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR8_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR8_MUX_Enum;

/* =============================================  PORTD PORTD_PCR8 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR8_LK                                                             */
  PORTD_PCR8_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR8_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR8_LK_Enum;

/* ============================================  PORTD PORTD_PCR8 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR8_IRQC                                                           */
  PORTD_PCR8_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR8_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR8_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR8_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR8_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR8_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR8_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR8_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR8_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR8_IRQC_Enum;

/* =============================================  PORTD PORTD_PCR8 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR8_ISF                                                            */
  PORTD_PCR8_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR8_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR8_ISF_Enum;

/* ======================================================  PORTD_PCR9  ======================================================= */
/* ==============================================  PORTD PORTD_PCR9 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR9_PS                                                             */
  PORTD_PCR9_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR9_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR9_PS_Enum;

/* ==============================================  PORTD PORTD_PCR9 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTD_PCR9_PE                                                             */
  PORTD_PCR9_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR9_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR9_PE_Enum;

/* =============================================  PORTD PORTD_PCR9 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR9_MUX                                                            */
  PORTD_PCR9_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR9_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR9_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR9_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR9_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR9_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR9_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR9_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR9_MUX_Enum;

/* =============================================  PORTD PORTD_PCR9 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR9_LK                                                             */
  PORTD_PCR9_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR9_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR9_LK_Enum;

/* ============================================  PORTD PORTD_PCR9 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR9_IRQC                                                           */
  PORTD_PCR9_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR9_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR9_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR9_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR9_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR9_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR9_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR9_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR9_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR9_IRQC_Enum;

/* =============================================  PORTD PORTD_PCR9 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR9_ISF                                                            */
  PORTD_PCR9_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR9_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR9_ISF_Enum;

/* ======================================================  PORTD_PCR10  ====================================================== */
/* ==============================================  PORTD PORTD_PCR10 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR10_PS                                                            */
  PORTD_PCR10_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR10_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR10_PS_Enum;

/* ==============================================  PORTD PORTD_PCR10 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR10_PE                                                            */
  PORTD_PCR10_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR10_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR10_PE_Enum;

/* =============================================  PORTD PORTD_PCR10 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR10_MUX                                                           */
  PORTD_PCR10_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR10_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR10_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR10_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR10_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR10_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR10_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR10_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR10_MUX_Enum;

/* =============================================  PORTD PORTD_PCR10 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR10_LK                                                            */
  PORTD_PCR10_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR10_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR10_LK_Enum;

/* ============================================  PORTD PORTD_PCR10 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR10_IRQC                                                          */
  PORTD_PCR10_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR10_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR10_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR10_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR10_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR10_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR10_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR10_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR10_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR10_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR10 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR10_ISF                                                           */
  PORTD_PCR10_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR10_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR10_ISF_Enum;

/* ======================================================  PORTD_PCR11  ====================================================== */
/* ==============================================  PORTD PORTD_PCR11 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR11_PS                                                            */
  PORTD_PCR11_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR11_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR11_PS_Enum;

/* ==============================================  PORTD PORTD_PCR11 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR11_PE                                                            */
  PORTD_PCR11_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR11_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR11_PE_Enum;

/* =============================================  PORTD PORTD_PCR11 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR11_MUX                                                           */
  PORTD_PCR11_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR11_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR11_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR11_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR11_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR11_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR11_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR11_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR11_MUX_Enum;

/* =============================================  PORTD PORTD_PCR11 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR11_LK                                                            */
  PORTD_PCR11_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR11_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR11_LK_Enum;

/* ============================================  PORTD PORTD_PCR11 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR11_IRQC                                                          */
  PORTD_PCR11_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR11_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR11_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR11_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR11_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR11_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR11_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR11_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR11_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR11_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR11 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR11_ISF                                                           */
  PORTD_PCR11_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR11_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR11_ISF_Enum;

/* ======================================================  PORTD_PCR12  ====================================================== */
/* ==============================================  PORTD PORTD_PCR12 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR12_PS                                                            */
  PORTD_PCR12_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR12_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR12_PS_Enum;

/* ==============================================  PORTD PORTD_PCR12 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR12_PE                                                            */
  PORTD_PCR12_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR12_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR12_PE_Enum;

/* =============================================  PORTD PORTD_PCR12 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR12_MUX                                                           */
  PORTD_PCR12_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR12_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR12_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR12_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR12_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR12_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR12_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR12_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR12_MUX_Enum;

/* =============================================  PORTD PORTD_PCR12 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR12_LK                                                            */
  PORTD_PCR12_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR12_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR12_LK_Enum;

/* ============================================  PORTD PORTD_PCR12 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR12_IRQC                                                          */
  PORTD_PCR12_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR12_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR12_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR12_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR12_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR12_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR12_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR12_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR12_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR12_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR12 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR12_ISF                                                           */
  PORTD_PCR12_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR12_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR12_ISF_Enum;

/* ======================================================  PORTD_PCR13  ====================================================== */
/* ==============================================  PORTD PORTD_PCR13 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR13_PS                                                            */
  PORTD_PCR13_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR13_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR13_PS_Enum;

/* ==============================================  PORTD PORTD_PCR13 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR13_PE                                                            */
  PORTD_PCR13_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR13_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR13_PE_Enum;

/* =============================================  PORTD PORTD_PCR13 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR13_MUX                                                           */
  PORTD_PCR13_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR13_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR13_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR13_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR13_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR13_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR13_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR13_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR13_MUX_Enum;

/* =============================================  PORTD PORTD_PCR13 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR13_LK                                                            */
  PORTD_PCR13_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR13_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR13_LK_Enum;

/* ============================================  PORTD PORTD_PCR13 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR13_IRQC                                                          */
  PORTD_PCR13_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR13_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR13_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR13_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR13_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR13_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR13_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR13_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR13_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR13_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR13 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR13_ISF                                                           */
  PORTD_PCR13_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR13_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR13_ISF_Enum;

/* ======================================================  PORTD_PCR14  ====================================================== */
/* ==============================================  PORTD PORTD_PCR14 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR14_PS                                                            */
  PORTD_PCR14_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR14_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR14_PS_Enum;

/* ==============================================  PORTD PORTD_PCR14 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR14_PE                                                            */
  PORTD_PCR14_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR14_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR14_PE_Enum;

/* =============================================  PORTD PORTD_PCR14 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR14_MUX                                                           */
  PORTD_PCR14_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR14_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR14_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR14_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR14_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR14_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR14_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR14_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR14_MUX_Enum;

/* =============================================  PORTD PORTD_PCR14 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR14_LK                                                            */
  PORTD_PCR14_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR14_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR14_LK_Enum;

/* ============================================  PORTD PORTD_PCR14 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR14_IRQC                                                          */
  PORTD_PCR14_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR14_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR14_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR14_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR14_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR14_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR14_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR14_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR14_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR14_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR14 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR14_ISF                                                           */
  PORTD_PCR14_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR14_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR14_ISF_Enum;

/* ======================================================  PORTD_PCR15  ====================================================== */
/* ==============================================  PORTD PORTD_PCR15 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR15_PS                                                            */
  PORTD_PCR15_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR15_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR15_PS_Enum;

/* ==============================================  PORTD PORTD_PCR15 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR15_PE                                                            */
  PORTD_PCR15_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR15_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR15_PE_Enum;

/* =============================================  PORTD PORTD_PCR15 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR15_DSE                                                           */
  PORTD_PCR15_DSE_0                    = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTD_PCR15_DSE_1                    = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTD_PCR15_DSE_Enum;

/* =============================================  PORTD PORTD_PCR15 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR15_MUX                                                           */
  PORTD_PCR15_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR15_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR15_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR15_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR15_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR15_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR15_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR15_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR15_MUX_Enum;

/* =============================================  PORTD PORTD_PCR15 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR15_LK                                                            */
  PORTD_PCR15_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR15_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR15_LK_Enum;

/* ============================================  PORTD PORTD_PCR15 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR15_IRQC                                                          */
  PORTD_PCR15_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR15_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR15_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR15_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR15_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR15_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR15_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR15_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR15_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR15_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR15 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR15_ISF                                                           */
  PORTD_PCR15_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR15_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR15_ISF_Enum;

/* ======================================================  PORTD_PCR16  ====================================================== */
/* ==============================================  PORTD PORTD_PCR16 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR16_PS                                                            */
  PORTD_PCR16_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR16_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR16_PS_Enum;

/* ==============================================  PORTD PORTD_PCR16 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR16_PE                                                            */
  PORTD_PCR16_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR16_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR16_PE_Enum;

/* =============================================  PORTD PORTD_PCR16 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR16_DSE                                                           */
  PORTD_PCR16_DSE_0                    = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTD_PCR16_DSE_1                    = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTD_PCR16_DSE_Enum;

/* =============================================  PORTD PORTD_PCR16 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR16_MUX                                                           */
  PORTD_PCR16_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR16_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR16_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR16_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR16_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR16_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR16_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR16_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR16_MUX_Enum;

/* =============================================  PORTD PORTD_PCR16 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR16_LK                                                            */
  PORTD_PCR16_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR16_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR16_LK_Enum;

/* ============================================  PORTD PORTD_PCR16 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR16_IRQC                                                          */
  PORTD_PCR16_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR16_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR16_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR16_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR16_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR16_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR16_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR16_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR16_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR16_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR16 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR16_ISF                                                           */
  PORTD_PCR16_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR16_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR16_ISF_Enum;

/* ======================================================  PORTD_PCR17  ====================================================== */
/* ==============================================  PORTD PORTD_PCR17 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR17_PS                                                            */
  PORTD_PCR17_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR17_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR17_PS_Enum;

/* ==============================================  PORTD PORTD_PCR17 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR17_PE                                                            */
  PORTD_PCR17_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR17_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR17_PE_Enum;

/* =============================================  PORTD PORTD_PCR17 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR17_MUX                                                           */
  PORTD_PCR17_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR17_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR17_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR17_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR17_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR17_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR17_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR17_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR17_MUX_Enum;

/* =============================================  PORTD PORTD_PCR17 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR17_LK                                                            */
  PORTD_PCR17_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR17_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR17_LK_Enum;

/* ============================================  PORTD PORTD_PCR17 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR17_IRQC                                                          */
  PORTD_PCR17_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR17_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR17_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR17_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR17_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR17_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR17_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR17_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR17_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR17_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR17 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR17_ISF                                                           */
  PORTD_PCR17_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR17_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR17_ISF_Enum;

/* ======================================================  PORTD_PCR18  ====================================================== */
/* ==============================================  PORTD PORTD_PCR18 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR18_PS                                                            */
  PORTD_PCR18_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR18_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR18_PS_Enum;

/* ==============================================  PORTD PORTD_PCR18 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR18_PE                                                            */
  PORTD_PCR18_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR18_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR18_PE_Enum;

/* =============================================  PORTD PORTD_PCR18 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR18_MUX                                                           */
  PORTD_PCR18_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR18_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR18_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR18_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR18_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR18_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR18_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR18_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR18_MUX_Enum;

/* =============================================  PORTD PORTD_PCR18 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR18_LK                                                            */
  PORTD_PCR18_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR18_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR18_LK_Enum;

/* ============================================  PORTD PORTD_PCR18 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR18_IRQC                                                          */
  PORTD_PCR18_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR18_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR18_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR18_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR18_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR18_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR18_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR18_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR18_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR18_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR18 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR18_ISF                                                           */
  PORTD_PCR18_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR18_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR18_ISF_Enum;

/* ======================================================  PORTD_PCR19  ====================================================== */
/* ==============================================  PORTD PORTD_PCR19 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR19_PS                                                            */
  PORTD_PCR19_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR19_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR19_PS_Enum;

/* ==============================================  PORTD PORTD_PCR19 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR19_PE                                                            */
  PORTD_PCR19_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR19_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR19_PE_Enum;

/* =============================================  PORTD PORTD_PCR19 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR19_MUX                                                           */
  PORTD_PCR19_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR19_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR19_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR19_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR19_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR19_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR19_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR19_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR19_MUX_Enum;

/* =============================================  PORTD PORTD_PCR19 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR19_LK                                                            */
  PORTD_PCR19_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR19_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR19_LK_Enum;

/* ============================================  PORTD PORTD_PCR19 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR19_IRQC                                                          */
  PORTD_PCR19_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR19_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR19_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR19_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR19_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR19_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR19_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR19_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR19_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR19_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR19 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR19_ISF                                                           */
  PORTD_PCR19_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR19_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR19_ISF_Enum;

/* ======================================================  PORTD_PCR20  ====================================================== */
/* ==============================================  PORTD PORTD_PCR20 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR20_PS                                                            */
  PORTD_PCR20_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR20_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR20_PS_Enum;

/* ==============================================  PORTD PORTD_PCR20 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR20_PE                                                            */
  PORTD_PCR20_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR20_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR20_PE_Enum;

/* =============================================  PORTD PORTD_PCR20 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR20_MUX                                                           */
  PORTD_PCR20_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR20_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR20_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR20_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR20_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR20_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR20_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR20_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR20_MUX_Enum;

/* =============================================  PORTD PORTD_PCR20 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR20_LK                                                            */
  PORTD_PCR20_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR20_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR20_LK_Enum;

/* ============================================  PORTD PORTD_PCR20 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR20_IRQC                                                          */
  PORTD_PCR20_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR20_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR20_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR20_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR20_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR20_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR20_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR20_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR20_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR20_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR20 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR20_ISF                                                           */
  PORTD_PCR20_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR20_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR20_ISF_Enum;

/* ======================================================  PORTD_PCR21  ====================================================== */
/* ==============================================  PORTD PORTD_PCR21 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR21_PS                                                            */
  PORTD_PCR21_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR21_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR21_PS_Enum;

/* ==============================================  PORTD PORTD_PCR21 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR21_PE                                                            */
  PORTD_PCR21_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR21_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR21_PE_Enum;

/* =============================================  PORTD PORTD_PCR21 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR21_MUX                                                           */
  PORTD_PCR21_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR21_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR21_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR21_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR21_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR21_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR21_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR21_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR21_MUX_Enum;

/* =============================================  PORTD PORTD_PCR21 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR21_LK                                                            */
  PORTD_PCR21_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR21_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR21_LK_Enum;

/* ============================================  PORTD PORTD_PCR21 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR21_IRQC                                                          */
  PORTD_PCR21_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR21_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR21_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR21_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR21_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR21_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR21_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR21_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR21_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR21_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR21 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR21_ISF                                                           */
  PORTD_PCR21_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR21_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR21_ISF_Enum;

/* ======================================================  PORTD_PCR22  ====================================================== */
/* ==============================================  PORTD PORTD_PCR22 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR22_PS                                                            */
  PORTD_PCR22_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR22_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR22_PS_Enum;

/* ==============================================  PORTD PORTD_PCR22 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR22_PE                                                            */
  PORTD_PCR22_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR22_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR22_PE_Enum;

/* =============================================  PORTD PORTD_PCR22 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR22_MUX                                                           */
  PORTD_PCR22_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR22_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR22_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR22_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR22_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR22_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR22_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR22_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR22_MUX_Enum;

/* =============================================  PORTD PORTD_PCR22 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR22_LK                                                            */
  PORTD_PCR22_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR22_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR22_LK_Enum;

/* ============================================  PORTD PORTD_PCR22 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR22_IRQC                                                          */
  PORTD_PCR22_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR22_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR22_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR22_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR22_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR22_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR22_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR22_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR22_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR22_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR22 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR22_ISF                                                           */
  PORTD_PCR22_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR22_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR22_ISF_Enum;

/* ======================================================  PORTD_PCR23  ====================================================== */
/* ==============================================  PORTD PORTD_PCR23 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR23_PS                                                            */
  PORTD_PCR23_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR23_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR23_PS_Enum;

/* ==============================================  PORTD PORTD_PCR23 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR23_PE                                                            */
  PORTD_PCR23_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR23_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR23_PE_Enum;

/* =============================================  PORTD PORTD_PCR23 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR23_MUX                                                           */
  PORTD_PCR23_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR23_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR23_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR23_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR23_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR23_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR23_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR23_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR23_MUX_Enum;

/* =============================================  PORTD PORTD_PCR23 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR23_LK                                                            */
  PORTD_PCR23_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR23_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR23_LK_Enum;

/* ============================================  PORTD PORTD_PCR23 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR23_IRQC                                                          */
  PORTD_PCR23_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR23_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR23_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR23_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR23_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR23_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR23_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR23_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR23_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR23_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR23 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR23_ISF                                                           */
  PORTD_PCR23_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR23_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR23_ISF_Enum;

/* ======================================================  PORTD_PCR24  ====================================================== */
/* ==============================================  PORTD PORTD_PCR24 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR24_PS                                                            */
  PORTD_PCR24_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR24_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR24_PS_Enum;

/* ==============================================  PORTD PORTD_PCR24 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR24_PE                                                            */
  PORTD_PCR24_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR24_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR24_PE_Enum;

/* =============================================  PORTD PORTD_PCR24 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR24_MUX                                                           */
  PORTD_PCR24_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR24_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR24_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR24_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR24_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR24_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR24_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR24_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR24_MUX_Enum;

/* =============================================  PORTD PORTD_PCR24 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR24_LK                                                            */
  PORTD_PCR24_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR24_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR24_LK_Enum;

/* ============================================  PORTD PORTD_PCR24 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR24_IRQC                                                          */
  PORTD_PCR24_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR24_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR24_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR24_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR24_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR24_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR24_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR24_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR24_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR24_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR24 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR24_ISF                                                           */
  PORTD_PCR24_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR24_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR24_ISF_Enum;

/* ======================================================  PORTD_PCR25  ====================================================== */
/* ==============================================  PORTD PORTD_PCR25 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR25_PS                                                            */
  PORTD_PCR25_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR25_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR25_PS_Enum;

/* ==============================================  PORTD PORTD_PCR25 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR25_PE                                                            */
  PORTD_PCR25_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR25_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR25_PE_Enum;

/* =============================================  PORTD PORTD_PCR25 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR25_MUX                                                           */
  PORTD_PCR25_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR25_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR25_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR25_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR25_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR25_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR25_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR25_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR25_MUX_Enum;

/* =============================================  PORTD PORTD_PCR25 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR25_LK                                                            */
  PORTD_PCR25_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR25_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR25_LK_Enum;

/* ============================================  PORTD PORTD_PCR25 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR25_IRQC                                                          */
  PORTD_PCR25_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR25_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR25_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR25_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR25_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR25_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR25_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR25_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR25_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR25_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR25 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR25_ISF                                                           */
  PORTD_PCR25_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR25_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR25_ISF_Enum;

/* ======================================================  PORTD_PCR26  ====================================================== */
/* ==============================================  PORTD PORTD_PCR26 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR26_PS                                                            */
  PORTD_PCR26_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR26_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR26_PS_Enum;

/* ==============================================  PORTD PORTD_PCR26 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR26_PE                                                            */
  PORTD_PCR26_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR26_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR26_PE_Enum;

/* =============================================  PORTD PORTD_PCR26 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR26_MUX                                                           */
  PORTD_PCR26_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR26_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR26_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR26_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR26_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR26_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR26_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR26_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR26_MUX_Enum;

/* =============================================  PORTD PORTD_PCR26 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR26_LK                                                            */
  PORTD_PCR26_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR26_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR26_LK_Enum;

/* ============================================  PORTD PORTD_PCR26 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR26_IRQC                                                          */
  PORTD_PCR26_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR26_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR26_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR26_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR26_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR26_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR26_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR26_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR26_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR26_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR26 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR26_ISF                                                           */
  PORTD_PCR26_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR26_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR26_ISF_Enum;

/* ======================================================  PORTD_PCR27  ====================================================== */
/* ==============================================  PORTD PORTD_PCR27 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR27_PS                                                            */
  PORTD_PCR27_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR27_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR27_PS_Enum;

/* ==============================================  PORTD PORTD_PCR27 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR27_PE                                                            */
  PORTD_PCR27_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR27_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR27_PE_Enum;

/* =============================================  PORTD PORTD_PCR27 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR27_MUX                                                           */
  PORTD_PCR27_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR27_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR27_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR27_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR27_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR27_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR27_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR27_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR27_MUX_Enum;

/* =============================================  PORTD PORTD_PCR27 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR27_LK                                                            */
  PORTD_PCR27_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR27_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR27_LK_Enum;

/* ============================================  PORTD PORTD_PCR27 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR27_IRQC                                                          */
  PORTD_PCR27_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR27_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR27_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR27_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR27_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR27_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR27_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR27_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR27_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR27_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR27 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR27_ISF                                                           */
  PORTD_PCR27_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR27_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR27_ISF_Enum;

/* ======================================================  PORTD_PCR28  ====================================================== */
/* ==============================================  PORTD PORTD_PCR28 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR28_PS                                                            */
  PORTD_PCR28_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR28_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR28_PS_Enum;

/* ==============================================  PORTD PORTD_PCR28 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR28_PE                                                            */
  PORTD_PCR28_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR28_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR28_PE_Enum;

/* =============================================  PORTD PORTD_PCR28 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR28_MUX                                                           */
  PORTD_PCR28_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR28_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR28_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR28_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR28_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR28_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR28_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR28_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR28_MUX_Enum;

/* =============================================  PORTD PORTD_PCR28 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR28_LK                                                            */
  PORTD_PCR28_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR28_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR28_LK_Enum;

/* ============================================  PORTD PORTD_PCR28 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR28_IRQC                                                          */
  PORTD_PCR28_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR28_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR28_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR28_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR28_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR28_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR28_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR28_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR28_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR28_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR28 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR28_ISF                                                           */
  PORTD_PCR28_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR28_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR28_ISF_Enum;

/* ======================================================  PORTD_PCR29  ====================================================== */
/* ==============================================  PORTD PORTD_PCR29 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR29_PS                                                            */
  PORTD_PCR29_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR29_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR29_PS_Enum;

/* ==============================================  PORTD PORTD_PCR29 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR29_PE                                                            */
  PORTD_PCR29_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR29_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR29_PE_Enum;

/* =============================================  PORTD PORTD_PCR29 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR29_MUX                                                           */
  PORTD_PCR29_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR29_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR29_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR29_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR29_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR29_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR29_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR29_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR29_MUX_Enum;

/* =============================================  PORTD PORTD_PCR29 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR29_LK                                                            */
  PORTD_PCR29_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR29_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR29_LK_Enum;

/* ============================================  PORTD PORTD_PCR29 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR29_IRQC                                                          */
  PORTD_PCR29_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR29_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR29_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR29_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR29_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR29_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR29_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR29_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR29_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR29_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR29 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR29_ISF                                                           */
  PORTD_PCR29_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR29_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR29_ISF_Enum;

/* ======================================================  PORTD_PCR30  ====================================================== */
/* ==============================================  PORTD PORTD_PCR30 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR30_PS                                                            */
  PORTD_PCR30_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR30_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR30_PS_Enum;

/* ==============================================  PORTD PORTD_PCR30 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR30_PE                                                            */
  PORTD_PCR30_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR30_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR30_PE_Enum;

/* =============================================  PORTD PORTD_PCR30 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR30_MUX                                                           */
  PORTD_PCR30_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR30_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR30_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR30_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR30_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR30_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR30_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR30_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR30_MUX_Enum;

/* =============================================  PORTD PORTD_PCR30 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR30_LK                                                            */
  PORTD_PCR30_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR30_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR30_LK_Enum;

/* ============================================  PORTD PORTD_PCR30 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR30_IRQC                                                          */
  PORTD_PCR30_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR30_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR30_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR30_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR30_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR30_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR30_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR30_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR30_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR30_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR30 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR30_ISF                                                           */
  PORTD_PCR30_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR30_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR30_ISF_Enum;

/* ======================================================  PORTD_PCR31  ====================================================== */
/* ==============================================  PORTD PORTD_PCR31 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR31_PS                                                            */
  PORTD_PCR31_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTD_PCR31_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTD_PCR31_PS_Enum;

/* ==============================================  PORTD PORTD_PCR31 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTD_PCR31_PE                                                            */
  PORTD_PCR31_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTD_PCR31_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTD_PCR31_PE_Enum;

/* =============================================  PORTD PORTD_PCR31 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR31_MUX                                                           */
  PORTD_PCR31_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTD_PCR31_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTD_PCR31_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTD_PCR31_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTD_PCR31_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTD_PCR31_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTD_PCR31_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTD_PCR31_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTD_PCR31_MUX_Enum;

/* =============================================  PORTD PORTD_PCR31 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR31_LK                                                            */
  PORTD_PCR31_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTD_PCR31_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTD_PCR31_LK_Enum;

/* ============================================  PORTD PORTD_PCR31 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTD_PCR31_IRQC                                                          */
  PORTD_PCR31_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTD_PCR31_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTD_PCR31_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTD_PCR31_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTD_PCR31_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTD_PCR31_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTD_PCR31_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTD_PCR31_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTD_PCR31_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTD_PCR31_IRQC_Enum;

/* ============================================  PORTD PORTD_PCR31 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTD_PCR31_ISF                                                           */
  PORTD_PCR31_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_PCR31_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_PCR31_ISF_Enum;

/* ======================================================  PORTD_GPCLR  ====================================================== */
/* ============================================  PORTD PORTD_GPCLR GPWE [16..31]  ============================================ */
typedef enum {                                  /*!< PORTD_GPCLR_GPWE                                                          */
  PORTD_GPCLR_GPWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTD_GPCLR_GPWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTD_GPCLR_GPWE_Enum;

/* ======================================================  PORTD_GPCHR  ====================================================== */
/* ============================================  PORTD PORTD_GPCHR GPWE [16..31]  ============================================ */
typedef enum {                                  /*!< PORTD_GPCHR_GPWE                                                          */
  PORTD_GPCHR_GPWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTD_GPCHR_GPWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTD_GPCHR_GPWE_Enum;

/* ======================================================  PORTD_GICLR  ====================================================== */
/* ============================================  PORTD PORTD_GICLR GIWE [0..15]  ============================================= */
typedef enum {                                  /*!< PORTD_GICLR_GIWE                                                          */
  PORTD_GICLR_GIWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTD_GICLR_GIWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTD_GICLR_GIWE_Enum;

/* ======================================================  PORTD_GICHR  ====================================================== */
/* ============================================  PORTD PORTD_GICHR GIWE [0..15]  ============================================= */
typedef enum {                                  /*!< PORTD_GICHR_GIWE                                                          */
  PORTD_GICHR_GIWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTD_GICHR_GIWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTD_GICHR_GIWE_Enum;

/* ======================================================  PORTD_ISFR  ======================================================= */
/* =============================================  PORTD PORTD_ISFR ISF [0..31]  ============================================== */
typedef enum {                                  /*!< PORTD_ISFR_ISF                                                            */
  PORTD_ISFR_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTD_ISFR_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTD_ISFR_ISF_Enum;

/* ======================================================  PORTD_DFER  ======================================================= */
/* =============================================  PORTD PORTD_DFER DFE [0..31]  ============================================== */
typedef enum {                                  /*!< PORTD_DFER_DFE                                                            */
  PORTD_DFER_DFE_0                     = 0,     /*!< 0 : Digital filter is disabled on the corresponding pin and
                                                     output of the digital filter is reset to zero.                            */
  PORTD_DFER_DFE_1                     = 1,     /*!< 1 : Digital filter is enabled on the corresponding pin, if the
                                                     pin is configured as a digital input.                                     */
} PORTD_DFER_DFE_Enum;

/* ======================================================  PORTD_DFCR  ======================================================= */
/* ==============================================  PORTD PORTD_DFCR CS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTD_DFCR_CS                                                             */
  PORTD_DFCR_CS_0                      = 0,     /*!< 0 : Digital filters are clocked by the bus clock.                         */
  PORTD_DFCR_CS_1                      = 1,     /*!< 1 : Digital filters are clocked by the LPO clock.                         */
} PORTD_DFCR_CS_Enum;

/* ======================================================  PORTD_DFWR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                           PORTE                                           ================ */
/* =========================================================================================================================== */

/* ======================================================  PORTE_PCR0  ======================================================= */
/* ==============================================  PORTE PORTE_PCR0 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR0_PS                                                             */
  PORTE_PCR0_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR0_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR0_PS_Enum;

/* ==============================================  PORTE PORTE_PCR0 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR0_PE                                                             */
  PORTE_PCR0_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR0_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR0_PE_Enum;

/* ==============================================  PORTE PORTE_PCR0 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR0_DSE                                                            */
  PORTE_PCR0_DSE_0                     = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTE_PCR0_DSE_1                     = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTE_PCR0_DSE_Enum;

/* =============================================  PORTE PORTE_PCR0 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR0_MUX                                                            */
  PORTE_PCR0_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR0_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR0_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR0_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR0_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR0_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR0_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR0_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR0_MUX_Enum;

/* =============================================  PORTE PORTE_PCR0 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR0_LK                                                             */
  PORTE_PCR0_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR0_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR0_LK_Enum;

/* ============================================  PORTE PORTE_PCR0 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR0_IRQC                                                           */
  PORTE_PCR0_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR0_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR0_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR0_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR0_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR0_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR0_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR0_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR0_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR0_IRQC_Enum;

/* =============================================  PORTE PORTE_PCR0 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR0_ISF                                                            */
  PORTE_PCR0_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR0_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR0_ISF_Enum;

/* ======================================================  PORTE_PCR1  ======================================================= */
/* ==============================================  PORTE PORTE_PCR1 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR1_PS                                                             */
  PORTE_PCR1_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR1_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR1_PS_Enum;

/* ==============================================  PORTE PORTE_PCR1 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR1_PE                                                             */
  PORTE_PCR1_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR1_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR1_PE_Enum;

/* ==============================================  PORTE PORTE_PCR1 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR1_DSE                                                            */
  PORTE_PCR1_DSE_0                     = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTE_PCR1_DSE_1                     = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTE_PCR1_DSE_Enum;

/* =============================================  PORTE PORTE_PCR1 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR1_MUX                                                            */
  PORTE_PCR1_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR1_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR1_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR1_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR1_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR1_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR1_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR1_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR1_MUX_Enum;

/* =============================================  PORTE PORTE_PCR1 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR1_LK                                                             */
  PORTE_PCR1_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR1_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR1_LK_Enum;

/* ============================================  PORTE PORTE_PCR1 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR1_IRQC                                                           */
  PORTE_PCR1_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR1_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR1_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR1_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR1_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR1_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR1_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR1_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR1_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR1_IRQC_Enum;

/* =============================================  PORTE PORTE_PCR1 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR1_ISF                                                            */
  PORTE_PCR1_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR1_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR1_ISF_Enum;

/* ======================================================  PORTE_PCR2  ======================================================= */
/* ==============================================  PORTE PORTE_PCR2 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR2_PS                                                             */
  PORTE_PCR2_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR2_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR2_PS_Enum;

/* ==============================================  PORTE PORTE_PCR2 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR2_PE                                                             */
  PORTE_PCR2_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR2_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR2_PE_Enum;

/* =============================================  PORTE PORTE_PCR2 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR2_MUX                                                            */
  PORTE_PCR2_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR2_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR2_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR2_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR2_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR2_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR2_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR2_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR2_MUX_Enum;

/* =============================================  PORTE PORTE_PCR2 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR2_LK                                                             */
  PORTE_PCR2_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR2_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR2_LK_Enum;

/* ============================================  PORTE PORTE_PCR2 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR2_IRQC                                                           */
  PORTE_PCR2_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR2_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR2_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR2_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR2_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR2_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR2_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR2_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR2_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR2_IRQC_Enum;

/* =============================================  PORTE PORTE_PCR2 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR2_ISF                                                            */
  PORTE_PCR2_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR2_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR2_ISF_Enum;

/* ======================================================  PORTE_PCR3  ======================================================= */
/* ==============================================  PORTE PORTE_PCR3 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR3_PS                                                             */
  PORTE_PCR3_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR3_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR3_PS_Enum;

/* ==============================================  PORTE PORTE_PCR3 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR3_PE                                                             */
  PORTE_PCR3_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR3_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR3_PE_Enum;

/* =============================================  PORTE PORTE_PCR3 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR3_MUX                                                            */
  PORTE_PCR3_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR3_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR3_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR3_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR3_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR3_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR3_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR3_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR3_MUX_Enum;

/* =============================================  PORTE PORTE_PCR3 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR3_LK                                                             */
  PORTE_PCR3_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR3_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR3_LK_Enum;

/* ============================================  PORTE PORTE_PCR3 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR3_IRQC                                                           */
  PORTE_PCR3_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR3_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR3_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR3_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR3_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR3_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR3_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR3_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR3_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR3_IRQC_Enum;

/* =============================================  PORTE PORTE_PCR3 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR3_ISF                                                            */
  PORTE_PCR3_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR3_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR3_ISF_Enum;

/* ======================================================  PORTE_PCR4  ======================================================= */
/* ==============================================  PORTE PORTE_PCR4 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR4_PS                                                             */
  PORTE_PCR4_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR4_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR4_PS_Enum;

/* ==============================================  PORTE PORTE_PCR4 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR4_PE                                                             */
  PORTE_PCR4_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR4_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR4_PE_Enum;

/* ==============================================  PORTE PORTE_PCR4 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR4_DSE                                                            */
  PORTE_PCR4_DSE_0                     = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTE_PCR4_DSE_1                     = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTE_PCR4_DSE_Enum;

/* =============================================  PORTE PORTE_PCR4 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR4_MUX                                                            */
  PORTE_PCR4_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR4_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR4_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR4_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR4_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR4_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR4_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR4_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR4_MUX_Enum;

/* =============================================  PORTE PORTE_PCR4 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR4_LK                                                             */
  PORTE_PCR4_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR4_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR4_LK_Enum;

/* ============================================  PORTE PORTE_PCR4 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR4_IRQC                                                           */
  PORTE_PCR4_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR4_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR4_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR4_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR4_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR4_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR4_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR4_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR4_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR4_IRQC_Enum;

/* =============================================  PORTE PORTE_PCR4 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR4_ISF                                                            */
  PORTE_PCR4_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR4_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR4_ISF_Enum;

/* ======================================================  PORTE_PCR5  ======================================================= */
/* ==============================================  PORTE PORTE_PCR5 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR5_PS                                                             */
  PORTE_PCR5_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR5_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR5_PS_Enum;

/* ==============================================  PORTE PORTE_PCR5 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR5_PE                                                             */
  PORTE_PCR5_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR5_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR5_PE_Enum;

/* =============================================  PORTE PORTE_PCR5 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR5_MUX                                                            */
  PORTE_PCR5_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR5_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR5_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR5_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR5_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR5_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR5_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR5_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR5_MUX_Enum;

/* =============================================  PORTE PORTE_PCR5 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR5_LK                                                             */
  PORTE_PCR5_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR5_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR5_LK_Enum;

/* ============================================  PORTE PORTE_PCR5 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR5_IRQC                                                           */
  PORTE_PCR5_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR5_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR5_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR5_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR5_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR5_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR5_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR5_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR5_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR5_IRQC_Enum;

/* =============================================  PORTE PORTE_PCR5 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR5_ISF                                                            */
  PORTE_PCR5_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR5_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR5_ISF_Enum;

/* ======================================================  PORTE_PCR6  ======================================================= */
/* ==============================================  PORTE PORTE_PCR6 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR6_PS                                                             */
  PORTE_PCR6_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR6_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR6_PS_Enum;

/* ==============================================  PORTE PORTE_PCR6 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR6_PE                                                             */
  PORTE_PCR6_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR6_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR6_PE_Enum;

/* =============================================  PORTE PORTE_PCR6 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR6_MUX                                                            */
  PORTE_PCR6_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR6_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR6_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR6_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR6_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR6_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR6_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR6_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR6_MUX_Enum;

/* =============================================  PORTE PORTE_PCR6 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR6_LK                                                             */
  PORTE_PCR6_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR6_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR6_LK_Enum;

/* ============================================  PORTE PORTE_PCR6 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR6_IRQC                                                           */
  PORTE_PCR6_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR6_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR6_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR6_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR6_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR6_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR6_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR6_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR6_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR6_IRQC_Enum;

/* =============================================  PORTE PORTE_PCR6 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR6_ISF                                                            */
  PORTE_PCR6_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR6_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR6_ISF_Enum;

/* ======================================================  PORTE_PCR7  ======================================================= */
/* ==============================================  PORTE PORTE_PCR7 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR7_PS                                                             */
  PORTE_PCR7_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR7_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR7_PS_Enum;

/* ==============================================  PORTE PORTE_PCR7 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR7_PE                                                             */
  PORTE_PCR7_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR7_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR7_PE_Enum;

/* =============================================  PORTE PORTE_PCR7 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR7_MUX                                                            */
  PORTE_PCR7_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR7_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR7_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR7_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR7_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR7_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR7_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR7_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR7_MUX_Enum;

/* =============================================  PORTE PORTE_PCR7 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR7_LK                                                             */
  PORTE_PCR7_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR7_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR7_LK_Enum;

/* ============================================  PORTE PORTE_PCR7 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR7_IRQC                                                           */
  PORTE_PCR7_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR7_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR7_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR7_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR7_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR7_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR7_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR7_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR7_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR7_IRQC_Enum;

/* =============================================  PORTE PORTE_PCR7 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR7_ISF                                                            */
  PORTE_PCR7_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR7_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR7_ISF_Enum;

/* ======================================================  PORTE_PCR8  ======================================================= */
/* ==============================================  PORTE PORTE_PCR8 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR8_PS                                                             */
  PORTE_PCR8_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR8_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR8_PS_Enum;

/* ==============================================  PORTE PORTE_PCR8 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR8_PE                                                             */
  PORTE_PCR8_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR8_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR8_PE_Enum;

/* =============================================  PORTE PORTE_PCR8 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR8_MUX                                                            */
  PORTE_PCR8_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR8_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR8_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR8_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR8_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR8_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR8_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR8_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR8_MUX_Enum;

/* =============================================  PORTE PORTE_PCR8 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR8_LK                                                             */
  PORTE_PCR8_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR8_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR8_LK_Enum;

/* ============================================  PORTE PORTE_PCR8 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR8_IRQC                                                           */
  PORTE_PCR8_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR8_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR8_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR8_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR8_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR8_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR8_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR8_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR8_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR8_IRQC_Enum;

/* =============================================  PORTE PORTE_PCR8 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR8_ISF                                                            */
  PORTE_PCR8_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR8_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR8_ISF_Enum;

/* ======================================================  PORTE_PCR9  ======================================================= */
/* ==============================================  PORTE PORTE_PCR9 PS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR9_PS                                                             */
  PORTE_PCR9_PS_0                      = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR9_PS_1                      = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR9_PS_Enum;

/* ==============================================  PORTE PORTE_PCR9 PE [1..1]  =============================================== */
typedef enum {                                  /*!< PORTE_PCR9_PE                                                             */
  PORTE_PCR9_PE_0                      = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR9_PE_1                      = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR9_PE_Enum;

/* =============================================  PORTE PORTE_PCR9 MUX [8..10]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR9_MUX                                                            */
  PORTE_PCR9_MUX_000                   = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR9_MUX_001                   = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR9_MUX_010                   = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR9_MUX_011                   = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR9_MUX_100                   = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR9_MUX_101                   = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR9_MUX_110                   = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR9_MUX_111                   = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR9_MUX_Enum;

/* =============================================  PORTE PORTE_PCR9 LK [15..15]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR9_LK                                                             */
  PORTE_PCR9_LK_0                      = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR9_LK_1                      = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR9_LK_Enum;

/* ============================================  PORTE PORTE_PCR9 IRQC [16..19]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR9_IRQC                                                           */
  PORTE_PCR9_IRQC_0000                 = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR9_IRQC_0001                 = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR9_IRQC_0010                 = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR9_IRQC_0011                 = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR9_IRQC_1000                 = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR9_IRQC_1001                 = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR9_IRQC_1010                 = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR9_IRQC_1011                 = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR9_IRQC_1100                 = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR9_IRQC_Enum;

/* =============================================  PORTE PORTE_PCR9 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR9_ISF                                                            */
  PORTE_PCR9_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR9_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR9_ISF_Enum;

/* ======================================================  PORTE_PCR10  ====================================================== */
/* ==============================================  PORTE PORTE_PCR10 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR10_PS                                                            */
  PORTE_PCR10_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR10_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR10_PS_Enum;

/* ==============================================  PORTE PORTE_PCR10 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR10_PE                                                            */
  PORTE_PCR10_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR10_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR10_PE_Enum;

/* =============================================  PORTE PORTE_PCR10 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR10_MUX                                                           */
  PORTE_PCR10_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR10_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR10_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR10_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR10_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR10_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR10_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR10_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR10_MUX_Enum;

/* =============================================  PORTE PORTE_PCR10 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR10_LK                                                            */
  PORTE_PCR10_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR10_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR10_LK_Enum;

/* ============================================  PORTE PORTE_PCR10 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR10_IRQC                                                          */
  PORTE_PCR10_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR10_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR10_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR10_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR10_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR10_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR10_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR10_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR10_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR10_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR10 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR10_ISF                                                           */
  PORTE_PCR10_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR10_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR10_ISF_Enum;

/* ======================================================  PORTE_PCR11  ====================================================== */
/* ==============================================  PORTE PORTE_PCR11 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR11_PS                                                            */
  PORTE_PCR11_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR11_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR11_PS_Enum;

/* ==============================================  PORTE PORTE_PCR11 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR11_PE                                                            */
  PORTE_PCR11_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR11_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR11_PE_Enum;

/* =============================================  PORTE PORTE_PCR11 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR11_MUX                                                           */
  PORTE_PCR11_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR11_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR11_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR11_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR11_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR11_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR11_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR11_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR11_MUX_Enum;

/* =============================================  PORTE PORTE_PCR11 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR11_LK                                                            */
  PORTE_PCR11_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR11_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR11_LK_Enum;

/* ============================================  PORTE PORTE_PCR11 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR11_IRQC                                                          */
  PORTE_PCR11_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR11_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR11_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR11_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR11_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR11_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR11_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR11_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR11_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR11_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR11 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR11_ISF                                                           */
  PORTE_PCR11_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR11_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR11_ISF_Enum;

/* ======================================================  PORTE_PCR12  ====================================================== */
/* ==============================================  PORTE PORTE_PCR12 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR12_PS                                                            */
  PORTE_PCR12_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR12_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR12_PS_Enum;

/* ==============================================  PORTE PORTE_PCR12 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR12_PE                                                            */
  PORTE_PCR12_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR12_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR12_PE_Enum;

/* =============================================  PORTE PORTE_PCR12 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR12_MUX                                                           */
  PORTE_PCR12_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR12_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR12_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR12_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR12_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR12_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR12_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR12_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR12_MUX_Enum;

/* =============================================  PORTE PORTE_PCR12 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR12_LK                                                            */
  PORTE_PCR12_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR12_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR12_LK_Enum;

/* ============================================  PORTE PORTE_PCR12 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR12_IRQC                                                          */
  PORTE_PCR12_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR12_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR12_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR12_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR12_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR12_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR12_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR12_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR12_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR12_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR12 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR12_ISF                                                           */
  PORTE_PCR12_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR12_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR12_ISF_Enum;

/* ======================================================  PORTE_PCR13  ====================================================== */
/* ==============================================  PORTE PORTE_PCR13 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR13_PS                                                            */
  PORTE_PCR13_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR13_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR13_PS_Enum;

/* ==============================================  PORTE PORTE_PCR13 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR13_PE                                                            */
  PORTE_PCR13_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR13_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR13_PE_Enum;

/* =============================================  PORTE PORTE_PCR13 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR13_MUX                                                           */
  PORTE_PCR13_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR13_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR13_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR13_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR13_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR13_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR13_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR13_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR13_MUX_Enum;

/* =============================================  PORTE PORTE_PCR13 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR13_LK                                                            */
  PORTE_PCR13_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR13_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR13_LK_Enum;

/* ============================================  PORTE PORTE_PCR13 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR13_IRQC                                                          */
  PORTE_PCR13_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR13_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR13_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR13_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR13_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR13_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR13_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR13_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR13_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR13_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR13 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR13_ISF                                                           */
  PORTE_PCR13_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR13_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR13_ISF_Enum;

/* ======================================================  PORTE_PCR14  ====================================================== */
/* ==============================================  PORTE PORTE_PCR14 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR14_PS                                                            */
  PORTE_PCR14_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR14_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR14_PS_Enum;

/* ==============================================  PORTE PORTE_PCR14 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR14_PE                                                            */
  PORTE_PCR14_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR14_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR14_PE_Enum;

/* =============================================  PORTE PORTE_PCR14 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR14_MUX                                                           */
  PORTE_PCR14_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR14_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR14_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR14_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR14_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR14_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR14_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR14_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR14_MUX_Enum;

/* =============================================  PORTE PORTE_PCR14 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR14_LK                                                            */
  PORTE_PCR14_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR14_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR14_LK_Enum;

/* ============================================  PORTE PORTE_PCR14 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR14_IRQC                                                          */
  PORTE_PCR14_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR14_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR14_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR14_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR14_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR14_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR14_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR14_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR14_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR14_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR14 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR14_ISF                                                           */
  PORTE_PCR14_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR14_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR14_ISF_Enum;

/* ======================================================  PORTE_PCR15  ====================================================== */
/* ==============================================  PORTE PORTE_PCR15 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR15_PS                                                            */
  PORTE_PCR15_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR15_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR15_PS_Enum;

/* ==============================================  PORTE PORTE_PCR15 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR15_PE                                                            */
  PORTE_PCR15_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR15_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR15_PE_Enum;

/* =============================================  PORTE PORTE_PCR15 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR15_MUX                                                           */
  PORTE_PCR15_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR15_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR15_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR15_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR15_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR15_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR15_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR15_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR15_MUX_Enum;

/* =============================================  PORTE PORTE_PCR15 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR15_LK                                                            */
  PORTE_PCR15_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR15_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR15_LK_Enum;

/* ============================================  PORTE PORTE_PCR15 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR15_IRQC                                                          */
  PORTE_PCR15_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR15_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR15_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR15_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR15_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR15_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR15_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR15_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR15_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR15_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR15 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR15_ISF                                                           */
  PORTE_PCR15_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR15_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR15_ISF_Enum;

/* ======================================================  PORTE_PCR16  ====================================================== */
/* ==============================================  PORTE PORTE_PCR16 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR16_PS                                                            */
  PORTE_PCR16_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR16_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR16_PS_Enum;

/* ==============================================  PORTE PORTE_PCR16 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR16_PE                                                            */
  PORTE_PCR16_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR16_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR16_PE_Enum;

/* =============================================  PORTE PORTE_PCR16 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR16_MUX                                                           */
  PORTE_PCR16_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR16_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR16_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR16_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR16_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR16_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR16_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR16_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR16_MUX_Enum;

/* =============================================  PORTE PORTE_PCR16 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR16_LK                                                            */
  PORTE_PCR16_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR16_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR16_LK_Enum;

/* ============================================  PORTE PORTE_PCR16 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR16_IRQC                                                          */
  PORTE_PCR16_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR16_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR16_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR16_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR16_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR16_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR16_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR16_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR16_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR16_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR16 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR16_ISF                                                           */
  PORTE_PCR16_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR16_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR16_ISF_Enum;

/* ======================================================  PORTE_PCR17  ====================================================== */
/* ==============================================  PORTE PORTE_PCR17 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR17_PS                                                            */
  PORTE_PCR17_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR17_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR17_PS_Enum;

/* ==============================================  PORTE PORTE_PCR17 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR17_PE                                                            */
  PORTE_PCR17_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR17_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR17_PE_Enum;

/* =============================================  PORTE PORTE_PCR17 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR17_MUX                                                           */
  PORTE_PCR17_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR17_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR17_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR17_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR17_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR17_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR17_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR17_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR17_MUX_Enum;

/* =============================================  PORTE PORTE_PCR17 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR17_LK                                                            */
  PORTE_PCR17_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR17_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR17_LK_Enum;

/* ============================================  PORTE PORTE_PCR17 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR17_IRQC                                                          */
  PORTE_PCR17_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR17_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR17_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR17_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR17_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR17_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR17_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR17_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR17_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR17_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR17 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR17_ISF                                                           */
  PORTE_PCR17_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR17_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR17_ISF_Enum;

/* ======================================================  PORTE_PCR18  ====================================================== */
/* ==============================================  PORTE PORTE_PCR18 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR18_PS                                                            */
  PORTE_PCR18_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR18_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR18_PS_Enum;

/* ==============================================  PORTE PORTE_PCR18 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR18_PE                                                            */
  PORTE_PCR18_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR18_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR18_PE_Enum;

/* =============================================  PORTE PORTE_PCR18 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR18_MUX                                                           */
  PORTE_PCR18_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR18_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR18_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR18_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR18_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR18_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR18_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR18_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR18_MUX_Enum;

/* =============================================  PORTE PORTE_PCR18 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR18_LK                                                            */
  PORTE_PCR18_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR18_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR18_LK_Enum;

/* ============================================  PORTE PORTE_PCR18 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR18_IRQC                                                          */
  PORTE_PCR18_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR18_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR18_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR18_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR18_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR18_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR18_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR18_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR18_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR18_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR18 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR18_ISF                                                           */
  PORTE_PCR18_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR18_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR18_ISF_Enum;

/* ======================================================  PORTE_PCR19  ====================================================== */
/* ==============================================  PORTE PORTE_PCR19 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR19_PS                                                            */
  PORTE_PCR19_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR19_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR19_PS_Enum;

/* ==============================================  PORTE PORTE_PCR19 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR19_PE                                                            */
  PORTE_PCR19_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR19_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR19_PE_Enum;

/* =============================================  PORTE PORTE_PCR19 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR19_MUX                                                           */
  PORTE_PCR19_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR19_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR19_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR19_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR19_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR19_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR19_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR19_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR19_MUX_Enum;

/* =============================================  PORTE PORTE_PCR19 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR19_LK                                                            */
  PORTE_PCR19_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR19_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR19_LK_Enum;

/* ============================================  PORTE PORTE_PCR19 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR19_IRQC                                                          */
  PORTE_PCR19_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR19_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR19_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR19_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR19_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR19_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR19_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR19_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR19_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR19_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR19 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR19_ISF                                                           */
  PORTE_PCR19_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR19_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR19_ISF_Enum;

/* ======================================================  PORTE_PCR20  ====================================================== */
/* ==============================================  PORTE PORTE_PCR20 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR20_PS                                                            */
  PORTE_PCR20_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR20_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR20_PS_Enum;

/* ==============================================  PORTE PORTE_PCR20 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR20_PE                                                            */
  PORTE_PCR20_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR20_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR20_PE_Enum;

/* =============================================  PORTE PORTE_PCR20 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR20_DSE                                                           */
  PORTE_PCR20_DSE_0                    = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTE_PCR20_DSE_1                    = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTE_PCR20_DSE_Enum;

/* =============================================  PORTE PORTE_PCR20 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR20_MUX                                                           */
  PORTE_PCR20_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR20_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR20_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR20_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR20_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR20_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR20_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR20_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR20_MUX_Enum;

/* =============================================  PORTE PORTE_PCR20 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR20_LK                                                            */
  PORTE_PCR20_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR20_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR20_LK_Enum;

/* ============================================  PORTE PORTE_PCR20 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR20_IRQC                                                          */
  PORTE_PCR20_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR20_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR20_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR20_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR20_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR20_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR20_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR20_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR20_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR20_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR20 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR20_ISF                                                           */
  PORTE_PCR20_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR20_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR20_ISF_Enum;

/* ======================================================  PORTE_PCR21  ====================================================== */
/* ==============================================  PORTE PORTE_PCR21 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR21_PS                                                            */
  PORTE_PCR21_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR21_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR21_PS_Enum;

/* ==============================================  PORTE PORTE_PCR21 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR21_PE                                                            */
  PORTE_PCR21_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR21_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR21_PE_Enum;

/* =============================================  PORTE PORTE_PCR21 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR21_DSE                                                           */
  PORTE_PCR21_DSE_0                    = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTE_PCR21_DSE_1                    = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTE_PCR21_DSE_Enum;

/* =============================================  PORTE PORTE_PCR21 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR21_MUX                                                           */
  PORTE_PCR21_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR21_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR21_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR21_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR21_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR21_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR21_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR21_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR21_MUX_Enum;

/* =============================================  PORTE PORTE_PCR21 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR21_LK                                                            */
  PORTE_PCR21_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR21_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR21_LK_Enum;

/* ============================================  PORTE PORTE_PCR21 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR21_IRQC                                                          */
  PORTE_PCR21_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR21_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR21_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR21_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR21_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR21_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR21_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR21_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR21_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR21_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR21 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR21_ISF                                                           */
  PORTE_PCR21_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR21_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR21_ISF_Enum;

/* ======================================================  PORTE_PCR22  ====================================================== */
/* ==============================================  PORTE PORTE_PCR22 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR22_PS                                                            */
  PORTE_PCR22_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR22_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR22_PS_Enum;

/* ==============================================  PORTE PORTE_PCR22 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR22_PE                                                            */
  PORTE_PCR22_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR22_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR22_PE_Enum;

/* =============================================  PORTE PORTE_PCR22 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR22_DSE                                                           */
  PORTE_PCR22_DSE_0                    = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTE_PCR22_DSE_1                    = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTE_PCR22_DSE_Enum;

/* =============================================  PORTE PORTE_PCR22 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR22_MUX                                                           */
  PORTE_PCR22_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR22_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR22_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR22_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR22_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR22_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR22_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR22_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR22_MUX_Enum;

/* =============================================  PORTE PORTE_PCR22 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR22_LK                                                            */
  PORTE_PCR22_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR22_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR22_LK_Enum;

/* ============================================  PORTE PORTE_PCR22 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR22_IRQC                                                          */
  PORTE_PCR22_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR22_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR22_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR22_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR22_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR22_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR22_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR22_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR22_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR22_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR22 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR22_ISF                                                           */
  PORTE_PCR22_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR22_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR22_ISF_Enum;

/* ======================================================  PORTE_PCR23  ====================================================== */
/* ==============================================  PORTE PORTE_PCR23 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR23_PS                                                            */
  PORTE_PCR23_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR23_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR23_PS_Enum;

/* ==============================================  PORTE PORTE_PCR23 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR23_PE                                                            */
  PORTE_PCR23_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR23_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR23_PE_Enum;

/* =============================================  PORTE PORTE_PCR23 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR23_DSE                                                           */
  PORTE_PCR23_DSE_0                    = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTE_PCR23_DSE_1                    = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTE_PCR23_DSE_Enum;

/* =============================================  PORTE PORTE_PCR23 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR23_MUX                                                           */
  PORTE_PCR23_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR23_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR23_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR23_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR23_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR23_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR23_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR23_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR23_MUX_Enum;

/* =============================================  PORTE PORTE_PCR23 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR23_LK                                                            */
  PORTE_PCR23_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR23_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR23_LK_Enum;

/* ============================================  PORTE PORTE_PCR23 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR23_IRQC                                                          */
  PORTE_PCR23_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR23_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR23_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR23_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR23_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR23_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR23_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR23_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR23_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR23_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR23 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR23_ISF                                                           */
  PORTE_PCR23_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR23_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR23_ISF_Enum;

/* ======================================================  PORTE_PCR24  ====================================================== */
/* ==============================================  PORTE PORTE_PCR24 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR24_PS                                                            */
  PORTE_PCR24_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR24_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR24_PS_Enum;

/* ==============================================  PORTE PORTE_PCR24 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR24_PE                                                            */
  PORTE_PCR24_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR24_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR24_PE_Enum;

/* =============================================  PORTE PORTE_PCR24 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR24_DSE                                                           */
  PORTE_PCR24_DSE_0                    = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTE_PCR24_DSE_1                    = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTE_PCR24_DSE_Enum;

/* =============================================  PORTE PORTE_PCR24 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR24_MUX                                                           */
  PORTE_PCR24_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR24_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR24_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR24_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR24_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR24_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR24_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR24_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR24_MUX_Enum;

/* =============================================  PORTE PORTE_PCR24 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR24_LK                                                            */
  PORTE_PCR24_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR24_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR24_LK_Enum;

/* ============================================  PORTE PORTE_PCR24 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR24_IRQC                                                          */
  PORTE_PCR24_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR24_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR24_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR24_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR24_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR24_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR24_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR24_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR24_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR24_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR24 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR24_ISF                                                           */
  PORTE_PCR24_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR24_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR24_ISF_Enum;

/* ======================================================  PORTE_PCR25  ====================================================== */
/* ==============================================  PORTE PORTE_PCR25 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR25_PS                                                            */
  PORTE_PCR25_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR25_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR25_PS_Enum;

/* ==============================================  PORTE PORTE_PCR25 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR25_PE                                                            */
  PORTE_PCR25_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR25_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR25_PE_Enum;

/* =============================================  PORTE PORTE_PCR25 DSE [6..6]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR25_DSE                                                           */
  PORTE_PCR25_DSE_0                    = 0,     /*!< 0 : Low drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
  PORTE_PCR25_DSE_1                    = 1,     /*!< 1 : High drive strength is configured on the corresponding pin,
                                                     if pin is configured as a digital output.                                 */
} PORTE_PCR25_DSE_Enum;

/* =============================================  PORTE PORTE_PCR25 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR25_MUX                                                           */
  PORTE_PCR25_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR25_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR25_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR25_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR25_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR25_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR25_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR25_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR25_MUX_Enum;

/* =============================================  PORTE PORTE_PCR25 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR25_LK                                                            */
  PORTE_PCR25_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR25_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR25_LK_Enum;

/* ============================================  PORTE PORTE_PCR25 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR25_IRQC                                                          */
  PORTE_PCR25_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR25_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR25_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR25_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR25_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR25_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR25_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR25_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR25_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR25_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR25 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR25_ISF                                                           */
  PORTE_PCR25_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR25_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR25_ISF_Enum;

/* ======================================================  PORTE_PCR26  ====================================================== */
/* ==============================================  PORTE PORTE_PCR26 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR26_PS                                                            */
  PORTE_PCR26_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR26_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR26_PS_Enum;

/* ==============================================  PORTE PORTE_PCR26 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR26_PE                                                            */
  PORTE_PCR26_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR26_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR26_PE_Enum;

/* =============================================  PORTE PORTE_PCR26 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR26_MUX                                                           */
  PORTE_PCR26_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR26_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR26_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR26_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR26_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR26_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR26_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR26_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR26_MUX_Enum;

/* =============================================  PORTE PORTE_PCR26 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR26_LK                                                            */
  PORTE_PCR26_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR26_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR26_LK_Enum;

/* ============================================  PORTE PORTE_PCR26 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR26_IRQC                                                          */
  PORTE_PCR26_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR26_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR26_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR26_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR26_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR26_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR26_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR26_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR26_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR26_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR26 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR26_ISF                                                           */
  PORTE_PCR26_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR26_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR26_ISF_Enum;

/* ======================================================  PORTE_PCR27  ====================================================== */
/* ==============================================  PORTE PORTE_PCR27 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR27_PS                                                            */
  PORTE_PCR27_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR27_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR27_PS_Enum;

/* ==============================================  PORTE PORTE_PCR27 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR27_PE                                                            */
  PORTE_PCR27_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR27_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR27_PE_Enum;

/* =============================================  PORTE PORTE_PCR27 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR27_MUX                                                           */
  PORTE_PCR27_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR27_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR27_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR27_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR27_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR27_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR27_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR27_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR27_MUX_Enum;

/* =============================================  PORTE PORTE_PCR27 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR27_LK                                                            */
  PORTE_PCR27_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR27_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR27_LK_Enum;

/* ============================================  PORTE PORTE_PCR27 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR27_IRQC                                                          */
  PORTE_PCR27_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR27_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR27_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR27_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR27_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR27_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR27_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR27_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR27_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR27_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR27 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR27_ISF                                                           */
  PORTE_PCR27_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR27_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR27_ISF_Enum;

/* ======================================================  PORTE_PCR28  ====================================================== */
/* ==============================================  PORTE PORTE_PCR28 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR28_PS                                                            */
  PORTE_PCR28_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR28_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR28_PS_Enum;

/* ==============================================  PORTE PORTE_PCR28 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR28_PE                                                            */
  PORTE_PCR28_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR28_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR28_PE_Enum;

/* =============================================  PORTE PORTE_PCR28 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR28_MUX                                                           */
  PORTE_PCR28_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR28_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR28_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR28_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR28_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR28_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR28_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR28_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR28_MUX_Enum;

/* =============================================  PORTE PORTE_PCR28 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR28_LK                                                            */
  PORTE_PCR28_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR28_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR28_LK_Enum;

/* ============================================  PORTE PORTE_PCR28 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR28_IRQC                                                          */
  PORTE_PCR28_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR28_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR28_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR28_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR28_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR28_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR28_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR28_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR28_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR28_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR28 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR28_ISF                                                           */
  PORTE_PCR28_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR28_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR28_ISF_Enum;

/* ======================================================  PORTE_PCR29  ====================================================== */
/* ==============================================  PORTE PORTE_PCR29 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR29_PS                                                            */
  PORTE_PCR29_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR29_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR29_PS_Enum;

/* ==============================================  PORTE PORTE_PCR29 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR29_PE                                                            */
  PORTE_PCR29_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR29_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR29_PE_Enum;

/* =============================================  PORTE PORTE_PCR29 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR29_MUX                                                           */
  PORTE_PCR29_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR29_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR29_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR29_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR29_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR29_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR29_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR29_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR29_MUX_Enum;

/* =============================================  PORTE PORTE_PCR29 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR29_LK                                                            */
  PORTE_PCR29_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR29_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR29_LK_Enum;

/* ============================================  PORTE PORTE_PCR29 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR29_IRQC                                                          */
  PORTE_PCR29_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR29_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR29_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR29_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR29_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR29_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR29_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR29_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR29_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR29_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR29 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR29_ISF                                                           */
  PORTE_PCR29_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR29_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR29_ISF_Enum;

/* ======================================================  PORTE_PCR30  ====================================================== */
/* ==============================================  PORTE PORTE_PCR30 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR30_PS                                                            */
  PORTE_PCR30_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR30_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR30_PS_Enum;

/* ==============================================  PORTE PORTE_PCR30 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR30_PE                                                            */
  PORTE_PCR30_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR30_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR30_PE_Enum;

/* =============================================  PORTE PORTE_PCR30 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR30_MUX                                                           */
  PORTE_PCR30_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR30_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR30_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR30_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR30_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR30_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR30_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR30_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR30_MUX_Enum;

/* =============================================  PORTE PORTE_PCR30 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR30_LK                                                            */
  PORTE_PCR30_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR30_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR30_LK_Enum;

/* ============================================  PORTE PORTE_PCR30 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR30_IRQC                                                          */
  PORTE_PCR30_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR30_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR30_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR30_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR30_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR30_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR30_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR30_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR30_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR30_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR30 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR30_ISF                                                           */
  PORTE_PCR30_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR30_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR30_ISF_Enum;

/* ======================================================  PORTE_PCR31  ====================================================== */
/* ==============================================  PORTE PORTE_PCR31 PS [0..0]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR31_PS                                                            */
  PORTE_PCR31_PS_0                     = 0,     /*!< 0 : Internal pulldown resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
  PORTE_PCR31_PS_1                     = 1,     /*!< 1 : Internal pullup resistor is enabled on the corresponding
                                                     pin, if the corresponding PE field is set.                                */
} PORTE_PCR31_PS_Enum;

/* ==============================================  PORTE PORTE_PCR31 PE [1..1]  ============================================== */
typedef enum {                                  /*!< PORTE_PCR31_PE                                                            */
  PORTE_PCR31_PE_0                     = 0,     /*!< 0 : Internal pullup or pulldown resistor is not enabled on the
                                                     corresponding pin.                                                        */
  PORTE_PCR31_PE_1                     = 1,     /*!< 1 : Internal pullup or pulldown resistor is enabled on the corresponding
                                                     pin, if the pin is configured as a digital input.                         */
} PORTE_PCR31_PE_Enum;

/* =============================================  PORTE PORTE_PCR31 MUX [8..10]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR31_MUX                                                           */
  PORTE_PCR31_MUX_000                  = 0,     /*!< 000 : Pin disabled (Alternative 0) (analog).                              */
  PORTE_PCR31_MUX_001                  = 1,     /*!< 001 : Alternative 1 (GPIO).                                               */
  PORTE_PCR31_MUX_010                  = 2,     /*!< 010 : Alternative 2 (chip-specific).                                      */
  PORTE_PCR31_MUX_011                  = 3,     /*!< 011 : Alternative 3 (chip-specific).                                      */
  PORTE_PCR31_MUX_100                  = 4,     /*!< 100 : Alternative 4 (chip-specific).                                      */
  PORTE_PCR31_MUX_101                  = 5,     /*!< 101 : Alternative 5 (chip-specific).                                      */
  PORTE_PCR31_MUX_110                  = 6,     /*!< 110 : Alternative 6 (chip-specific).                                      */
  PORTE_PCR31_MUX_111                  = 7,     /*!< 111 : Alternative 7 (chip-specific).                                      */
} PORTE_PCR31_MUX_Enum;

/* =============================================  PORTE PORTE_PCR31 LK [15..15]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR31_LK                                                            */
  PORTE_PCR31_LK_0                     = 0,     /*!< 0 : Pin Control Register fields [15:0] are not locked.                    */
  PORTE_PCR31_LK_1                     = 1,     /*!< 1 : Pin Control Register fields [15:0] are locked and cannot
                                                     be updated until the next system reset.                                   */
} PORTE_PCR31_LK_Enum;

/* ============================================  PORTE PORTE_PCR31 IRQC [16..19]  ============================================ */
typedef enum {                                  /*!< PORTE_PCR31_IRQC                                                          */
  PORTE_PCR31_IRQC_0000                = 0,     /*!< 0000 : Interrupt Status Flag (ISF) is disabled.                           */
  PORTE_PCR31_IRQC_0001                = 1,     /*!< 0001 : ISF flag and DMA request on rising edge.                           */
  PORTE_PCR31_IRQC_0010                = 2,     /*!< 0010 : ISF flag and DMA request on falling edge.                          */
  PORTE_PCR31_IRQC_0011                = 3,     /*!< 0011 : ISF flag and DMA request on either edge.                           */
  PORTE_PCR31_IRQC_1000                = 8,     /*!< 1000 : ISF flag and Interrupt when logic 0.                               */
  PORTE_PCR31_IRQC_1001                = 9,     /*!< 1001 : ISF flag and Interrupt on rising-edge.                             */
  PORTE_PCR31_IRQC_1010                = 10,    /*!< 1010 : ISF flag and Interrupt on falling-edge.                            */
  PORTE_PCR31_IRQC_1011                = 11,    /*!< 1011 : ISF flag and Interrupt on either edge.                             */
  PORTE_PCR31_IRQC_1100                = 12,    /*!< 1100 : ISF flag and Interrupt when logic 1.                               */
} PORTE_PCR31_IRQC_Enum;

/* ============================================  PORTE PORTE_PCR31 ISF [24..24]  ============================================= */
typedef enum {                                  /*!< PORTE_PCR31_ISF                                                           */
  PORTE_PCR31_ISF_0                    = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_PCR31_ISF_1                    = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_PCR31_ISF_Enum;

/* ======================================================  PORTE_GPCLR  ====================================================== */
/* ============================================  PORTE PORTE_GPCLR GPWE [16..31]  ============================================ */
typedef enum {                                  /*!< PORTE_GPCLR_GPWE                                                          */
  PORTE_GPCLR_GPWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTE_GPCLR_GPWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTE_GPCLR_GPWE_Enum;

/* ======================================================  PORTE_GPCHR  ====================================================== */
/* ============================================  PORTE PORTE_GPCHR GPWE [16..31]  ============================================ */
typedef enum {                                  /*!< PORTE_GPCHR_GPWE                                                          */
  PORTE_GPCHR_GPWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTE_GPCHR_GPWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTE_GPCHR_GPWE_Enum;

/* ======================================================  PORTE_GICLR  ====================================================== */
/* ============================================  PORTE PORTE_GICLR GIWE [0..15]  ============================================= */
typedef enum {                                  /*!< PORTE_GICLR_GIWE                                                          */
  PORTE_GICLR_GIWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTE_GICLR_GIWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTE_GICLR_GIWE_Enum;

/* ======================================================  PORTE_GICHR  ====================================================== */
/* ============================================  PORTE PORTE_GICHR GIWE [0..15]  ============================================= */
typedef enum {                                  /*!< PORTE_GICHR_GIWE                                                          */
  PORTE_GICHR_GIWE_0                   = 0,     /*!< 0 : Corresponding Pin Control Register is not updated with the
                                                     value in GPWD.                                                            */
  PORTE_GICHR_GIWE_1                   = 1,     /*!< 1 : Corresponding Pin Control Register is updated with the value
                                                     in GPWD.                                                                  */
} PORTE_GICHR_GIWE_Enum;

/* ======================================================  PORTE_ISFR  ======================================================= */
/* =============================================  PORTE PORTE_ISFR ISF [0..31]  ============================================== */
typedef enum {                                  /*!< PORTE_ISFR_ISF                                                            */
  PORTE_ISFR_ISF_0                     = 0,     /*!< 0 : Configured interrupt is not detected.                                 */
  PORTE_ISFR_ISF_1                     = 1,     /*!< 1 : Configured interrupt is detected. If the pin is configured
                                                     to generate a DMA request, then the corresponding flag
                                                     will be cleared automatically at the completion of the
                                                     requested DMA transfer. Otherwise, the flag remains set
                                                     until a logic 1 is written to the flag. If the pin is configured
                                                     for a level sensitive interrupt and the pin remains asserted,
                                                     then the flag is set again immediately after it is cleared.               */
} PORTE_ISFR_ISF_Enum;

/* ======================================================  PORTE_DFER  ======================================================= */
/* =============================================  PORTE PORTE_DFER DFE [0..31]  ============================================== */
typedef enum {                                  /*!< PORTE_DFER_DFE                                                            */
  PORTE_DFER_DFE_0                     = 0,     /*!< 0 : Digital filter is disabled on the corresponding pin and
                                                     output of the digital filter is reset to zero.                            */
  PORTE_DFER_DFE_1                     = 1,     /*!< 1 : Digital filter is enabled on the corresponding pin, if the
                                                     pin is configured as a digital input.                                     */
} PORTE_DFER_DFE_Enum;

/* ======================================================  PORTE_DFCR  ======================================================= */
/* ==============================================  PORTE PORTE_DFCR CS [0..0]  =============================================== */
typedef enum {                                  /*!< PORTE_DFCR_CS                                                             */
  PORTE_DFCR_CS_0                      = 0,     /*!< 0 : Digital filters are clocked by the bus clock.                         */
  PORTE_DFCR_CS_1                      = 1,     /*!< 1 : Digital filters are clocked by the LPO clock.                         */
} PORTE_DFCR_CS_Enum;

/* ======================================================  PORTE_DFWR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                           WDOG                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  WDOG_CS  ======================================================== */
/* ===============================================  WDOG WDOG_CS STOP [0..0]  ================================================ */
typedef enum {                                  /*!< WDOG_CS_STOP                                                              */
  WDOG_CS_STOP_0                       = 0,     /*!< 0 : Watchdog disabled in chip stop mode.                                  */
  WDOG_CS_STOP_1                       = 1,     /*!< 1 : Watchdog enabled in chip stop mode.                                   */
} WDOG_CS_STOP_Enum;

/* ===============================================  WDOG WDOG_CS WAIT [1..1]  ================================================ */
typedef enum {                                  /*!< WDOG_CS_WAIT                                                              */
  WDOG_CS_WAIT_0                       = 0,     /*!< 0 : Watchdog disabled in chip wait mode.                                  */
  WDOG_CS_WAIT_1                       = 1,     /*!< 1 : Watchdog enabled in chip wait mode.                                   */
} WDOG_CS_WAIT_Enum;

/* ================================================  WDOG WDOG_CS DBG [2..2]  ================================================ */
typedef enum {                                  /*!< WDOG_CS_DBG                                                               */
  WDOG_CS_DBG_0                        = 0,     /*!< 0 : Watchdog disabled in chip debug mode.                                 */
  WDOG_CS_DBG_1                        = 1,     /*!< 1 : Watchdog enabled in chip debug mode.                                  */
} WDOG_CS_DBG_Enum;

/* ================================================  WDOG WDOG_CS TST [3..4]  ================================================ */
typedef enum {                                  /*!< WDOG_CS_TST                                                               */
  WDOG_CS_TST_00                       = 0,     /*!< 00 : Watchdog test mode disabled.                                         */
  WDOG_CS_TST_01                       = 1,     /*!< 01 : Watchdog user mode enabled. (Watchdog test mode disabled.)
                                                     After testing the watchdog, software should use this setting
                                                     to indicate that the watchdog is functioning normally in
                                                     user mode.                                                                */
  WDOG_CS_TST_10                       = 2,     /*!< 10 : Watchdog test mode enabled, only the low byte is used.
                                                     CNT[CNTLOW] is compared with TOVAL[TOVALLOW].                             */
  WDOG_CS_TST_11                       = 3,     /*!< 11 : Watchdog test mode enabled, only the high byte is used.
                                                     CNT[CNTHIGH] is compared with TOVAL[TOVALHIGH].                           */
} WDOG_CS_TST_Enum;

/* ==============================================  WDOG WDOG_CS UPDATE [5..5]  =============================================== */
typedef enum {                                  /*!< WDOG_CS_UPDATE                                                            */
  WDOG_CS_UPDATE_0                     = 0,     /*!< 0 : Updates not allowed. After the initial configuration, the
                                                     watchdog cannot be later modified without forcing a reset.                */
  WDOG_CS_UPDATE_1                     = 1,     /*!< 1 : Updates allowed. Software can modify the watchdog configuration
                                                     registers within 8d128 bus clocks after performing the
                                                     unlock write sequence.                                                    */
} WDOG_CS_UPDATE_Enum;

/* ================================================  WDOG WDOG_CS INT [6..6]  ================================================ */
typedef enum {                                  /*!< WDOG_CS_INT                                                               */
  WDOG_CS_INT_0                        = 0,     /*!< 0 : Watchdog interrupts are disabled. Watchdog resets are not
                                                     delayed.                                                                  */
  WDOG_CS_INT_1                        = 1,     /*!< 1 : Watchdog interrupts are enabled. Watchdog resets are delayed
                                                     by 8d128 bus clocks from the interrupt vector fetch.                      */
} WDOG_CS_INT_Enum;

/* ================================================  WDOG WDOG_CS EN [7..7]  ================================================= */
typedef enum {                                  /*!< WDOG_CS_EN                                                                */
  WDOG_CS_EN_0                         = 0,     /*!< 0 : Watchdog disabled.                                                    */
  WDOG_CS_EN_1                         = 1,     /*!< 1 : Watchdog enabled.                                                     */
} WDOG_CS_EN_Enum;

/* ================================================  WDOG WDOG_CS CLK [8..9]  ================================================ */
typedef enum {                                  /*!< WDOG_CS_CLK                                                               */
  WDOG_CS_CLK_00                       = 0,     /*!< 00 : Bus clock                                                            */
  WDOG_CS_CLK_01                       = 1,     /*!< 01 : LPO clock                                                            */
  WDOG_CS_CLK_10                       = 2,     /*!< 10 : INTCLK (internal clock)                                              */
  WDOG_CS_CLK_11                       = 3,     /*!< 11 : ERCLK (external reference clock)                                     */
} WDOG_CS_CLK_Enum;

/* ===============================================  WDOG WDOG_CS RCS [10..10]  =============================================== */
typedef enum {                                  /*!< WDOG_CS_RCS                                                               */
  WDOG_CS_RCS_0                        = 0,     /*!< 0 : Reconfiguring WDOG.                                                   */
  WDOG_CS_RCS_1                        = 1,     /*!< 1 : Reconfiguration is successful.                                        */
} WDOG_CS_RCS_Enum;

/* ===============================================  WDOG WDOG_CS ULK [11..11]  =============================================== */
typedef enum {                                  /*!< WDOG_CS_ULK                                                               */
  WDOG_CS_ULK_0                        = 0,     /*!< 0 : WDOG is locked.                                                       */
  WDOG_CS_ULK_1                        = 1,     /*!< 1 : WDOG is unlocked.                                                     */
} WDOG_CS_ULK_Enum;

/* ==============================================  WDOG WDOG_CS PRES [12..12]  =============================================== */
typedef enum {                                  /*!< WDOG_CS_PRES                                                              */
  WDOG_CS_PRES_0                       = 0,     /*!< 0 : 256 prescaler disabled.                                               */
  WDOG_CS_PRES_1                       = 1,     /*!< 1 : 256 prescaler enabled.                                                */
} WDOG_CS_PRES_Enum;

/* =============================================  WDOG WDOG_CS CMD32EN [13..13]  ============================================= */
typedef enum {                                  /*!< WDOG_CS_CMD32EN                                                           */
  WDOG_CS_CMD32EN_0                    = 0,     /*!< 0 : Disables support for 32-bit refresh/unlock command write
                                                     words. Only 16-bit or 8-bit is supported.                                 */
  WDOG_CS_CMD32EN_1                    = 1,     /*!< 1 : Enables support for 32-bit refresh/unlock command write
                                                     words. 16-bit or 8-bit is NOT supported.                                  */
} WDOG_CS_CMD32EN_Enum;

/* ===============================================  WDOG WDOG_CS FLG [14..14]  =============================================== */
typedef enum {                                  /*!< WDOG_CS_FLG                                                               */
  WDOG_CS_FLG_0                        = 0,     /*!< 0 : No interrupt occurred.                                                */
  WDOG_CS_FLG_1                        = 1,     /*!< 1 : An interrupt occurred.                                                */
} WDOG_CS_FLG_Enum;

/* ===============================================  WDOG WDOG_CS WIN [15..15]  =============================================== */
typedef enum {                                  /*!< WDOG_CS_WIN                                                               */
  WDOG_CS_WIN_0                        = 0,     /*!< 0 : Window mode disabled.                                                 */
  WDOG_CS_WIN_1                        = 1,     /*!< 1 : Window mode enabled.                                                  */
} WDOG_CS_WIN_Enum;

/* =======================================================  WDOG_CNT  ======================================================== */
/* ======================================================  WDOG_TOVAL  ======================================================= */
/* =======================================================  WDOG_WIN  ======================================================== */


/* =========================================================================================================================== */
/* ================                                          FLEXIO                                           ================ */
/* =========================================================================================================================== */

/* =====================================================  FLEXIO_VERID  ====================================================== */
/* ==========================================  FLEXIO FLEXIO_VERID FEATURE [0..15]  ========================================== */
typedef enum {                                  /*!< FLEXIO_VERID_FEATURE                                                      */
  FLEXIO_VERID_FEATURE_0000000000000000 = 0,    /*!< 0000000000000000 : Standard features implemented.                         */
  FLEXIO_VERID_FEATURE_0000000000000001 = 1,    /*!< 0000000000000001 : Supports state, logic and parallel modes.              */
} FLEXIO_VERID_FEATURE_Enum;

/* =====================================================  FLEXIO_PARAM  ====================================================== */
/* ======================================================  FLEXIO_CTRL  ====================================================== */
/* ===========================================  FLEXIO FLEXIO_CTRL FLEXEN [0..0]  ============================================ */
typedef enum {                                  /*!< FLEXIO_CTRL_FLEXEN                                                        */
  FLEXIO_CTRL_FLEXEN_0                 = 0,     /*!< 0 : FlexIO module is disabled.                                            */
  FLEXIO_CTRL_FLEXEN_1                 = 1,     /*!< 1 : FlexIO module is enabled.                                             */
} FLEXIO_CTRL_FLEXEN_Enum;

/* ============================================  FLEXIO FLEXIO_CTRL SWRST [1..1]  ============================================ */
typedef enum {                                  /*!< FLEXIO_CTRL_SWRST                                                         */
  FLEXIO_CTRL_SWRST_0                  = 0,     /*!< 0 : Software reset is disabled                                            */
  FLEXIO_CTRL_SWRST_1                  = 1,     /*!< 1 : Software reset is enabled, all FlexIO registers except the
                                                     Control Register are reset.                                               */
} FLEXIO_CTRL_SWRST_Enum;

/* ===========================================  FLEXIO FLEXIO_CTRL FASTACC [2..2]  =========================================== */
typedef enum {                                  /*!< FLEXIO_CTRL_FASTACC                                                       */
  FLEXIO_CTRL_FASTACC_0                = 0,     /*!< 0 : Configures for normal register accesses to FlexIO                     */
  FLEXIO_CTRL_FASTACC_1                = 1,     /*!< 1 : Configures for fast register accesses to FlexIO                       */
} FLEXIO_CTRL_FASTACC_Enum;

/* ===========================================  FLEXIO FLEXIO_CTRL DBGE [30..30]  ============================================ */
typedef enum {                                  /*!< FLEXIO_CTRL_DBGE                                                          */
  FLEXIO_CTRL_DBGE_0                   = 0,     /*!< 0 : FlexIO is disabled in debug modes.                                    */
  FLEXIO_CTRL_DBGE_1                   = 1,     /*!< 1 : FlexIO is enabled in debug modes                                      */
} FLEXIO_CTRL_DBGE_Enum;

/* ===========================================  FLEXIO FLEXIO_CTRL DOZEN [31..31]  =========================================== */
typedef enum {                                  /*!< FLEXIO_CTRL_DOZEN                                                         */
  FLEXIO_CTRL_DOZEN_0                  = 0,     /*!< 0 : FlexIO enabled in Doze modes.                                         */
  FLEXIO_CTRL_DOZEN_1                  = 1,     /*!< 1 : FlexIO disabled in Doze modes.                                        */
} FLEXIO_CTRL_DOZEN_Enum;

/* ======================================================  FLEXIO_PIN  ======================================================= */
/* ===================================================  FLEXIO_SHIFTSTAT  ==================================================== */
/* ====================================================  FLEXIO_SHIFTERR  ==================================================== */
/* ====================================================  FLEXIO_TIMSTAT  ===================================================== */
/* ===================================================  FLEXIO_SHIFTSIEN  ==================================================== */
/* ===================================================  FLEXIO_SHIFTEIEN  ==================================================== */
/* =====================================================  FLEXIO_TIMIEN  ===================================================== */
/* ===================================================  FLEXIO_SHIFTSDEN  ==================================================== */
/* ===================================================  FLEXIO_SHIFTCTL0  ==================================================== */
/* ==========================================  FLEXIO FLEXIO_SHIFTCTL0 SMOD [0..2]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL0_SMOD                                                     */
  FLEXIO_SHIFTCTL0_SMOD_0              = 0,     /*!< 0 : Disabled.                                                             */
  FLEXIO_SHIFTCTL0_SMOD_1              = 1,     /*!< 1 : Receive mode. Captures the current Shifter content into
                                                     the SHIFTBUF on expiration of the Timer.                                  */
  FLEXIO_SHIFTCTL0_SMOD_10             = 2,     /*!< 10 : Transmit mode. Load SHIFTBUF contents into the Shifter
                                                     on expiration of the Timer.                                               */
  FLEXIO_SHIFTCTL0_SMOD_100            = 4,     /*!< 100 : Match Store mode. Shifter data is compared to SHIFTBUF
                                                     content on expiration of the Timer.                                       */
  FLEXIO_SHIFTCTL0_SMOD_101            = 5,     /*!< 101 : Match Continuous mode. Shifter data is continuously compared
                                                     to SHIFTBUF contents.                                                     */
} FLEXIO_SHIFTCTL0_SMOD_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCTL0 PINPOL [7..7]  ========================================= */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL0_PINPOL                                                   */
  FLEXIO_SHIFTCTL0_PINPOL_0            = 0,     /*!< 0 : Pin is active high                                                    */
  FLEXIO_SHIFTCTL0_PINPOL_1            = 1,     /*!< 1 : Pin is active low                                                     */
} FLEXIO_SHIFTCTL0_PINPOL_Enum;

/* ========================================  FLEXIO FLEXIO_SHIFTCTL0 PINCFG [16..17]  ======================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL0_PINCFG                                                   */
  FLEXIO_SHIFTCTL0_PINCFG_0            = 0,     /*!< 0 : Shifter pin output disabled                                           */
  FLEXIO_SHIFTCTL0_PINCFG_1            = 1,     /*!< 1 : Shifter pin open drain or bidirectional output enable                 */
  FLEXIO_SHIFTCTL0_PINCFG_10           = 2,     /*!< 10 : Shifter pin bidirectional output data                                */
  FLEXIO_SHIFTCTL0_PINCFG_11           = 3,     /*!< 11 : Shifter pin output                                                   */
} FLEXIO_SHIFTCTL0_PINCFG_Enum;

/* ========================================  FLEXIO FLEXIO_SHIFTCTL0 TIMPOL [23..23]  ======================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL0_TIMPOL                                                   */
  FLEXIO_SHIFTCTL0_TIMPOL_0            = 0,     /*!< 0 : Shift on posedge of Shift clock                                       */
  FLEXIO_SHIFTCTL0_TIMPOL_1            = 1,     /*!< 1 : Shift on negedge of Shift clock                                       */
} FLEXIO_SHIFTCTL0_TIMPOL_Enum;

/* ===================================================  FLEXIO_SHIFTCTL1  ==================================================== */
/* ==========================================  FLEXIO FLEXIO_SHIFTCTL1 SMOD [0..2]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL1_SMOD                                                     */
  FLEXIO_SHIFTCTL1_SMOD_0              = 0,     /*!< 0 : Disabled.                                                             */
  FLEXIO_SHIFTCTL1_SMOD_1              = 1,     /*!< 1 : Receive mode. Captures the current Shifter content into
                                                     the SHIFTBUF on expiration of the Timer.                                  */
  FLEXIO_SHIFTCTL1_SMOD_10             = 2,     /*!< 10 : Transmit mode. Load SHIFTBUF contents into the Shifter
                                                     on expiration of the Timer.                                               */
  FLEXIO_SHIFTCTL1_SMOD_100            = 4,     /*!< 100 : Match Store mode. Shifter data is compared to SHIFTBUF
                                                     content on expiration of the Timer.                                       */
  FLEXIO_SHIFTCTL1_SMOD_101            = 5,     /*!< 101 : Match Continuous mode. Shifter data is continuously compared
                                                     to SHIFTBUF contents.                                                     */
} FLEXIO_SHIFTCTL1_SMOD_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCTL1 PINPOL [7..7]  ========================================= */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL1_PINPOL                                                   */
  FLEXIO_SHIFTCTL1_PINPOL_0            = 0,     /*!< 0 : Pin is active high                                                    */
  FLEXIO_SHIFTCTL1_PINPOL_1            = 1,     /*!< 1 : Pin is active low                                                     */
} FLEXIO_SHIFTCTL1_PINPOL_Enum;

/* ========================================  FLEXIO FLEXIO_SHIFTCTL1 PINCFG [16..17]  ======================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL1_PINCFG                                                   */
  FLEXIO_SHIFTCTL1_PINCFG_0            = 0,     /*!< 0 : Shifter pin output disabled                                           */
  FLEXIO_SHIFTCTL1_PINCFG_1            = 1,     /*!< 1 : Shifter pin open drain or bidirectional output enable                 */
  FLEXIO_SHIFTCTL1_PINCFG_10           = 2,     /*!< 10 : Shifter pin bidirectional output data                                */
  FLEXIO_SHIFTCTL1_PINCFG_11           = 3,     /*!< 11 : Shifter pin output                                                   */
} FLEXIO_SHIFTCTL1_PINCFG_Enum;

/* ========================================  FLEXIO FLEXIO_SHIFTCTL1 TIMPOL [23..23]  ======================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL1_TIMPOL                                                   */
  FLEXIO_SHIFTCTL1_TIMPOL_0            = 0,     /*!< 0 : Shift on posedge of Shift clock                                       */
  FLEXIO_SHIFTCTL1_TIMPOL_1            = 1,     /*!< 1 : Shift on negedge of Shift clock                                       */
} FLEXIO_SHIFTCTL1_TIMPOL_Enum;

/* ===================================================  FLEXIO_SHIFTCTL2  ==================================================== */
/* ==========================================  FLEXIO FLEXIO_SHIFTCTL2 SMOD [0..2]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL2_SMOD                                                     */
  FLEXIO_SHIFTCTL2_SMOD_0              = 0,     /*!< 0 : Disabled.                                                             */
  FLEXIO_SHIFTCTL2_SMOD_1              = 1,     /*!< 1 : Receive mode. Captures the current Shifter content into
                                                     the SHIFTBUF on expiration of the Timer.                                  */
  FLEXIO_SHIFTCTL2_SMOD_10             = 2,     /*!< 10 : Transmit mode. Load SHIFTBUF contents into the Shifter
                                                     on expiration of the Timer.                                               */
  FLEXIO_SHIFTCTL2_SMOD_100            = 4,     /*!< 100 : Match Store mode. Shifter data is compared to SHIFTBUF
                                                     content on expiration of the Timer.                                       */
  FLEXIO_SHIFTCTL2_SMOD_101            = 5,     /*!< 101 : Match Continuous mode. Shifter data is continuously compared
                                                     to SHIFTBUF contents.                                                     */
} FLEXIO_SHIFTCTL2_SMOD_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCTL2 PINPOL [7..7]  ========================================= */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL2_PINPOL                                                   */
  FLEXIO_SHIFTCTL2_PINPOL_0            = 0,     /*!< 0 : Pin is active high                                                    */
  FLEXIO_SHIFTCTL2_PINPOL_1            = 1,     /*!< 1 : Pin is active low                                                     */
} FLEXIO_SHIFTCTL2_PINPOL_Enum;

/* ========================================  FLEXIO FLEXIO_SHIFTCTL2 PINCFG [16..17]  ======================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL2_PINCFG                                                   */
  FLEXIO_SHIFTCTL2_PINCFG_0            = 0,     /*!< 0 : Shifter pin output disabled                                           */
  FLEXIO_SHIFTCTL2_PINCFG_1            = 1,     /*!< 1 : Shifter pin open drain or bidirectional output enable                 */
  FLEXIO_SHIFTCTL2_PINCFG_10           = 2,     /*!< 10 : Shifter pin bidirectional output data                                */
  FLEXIO_SHIFTCTL2_PINCFG_11           = 3,     /*!< 11 : Shifter pin output                                                   */
} FLEXIO_SHIFTCTL2_PINCFG_Enum;

/* ========================================  FLEXIO FLEXIO_SHIFTCTL2 TIMPOL [23..23]  ======================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL2_TIMPOL                                                   */
  FLEXIO_SHIFTCTL2_TIMPOL_0            = 0,     /*!< 0 : Shift on posedge of Shift clock                                       */
  FLEXIO_SHIFTCTL2_TIMPOL_1            = 1,     /*!< 1 : Shift on negedge of Shift clock                                       */
} FLEXIO_SHIFTCTL2_TIMPOL_Enum;

/* ===================================================  FLEXIO_SHIFTCTL3  ==================================================== */
/* ==========================================  FLEXIO FLEXIO_SHIFTCTL3 SMOD [0..2]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL3_SMOD                                                     */
  FLEXIO_SHIFTCTL3_SMOD_0              = 0,     /*!< 0 : Disabled.                                                             */
  FLEXIO_SHIFTCTL3_SMOD_1              = 1,     /*!< 1 : Receive mode. Captures the current Shifter content into
                                                     the SHIFTBUF on expiration of the Timer.                                  */
  FLEXIO_SHIFTCTL3_SMOD_10             = 2,     /*!< 10 : Transmit mode. Load SHIFTBUF contents into the Shifter
                                                     on expiration of the Timer.                                               */
  FLEXIO_SHIFTCTL3_SMOD_100            = 4,     /*!< 100 : Match Store mode. Shifter data is compared to SHIFTBUF
                                                     content on expiration of the Timer.                                       */
  FLEXIO_SHIFTCTL3_SMOD_101            = 5,     /*!< 101 : Match Continuous mode. Shifter data is continuously compared
                                                     to SHIFTBUF contents.                                                     */
} FLEXIO_SHIFTCTL3_SMOD_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCTL3 PINPOL [7..7]  ========================================= */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL3_PINPOL                                                   */
  FLEXIO_SHIFTCTL3_PINPOL_0            = 0,     /*!< 0 : Pin is active high                                                    */
  FLEXIO_SHIFTCTL3_PINPOL_1            = 1,     /*!< 1 : Pin is active low                                                     */
} FLEXIO_SHIFTCTL3_PINPOL_Enum;

/* ========================================  FLEXIO FLEXIO_SHIFTCTL3 PINCFG [16..17]  ======================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL3_PINCFG                                                   */
  FLEXIO_SHIFTCTL3_PINCFG_0            = 0,     /*!< 0 : Shifter pin output disabled                                           */
  FLEXIO_SHIFTCTL3_PINCFG_1            = 1,     /*!< 1 : Shifter pin open drain or bidirectional output enable                 */
  FLEXIO_SHIFTCTL3_PINCFG_10           = 2,     /*!< 10 : Shifter pin bidirectional output data                                */
  FLEXIO_SHIFTCTL3_PINCFG_11           = 3,     /*!< 11 : Shifter pin output                                                   */
} FLEXIO_SHIFTCTL3_PINCFG_Enum;

/* ========================================  FLEXIO FLEXIO_SHIFTCTL3 TIMPOL [23..23]  ======================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCTL3_TIMPOL                                                   */
  FLEXIO_SHIFTCTL3_TIMPOL_0            = 0,     /*!< 0 : Shift on posedge of Shift clock                                       */
  FLEXIO_SHIFTCTL3_TIMPOL_1            = 1,     /*!< 1 : Shift on negedge of Shift clock                                       */
} FLEXIO_SHIFTCTL3_TIMPOL_Enum;

/* ===================================================  FLEXIO_SHIFTCFG0  ==================================================== */
/* =========================================  FLEXIO FLEXIO_SHIFTCFG0 SSTART [0..1]  ========================================= */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG0_SSTART                                                   */
  FLEXIO_SHIFTCFG0_SSTART_0            = 0,     /*!< 0 : Start bit disabled for transmitter/receiver/match store,
                                                     transmitter loads data on enable                                          */
  FLEXIO_SHIFTCFG0_SSTART_1            = 1,     /*!< 1 : Start bit disabled for transmitter/receiver/match store,
                                                     transmitter loads data on first shift                                     */
  FLEXIO_SHIFTCFG0_SSTART_10           = 2,     /*!< 10 : Transmitter outputs start bit value 0 before loading data
                                                     on first shift, receiver/match store sets error flag if
                                                     start bit is not 0                                                        */
  FLEXIO_SHIFTCFG0_SSTART_11           = 3,     /*!< 11 : Transmitter outputs start bit value 1 before loading data
                                                     on first shift, receiver/match store sets error flag if
                                                     start bit is not 1                                                        */
} FLEXIO_SHIFTCFG0_SSTART_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCFG0 SSTOP [4..5]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG0_SSTOP                                                    */
  FLEXIO_SHIFTCFG0_SSTOP_0             = 0,     /*!< 0 : Stop bit disabled for transmitter/receiver/match store                */
  FLEXIO_SHIFTCFG0_SSTOP_1             = 1,     /*!< 1 : Reserved for transmitter/receiver/match store                         */
  FLEXIO_SHIFTCFG0_SSTOP_10            = 2,     /*!< 10 : Transmitter outputs stop bit value 0 on store, receiver/match
                                                     store sets error flag if stop bit is not 0                                */
  FLEXIO_SHIFTCFG0_SSTOP_11            = 3,     /*!< 11 : Transmitter outputs stop bit value 1 on store, receiver/match
                                                     store sets error flag if stop bit is not 1                                */
} FLEXIO_SHIFTCFG0_SSTOP_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCFG0 INSRC [8..8]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG0_INSRC                                                    */
  FLEXIO_SHIFTCFG0_INSRC_0             = 0,     /*!< 0 : Pin                                                                   */
  FLEXIO_SHIFTCFG0_INSRC_1             = 1,     /*!< 1 : Shifter N+1 Output                                                    */
} FLEXIO_SHIFTCFG0_INSRC_Enum;

/* ===================================================  FLEXIO_SHIFTCFG1  ==================================================== */
/* =========================================  FLEXIO FLEXIO_SHIFTCFG1 SSTART [0..1]  ========================================= */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG1_SSTART                                                   */
  FLEXIO_SHIFTCFG1_SSTART_0            = 0,     /*!< 0 : Start bit disabled for transmitter/receiver/match store,
                                                     transmitter loads data on enable                                          */
  FLEXIO_SHIFTCFG1_SSTART_1            = 1,     /*!< 1 : Start bit disabled for transmitter/receiver/match store,
                                                     transmitter loads data on first shift                                     */
  FLEXIO_SHIFTCFG1_SSTART_10           = 2,     /*!< 10 : Transmitter outputs start bit value 0 before loading data
                                                     on first shift, receiver/match store sets error flag if
                                                     start bit is not 0                                                        */
  FLEXIO_SHIFTCFG1_SSTART_11           = 3,     /*!< 11 : Transmitter outputs start bit value 1 before loading data
                                                     on first shift, receiver/match store sets error flag if
                                                     start bit is not 1                                                        */
} FLEXIO_SHIFTCFG1_SSTART_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCFG1 SSTOP [4..5]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG1_SSTOP                                                    */
  FLEXIO_SHIFTCFG1_SSTOP_0             = 0,     /*!< 0 : Stop bit disabled for transmitter/receiver/match store                */
  FLEXIO_SHIFTCFG1_SSTOP_1             = 1,     /*!< 1 : Reserved for transmitter/receiver/match store                         */
  FLEXIO_SHIFTCFG1_SSTOP_10            = 2,     /*!< 10 : Transmitter outputs stop bit value 0 on store, receiver/match
                                                     store sets error flag if stop bit is not 0                                */
  FLEXIO_SHIFTCFG1_SSTOP_11            = 3,     /*!< 11 : Transmitter outputs stop bit value 1 on store, receiver/match
                                                     store sets error flag if stop bit is not 1                                */
} FLEXIO_SHIFTCFG1_SSTOP_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCFG1 INSRC [8..8]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG1_INSRC                                                    */
  FLEXIO_SHIFTCFG1_INSRC_0             = 0,     /*!< 0 : Pin                                                                   */
  FLEXIO_SHIFTCFG1_INSRC_1             = 1,     /*!< 1 : Shifter N+1 Output                                                    */
} FLEXIO_SHIFTCFG1_INSRC_Enum;

/* ===================================================  FLEXIO_SHIFTCFG2  ==================================================== */
/* =========================================  FLEXIO FLEXIO_SHIFTCFG2 SSTART [0..1]  ========================================= */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG2_SSTART                                                   */
  FLEXIO_SHIFTCFG2_SSTART_0            = 0,     /*!< 0 : Start bit disabled for transmitter/receiver/match store,
                                                     transmitter loads data on enable                                          */
  FLEXIO_SHIFTCFG2_SSTART_1            = 1,     /*!< 1 : Start bit disabled for transmitter/receiver/match store,
                                                     transmitter loads data on first shift                                     */
  FLEXIO_SHIFTCFG2_SSTART_10           = 2,     /*!< 10 : Transmitter outputs start bit value 0 before loading data
                                                     on first shift, receiver/match store sets error flag if
                                                     start bit is not 0                                                        */
  FLEXIO_SHIFTCFG2_SSTART_11           = 3,     /*!< 11 : Transmitter outputs start bit value 1 before loading data
                                                     on first shift, receiver/match store sets error flag if
                                                     start bit is not 1                                                        */
} FLEXIO_SHIFTCFG2_SSTART_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCFG2 SSTOP [4..5]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG2_SSTOP                                                    */
  FLEXIO_SHIFTCFG2_SSTOP_0             = 0,     /*!< 0 : Stop bit disabled for transmitter/receiver/match store                */
  FLEXIO_SHIFTCFG2_SSTOP_1             = 1,     /*!< 1 : Reserved for transmitter/receiver/match store                         */
  FLEXIO_SHIFTCFG2_SSTOP_10            = 2,     /*!< 10 : Transmitter outputs stop bit value 0 on store, receiver/match
                                                     store sets error flag if stop bit is not 0                                */
  FLEXIO_SHIFTCFG2_SSTOP_11            = 3,     /*!< 11 : Transmitter outputs stop bit value 1 on store, receiver/match
                                                     store sets error flag if stop bit is not 1                                */
} FLEXIO_SHIFTCFG2_SSTOP_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCFG2 INSRC [8..8]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG2_INSRC                                                    */
  FLEXIO_SHIFTCFG2_INSRC_0             = 0,     /*!< 0 : Pin                                                                   */
  FLEXIO_SHIFTCFG2_INSRC_1             = 1,     /*!< 1 : Shifter N+1 Output                                                    */
} FLEXIO_SHIFTCFG2_INSRC_Enum;

/* ===================================================  FLEXIO_SHIFTCFG3  ==================================================== */
/* =========================================  FLEXIO FLEXIO_SHIFTCFG3 SSTART [0..1]  ========================================= */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG3_SSTART                                                   */
  FLEXIO_SHIFTCFG3_SSTART_0            = 0,     /*!< 0 : Start bit disabled for transmitter/receiver/match store,
                                                     transmitter loads data on enable                                          */
  FLEXIO_SHIFTCFG3_SSTART_1            = 1,     /*!< 1 : Start bit disabled for transmitter/receiver/match store,
                                                     transmitter loads data on first shift                                     */
  FLEXIO_SHIFTCFG3_SSTART_10           = 2,     /*!< 10 : Transmitter outputs start bit value 0 before loading data
                                                     on first shift, receiver/match store sets error flag if
                                                     start bit is not 0                                                        */
  FLEXIO_SHIFTCFG3_SSTART_11           = 3,     /*!< 11 : Transmitter outputs start bit value 1 before loading data
                                                     on first shift, receiver/match store sets error flag if
                                                     start bit is not 1                                                        */
} FLEXIO_SHIFTCFG3_SSTART_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCFG3 SSTOP [4..5]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG3_SSTOP                                                    */
  FLEXIO_SHIFTCFG3_SSTOP_0             = 0,     /*!< 0 : Stop bit disabled for transmitter/receiver/match store                */
  FLEXIO_SHIFTCFG3_SSTOP_1             = 1,     /*!< 1 : Reserved for transmitter/receiver/match store                         */
  FLEXIO_SHIFTCFG3_SSTOP_10            = 2,     /*!< 10 : Transmitter outputs stop bit value 0 on store, receiver/match
                                                     store sets error flag if stop bit is not 0                                */
  FLEXIO_SHIFTCFG3_SSTOP_11            = 3,     /*!< 11 : Transmitter outputs stop bit value 1 on store, receiver/match
                                                     store sets error flag if stop bit is not 1                                */
} FLEXIO_SHIFTCFG3_SSTOP_Enum;

/* =========================================  FLEXIO FLEXIO_SHIFTCFG3 INSRC [8..8]  ========================================== */
typedef enum {                                  /*!< FLEXIO_SHIFTCFG3_INSRC                                                    */
  FLEXIO_SHIFTCFG3_INSRC_0             = 0,     /*!< 0 : Pin                                                                   */
  FLEXIO_SHIFTCFG3_INSRC_1             = 1,     /*!< 1 : Shifter N+1 Output                                                    */
} FLEXIO_SHIFTCFG3_INSRC_Enum;

/* ===================================================  FLEXIO_SHIFTBUF0  ==================================================== */
/* ===================================================  FLEXIO_SHIFTBUF1  ==================================================== */
/* ===================================================  FLEXIO_SHIFTBUF2  ==================================================== */
/* ===================================================  FLEXIO_SHIFTBUF3  ==================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBIS0  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBIS1  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBIS2  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBIS3  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBYS0  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBYS1  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBYS2  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBYS3  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBBS0  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBBS1  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBBS2  ================================================== */
/* ==================================================  FLEXIO_SHIFTBUFBBS3  ================================================== */
/* ====================================================  FLEXIO_TIMCTL0  ===================================================== */
/* ==========================================  FLEXIO FLEXIO_TIMCTL0 TIMOD [0..1]  =========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCTL0_TIMOD                                                      */
  FLEXIO_TIMCTL0_TIMOD_0               = 0,     /*!< 0 : Timer Disabled.                                                       */
  FLEXIO_TIMCTL0_TIMOD_1               = 1,     /*!< 1 : Dual 8-bit counters baud/bit mode.                                    */
  FLEXIO_TIMCTL0_TIMOD_10              = 2,     /*!< 10 : Dual 8-bit counters PWM mode.                                        */
  FLEXIO_TIMCTL0_TIMOD_11              = 3,     /*!< 11 : Single 16-bit counter mode.                                          */
} FLEXIO_TIMCTL0_TIMOD_Enum;

/* ==========================================  FLEXIO FLEXIO_TIMCTL0 PINPOL [7..7]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCTL0_PINPOL                                                     */
  FLEXIO_TIMCTL0_PINPOL_0              = 0,     /*!< 0 : Pin is active high                                                    */
  FLEXIO_TIMCTL0_PINPOL_1              = 1,     /*!< 1 : Pin is active low                                                     */
} FLEXIO_TIMCTL0_PINPOL_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL0 PINCFG [16..17]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL0_PINCFG                                                     */
  FLEXIO_TIMCTL0_PINCFG_0              = 0,     /*!< 0 : Timer pin output disabled                                             */
  FLEXIO_TIMCTL0_PINCFG_1              = 1,     /*!< 1 : Timer pin open drain or bidirectional output enable                   */
  FLEXIO_TIMCTL0_PINCFG_10             = 2,     /*!< 10 : Timer pin bidirectional output data                                  */
  FLEXIO_TIMCTL0_PINCFG_11             = 3,     /*!< 11 : Timer pin output                                                     */
} FLEXIO_TIMCTL0_PINCFG_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL0 TRGSRC [22..22]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL0_TRGSRC                                                     */
  FLEXIO_TIMCTL0_TRGSRC_0              = 0,     /*!< 0 : External trigger selected                                             */
  FLEXIO_TIMCTL0_TRGSRC_1              = 1,     /*!< 1 : Internal trigger selected                                             */
} FLEXIO_TIMCTL0_TRGSRC_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL0 TRGPOL [23..23]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL0_TRGPOL                                                     */
  FLEXIO_TIMCTL0_TRGPOL_0              = 0,     /*!< 0 : Trigger active high                                                   */
  FLEXIO_TIMCTL0_TRGPOL_1              = 1,     /*!< 1 : Trigger active low                                                    */
} FLEXIO_TIMCTL0_TRGPOL_Enum;

/* ====================================================  FLEXIO_TIMCTL1  ===================================================== */
/* ==========================================  FLEXIO FLEXIO_TIMCTL1 TIMOD [0..1]  =========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCTL1_TIMOD                                                      */
  FLEXIO_TIMCTL1_TIMOD_0               = 0,     /*!< 0 : Timer Disabled.                                                       */
  FLEXIO_TIMCTL1_TIMOD_1               = 1,     /*!< 1 : Dual 8-bit counters baud/bit mode.                                    */
  FLEXIO_TIMCTL1_TIMOD_10              = 2,     /*!< 10 : Dual 8-bit counters PWM mode.                                        */
  FLEXIO_TIMCTL1_TIMOD_11              = 3,     /*!< 11 : Single 16-bit counter mode.                                          */
} FLEXIO_TIMCTL1_TIMOD_Enum;

/* ==========================================  FLEXIO FLEXIO_TIMCTL1 PINPOL [7..7]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCTL1_PINPOL                                                     */
  FLEXIO_TIMCTL1_PINPOL_0              = 0,     /*!< 0 : Pin is active high                                                    */
  FLEXIO_TIMCTL1_PINPOL_1              = 1,     /*!< 1 : Pin is active low                                                     */
} FLEXIO_TIMCTL1_PINPOL_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL1 PINCFG [16..17]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL1_PINCFG                                                     */
  FLEXIO_TIMCTL1_PINCFG_0              = 0,     /*!< 0 : Timer pin output disabled                                             */
  FLEXIO_TIMCTL1_PINCFG_1              = 1,     /*!< 1 : Timer pin open drain or bidirectional output enable                   */
  FLEXIO_TIMCTL1_PINCFG_10             = 2,     /*!< 10 : Timer pin bidirectional output data                                  */
  FLEXIO_TIMCTL1_PINCFG_11             = 3,     /*!< 11 : Timer pin output                                                     */
} FLEXIO_TIMCTL1_PINCFG_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL1 TRGSRC [22..22]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL1_TRGSRC                                                     */
  FLEXIO_TIMCTL1_TRGSRC_0              = 0,     /*!< 0 : External trigger selected                                             */
  FLEXIO_TIMCTL1_TRGSRC_1              = 1,     /*!< 1 : Internal trigger selected                                             */
} FLEXIO_TIMCTL1_TRGSRC_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL1 TRGPOL [23..23]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL1_TRGPOL                                                     */
  FLEXIO_TIMCTL1_TRGPOL_0              = 0,     /*!< 0 : Trigger active high                                                   */
  FLEXIO_TIMCTL1_TRGPOL_1              = 1,     /*!< 1 : Trigger active low                                                    */
} FLEXIO_TIMCTL1_TRGPOL_Enum;

/* ====================================================  FLEXIO_TIMCTL2  ===================================================== */
/* ==========================================  FLEXIO FLEXIO_TIMCTL2 TIMOD [0..1]  =========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCTL2_TIMOD                                                      */
  FLEXIO_TIMCTL2_TIMOD_0               = 0,     /*!< 0 : Timer Disabled.                                                       */
  FLEXIO_TIMCTL2_TIMOD_1               = 1,     /*!< 1 : Dual 8-bit counters baud/bit mode.                                    */
  FLEXIO_TIMCTL2_TIMOD_10              = 2,     /*!< 10 : Dual 8-bit counters PWM mode.                                        */
  FLEXIO_TIMCTL2_TIMOD_11              = 3,     /*!< 11 : Single 16-bit counter mode.                                          */
} FLEXIO_TIMCTL2_TIMOD_Enum;

/* ==========================================  FLEXIO FLEXIO_TIMCTL2 PINPOL [7..7]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCTL2_PINPOL                                                     */
  FLEXIO_TIMCTL2_PINPOL_0              = 0,     /*!< 0 : Pin is active high                                                    */
  FLEXIO_TIMCTL2_PINPOL_1              = 1,     /*!< 1 : Pin is active low                                                     */
} FLEXIO_TIMCTL2_PINPOL_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL2 PINCFG [16..17]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL2_PINCFG                                                     */
  FLEXIO_TIMCTL2_PINCFG_0              = 0,     /*!< 0 : Timer pin output disabled                                             */
  FLEXIO_TIMCTL2_PINCFG_1              = 1,     /*!< 1 : Timer pin open drain or bidirectional output enable                   */
  FLEXIO_TIMCTL2_PINCFG_10             = 2,     /*!< 10 : Timer pin bidirectional output data                                  */
  FLEXIO_TIMCTL2_PINCFG_11             = 3,     /*!< 11 : Timer pin output                                                     */
} FLEXIO_TIMCTL2_PINCFG_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL2 TRGSRC [22..22]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL2_TRGSRC                                                     */
  FLEXIO_TIMCTL2_TRGSRC_0              = 0,     /*!< 0 : External trigger selected                                             */
  FLEXIO_TIMCTL2_TRGSRC_1              = 1,     /*!< 1 : Internal trigger selected                                             */
} FLEXIO_TIMCTL2_TRGSRC_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL2 TRGPOL [23..23]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL2_TRGPOL                                                     */
  FLEXIO_TIMCTL2_TRGPOL_0              = 0,     /*!< 0 : Trigger active high                                                   */
  FLEXIO_TIMCTL2_TRGPOL_1              = 1,     /*!< 1 : Trigger active low                                                    */
} FLEXIO_TIMCTL2_TRGPOL_Enum;

/* ====================================================  FLEXIO_TIMCTL3  ===================================================== */
/* ==========================================  FLEXIO FLEXIO_TIMCTL3 TIMOD [0..1]  =========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCTL3_TIMOD                                                      */
  FLEXIO_TIMCTL3_TIMOD_0               = 0,     /*!< 0 : Timer Disabled.                                                       */
  FLEXIO_TIMCTL3_TIMOD_1               = 1,     /*!< 1 : Dual 8-bit counters baud/bit mode.                                    */
  FLEXIO_TIMCTL3_TIMOD_10              = 2,     /*!< 10 : Dual 8-bit counters PWM mode.                                        */
  FLEXIO_TIMCTL3_TIMOD_11              = 3,     /*!< 11 : Single 16-bit counter mode.                                          */
} FLEXIO_TIMCTL3_TIMOD_Enum;

/* ==========================================  FLEXIO FLEXIO_TIMCTL3 PINPOL [7..7]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCTL3_PINPOL                                                     */
  FLEXIO_TIMCTL3_PINPOL_0              = 0,     /*!< 0 : Pin is active high                                                    */
  FLEXIO_TIMCTL3_PINPOL_1              = 1,     /*!< 1 : Pin is active low                                                     */
} FLEXIO_TIMCTL3_PINPOL_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL3 PINCFG [16..17]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL3_PINCFG                                                     */
  FLEXIO_TIMCTL3_PINCFG_0              = 0,     /*!< 0 : Timer pin output disabled                                             */
  FLEXIO_TIMCTL3_PINCFG_1              = 1,     /*!< 1 : Timer pin open drain or bidirectional output enable                   */
  FLEXIO_TIMCTL3_PINCFG_10             = 2,     /*!< 10 : Timer pin bidirectional output data                                  */
  FLEXIO_TIMCTL3_PINCFG_11             = 3,     /*!< 11 : Timer pin output                                                     */
} FLEXIO_TIMCTL3_PINCFG_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL3 TRGSRC [22..22]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL3_TRGSRC                                                     */
  FLEXIO_TIMCTL3_TRGSRC_0              = 0,     /*!< 0 : External trigger selected                                             */
  FLEXIO_TIMCTL3_TRGSRC_1              = 1,     /*!< 1 : Internal trigger selected                                             */
} FLEXIO_TIMCTL3_TRGSRC_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCTL3 TRGPOL [23..23]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCTL3_TRGPOL                                                     */
  FLEXIO_TIMCTL3_TRGPOL_0              = 0,     /*!< 0 : Trigger active high                                                   */
  FLEXIO_TIMCTL3_TRGPOL_1              = 1,     /*!< 1 : Trigger active low                                                    */
} FLEXIO_TIMCTL3_TRGPOL_Enum;

/* ====================================================  FLEXIO_TIMCFG0  ===================================================== */
/* ==========================================  FLEXIO FLEXIO_TIMCFG0 TSTART [1..1]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG0_TSTART                                                     */
  FLEXIO_TIMCFG0_TSTART_0              = 0,     /*!< 0 : Start bit disabled                                                    */
  FLEXIO_TIMCFG0_TSTART_1              = 1,     /*!< 1 : Start bit enabled                                                     */
} FLEXIO_TIMCFG0_TSTART_Enum;

/* ==========================================  FLEXIO FLEXIO_TIMCFG0 TSTOP [4..5]  =========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG0_TSTOP                                                      */
  FLEXIO_TIMCFG0_TSTOP_0               = 0,     /*!< 0 : Stop bit disabled                                                     */
  FLEXIO_TIMCFG0_TSTOP_1               = 1,     /*!< 1 : Stop bit is enabled on timer compare                                  */
  FLEXIO_TIMCFG0_TSTOP_10              = 2,     /*!< 10 : Stop bit is enabled on timer disable                                 */
  FLEXIO_TIMCFG0_TSTOP_11              = 3,     /*!< 11 : Stop bit is enabled on timer compare and timer disable               */
} FLEXIO_TIMCFG0_TSTOP_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG0 TIMENA [8..10]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG0_TIMENA                                                     */
  FLEXIO_TIMCFG0_TIMENA_0              = 0,     /*!< 0 : Timer always enabled                                                  */
  FLEXIO_TIMCFG0_TIMENA_1              = 1,     /*!< 1 : Timer enabled on Timer N-1 enable                                     */
  FLEXIO_TIMCFG0_TIMENA_10             = 2,     /*!< 10 : Timer enabled on Trigger high                                        */
  FLEXIO_TIMCFG0_TIMENA_11             = 3,     /*!< 11 : Timer enabled on Trigger high and Pin high                           */
  FLEXIO_TIMCFG0_TIMENA_100            = 4,     /*!< 100 : Timer enabled on Pin rising edge                                    */
  FLEXIO_TIMCFG0_TIMENA_101            = 5,     /*!< 101 : Timer enabled on Pin rising edge and Trigger high                   */
  FLEXIO_TIMCFG0_TIMENA_110            = 6,     /*!< 110 : Timer enabled on Trigger rising edge                                */
  FLEXIO_TIMCFG0_TIMENA_111            = 7,     /*!< 111 : Timer enabled on Trigger rising or falling edge                     */
} FLEXIO_TIMCFG0_TIMENA_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG0 TIMDIS [12..14]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG0_TIMDIS                                                     */
  FLEXIO_TIMCFG0_TIMDIS_0              = 0,     /*!< 0 : Timer never disabled                                                  */
  FLEXIO_TIMCFG0_TIMDIS_1              = 1,     /*!< 1 : Timer disabled on Timer N-1 disable                                   */
  FLEXIO_TIMCFG0_TIMDIS_10             = 2,     /*!< 10 : Timer disabled on Timer compare                                      */
  FLEXIO_TIMCFG0_TIMDIS_11             = 3,     /*!< 11 : Timer disabled on Timer compare and Trigger Low                      */
  FLEXIO_TIMCFG0_TIMDIS_100            = 4,     /*!< 100 : Timer disabled on Pin rising or falling edge                        */
  FLEXIO_TIMCFG0_TIMDIS_101            = 5,     /*!< 101 : Timer disabled on Pin rising or falling edge provided
                                                     Trigger is high                                                           */
  FLEXIO_TIMCFG0_TIMDIS_110            = 6,     /*!< 110 : Timer disabled on Trigger falling edge                              */
} FLEXIO_TIMCFG0_TIMDIS_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG0 TIMRST [16..18]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG0_TIMRST                                                     */
  FLEXIO_TIMCFG0_TIMRST_0              = 0,     /*!< 0 : Timer never reset                                                     */
  FLEXIO_TIMCFG0_TIMRST_10             = 2,     /*!< 10 : Timer reset on Timer Pin equal to Timer Output                       */
  FLEXIO_TIMCFG0_TIMRST_11             = 3,     /*!< 11 : Timer reset on Timer Trigger equal to Timer Output                   */
  FLEXIO_TIMCFG0_TIMRST_100            = 4,     /*!< 100 : Timer reset on Timer Pin rising edge                                */
  FLEXIO_TIMCFG0_TIMRST_110            = 6,     /*!< 110 : Timer reset on Trigger rising edge                                  */
  FLEXIO_TIMCFG0_TIMRST_111            = 7,     /*!< 111 : Timer reset on Trigger rising or falling edge                       */
} FLEXIO_TIMCFG0_TIMRST_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG0 TIMDEC [20..21]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG0_TIMDEC                                                     */
  FLEXIO_TIMCFG0_TIMDEC_0              = 0,     /*!< 0 : Decrement counter on FlexIO clock, Shift clock equals Timer
                                                     output.                                                                   */
  FLEXIO_TIMCFG0_TIMDEC_1              = 1,     /*!< 1 : Decrement counter on Trigger input (both edges), Shift clock
                                                     equals Timer output.                                                      */
  FLEXIO_TIMCFG0_TIMDEC_10             = 2,     /*!< 10 : Decrement counter on Pin input (both edges), Shift clock
                                                     equals Pin input.                                                         */
  FLEXIO_TIMCFG0_TIMDEC_11             = 3,     /*!< 11 : Decrement counter on Trigger input (both edges), Shift
                                                     clock equals Trigger input.                                               */
} FLEXIO_TIMCFG0_TIMDEC_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG0 TIMOUT [24..25]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG0_TIMOUT                                                     */
  FLEXIO_TIMCFG0_TIMOUT_0              = 0,     /*!< 0 : Timer output is logic one when enabled and is not affected
                                                     by timer reset                                                            */
  FLEXIO_TIMCFG0_TIMOUT_1              = 1,     /*!< 1 : Timer output is logic zero when enabled and is not affected
                                                     by timer reset                                                            */
  FLEXIO_TIMCFG0_TIMOUT_10             = 2,     /*!< 10 : Timer output is logic one when enabled and on timer reset            */
  FLEXIO_TIMCFG0_TIMOUT_11             = 3,     /*!< 11 : Timer output is logic zero when enabled and on timer reset           */
} FLEXIO_TIMCFG0_TIMOUT_Enum;

/* ====================================================  FLEXIO_TIMCFG1  ===================================================== */
/* ==========================================  FLEXIO FLEXIO_TIMCFG1 TSTART [1..1]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG1_TSTART                                                     */
  FLEXIO_TIMCFG1_TSTART_0              = 0,     /*!< 0 : Start bit disabled                                                    */
  FLEXIO_TIMCFG1_TSTART_1              = 1,     /*!< 1 : Start bit enabled                                                     */
} FLEXIO_TIMCFG1_TSTART_Enum;

/* ==========================================  FLEXIO FLEXIO_TIMCFG1 TSTOP [4..5]  =========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG1_TSTOP                                                      */
  FLEXIO_TIMCFG1_TSTOP_0               = 0,     /*!< 0 : Stop bit disabled                                                     */
  FLEXIO_TIMCFG1_TSTOP_1               = 1,     /*!< 1 : Stop bit is enabled on timer compare                                  */
  FLEXIO_TIMCFG1_TSTOP_10              = 2,     /*!< 10 : Stop bit is enabled on timer disable                                 */
  FLEXIO_TIMCFG1_TSTOP_11              = 3,     /*!< 11 : Stop bit is enabled on timer compare and timer disable               */
} FLEXIO_TIMCFG1_TSTOP_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG1 TIMENA [8..10]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG1_TIMENA                                                     */
  FLEXIO_TIMCFG1_TIMENA_0              = 0,     /*!< 0 : Timer always enabled                                                  */
  FLEXIO_TIMCFG1_TIMENA_1              = 1,     /*!< 1 : Timer enabled on Timer N-1 enable                                     */
  FLEXIO_TIMCFG1_TIMENA_10             = 2,     /*!< 10 : Timer enabled on Trigger high                                        */
  FLEXIO_TIMCFG1_TIMENA_11             = 3,     /*!< 11 : Timer enabled on Trigger high and Pin high                           */
  FLEXIO_TIMCFG1_TIMENA_100            = 4,     /*!< 100 : Timer enabled on Pin rising edge                                    */
  FLEXIO_TIMCFG1_TIMENA_101            = 5,     /*!< 101 : Timer enabled on Pin rising edge and Trigger high                   */
  FLEXIO_TIMCFG1_TIMENA_110            = 6,     /*!< 110 : Timer enabled on Trigger rising edge                                */
  FLEXIO_TIMCFG1_TIMENA_111            = 7,     /*!< 111 : Timer enabled on Trigger rising or falling edge                     */
} FLEXIO_TIMCFG1_TIMENA_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG1 TIMDIS [12..14]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG1_TIMDIS                                                     */
  FLEXIO_TIMCFG1_TIMDIS_0              = 0,     /*!< 0 : Timer never disabled                                                  */
  FLEXIO_TIMCFG1_TIMDIS_1              = 1,     /*!< 1 : Timer disabled on Timer N-1 disable                                   */
  FLEXIO_TIMCFG1_TIMDIS_10             = 2,     /*!< 10 : Timer disabled on Timer compare                                      */
  FLEXIO_TIMCFG1_TIMDIS_11             = 3,     /*!< 11 : Timer disabled on Timer compare and Trigger Low                      */
  FLEXIO_TIMCFG1_TIMDIS_100            = 4,     /*!< 100 : Timer disabled on Pin rising or falling edge                        */
  FLEXIO_TIMCFG1_TIMDIS_101            = 5,     /*!< 101 : Timer disabled on Pin rising or falling edge provided
                                                     Trigger is high                                                           */
  FLEXIO_TIMCFG1_TIMDIS_110            = 6,     /*!< 110 : Timer disabled on Trigger falling edge                              */
} FLEXIO_TIMCFG1_TIMDIS_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG1 TIMRST [16..18]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG1_TIMRST                                                     */
  FLEXIO_TIMCFG1_TIMRST_0              = 0,     /*!< 0 : Timer never reset                                                     */
  FLEXIO_TIMCFG1_TIMRST_10             = 2,     /*!< 10 : Timer reset on Timer Pin equal to Timer Output                       */
  FLEXIO_TIMCFG1_TIMRST_11             = 3,     /*!< 11 : Timer reset on Timer Trigger equal to Timer Output                   */
  FLEXIO_TIMCFG1_TIMRST_100            = 4,     /*!< 100 : Timer reset on Timer Pin rising edge                                */
  FLEXIO_TIMCFG1_TIMRST_110            = 6,     /*!< 110 : Timer reset on Trigger rising edge                                  */
  FLEXIO_TIMCFG1_TIMRST_111            = 7,     /*!< 111 : Timer reset on Trigger rising or falling edge                       */
} FLEXIO_TIMCFG1_TIMRST_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG1 TIMDEC [20..21]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG1_TIMDEC                                                     */
  FLEXIO_TIMCFG1_TIMDEC_0              = 0,     /*!< 0 : Decrement counter on FlexIO clock, Shift clock equals Timer
                                                     output.                                                                   */
  FLEXIO_TIMCFG1_TIMDEC_1              = 1,     /*!< 1 : Decrement counter on Trigger input (both edges), Shift clock
                                                     equals Timer output.                                                      */
  FLEXIO_TIMCFG1_TIMDEC_10             = 2,     /*!< 10 : Decrement counter on Pin input (both edges), Shift clock
                                                     equals Pin input.                                                         */
  FLEXIO_TIMCFG1_TIMDEC_11             = 3,     /*!< 11 : Decrement counter on Trigger input (both edges), Shift
                                                     clock equals Trigger input.                                               */
} FLEXIO_TIMCFG1_TIMDEC_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG1 TIMOUT [24..25]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG1_TIMOUT                                                     */
  FLEXIO_TIMCFG1_TIMOUT_0              = 0,     /*!< 0 : Timer output is logic one when enabled and is not affected
                                                     by timer reset                                                            */
  FLEXIO_TIMCFG1_TIMOUT_1              = 1,     /*!< 1 : Timer output is logic zero when enabled and is not affected
                                                     by timer reset                                                            */
  FLEXIO_TIMCFG1_TIMOUT_10             = 2,     /*!< 10 : Timer output is logic one when enabled and on timer reset            */
  FLEXIO_TIMCFG1_TIMOUT_11             = 3,     /*!< 11 : Timer output is logic zero when enabled and on timer reset           */
} FLEXIO_TIMCFG1_TIMOUT_Enum;

/* ====================================================  FLEXIO_TIMCFG2  ===================================================== */
/* ==========================================  FLEXIO FLEXIO_TIMCFG2 TSTART [1..1]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG2_TSTART                                                     */
  FLEXIO_TIMCFG2_TSTART_0              = 0,     /*!< 0 : Start bit disabled                                                    */
  FLEXIO_TIMCFG2_TSTART_1              = 1,     /*!< 1 : Start bit enabled                                                     */
} FLEXIO_TIMCFG2_TSTART_Enum;

/* ==========================================  FLEXIO FLEXIO_TIMCFG2 TSTOP [4..5]  =========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG2_TSTOP                                                      */
  FLEXIO_TIMCFG2_TSTOP_0               = 0,     /*!< 0 : Stop bit disabled                                                     */
  FLEXIO_TIMCFG2_TSTOP_1               = 1,     /*!< 1 : Stop bit is enabled on timer compare                                  */
  FLEXIO_TIMCFG2_TSTOP_10              = 2,     /*!< 10 : Stop bit is enabled on timer disable                                 */
  FLEXIO_TIMCFG2_TSTOP_11              = 3,     /*!< 11 : Stop bit is enabled on timer compare and timer disable               */
} FLEXIO_TIMCFG2_TSTOP_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG2 TIMENA [8..10]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG2_TIMENA                                                     */
  FLEXIO_TIMCFG2_TIMENA_0              = 0,     /*!< 0 : Timer always enabled                                                  */
  FLEXIO_TIMCFG2_TIMENA_1              = 1,     /*!< 1 : Timer enabled on Timer N-1 enable                                     */
  FLEXIO_TIMCFG2_TIMENA_10             = 2,     /*!< 10 : Timer enabled on Trigger high                                        */
  FLEXIO_TIMCFG2_TIMENA_11             = 3,     /*!< 11 : Timer enabled on Trigger high and Pin high                           */
  FLEXIO_TIMCFG2_TIMENA_100            = 4,     /*!< 100 : Timer enabled on Pin rising edge                                    */
  FLEXIO_TIMCFG2_TIMENA_101            = 5,     /*!< 101 : Timer enabled on Pin rising edge and Trigger high                   */
  FLEXIO_TIMCFG2_TIMENA_110            = 6,     /*!< 110 : Timer enabled on Trigger rising edge                                */
  FLEXIO_TIMCFG2_TIMENA_111            = 7,     /*!< 111 : Timer enabled on Trigger rising or falling edge                     */
} FLEXIO_TIMCFG2_TIMENA_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG2 TIMDIS [12..14]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG2_TIMDIS                                                     */
  FLEXIO_TIMCFG2_TIMDIS_0              = 0,     /*!< 0 : Timer never disabled                                                  */
  FLEXIO_TIMCFG2_TIMDIS_1              = 1,     /*!< 1 : Timer disabled on Timer N-1 disable                                   */
  FLEXIO_TIMCFG2_TIMDIS_10             = 2,     /*!< 10 : Timer disabled on Timer compare                                      */
  FLEXIO_TIMCFG2_TIMDIS_11             = 3,     /*!< 11 : Timer disabled on Timer compare and Trigger Low                      */
  FLEXIO_TIMCFG2_TIMDIS_100            = 4,     /*!< 100 : Timer disabled on Pin rising or falling edge                        */
  FLEXIO_TIMCFG2_TIMDIS_101            = 5,     /*!< 101 : Timer disabled on Pin rising or falling edge provided
                                                     Trigger is high                                                           */
  FLEXIO_TIMCFG2_TIMDIS_110            = 6,     /*!< 110 : Timer disabled on Trigger falling edge                              */
} FLEXIO_TIMCFG2_TIMDIS_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG2 TIMRST [16..18]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG2_TIMRST                                                     */
  FLEXIO_TIMCFG2_TIMRST_0              = 0,     /*!< 0 : Timer never reset                                                     */
  FLEXIO_TIMCFG2_TIMRST_10             = 2,     /*!< 10 : Timer reset on Timer Pin equal to Timer Output                       */
  FLEXIO_TIMCFG2_TIMRST_11             = 3,     /*!< 11 : Timer reset on Timer Trigger equal to Timer Output                   */
  FLEXIO_TIMCFG2_TIMRST_100            = 4,     /*!< 100 : Timer reset on Timer Pin rising edge                                */
  FLEXIO_TIMCFG2_TIMRST_110            = 6,     /*!< 110 : Timer reset on Trigger rising edge                                  */
  FLEXIO_TIMCFG2_TIMRST_111            = 7,     /*!< 111 : Timer reset on Trigger rising or falling edge                       */
} FLEXIO_TIMCFG2_TIMRST_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG2 TIMDEC [20..21]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG2_TIMDEC                                                     */
  FLEXIO_TIMCFG2_TIMDEC_0              = 0,     /*!< 0 : Decrement counter on FlexIO clock, Shift clock equals Timer
                                                     output.                                                                   */
  FLEXIO_TIMCFG2_TIMDEC_1              = 1,     /*!< 1 : Decrement counter on Trigger input (both edges), Shift clock
                                                     equals Timer output.                                                      */
  FLEXIO_TIMCFG2_TIMDEC_10             = 2,     /*!< 10 : Decrement counter on Pin input (both edges), Shift clock
                                                     equals Pin input.                                                         */
  FLEXIO_TIMCFG2_TIMDEC_11             = 3,     /*!< 11 : Decrement counter on Trigger input (both edges), Shift
                                                     clock equals Trigger input.                                               */
} FLEXIO_TIMCFG2_TIMDEC_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG2 TIMOUT [24..25]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG2_TIMOUT                                                     */
  FLEXIO_TIMCFG2_TIMOUT_0              = 0,     /*!< 0 : Timer output is logic one when enabled and is not affected
                                                     by timer reset                                                            */
  FLEXIO_TIMCFG2_TIMOUT_1              = 1,     /*!< 1 : Timer output is logic zero when enabled and is not affected
                                                     by timer reset                                                            */
  FLEXIO_TIMCFG2_TIMOUT_10             = 2,     /*!< 10 : Timer output is logic one when enabled and on timer reset            */
  FLEXIO_TIMCFG2_TIMOUT_11             = 3,     /*!< 11 : Timer output is logic zero when enabled and on timer reset           */
} FLEXIO_TIMCFG2_TIMOUT_Enum;

/* ====================================================  FLEXIO_TIMCFG3  ===================================================== */
/* ==========================================  FLEXIO FLEXIO_TIMCFG3 TSTART [1..1]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG3_TSTART                                                     */
  FLEXIO_TIMCFG3_TSTART_0              = 0,     /*!< 0 : Start bit disabled                                                    */
  FLEXIO_TIMCFG3_TSTART_1              = 1,     /*!< 1 : Start bit enabled                                                     */
} FLEXIO_TIMCFG3_TSTART_Enum;

/* ==========================================  FLEXIO FLEXIO_TIMCFG3 TSTOP [4..5]  =========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG3_TSTOP                                                      */
  FLEXIO_TIMCFG3_TSTOP_0               = 0,     /*!< 0 : Stop bit disabled                                                     */
  FLEXIO_TIMCFG3_TSTOP_1               = 1,     /*!< 1 : Stop bit is enabled on timer compare                                  */
  FLEXIO_TIMCFG3_TSTOP_10              = 2,     /*!< 10 : Stop bit is enabled on timer disable                                 */
  FLEXIO_TIMCFG3_TSTOP_11              = 3,     /*!< 11 : Stop bit is enabled on timer compare and timer disable               */
} FLEXIO_TIMCFG3_TSTOP_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG3 TIMENA [8..10]  ========================================== */
typedef enum {                                  /*!< FLEXIO_TIMCFG3_TIMENA                                                     */
  FLEXIO_TIMCFG3_TIMENA_0              = 0,     /*!< 0 : Timer always enabled                                                  */
  FLEXIO_TIMCFG3_TIMENA_1              = 1,     /*!< 1 : Timer enabled on Timer N-1 enable                                     */
  FLEXIO_TIMCFG3_TIMENA_10             = 2,     /*!< 10 : Timer enabled on Trigger high                                        */
  FLEXIO_TIMCFG3_TIMENA_11             = 3,     /*!< 11 : Timer enabled on Trigger high and Pin high                           */
  FLEXIO_TIMCFG3_TIMENA_100            = 4,     /*!< 100 : Timer enabled on Pin rising edge                                    */
  FLEXIO_TIMCFG3_TIMENA_101            = 5,     /*!< 101 : Timer enabled on Pin rising edge and Trigger high                   */
  FLEXIO_TIMCFG3_TIMENA_110            = 6,     /*!< 110 : Timer enabled on Trigger rising edge                                */
  FLEXIO_TIMCFG3_TIMENA_111            = 7,     /*!< 111 : Timer enabled on Trigger rising or falling edge                     */
} FLEXIO_TIMCFG3_TIMENA_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG3 TIMDIS [12..14]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG3_TIMDIS                                                     */
  FLEXIO_TIMCFG3_TIMDIS_0              = 0,     /*!< 0 : Timer never disabled                                                  */
  FLEXIO_TIMCFG3_TIMDIS_1              = 1,     /*!< 1 : Timer disabled on Timer N-1 disable                                   */
  FLEXIO_TIMCFG3_TIMDIS_10             = 2,     /*!< 10 : Timer disabled on Timer compare                                      */
  FLEXIO_TIMCFG3_TIMDIS_11             = 3,     /*!< 11 : Timer disabled on Timer compare and Trigger Low                      */
  FLEXIO_TIMCFG3_TIMDIS_100            = 4,     /*!< 100 : Timer disabled on Pin rising or falling edge                        */
  FLEXIO_TIMCFG3_TIMDIS_101            = 5,     /*!< 101 : Timer disabled on Pin rising or falling edge provided
                                                     Trigger is high                                                           */
  FLEXIO_TIMCFG3_TIMDIS_110            = 6,     /*!< 110 : Timer disabled on Trigger falling edge                              */
} FLEXIO_TIMCFG3_TIMDIS_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG3 TIMRST [16..18]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG3_TIMRST                                                     */
  FLEXIO_TIMCFG3_TIMRST_0              = 0,     /*!< 0 : Timer never reset                                                     */
  FLEXIO_TIMCFG3_TIMRST_10             = 2,     /*!< 10 : Timer reset on Timer Pin equal to Timer Output                       */
  FLEXIO_TIMCFG3_TIMRST_11             = 3,     /*!< 11 : Timer reset on Timer Trigger equal to Timer Output                   */
  FLEXIO_TIMCFG3_TIMRST_100            = 4,     /*!< 100 : Timer reset on Timer Pin rising edge                                */
  FLEXIO_TIMCFG3_TIMRST_110            = 6,     /*!< 110 : Timer reset on Trigger rising edge                                  */
  FLEXIO_TIMCFG3_TIMRST_111            = 7,     /*!< 111 : Timer reset on Trigger rising or falling edge                       */
} FLEXIO_TIMCFG3_TIMRST_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG3 TIMDEC [20..21]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG3_TIMDEC                                                     */
  FLEXIO_TIMCFG3_TIMDEC_0              = 0,     /*!< 0 : Decrement counter on FlexIO clock, Shift clock equals Timer
                                                     output.                                                                   */
  FLEXIO_TIMCFG3_TIMDEC_1              = 1,     /*!< 1 : Decrement counter on Trigger input (both edges), Shift clock
                                                     equals Timer output.                                                      */
  FLEXIO_TIMCFG3_TIMDEC_10             = 2,     /*!< 10 : Decrement counter on Pin input (both edges), Shift clock
                                                     equals Pin input.                                                         */
  FLEXIO_TIMCFG3_TIMDEC_11             = 3,     /*!< 11 : Decrement counter on Trigger input (both edges), Shift
                                                     clock equals Trigger input.                                               */
} FLEXIO_TIMCFG3_TIMDEC_Enum;

/* =========================================  FLEXIO FLEXIO_TIMCFG3 TIMOUT [24..25]  ========================================= */
typedef enum {                                  /*!< FLEXIO_TIMCFG3_TIMOUT                                                     */
  FLEXIO_TIMCFG3_TIMOUT_0              = 0,     /*!< 0 : Timer output is logic one when enabled and is not affected
                                                     by timer reset                                                            */
  FLEXIO_TIMCFG3_TIMOUT_1              = 1,     /*!< 1 : Timer output is logic zero when enabled and is not affected
                                                     by timer reset                                                            */
  FLEXIO_TIMCFG3_TIMOUT_10             = 2,     /*!< 10 : Timer output is logic one when enabled and on timer reset            */
  FLEXIO_TIMCFG3_TIMOUT_11             = 3,     /*!< 11 : Timer output is logic zero when enabled and on timer reset           */
} FLEXIO_TIMCFG3_TIMOUT_Enum;

/* ====================================================  FLEXIO_TIMCMP0  ===================================================== */
/* ====================================================  FLEXIO_TIMCMP1  ===================================================== */
/* ====================================================  FLEXIO_TIMCMP2  ===================================================== */
/* ====================================================  FLEXIO_TIMCMP3  ===================================================== */


/* =========================================================================================================================== */
/* ================                                          TRGMUX                                           ================ */
/* =========================================================================================================================== */

/* ====================================================  TRGMUX_DMAMUX0  ===================================================== */
/* ===========================================  TRGMUX TRGMUX_DMAMUX0 LK [31..31]  =========================================== */
typedef enum {                                  /*!< TRGMUX_TRGMUX_DMAMUX0_LK                                                  */
  TRGMUX_TRGMUX_DMAMUX0_LK_0           = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_DMAMUX0_LK_1           = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_DMAMUX0_LK_Enum;

/* ====================================================  TRGMUX_EXTOUT0  ===================================================== */
/* ===========================================  TRGMUX TRGMUX_EXTOUT0 LK [31..31]  =========================================== */
typedef enum {                                  /*!< TRGMUX_TRGMUX_EXTOUT0_LK                                                  */
  TRGMUX_TRGMUX_EXTOUT0_LK_0           = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_EXTOUT0_LK_1           = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_EXTOUT0_LK_Enum;

/* ====================================================  TRGMUX_EXTOUT1  ===================================================== */
/* ===========================================  TRGMUX TRGMUX_EXTOUT1 LK [31..31]  =========================================== */
typedef enum {                                  /*!< TRGMUX_TRGMUX_EXTOUT1_LK                                                  */
  TRGMUX_TRGMUX_EXTOUT1_LK_0           = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_EXTOUT1_LK_1           = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_EXTOUT1_LK_Enum;

/* ======================================================  TRGMUX_ADC0  ====================================================== */
/* ============================================  TRGMUX TRGMUX_ADC0 LK [31..31]  ============================================= */
typedef enum {                                  /*!< TRGMUX_TRGMUX_ADC0_LK                                                     */
  TRGMUX_TRGMUX_ADC0_LK_0              = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_ADC0_LK_1              = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_ADC0_LK_Enum;

/* ======================================================  TRGMUX_CMP0  ====================================================== */
/* ============================================  TRGMUX TRGMUX_CMP0 LK [31..31]  ============================================= */
typedef enum {                                  /*!< TRGMUX_TRGMUX_CMP0_LK                                                     */
  TRGMUX_TRGMUX_CMP0_LK_0              = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_CMP0_LK_1              = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_CMP0_LK_Enum;

/* ======================================================  TRGMUX_FTM0  ====================================================== */
/* ============================================  TRGMUX TRGMUX_FTM0 LK [31..31]  ============================================= */
typedef enum {                                  /*!< TRGMUX_TRGMUX_FTM0_LK                                                     */
  TRGMUX_TRGMUX_FTM0_LK_0              = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_FTM0_LK_1              = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_FTM0_LK_Enum;

/* ======================================================  TRGMUX_FTM1  ====================================================== */
/* ============================================  TRGMUX TRGMUX_FTM1 LK [31..31]  ============================================= */
typedef enum {                                  /*!< TRGMUX_TRGMUX_FTM1_LK                                                     */
  TRGMUX_TRGMUX_FTM1_LK_0              = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_FTM1_LK_1              = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_FTM1_LK_Enum;

/* ======================================================  TRGMUX_PDB0  ====================================================== */
/* ============================================  TRGMUX TRGMUX_PDB0 LK [31..31]  ============================================= */
typedef enum {                                  /*!< TRGMUX_TRGMUX_PDB0_LK                                                     */
  TRGMUX_TRGMUX_PDB0_LK_0              = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_PDB0_LK_1              = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_PDB0_LK_Enum;

/* =====================================================  TRGMUX_FLEXIO  ===================================================== */
/* ===========================================  TRGMUX TRGMUX_FLEXIO LK [31..31]  ============================================ */
typedef enum {                                  /*!< TRGMUX_TRGMUX_FLEXIO_LK                                                   */
  TRGMUX_TRGMUX_FLEXIO_LK_0            = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_FLEXIO_LK_1            = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_FLEXIO_LK_Enum;

/* =====================================================  TRGMUX_LPIT0  ====================================================== */
/* ============================================  TRGMUX TRGMUX_LPIT0 LK [31..31]  ============================================ */
typedef enum {                                  /*!< TRGMUX_TRGMUX_LPIT0_LK                                                    */
  TRGMUX_TRGMUX_LPIT0_LK_0             = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_LPIT0_LK_1             = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_LPIT0_LK_Enum;

/* ====================================================  TRGMUX_LPUART0  ===================================================== */
/* ===========================================  TRGMUX TRGMUX_LPUART0 LK [31..31]  =========================================== */
typedef enum {                                  /*!< TRGMUX_TRGMUX_LPUART0_LK                                                  */
  TRGMUX_TRGMUX_LPUART0_LK_0           = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_LPUART0_LK_1           = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_LPUART0_LK_Enum;

/* ====================================================  TRGMUX_LPUART1  ===================================================== */
/* ===========================================  TRGMUX TRGMUX_LPUART1 LK [31..31]  =========================================== */
typedef enum {                                  /*!< TRGMUX_TRGMUX_LPUART1_LK                                                  */
  TRGMUX_TRGMUX_LPUART1_LK_0           = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_LPUART1_LK_1           = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_LPUART1_LK_Enum;

/* =====================================================  TRGMUX_LPI2C0  ===================================================== */
/* ===========================================  TRGMUX TRGMUX_LPI2C0 LK [31..31]  ============================================ */
typedef enum {                                  /*!< TRGMUX_TRGMUX_LPI2C0_LK                                                   */
  TRGMUX_TRGMUX_LPI2C0_LK_0            = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_LPI2C0_LK_1            = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_LPI2C0_LK_Enum;

/* =====================================================  TRGMUX_LPSPI0  ===================================================== */
/* ===========================================  TRGMUX TRGMUX_LPSPI0 LK [31..31]  ============================================ */
typedef enum {                                  /*!< TRGMUX_TRGMUX_LPSPI0_LK                                                   */
  TRGMUX_TRGMUX_LPSPI0_LK_0            = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_LPSPI0_LK_1            = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_LPSPI0_LK_Enum;

/* =====================================================  TRGMUX_LPTMR0  ===================================================== */
/* ===========================================  TRGMUX TRGMUX_LPTMR0 LK [31..31]  ============================================ */
typedef enum {                                  /*!< TRGMUX_TRGMUX_LPTMR0_LK                                                   */
  TRGMUX_TRGMUX_LPTMR0_LK_0            = 0,     /*!< 0 : Register can be written.                                              */
  TRGMUX_TRGMUX_LPTMR0_LK_1            = 1,     /*!< 1 : Register cannot be written until the next system Reset.               */
} TRGMUX_TRGMUX_LPTMR0_LK_Enum;



/* =========================================================================================================================== */
/* ================                                            SCG                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  SCG_VERID  ======================================================= */
/* =======================================================  SCG_PARAM  ======================================================= */
/* ========================================================  SCG_CSR  ======================================================== */
/* ==============================================  SCG SCG_CSR DIVSLOW [0..3]  =============================================== */
typedef enum {                                  /*!< SCG_CSR_DIVSLOW                                                           */
  SCG_CSR_DIVSLOW_0000                 = 0,     /*!< 0000 : Divide-by-1                                                        */
  SCG_CSR_DIVSLOW_0001                 = 1,     /*!< 0001 : Divide-by-2                                                        */
  SCG_CSR_DIVSLOW_0010                 = 2,     /*!< 0010 : Divide-by-3                                                        */
  SCG_CSR_DIVSLOW_0011                 = 3,     /*!< 0011 : Divide-by-4                                                        */
  SCG_CSR_DIVSLOW_0100                 = 4,     /*!< 0100 : Divide-by-5                                                        */
  SCG_CSR_DIVSLOW_0101                 = 5,     /*!< 0101 : Divide-by-6                                                        */
  SCG_CSR_DIVSLOW_0110                 = 6,     /*!< 0110 : Divide-by-7                                                        */
  SCG_CSR_DIVSLOW_0111                 = 7,     /*!< 0111 : Divide-by-8                                                        */
} SCG_CSR_DIVSLOW_Enum;

/* ===============================================  SCG SCG_CSR DIVBUS [4..7]  =============================================== */
typedef enum {                                  /*!< SCG_CSR_DIVBUS                                                            */
  SCG_CSR_DIVBUS_0000                  = 0,     /*!< 0000 : Divide-by-1                                                        */
  SCG_CSR_DIVBUS_0001                  = 1,     /*!< 0001 : Divide-by-2                                                        */
  SCG_CSR_DIVBUS_0010                  = 2,     /*!< 0010 : Divide-by-3                                                        */
  SCG_CSR_DIVBUS_0011                  = 3,     /*!< 0011 : Divide-by-4                                                        */
  SCG_CSR_DIVBUS_0100                  = 4,     /*!< 0100 : Divide-by-5                                                        */
  SCG_CSR_DIVBUS_0101                  = 5,     /*!< 0101 : Divide-by-6                                                        */
  SCG_CSR_DIVBUS_0110                  = 6,     /*!< 0110 : Divide-by-7                                                        */
  SCG_CSR_DIVBUS_0111                  = 7,     /*!< 0111 : Divide-by-8                                                        */
  SCG_CSR_DIVBUS_1000                  = 8,     /*!< 1000 : Divide-by-9                                                        */
  SCG_CSR_DIVBUS_1001                  = 9,     /*!< 1001 : Divide-by-10                                                       */
  SCG_CSR_DIVBUS_1010                  = 10,    /*!< 1010 : Divide-by-11                                                       */
  SCG_CSR_DIVBUS_1011                  = 11,    /*!< 1011 : Divide-by-12                                                       */
  SCG_CSR_DIVBUS_1100                  = 12,    /*!< 1100 : Divide-by-13                                                       */
  SCG_CSR_DIVBUS_1101                  = 13,    /*!< 1101 : Divide-by-14                                                       */
  SCG_CSR_DIVBUS_1110                  = 14,    /*!< 1110 : Divide-by-15                                                       */
  SCG_CSR_DIVBUS_1111                  = 15,    /*!< 1111 : Divide-by-16                                                       */
} SCG_CSR_DIVBUS_Enum;

/* =============================================  SCG SCG_CSR DIVCORE [16..19]  ============================================== */
typedef enum {                                  /*!< SCG_CSR_DIVCORE                                                           */
  SCG_CSR_DIVCORE_0000                 = 0,     /*!< 0000 : Divide-by-1                                                        */
  SCG_CSR_DIVCORE_0001                 = 1,     /*!< 0001 : Divide-by-2                                                        */
  SCG_CSR_DIVCORE_0010                 = 2,     /*!< 0010 : Divide-by-3                                                        */
  SCG_CSR_DIVCORE_0011                 = 3,     /*!< 0011 : Divide-by-4                                                        */
  SCG_CSR_DIVCORE_0100                 = 4,     /*!< 0100 : Divide-by-5                                                        */
  SCG_CSR_DIVCORE_0101                 = 5,     /*!< 0101 : Divide-by-6                                                        */
  SCG_CSR_DIVCORE_0110                 = 6,     /*!< 0110 : Divide-by-7                                                        */
  SCG_CSR_DIVCORE_0111                 = 7,     /*!< 0111 : Divide-by-8                                                        */
  SCG_CSR_DIVCORE_1000                 = 8,     /*!< 1000 : Divide-by-9                                                        */
  SCG_CSR_DIVCORE_1001                 = 9,     /*!< 1001 : Divide-by-10                                                       */
  SCG_CSR_DIVCORE_1010                 = 10,    /*!< 1010 : Divide-by-11                                                       */
  SCG_CSR_DIVCORE_1011                 = 11,    /*!< 1011 : Divide-by-12                                                       */
  SCG_CSR_DIVCORE_1100                 = 12,    /*!< 1100 : Divide-by-13                                                       */
  SCG_CSR_DIVCORE_1101                 = 13,    /*!< 1101 : Divide-by-14                                                       */
  SCG_CSR_DIVCORE_1110                 = 14,    /*!< 1110 : Divide-by-15                                                       */
  SCG_CSR_DIVCORE_1111                 = 15,    /*!< 1111 : Divide-by-16                                                       */
} SCG_CSR_DIVCORE_Enum;

/* ===============================================  SCG SCG_CSR SCS [24..27]  ================================================ */
typedef enum {                                  /*!< SCG_CSR_SCS                                                               */
  SCG_CSR_SCS_0001                     = 1,     /*!< 0001 : System OSC (SOSC_CLK)                                              */
  SCG_CSR_SCS_0010                     = 2,     /*!< 0010 : Slow IRC (SIRC_CLK)                                                */
  SCG_CSR_SCS_0011                     = 3,     /*!< 0011 : Fast IRC (FIRC_CLK)                                                */
} SCG_CSR_SCS_Enum;

/* =======================================================  SCG_RCCR  ======================================================== */
/* ==============================================  SCG SCG_RCCR DIVSLOW [0..3]  ============================================== */
typedef enum {                                  /*!< SCG_RCCR_DIVSLOW                                                          */
  SCG_RCCR_DIVSLOW_0000                = 0,     /*!< 0000 : Divide-by-1                                                        */
  SCG_RCCR_DIVSLOW_0001                = 1,     /*!< 0001 : Divide-by-2                                                        */
  SCG_RCCR_DIVSLOW_0010                = 2,     /*!< 0010 : Divide-by-3                                                        */
  SCG_RCCR_DIVSLOW_0011                = 3,     /*!< 0011 : Divide-by-4                                                        */
  SCG_RCCR_DIVSLOW_0100                = 4,     /*!< 0100 : Divide-by-5                                                        */
  SCG_RCCR_DIVSLOW_0101                = 5,     /*!< 0101 : Divide-by-6                                                        */
  SCG_RCCR_DIVSLOW_0110                = 6,     /*!< 0110 : Divide-by-7                                                        */
  SCG_RCCR_DIVSLOW_0111                = 7,     /*!< 0111 : Divide-by-8                                                        */
} SCG_RCCR_DIVSLOW_Enum;

/* ==============================================  SCG SCG_RCCR DIVBUS [4..7]  =============================================== */
typedef enum {                                  /*!< SCG_RCCR_DIVBUS                                                           */
  SCG_RCCR_DIVBUS_0000                 = 0,     /*!< 0000 : Divide-by-1                                                        */
  SCG_RCCR_DIVBUS_0001                 = 1,     /*!< 0001 : Divide-by-2                                                        */
  SCG_RCCR_DIVBUS_0010                 = 2,     /*!< 0010 : Divide-by-3                                                        */
  SCG_RCCR_DIVBUS_0011                 = 3,     /*!< 0011 : Divide-by-4                                                        */
  SCG_RCCR_DIVBUS_0100                 = 4,     /*!< 0100 : Divide-by-5                                                        */
  SCG_RCCR_DIVBUS_0101                 = 5,     /*!< 0101 : Divide-by-6                                                        */
  SCG_RCCR_DIVBUS_0110                 = 6,     /*!< 0110 : Divide-by-7                                                        */
  SCG_RCCR_DIVBUS_0111                 = 7,     /*!< 0111 : Divide-by-8                                                        */
  SCG_RCCR_DIVBUS_1000                 = 8,     /*!< 1000 : Divide-by-9                                                        */
  SCG_RCCR_DIVBUS_1001                 = 9,     /*!< 1001 : Divide-by-10                                                       */
  SCG_RCCR_DIVBUS_1010                 = 10,    /*!< 1010 : Divide-by-11                                                       */
  SCG_RCCR_DIVBUS_1011                 = 11,    /*!< 1011 : Divide-by-12                                                       */
  SCG_RCCR_DIVBUS_1100                 = 12,    /*!< 1100 : Divide-by-13                                                       */
  SCG_RCCR_DIVBUS_1101                 = 13,    /*!< 1101 : Divide-by-14                                                       */
  SCG_RCCR_DIVBUS_1110                 = 14,    /*!< 1110 : Divide-by-15                                                       */
  SCG_RCCR_DIVBUS_1111                 = 15,    /*!< 1111 : Divide-by-16                                                       */
} SCG_RCCR_DIVBUS_Enum;

/* =============================================  SCG SCG_RCCR DIVCORE [16..19]  ============================================= */
typedef enum {                                  /*!< SCG_RCCR_DIVCORE                                                          */
  SCG_RCCR_DIVCORE_0000                = 0,     /*!< 0000 : Divide-by-1                                                        */
  SCG_RCCR_DIVCORE_0001                = 1,     /*!< 0001 : Divide-by-2                                                        */
  SCG_RCCR_DIVCORE_0010                = 2,     /*!< 0010 : Divide-by-3                                                        */
  SCG_RCCR_DIVCORE_0011                = 3,     /*!< 0011 : Divide-by-4                                                        */
  SCG_RCCR_DIVCORE_0100                = 4,     /*!< 0100 : Divide-by-5                                                        */
  SCG_RCCR_DIVCORE_0101                = 5,     /*!< 0101 : Divide-by-6                                                        */
  SCG_RCCR_DIVCORE_0110                = 6,     /*!< 0110 : Divide-by-7                                                        */
  SCG_RCCR_DIVCORE_0111                = 7,     /*!< 0111 : Divide-by-8                                                        */
  SCG_RCCR_DIVCORE_1000                = 8,     /*!< 1000 : Divide-by-9                                                        */
  SCG_RCCR_DIVCORE_1001                = 9,     /*!< 1001 : Divide-by-10                                                       */
  SCG_RCCR_DIVCORE_1010                = 10,    /*!< 1010 : Divide-by-11                                                       */
  SCG_RCCR_DIVCORE_1011                = 11,    /*!< 1011 : Divide-by-12                                                       */
  SCG_RCCR_DIVCORE_1100                = 12,    /*!< 1100 : Divide-by-13                                                       */
  SCG_RCCR_DIVCORE_1101                = 13,    /*!< 1101 : Divide-by-14                                                       */
  SCG_RCCR_DIVCORE_1110                = 14,    /*!< 1110 : Divide-by-15                                                       */
  SCG_RCCR_DIVCORE_1111                = 15,    /*!< 1111 : Divide-by-16                                                       */
} SCG_RCCR_DIVCORE_Enum;

/* ===============================================  SCG SCG_RCCR SCS [24..27]  =============================================== */
typedef enum {                                  /*!< SCG_RCCR_SCS                                                              */
  SCG_RCCR_SCS_0001                    = 1,     /*!< 0001 : System OSC (SOSC_CLK)                                              */
  SCG_RCCR_SCS_0010                    = 2,     /*!< 0010 : Slow IRC (SIRC_CLK)                                                */
  SCG_RCCR_SCS_0011                    = 3,     /*!< 0011 : Fast IRC (FIRC_CLK)                                                */
} SCG_RCCR_SCS_Enum;

/* =======================================================  SCG_VCCR  ======================================================== */
/* ==============================================  SCG SCG_VCCR DIVSLOW [0..3]  ============================================== */
typedef enum {                                  /*!< SCG_VCCR_DIVSLOW                                                          */
  SCG_VCCR_DIVSLOW_0000                = 0,     /*!< 0000 : Divide-by-1                                                        */
  SCG_VCCR_DIVSLOW_0001                = 1,     /*!< 0001 : Divide-by-2                                                        */
  SCG_VCCR_DIVSLOW_0010                = 2,     /*!< 0010 : Divide-by-3                                                        */
  SCG_VCCR_DIVSLOW_0011                = 3,     /*!< 0011 : Divide-by-4                                                        */
  SCG_VCCR_DIVSLOW_0100                = 4,     /*!< 0100 : Divide-by-5                                                        */
  SCG_VCCR_DIVSLOW_0101                = 5,     /*!< 0101 : Divide-by-6                                                        */
  SCG_VCCR_DIVSLOW_0110                = 6,     /*!< 0110 : Divide-by-7                                                        */
  SCG_VCCR_DIVSLOW_0111                = 7,     /*!< 0111 : Divide-by-8                                                        */
} SCG_VCCR_DIVSLOW_Enum;

/* ==============================================  SCG SCG_VCCR DIVBUS [4..7]  =============================================== */
typedef enum {                                  /*!< SCG_VCCR_DIVBUS                                                           */
  SCG_VCCR_DIVBUS_0000                 = 0,     /*!< 0000 : Divide-by-1                                                        */
  SCG_VCCR_DIVBUS_0001                 = 1,     /*!< 0001 : Divide-by-2                                                        */
  SCG_VCCR_DIVBUS_0010                 = 2,     /*!< 0010 : Divide-by-3                                                        */
  SCG_VCCR_DIVBUS_0011                 = 3,     /*!< 0011 : Divide-by-4                                                        */
  SCG_VCCR_DIVBUS_0100                 = 4,     /*!< 0100 : Divide-by-5                                                        */
  SCG_VCCR_DIVBUS_0101                 = 5,     /*!< 0101 : Divide-by-6                                                        */
  SCG_VCCR_DIVBUS_0110                 = 6,     /*!< 0110 : Divide-by-7                                                        */
  SCG_VCCR_DIVBUS_0111                 = 7,     /*!< 0111 : Divide-by-8                                                        */
  SCG_VCCR_DIVBUS_1000                 = 8,     /*!< 1000 : Divide-by-9                                                        */
  SCG_VCCR_DIVBUS_1001                 = 9,     /*!< 1001 : Divide-by-10                                                       */
  SCG_VCCR_DIVBUS_1010                 = 10,    /*!< 1010 : Divide-by-11                                                       */
  SCG_VCCR_DIVBUS_1011                 = 11,    /*!< 1011 : Divide-by-12                                                       */
  SCG_VCCR_DIVBUS_1100                 = 12,    /*!< 1100 : Divide-by-13                                                       */
  SCG_VCCR_DIVBUS_1101                 = 13,    /*!< 1101 : Divide-by-14                                                       */
  SCG_VCCR_DIVBUS_1110                 = 14,    /*!< 1110 : Divide-by-15                                                       */
  SCG_VCCR_DIVBUS_1111                 = 15,    /*!< 1111 : Divide-by-16                                                       */
} SCG_VCCR_DIVBUS_Enum;

/* =============================================  SCG SCG_VCCR DIVCORE [16..19]  ============================================= */
typedef enum {                                  /*!< SCG_VCCR_DIVCORE                                                          */
  SCG_VCCR_DIVCORE_0000                = 0,     /*!< 0000 : Divide-by-1                                                        */
  SCG_VCCR_DIVCORE_0001                = 1,     /*!< 0001 : Divide-by-2                                                        */
  SCG_VCCR_DIVCORE_0010                = 2,     /*!< 0010 : Divide-by-3                                                        */
  SCG_VCCR_DIVCORE_0011                = 3,     /*!< 0011 : Divide-by-4                                                        */
  SCG_VCCR_DIVCORE_0100                = 4,     /*!< 0100 : Divide-by-5                                                        */
  SCG_VCCR_DIVCORE_0101                = 5,     /*!< 0101 : Divide-by-6                                                        */
  SCG_VCCR_DIVCORE_0110                = 6,     /*!< 0110 : Divide-by-7                                                        */
  SCG_VCCR_DIVCORE_0111                = 7,     /*!< 0111 : Divide-by-8                                                        */
  SCG_VCCR_DIVCORE_1000                = 8,     /*!< 1000 : Divide-by-9                                                        */
  SCG_VCCR_DIVCORE_1001                = 9,     /*!< 1001 : Divide-by-10                                                       */
  SCG_VCCR_DIVCORE_1010                = 10,    /*!< 1010 : Divide-by-11                                                       */
  SCG_VCCR_DIVCORE_1011                = 11,    /*!< 1011 : Divide-by-12                                                       */
  SCG_VCCR_DIVCORE_1100                = 12,    /*!< 1100 : Divide-by-13                                                       */
  SCG_VCCR_DIVCORE_1101                = 13,    /*!< 1101 : Divide-by-14                                                       */
  SCG_VCCR_DIVCORE_1110                = 14,    /*!< 1110 : Divide-by-15                                                       */
  SCG_VCCR_DIVCORE_1111                = 15,    /*!< 1111 : Divide-by-16                                                       */
} SCG_VCCR_DIVCORE_Enum;

/* ===============================================  SCG SCG_VCCR SCS [24..27]  =============================================== */
typedef enum {                                  /*!< SCG_VCCR_SCS                                                              */
  SCG_VCCR_SCS_0010                    = 2,     /*!< 0010 : Slow IRC (SIRC_CLK)                                                */
} SCG_VCCR_SCS_Enum;

/* ====================================================  SCG_CLKOUTCNFG  ===================================================== */
/* =========================================  SCG SCG_CLKOUTCNFG CLKOUTSEL [24..27]  ========================================= */
typedef enum {                                  /*!< SCG_CLKOUTCNFG_CLKOUTSEL                                                  */
  SCG_CLKOUTCNFG_CLKOUTSEL_0000        = 0,     /*!< 0000 : SCG SLOW Clock                                                     */
  SCG_CLKOUTCNFG_CLKOUTSEL_0001        = 1,     /*!< 0001 : System OSC (SOSC_CLK)                                              */
  SCG_CLKOUTCNFG_CLKOUTSEL_0010        = 2,     /*!< 0010 : Slow IRC (SIRC_CLK)                                                */
  SCG_CLKOUTCNFG_CLKOUTSEL_0011        = 3,     /*!< 0011 : Fast IRC (FIRC_CLK)                                                */
} SCG_CLKOUTCNFG_CLKOUTSEL_Enum;

/* ======================================================  SCG_SOSCCSR  ====================================================== */
/* =============================================  SCG SCG_SOSCCSR SOSCEN [0..0]  ============================================= */
typedef enum {                                  /*!< SCG_SOSCCSR_SOSCEN                                                        */
  SCG_SOSCCSR_SOSCEN_0                 = 0,     /*!< 0 : System OSC is disabled                                                */
  SCG_SOSCCSR_SOSCEN_1                 = 1,     /*!< 1 : System OSC is enabled                                                 */
} SCG_SOSCCSR_SOSCEN_Enum;

/* ============================================  SCG SCG_SOSCCSR SOSCCM [16..16]  ============================================ */
typedef enum {                                  /*!< SCG_SOSCCSR_SOSCCM                                                        */
  SCG_SOSCCSR_SOSCCM_0                 = 0,     /*!< 0 : System OSC Clock Monitor is disabled                                  */
  SCG_SOSCCSR_SOSCCM_1                 = 1,     /*!< 1 : System OSC Clock Monitor is enabled                                   */
} SCG_SOSCCSR_SOSCCM_Enum;

/* ===========================================  SCG SCG_SOSCCSR SOSCCMRE [17..17]  =========================================== */
typedef enum {                                  /*!< SCG_SOSCCSR_SOSCCMRE                                                      */
  SCG_SOSCCSR_SOSCCMRE_0               = 0,     /*!< 0 : Clock Monitor generates interrupt when error detected                 */
  SCG_SOSCCSR_SOSCCMRE_1               = 1,     /*!< 1 : Clock Monitor generates reset when error detected                     */
} SCG_SOSCCSR_SOSCCMRE_Enum;

/* ==============================================  SCG SCG_SOSCCSR LK [23..23]  ============================================== */
typedef enum {                                  /*!< SCG_SOSCCSR_LK                                                            */
  SCG_SOSCCSR_LK_0                     = 0,     /*!< 0 : This Control Status Register can be written.                          */
  SCG_SOSCCSR_LK_1                     = 1,     /*!< 1 : This Control Status Register cannot be written.                       */
} SCG_SOSCCSR_LK_Enum;

/* ===========================================  SCG SCG_SOSCCSR SOSCVLD [24..24]  ============================================ */
typedef enum {                                  /*!< SCG_SOSCCSR_SOSCVLD                                                       */
  SCG_SOSCCSR_SOSCVLD_0                = 0,     /*!< 0 : System OSC is not enabled or clock is not valid                       */
  SCG_SOSCCSR_SOSCVLD_1                = 1,     /*!< 1 : System OSC is enabled and output clock is valid                       */
} SCG_SOSCCSR_SOSCVLD_Enum;

/* ===========================================  SCG SCG_SOSCCSR SOSCSEL [25..25]  ============================================ */
typedef enum {                                  /*!< SCG_SOSCCSR_SOSCSEL                                                       */
  SCG_SOSCCSR_SOSCSEL_0                = 0,     /*!< 0 : System OSC is not the system clock source                             */
  SCG_SOSCCSR_SOSCSEL_1                = 1,     /*!< 1 : System OSC is the system clock source                                 */
} SCG_SOSCCSR_SOSCSEL_Enum;

/* ===========================================  SCG SCG_SOSCCSR SOSCERR [26..26]  ============================================ */
typedef enum {                                  /*!< SCG_SOSCCSR_SOSCERR                                                       */
  SCG_SOSCCSR_SOSCERR_0                = 0,     /*!< 0 : System OSC Clock Monitor is disabled or has not detected
                                                     an error                                                                  */
  SCG_SOSCCSR_SOSCERR_1                = 1,     /*!< 1 : System OSC Clock Monitor is enabled and detected an error             */
} SCG_SOSCCSR_SOSCERR_Enum;

/* ======================================================  SCG_SOSCDIV  ====================================================== */
/* ============================================  SCG SCG_SOSCDIV SOSCDIV1 [0..2]  ============================================ */
typedef enum {                                  /*!< SCG_SOSCDIV_SOSCDIV1                                                      */
  SCG_SOSCDIV_SOSCDIV1_000             = 0,     /*!< 000 : Output disabled                                                     */
  SCG_SOSCDIV_SOSCDIV1_001             = 1,     /*!< 001 : Divide by 1                                                         */
  SCG_SOSCDIV_SOSCDIV1_010             = 2,     /*!< 010 : Divide by 2                                                         */
  SCG_SOSCDIV_SOSCDIV1_011             = 3,     /*!< 011 : Divide by 4                                                         */
  SCG_SOSCDIV_SOSCDIV1_100             = 4,     /*!< 100 : Divide by 8                                                         */
  SCG_SOSCDIV_SOSCDIV1_101             = 5,     /*!< 101 : Divide by 16                                                        */
  SCG_SOSCDIV_SOSCDIV1_110             = 6,     /*!< 110 : Divide by 32                                                        */
  SCG_SOSCDIV_SOSCDIV1_111             = 7,     /*!< 111 : Divide by 64                                                        */
} SCG_SOSCDIV_SOSCDIV1_Enum;

/* ===========================================  SCG SCG_SOSCDIV SOSCDIV2 [8..10]  ============================================ */
typedef enum {                                  /*!< SCG_SOSCDIV_SOSCDIV2                                                      */
  SCG_SOSCDIV_SOSCDIV2_000             = 0,     /*!< 000 : Output disabled                                                     */
  SCG_SOSCDIV_SOSCDIV2_001             = 1,     /*!< 001 : Divide by 1                                                         */
  SCG_SOSCDIV_SOSCDIV2_010             = 2,     /*!< 010 : Divide by 2                                                         */
  SCG_SOSCDIV_SOSCDIV2_011             = 3,     /*!< 011 : Divide by 4                                                         */
  SCG_SOSCDIV_SOSCDIV2_100             = 4,     /*!< 100 : Divide by 8                                                         */
  SCG_SOSCDIV_SOSCDIV2_101             = 5,     /*!< 101 : Divide by 16                                                        */
  SCG_SOSCDIV_SOSCDIV2_110             = 6,     /*!< 110 : Divide by 32                                                        */
  SCG_SOSCDIV_SOSCDIV2_111             = 7,     /*!< 111 : Divide by 64                                                        */
} SCG_SOSCDIV_SOSCDIV2_Enum;

/* ======================================================  SCG_SOSCCFG  ====================================================== */
/* =============================================  SCG SCG_SOSCCFG EREFS [2..2]  ============================================== */
typedef enum {                                  /*!< SCG_SOSCCFG_EREFS                                                         */
  SCG_SOSCCFG_EREFS_0                  = 0,     /*!< 0 : External reference clock selected                                     */
  SCG_SOSCCFG_EREFS_1                  = 1,     /*!< 1 : Internal crystal oscillator of OSC selected.                          */
} SCG_SOSCCFG_EREFS_Enum;

/* ==============================================  SCG SCG_SOSCCFG HGO [3..3]  =============================================== */
typedef enum {                                  /*!< SCG_SOSCCFG_HGO                                                           */
  SCG_SOSCCFG_HGO_0                    = 0,     /*!< 0 : Configure crystal oscillator for low-gain operation                   */
  SCG_SOSCCFG_HGO_1                    = 1,     /*!< 1 : Configure crystal oscillator for high-gain operation                  */
} SCG_SOSCCFG_HGO_Enum;

/* =============================================  SCG SCG_SOSCCFG RANGE [4..5]  ============================================== */
typedef enum {                                  /*!< SCG_SOSCCFG_RANGE                                                         */
  SCG_SOSCCFG_RANGE_01                 = 1,     /*!< 01 : Low frequency range selected for the crystal oscillator              */
  SCG_SOSCCFG_RANGE_10                 = 2,     /*!< 10 : Medium frequency range selected for the crytstal oscillator          */
  SCG_SOSCCFG_RANGE_11                 = 3,     /*!< 11 : High frequency range selected for the crystal oscillator             */
} SCG_SOSCCFG_RANGE_Enum;

/* ======================================================  SCG_SIRCCSR  ====================================================== */
/* =============================================  SCG SCG_SIRCCSR SIRCEN [0..0]  ============================================= */
typedef enum {                                  /*!< SCG_SIRCCSR_SIRCEN                                                        */
  SCG_SIRCCSR_SIRCEN_0                 = 0,     /*!< 0 : Slow IRC is disabled                                                  */
  SCG_SIRCCSR_SIRCEN_1                 = 1,     /*!< 1 : Slow IRC is enabled                                                   */
} SCG_SIRCCSR_SIRCEN_Enum;

/* ============================================  SCG SCG_SIRCCSR SIRCSTEN [1..1]  ============================================ */
typedef enum {                                  /*!< SCG_SIRCCSR_SIRCSTEN                                                      */
  SCG_SIRCCSR_SIRCSTEN_0               = 0,     /*!< 0 : Slow IRC is disabled in supported Stop modes                          */
  SCG_SIRCCSR_SIRCSTEN_1               = 1,     /*!< 1 : Slow IRC is enabled in supported Stop modes                           */
} SCG_SIRCCSR_SIRCSTEN_Enum;

/* ============================================  SCG SCG_SIRCCSR SIRCLPEN [2..2]  ============================================ */
typedef enum {                                  /*!< SCG_SIRCCSR_SIRCLPEN                                                      */
  SCG_SIRCCSR_SIRCLPEN_0               = 0,     /*!< 0 : Slow IRC is disabled in VLP modes                                     */
  SCG_SIRCCSR_SIRCLPEN_1               = 1,     /*!< 1 : Slow IRC is enabled in VLP modes                                      */
} SCG_SIRCCSR_SIRCLPEN_Enum;

/* ==============================================  SCG SCG_SIRCCSR LK [23..23]  ============================================== */
typedef enum {                                  /*!< SCG_SIRCCSR_LK                                                            */
  SCG_SIRCCSR_LK_0                     = 0,     /*!< 0 : Control Status Register can be written.                               */
  SCG_SIRCCSR_LK_1                     = 1,     /*!< 1 : Control Status Register cannot be written.                            */
} SCG_SIRCCSR_LK_Enum;

/* ===========================================  SCG SCG_SIRCCSR SIRCVLD [24..24]  ============================================ */
typedef enum {                                  /*!< SCG_SIRCCSR_SIRCVLD                                                       */
  SCG_SIRCCSR_SIRCVLD_0                = 0,     /*!< 0 : Slow IRC is not enabled or clock is not valid                         */
  SCG_SIRCCSR_SIRCVLD_1                = 1,     /*!< 1 : Slow IRC is enabled and output clock is valid                         */
} SCG_SIRCCSR_SIRCVLD_Enum;

/* ===========================================  SCG SCG_SIRCCSR SIRCSEL [25..25]  ============================================ */
typedef enum {                                  /*!< SCG_SIRCCSR_SIRCSEL                                                       */
  SCG_SIRCCSR_SIRCSEL_0                = 0,     /*!< 0 : Slow IRC is not the system clock source                               */
  SCG_SIRCCSR_SIRCSEL_1                = 1,     /*!< 1 : Slow IRC is the system clock source                                   */
} SCG_SIRCCSR_SIRCSEL_Enum;

/* ======================================================  SCG_SIRCDIV  ====================================================== */
/* ============================================  SCG SCG_SIRCDIV SIRCDIV1 [0..2]  ============================================ */
typedef enum {                                  /*!< SCG_SIRCDIV_SIRCDIV1                                                      */
  SCG_SIRCDIV_SIRCDIV1_000             = 0,     /*!< 000 : Output disabled                                                     */
  SCG_SIRCDIV_SIRCDIV1_001             = 1,     /*!< 001 : Divide by 1                                                         */
  SCG_SIRCDIV_SIRCDIV1_010             = 2,     /*!< 010 : Divide by 2                                                         */
  SCG_SIRCDIV_SIRCDIV1_011             = 3,     /*!< 011 : Divide by 4                                                         */
  SCG_SIRCDIV_SIRCDIV1_100             = 4,     /*!< 100 : Divide by 8                                                         */
  SCG_SIRCDIV_SIRCDIV1_101             = 5,     /*!< 101 : Divide by 16                                                        */
  SCG_SIRCDIV_SIRCDIV1_110             = 6,     /*!< 110 : Divide by 32                                                        */
  SCG_SIRCDIV_SIRCDIV1_111             = 7,     /*!< 111 : Divide by 64                                                        */
} SCG_SIRCDIV_SIRCDIV1_Enum;

/* ===========================================  SCG SCG_SIRCDIV SIRCDIV2 [8..10]  ============================================ */
typedef enum {                                  /*!< SCG_SIRCDIV_SIRCDIV2                                                      */
  SCG_SIRCDIV_SIRCDIV2_000             = 0,     /*!< 000 : Output disabled                                                     */
  SCG_SIRCDIV_SIRCDIV2_001             = 1,     /*!< 001 : Divide by 1                                                         */
  SCG_SIRCDIV_SIRCDIV2_010             = 2,     /*!< 010 : Divide by 2                                                         */
  SCG_SIRCDIV_SIRCDIV2_011             = 3,     /*!< 011 : Divide by 4                                                         */
  SCG_SIRCDIV_SIRCDIV2_100             = 4,     /*!< 100 : Divide by 8                                                         */
  SCG_SIRCDIV_SIRCDIV2_101             = 5,     /*!< 101 : Divide by 16                                                        */
  SCG_SIRCDIV_SIRCDIV2_110             = 6,     /*!< 110 : Divide by 32                                                        */
  SCG_SIRCDIV_SIRCDIV2_111             = 7,     /*!< 111 : Divide by 64                                                        */
} SCG_SIRCDIV_SIRCDIV2_Enum;

/* ======================================================  SCG_SIRCCFG  ====================================================== */
/* =============================================  SCG SCG_SIRCCFG RANGE [0..0]  ============================================== */
typedef enum {                                  /*!< SCG_SIRCCFG_RANGE                                                         */
  SCG_SIRCCFG_RANGE_0                  = 0,     /*!< 0 : Slow IRC low range clock (2 MHz)                                      */
  SCG_SIRCCFG_RANGE_1                  = 1,     /*!< 1 : Slow IRC high range clock (8 MHz )                                    */
} SCG_SIRCCFG_RANGE_Enum;

/* ======================================================  SCG_FIRCCSR  ====================================================== */
/* =============================================  SCG SCG_FIRCCSR FIRCEN [0..0]  ============================================= */
typedef enum {                                  /*!< SCG_FIRCCSR_FIRCEN                                                        */
  SCG_FIRCCSR_FIRCEN_0                 = 0,     /*!< 0 : Fast IRC is disabled                                                  */
  SCG_FIRCCSR_FIRCEN_1                 = 1,     /*!< 1 : Fast IRC is enabled                                                   */
} SCG_FIRCCSR_FIRCEN_Enum;

/* ===========================================  SCG SCG_FIRCCSR FIRCREGOFF [3..3]  =========================================== */
typedef enum {                                  /*!< SCG_FIRCCSR_FIRCREGOFF                                                    */
  SCG_FIRCCSR_FIRCREGOFF_0             = 0,     /*!< 0 : Fast IRC Regulator is enabled.                                        */
  SCG_FIRCCSR_FIRCREGOFF_1             = 1,     /*!< 1 : Fast IRC Regulator is disabled.                                       */
} SCG_FIRCCSR_FIRCREGOFF_Enum;

/* ==============================================  SCG SCG_FIRCCSR LK [23..23]  ============================================== */
typedef enum {                                  /*!< SCG_FIRCCSR_LK                                                            */
  SCG_FIRCCSR_LK_0                     = 0,     /*!< 0 : Control Status Register can be written.                               */
  SCG_FIRCCSR_LK_1                     = 1,     /*!< 1 : Control Status Register cannot be written.                            */
} SCG_FIRCCSR_LK_Enum;

/* ===========================================  SCG SCG_FIRCCSR FIRCVLD [24..24]  ============================================ */
typedef enum {                                  /*!< SCG_FIRCCSR_FIRCVLD                                                       */
  SCG_FIRCCSR_FIRCVLD_0                = 0,     /*!< 0 : Fast IRC is not enabled or clock is not valid.                        */
  SCG_FIRCCSR_FIRCVLD_1                = 1,     /*!< 1 : Fast IRC is enabled and output clock is valid. The clock
                                                     is valid once there is an output clock from the FIRC analog.              */
} SCG_FIRCCSR_FIRCVLD_Enum;

/* ===========================================  SCG SCG_FIRCCSR FIRCSEL [25..25]  ============================================ */
typedef enum {                                  /*!< SCG_FIRCCSR_FIRCSEL                                                       */
  SCG_FIRCCSR_FIRCSEL_0                = 0,     /*!< 0 : Fast IRC is not the system clock source                               */
  SCG_FIRCCSR_FIRCSEL_1                = 1,     /*!< 1 : Fast IRC is the system clock source                                   */
} SCG_FIRCCSR_FIRCSEL_Enum;

/* ===========================================  SCG SCG_FIRCCSR FIRCERR [26..26]  ============================================ */
typedef enum {                                  /*!< SCG_FIRCCSR_FIRCERR                                                       */
  SCG_FIRCCSR_FIRCERR_0                = 0,     /*!< 0 : Error not detected with the Fast IRC trimming.                        */
  SCG_FIRCCSR_FIRCERR_1                = 1,     /*!< 1 : Error detected with the Fast IRC trimming.                            */
} SCG_FIRCCSR_FIRCERR_Enum;

/* ======================================================  SCG_FIRCDIV  ====================================================== */
/* ============================================  SCG SCG_FIRCDIV FIRCDIV1 [0..2]  ============================================ */
typedef enum {                                  /*!< SCG_FIRCDIV_FIRCDIV1                                                      */
  SCG_FIRCDIV_FIRCDIV1_000             = 0,     /*!< 000 : Output disabled                                                     */
  SCG_FIRCDIV_FIRCDIV1_001             = 1,     /*!< 001 : Divide by 1                                                         */
  SCG_FIRCDIV_FIRCDIV1_010             = 2,     /*!< 010 : Divide by 2                                                         */
  SCG_FIRCDIV_FIRCDIV1_011             = 3,     /*!< 011 : Divide by 4                                                         */
  SCG_FIRCDIV_FIRCDIV1_100             = 4,     /*!< 100 : Divide by 8                                                         */
  SCG_FIRCDIV_FIRCDIV1_101             = 5,     /*!< 101 : Divide by 16                                                        */
  SCG_FIRCDIV_FIRCDIV1_110             = 6,     /*!< 110 : Divide by 32                                                        */
  SCG_FIRCDIV_FIRCDIV1_111             = 7,     /*!< 111 : Divide by 64                                                        */
} SCG_FIRCDIV_FIRCDIV1_Enum;

/* ===========================================  SCG SCG_FIRCDIV FIRCDIV2 [8..10]  ============================================ */
typedef enum {                                  /*!< SCG_FIRCDIV_FIRCDIV2                                                      */
  SCG_FIRCDIV_FIRCDIV2_000             = 0,     /*!< 000 : Output disabled                                                     */
  SCG_FIRCDIV_FIRCDIV2_001             = 1,     /*!< 001 : Divide by 1                                                         */
  SCG_FIRCDIV_FIRCDIV2_010             = 2,     /*!< 010 : Divide by 2                                                         */
  SCG_FIRCDIV_FIRCDIV2_011             = 3,     /*!< 011 : Divide by 4                                                         */
  SCG_FIRCDIV_FIRCDIV2_100             = 4,     /*!< 100 : Divide by 8                                                         */
  SCG_FIRCDIV_FIRCDIV2_101             = 5,     /*!< 101 : Divide by 16                                                        */
  SCG_FIRCDIV_FIRCDIV2_110             = 6,     /*!< 110 : Divide by 32                                                        */
  SCG_FIRCDIV_FIRCDIV2_111             = 7,     /*!< 111 : Divide by 64                                                        */
} SCG_FIRCDIV_FIRCDIV2_Enum;

/* ======================================================  SCG_FIRCCFG  ====================================================== */
/* =============================================  SCG SCG_FIRCCFG RANGE [0..1]  ============================================== */
typedef enum {                                  /*!< SCG_FIRCCFG_RANGE                                                         */
  SCG_FIRCCFG_RANGE_00                 = 0,     /*!< 00 : Fast IRC is trimmed to 48 MHz                                        */
} SCG_FIRCCFG_RANGE_Enum;



/* =========================================================================================================================== */
/* ================                                            PCC                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  PCC_FTFC  ======================================================== */
/* ===============================================  PCC PCC_FTFC CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_FTFC_CGC                                                          */
  PCC_PCC_FTFC_CGC_0                   = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_FTFC_CGC_1                   = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_FTFC_CGC_Enum;

/* ===============================================  PCC PCC_FTFC PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_FTFC_PR                                                           */
  PCC_PCC_FTFC_PR_0                    = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_FTFC_PR_1                    = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_FTFC_PR_Enum;

/* ======================================================  PCC_DMAMUX  ======================================================= */
/* ==============================================  PCC PCC_DMAMUX CGC [30..30]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_DMAMUX_CGC                                                        */
  PCC_PCC_DMAMUX_CGC_0                 = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_DMAMUX_CGC_1                 = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_DMAMUX_CGC_Enum;

/* ==============================================  PCC PCC_DMAMUX PR [31..31]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_DMAMUX_PR                                                         */
  PCC_PCC_DMAMUX_PR_0                  = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_DMAMUX_PR_1                  = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_DMAMUX_PR_Enum;

/* =====================================================  PCC_FlexCAN0  ====================================================== */
/* =============================================  PCC PCC_FlexCAN0 CGC [30..30]  ============================================= */
typedef enum {                                  /*!< PCC_PCC_FlexCAN0_CGC                                                      */
  PCC_PCC_FlexCAN0_CGC_0               = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_FlexCAN0_CGC_1               = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_FlexCAN0_CGC_Enum;

/* =============================================  PCC PCC_FlexCAN0 PR [31..31]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_FlexCAN0_PR                                                       */
  PCC_PCC_FlexCAN0_PR_0                = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_FlexCAN0_PR_1                = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_FlexCAN0_PR_Enum;

/* ======================================================  PCC_LPSPI0  ======================================================= */
/* ==============================================  PCC PCC_LPSPI0 PCS [24..26]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPSPI0_PCS                                                        */
  PCC_PCC_LPSPI0_PCS_000               = 0,     /*!< 000 : Clock is off.                                                       */
  PCC_PCC_LPSPI0_PCS_001               = 1,     /*!< 001 : Clock option 1                                                      */
  PCC_PCC_LPSPI0_PCS_010               = 2,     /*!< 010 : Clock option 2                                                      */
  PCC_PCC_LPSPI0_PCS_011               = 3,     /*!< 011 : Clock option 3                                                      */
  PCC_PCC_LPSPI0_PCS_100               = 4,     /*!< 100 : Clock option 4                                                      */
  PCC_PCC_LPSPI0_PCS_101               = 5,     /*!< 101 : Clock option 5                                                      */
  PCC_PCC_LPSPI0_PCS_110               = 6,     /*!< 110 : Clock option 6                                                      */
  PCC_PCC_LPSPI0_PCS_111               = 7,     /*!< 111 : Clock option 7                                                      */
} PCC_PCC_LPSPI0_PCS_Enum;

/* ==============================================  PCC PCC_LPSPI0 CGC [30..30]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPSPI0_CGC                                                        */
  PCC_PCC_LPSPI0_CGC_0                 = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_LPSPI0_CGC_1                 = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_LPSPI0_CGC_Enum;

/* ==============================================  PCC PCC_LPSPI0 PR [31..31]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_LPSPI0_PR                                                         */
  PCC_PCC_LPSPI0_PR_0                  = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_LPSPI0_PR_1                  = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_LPSPI0_PR_Enum;

/* ========================================================  PCC_CRC  ======================================================== */
/* ===============================================  PCC PCC_CRC CGC [30..30]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_CRC_CGC                                                           */
  PCC_PCC_CRC_CGC_0                    = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_CRC_CGC_1                    = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_CRC_CGC_Enum;

/* ================================================  PCC PCC_CRC PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_CRC_PR                                                            */
  PCC_PCC_CRC_PR_0                     = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_CRC_PR_1                     = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_CRC_PR_Enum;

/* =======================================================  PCC_PDB0  ======================================================== */
/* ===============================================  PCC PCC_PDB0 CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PDB0_CGC                                                          */
  PCC_PCC_PDB0_CGC_0                   = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_PDB0_CGC_1                   = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_PDB0_CGC_Enum;

/* ===============================================  PCC PCC_PDB0 PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_PDB0_PR                                                           */
  PCC_PCC_PDB0_PR_0                    = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_PDB0_PR_1                    = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_PDB0_PR_Enum;

/* =======================================================  PCC_LPIT  ======================================================== */
/* ===============================================  PCC PCC_LPIT PCS [24..26]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_LPIT_PCS                                                          */
  PCC_PCC_LPIT_PCS_000                 = 0,     /*!< 000 : Clock is off.                                                       */
  PCC_PCC_LPIT_PCS_001                 = 1,     /*!< 001 : Clock option 1                                                      */
  PCC_PCC_LPIT_PCS_010                 = 2,     /*!< 010 : Clock option 2                                                      */
  PCC_PCC_LPIT_PCS_011                 = 3,     /*!< 011 : Clock option 3                                                      */
  PCC_PCC_LPIT_PCS_100                 = 4,     /*!< 100 : Clock option 4                                                      */
  PCC_PCC_LPIT_PCS_101                 = 5,     /*!< 101 : Clock option 5                                                      */
  PCC_PCC_LPIT_PCS_110                 = 6,     /*!< 110 : Clock option 6                                                      */
  PCC_PCC_LPIT_PCS_111                 = 7,     /*!< 111 : Clock option 7                                                      */
} PCC_PCC_LPIT_PCS_Enum;

/* ===============================================  PCC PCC_LPIT CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_LPIT_CGC                                                          */
  PCC_PCC_LPIT_CGC_0                   = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_LPIT_CGC_1                   = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_LPIT_CGC_Enum;

/* ===============================================  PCC PCC_LPIT PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_LPIT_PR                                                           */
  PCC_PCC_LPIT_PR_0                    = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_LPIT_PR_1                    = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_LPIT_PR_Enum;

/* =======================================================  PCC_FTM0  ======================================================== */
/* ===============================================  PCC PCC_FTM0 PCS [24..26]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_FTM0_PCS                                                          */
  PCC_PCC_FTM0_PCS_000                 = 0,     /*!< 000 : Clock is off. An external clock can be enabled for this
                                                     peripheral.                                                               */
  PCC_PCC_FTM0_PCS_001                 = 1,     /*!< 001 : Clock option 1                                                      */
  PCC_PCC_FTM0_PCS_010                 = 2,     /*!< 010 : Clock option 2                                                      */
  PCC_PCC_FTM0_PCS_011                 = 3,     /*!< 011 : Clock option 3                                                      */
  PCC_PCC_FTM0_PCS_100                 = 4,     /*!< 100 : Clock option 4                                                      */
  PCC_PCC_FTM0_PCS_101                 = 5,     /*!< 101 : Clock option 5                                                      */
  PCC_PCC_FTM0_PCS_110                 = 6,     /*!< 110 : Clock option 6                                                      */
  PCC_PCC_FTM0_PCS_111                 = 7,     /*!< 111 : Clock option 7                                                      */
} PCC_PCC_FTM0_PCS_Enum;

/* ===============================================  PCC PCC_FTM0 CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_FTM0_CGC                                                          */
  PCC_PCC_FTM0_CGC_0                   = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_FTM0_CGC_1                   = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_FTM0_CGC_Enum;

/* ===============================================  PCC PCC_FTM0 PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_FTM0_PR                                                           */
  PCC_PCC_FTM0_PR_0                    = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_FTM0_PR_1                    = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_FTM0_PR_Enum;

/* =======================================================  PCC_FTM1  ======================================================== */
/* ===============================================  PCC PCC_FTM1 PCS [24..26]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_FTM1_PCS                                                          */
  PCC_PCC_FTM1_PCS_000                 = 0,     /*!< 000 : Clock is off. An external clock can be enabled for this
                                                     peripheral.                                                               */
  PCC_PCC_FTM1_PCS_001                 = 1,     /*!< 001 : Clock option 1                                                      */
  PCC_PCC_FTM1_PCS_010                 = 2,     /*!< 010 : Clock option 2                                                      */
  PCC_PCC_FTM1_PCS_011                 = 3,     /*!< 011 : Clock option 3                                                      */
  PCC_PCC_FTM1_PCS_100                 = 4,     /*!< 100 : Clock option 4                                                      */
  PCC_PCC_FTM1_PCS_101                 = 5,     /*!< 101 : Clock option 5                                                      */
  PCC_PCC_FTM1_PCS_110                 = 6,     /*!< 110 : Clock option 6                                                      */
  PCC_PCC_FTM1_PCS_111                 = 7,     /*!< 111 : Clock option 7                                                      */
} PCC_PCC_FTM1_PCS_Enum;

/* ===============================================  PCC PCC_FTM1 CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_FTM1_CGC                                                          */
  PCC_PCC_FTM1_CGC_0                   = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_FTM1_CGC_1                   = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_FTM1_CGC_Enum;

/* ===============================================  PCC PCC_FTM1 PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_FTM1_PR                                                           */
  PCC_PCC_FTM1_PR_0                    = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_FTM1_PR_1                    = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_FTM1_PR_Enum;

/* =======================================================  PCC_ADC0  ======================================================== */
/* ===============================================  PCC PCC_ADC0 PCS [24..26]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_ADC0_PCS                                                          */
  PCC_PCC_ADC0_PCS_000                 = 0,     /*!< 000 : Clock is off.                                                       */
  PCC_PCC_ADC0_PCS_001                 = 1,     /*!< 001 : Clock option 1                                                      */
  PCC_PCC_ADC0_PCS_010                 = 2,     /*!< 010 : Clock option 2                                                      */
  PCC_PCC_ADC0_PCS_011                 = 3,     /*!< 011 : Clock option 3                                                      */
  PCC_PCC_ADC0_PCS_100                 = 4,     /*!< 100 : Clock option 4                                                      */
  PCC_PCC_ADC0_PCS_101                 = 5,     /*!< 101 : Clock option 5                                                      */
  PCC_PCC_ADC0_PCS_110                 = 6,     /*!< 110 : Clock option 6                                                      */
  PCC_PCC_ADC0_PCS_111                 = 7,     /*!< 111 : Clock option 7                                                      */
} PCC_PCC_ADC0_PCS_Enum;

/* ===============================================  PCC PCC_ADC0 CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_ADC0_CGC                                                          */
  PCC_PCC_ADC0_CGC_0                   = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_ADC0_CGC_1                   = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_ADC0_CGC_Enum;

/* ===============================================  PCC PCC_ADC0 PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_ADC0_PR                                                           */
  PCC_PCC_ADC0_PR_0                    = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_ADC0_PR_1                    = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_ADC0_PR_Enum;

/* ========================================================  PCC_RTC  ======================================================== */
/* ===============================================  PCC PCC_RTC CGC [30..30]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_RTC_CGC                                                           */
  PCC_PCC_RTC_CGC_0                    = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_RTC_CGC_1                    = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_RTC_CGC_Enum;

/* ================================================  PCC PCC_RTC PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_RTC_PR                                                            */
  PCC_PCC_RTC_PR_0                     = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_RTC_PR_1                     = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_RTC_PR_Enum;

/* =======================================================  PCC_CMU0  ======================================================== */
/* ===============================================  PCC PCC_CMU0 CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_CMU0_CGC                                                          */
  PCC_PCC_CMU0_CGC_0                   = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_CMU0_CGC_1                   = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_CMU0_CGC_Enum;

/* ===============================================  PCC PCC_CMU0 PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_CMU0_PR                                                           */
  PCC_PCC_CMU0_PR_0                    = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_CMU0_PR_1                    = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_CMU0_PR_Enum;

/* =======================================================  PCC_CMU1  ======================================================== */
/* ===============================================  PCC PCC_CMU1 CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_CMU1_CGC                                                          */
  PCC_PCC_CMU1_CGC_0                   = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_CMU1_CGC_1                   = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_CMU1_CGC_Enum;

/* ===============================================  PCC PCC_CMU1 PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_CMU1_PR                                                           */
  PCC_PCC_CMU1_PR_0                    = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_CMU1_PR_1                    = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_CMU1_PR_Enum;

/* ======================================================  PCC_LPTMR0  ======================================================= */
/* ===============================================  PCC PCC_LPTMR0 PCD [0..3]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_LPTMR0_PCD                                                        */
  PCC_PCC_LPTMR0_PCD_0000              = 0,     /*!< 0000 : Divide by 1.                                                       */
  PCC_PCC_LPTMR0_PCD_0001              = 1,     /*!< 0001 : Divide by 2.                                                       */
  PCC_PCC_LPTMR0_PCD_0010              = 2,     /*!< 0010 : Divide by 3.                                                       */
  PCC_PCC_LPTMR0_PCD_0011              = 3,     /*!< 0011 : Divide by 4.                                                       */
  PCC_PCC_LPTMR0_PCD_0100              = 4,     /*!< 0100 : Divide by 5.                                                       */
  PCC_PCC_LPTMR0_PCD_0101              = 5,     /*!< 0101 : Divide by 6.                                                       */
  PCC_PCC_LPTMR0_PCD_0110              = 6,     /*!< 0110 : Divide by 7.                                                       */
  PCC_PCC_LPTMR0_PCD_0111              = 7,     /*!< 0111 : Divide by 8.                                                       */
} PCC_PCC_LPTMR0_PCD_Enum;

/* ==============================================  PCC PCC_LPTMR0 FRAC [4..4]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_LPTMR0_FRAC                                                       */
  PCC_PCC_LPTMR0_FRAC_0                = 0,     /*!< 0 : Fractional value is 0.                                                */
  PCC_PCC_LPTMR0_FRAC_1                = 1,     /*!< 1 : Fractional value is 1.                                                */
} PCC_PCC_LPTMR0_FRAC_Enum;

/* ==============================================  PCC PCC_LPTMR0 PCS [24..26]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPTMR0_PCS                                                        */
  PCC_PCC_LPTMR0_PCS_000               = 0,     /*!< 000 : Clock is off.                                                       */
  PCC_PCC_LPTMR0_PCS_001               = 1,     /*!< 001 : Clock option 1                                                      */
  PCC_PCC_LPTMR0_PCS_010               = 2,     /*!< 010 : Clock option 2                                                      */
  PCC_PCC_LPTMR0_PCS_011               = 3,     /*!< 011 : Clock option 3                                                      */
  PCC_PCC_LPTMR0_PCS_100               = 4,     /*!< 100 : Clock option 4                                                      */
  PCC_PCC_LPTMR0_PCS_101               = 5,     /*!< 101 : Clock option 5                                                      */
  PCC_PCC_LPTMR0_PCS_110               = 6,     /*!< 110 : Clock option 6                                                      */
  PCC_PCC_LPTMR0_PCS_111               = 7,     /*!< 111 : Clock option 7                                                      */
} PCC_PCC_LPTMR0_PCS_Enum;

/* ==============================================  PCC PCC_LPTMR0 CGC [30..30]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPTMR0_CGC                                                        */
  PCC_PCC_LPTMR0_CGC_0                 = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_LPTMR0_CGC_1                 = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_LPTMR0_CGC_Enum;

/* ==============================================  PCC PCC_LPTMR0 PR [31..31]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_LPTMR0_PR                                                         */
  PCC_PCC_LPTMR0_PR_0                  = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_LPTMR0_PR_1                  = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_LPTMR0_PR_Enum;

/* =======================================================  PCC_PORTA  ======================================================= */
/* ==============================================  PCC PCC_PORTA CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PORTA_CGC                                                         */
  PCC_PCC_PORTA_CGC_0                  = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_PORTA_CGC_1                  = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_PORTA_CGC_Enum;

/* ===============================================  PCC PCC_PORTA PR [31..31]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PORTA_PR                                                          */
  PCC_PCC_PORTA_PR_0                   = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_PORTA_PR_1                   = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_PORTA_PR_Enum;

/* =======================================================  PCC_PORTB  ======================================================= */
/* ==============================================  PCC PCC_PORTB CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PORTB_CGC                                                         */
  PCC_PCC_PORTB_CGC_0                  = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_PORTB_CGC_1                  = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_PORTB_CGC_Enum;

/* ===============================================  PCC PCC_PORTB PR [31..31]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PORTB_PR                                                          */
  PCC_PCC_PORTB_PR_0                   = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_PORTB_PR_1                   = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_PORTB_PR_Enum;

/* =======================================================  PCC_PORTC  ======================================================= */
/* ==============================================  PCC PCC_PORTC CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PORTC_CGC                                                         */
  PCC_PCC_PORTC_CGC_0                  = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_PORTC_CGC_1                  = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_PORTC_CGC_Enum;

/* ===============================================  PCC PCC_PORTC PR [31..31]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PORTC_PR                                                          */
  PCC_PCC_PORTC_PR_0                   = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_PORTC_PR_1                   = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_PORTC_PR_Enum;

/* =======================================================  PCC_PORTD  ======================================================= */
/* ==============================================  PCC PCC_PORTD CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PORTD_CGC                                                         */
  PCC_PCC_PORTD_CGC_0                  = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_PORTD_CGC_1                  = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_PORTD_CGC_Enum;

/* ===============================================  PCC PCC_PORTD PR [31..31]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PORTD_PR                                                          */
  PCC_PCC_PORTD_PR_0                   = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_PORTD_PR_1                   = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_PORTD_PR_Enum;

/* =======================================================  PCC_PORTE  ======================================================= */
/* ==============================================  PCC PCC_PORTE CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PORTE_CGC                                                         */
  PCC_PCC_PORTE_CGC_0                  = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_PORTE_CGC_1                  = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_PORTE_CGC_Enum;

/* ===============================================  PCC PCC_PORTE PR [31..31]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_PORTE_PR                                                          */
  PCC_PCC_PORTE_PR_0                   = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_PORTE_PR_1                   = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_PORTE_PR_Enum;

/* ======================================================  PCC_FlexIO  ======================================================= */
/* ==============================================  PCC PCC_FlexIO PCS [24..26]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_FlexIO_PCS                                                        */
  PCC_PCC_FlexIO_PCS_000               = 0,     /*!< 000 : Clock is off.                                                       */
  PCC_PCC_FlexIO_PCS_001               = 1,     /*!< 001 : Clock option 1                                                      */
  PCC_PCC_FlexIO_PCS_010               = 2,     /*!< 010 : Clock option 2                                                      */
  PCC_PCC_FlexIO_PCS_011               = 3,     /*!< 011 : Clock option 3                                                      */
  PCC_PCC_FlexIO_PCS_100               = 4,     /*!< 100 : Clock option 4                                                      */
  PCC_PCC_FlexIO_PCS_101               = 5,     /*!< 101 : Clock option 5                                                      */
  PCC_PCC_FlexIO_PCS_110               = 6,     /*!< 110 : Clock option 6                                                      */
  PCC_PCC_FlexIO_PCS_111               = 7,     /*!< 111 : Clock option 7                                                      */
} PCC_PCC_FlexIO_PCS_Enum;

/* ==============================================  PCC PCC_FlexIO CGC [30..30]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_FlexIO_CGC                                                        */
  PCC_PCC_FlexIO_CGC_0                 = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_FlexIO_CGC_1                 = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_FlexIO_CGC_Enum;

/* ==============================================  PCC PCC_FlexIO PR [31..31]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_FlexIO_PR                                                         */
  PCC_PCC_FlexIO_PR_0                  = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_FlexIO_PR_1                  = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_FlexIO_PR_Enum;

/* ======================================================  PCC_LPI2C0  ======================================================= */
/* ==============================================  PCC PCC_LPI2C0 PCS [24..26]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPI2C0_PCS                                                        */
  PCC_PCC_LPI2C0_PCS_000               = 0,     /*!< 000 : Clock is off.                                                       */
  PCC_PCC_LPI2C0_PCS_001               = 1,     /*!< 001 : Clock option 1                                                      */
  PCC_PCC_LPI2C0_PCS_010               = 2,     /*!< 010 : Clock option 2                                                      */
  PCC_PCC_LPI2C0_PCS_011               = 3,     /*!< 011 : Clock option 3                                                      */
  PCC_PCC_LPI2C0_PCS_100               = 4,     /*!< 100 : Clock option 4                                                      */
  PCC_PCC_LPI2C0_PCS_101               = 5,     /*!< 101 : Clock option 5                                                      */
  PCC_PCC_LPI2C0_PCS_110               = 6,     /*!< 110 : Clock option 6                                                      */
  PCC_PCC_LPI2C0_PCS_111               = 7,     /*!< 111 : Clock option 7                                                      */
} PCC_PCC_LPI2C0_PCS_Enum;

/* ==============================================  PCC PCC_LPI2C0 CGC [30..30]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPI2C0_CGC                                                        */
  PCC_PCC_LPI2C0_CGC_0                 = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_LPI2C0_CGC_1                 = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_LPI2C0_CGC_Enum;

/* ==============================================  PCC PCC_LPI2C0 PR [31..31]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_LPI2C0_PR                                                         */
  PCC_PCC_LPI2C0_PR_0                  = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_LPI2C0_PR_1                  = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_LPI2C0_PR_Enum;

/* ======================================================  PCC_LPUART0  ====================================================== */
/* =============================================  PCC PCC_LPUART0 PCS [24..26]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPUART0_PCS                                                       */
  PCC_PCC_LPUART0_PCS_000              = 0,     /*!< 000 : Clock is off.                                                       */
  PCC_PCC_LPUART0_PCS_001              = 1,     /*!< 001 : Clock option 1                                                      */
  PCC_PCC_LPUART0_PCS_010              = 2,     /*!< 010 : Clock option 2                                                      */
  PCC_PCC_LPUART0_PCS_011              = 3,     /*!< 011 : Clock option 3                                                      */
  PCC_PCC_LPUART0_PCS_100              = 4,     /*!< 100 : Clock option 4                                                      */
  PCC_PCC_LPUART0_PCS_101              = 5,     /*!< 101 : Clock option 5                                                      */
  PCC_PCC_LPUART0_PCS_110              = 6,     /*!< 110 : Clock option 6                                                      */
  PCC_PCC_LPUART0_PCS_111              = 7,     /*!< 111 : Clock option 7                                                      */
} PCC_PCC_LPUART0_PCS_Enum;

/* =============================================  PCC PCC_LPUART0 CGC [30..30]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPUART0_CGC                                                       */
  PCC_PCC_LPUART0_CGC_0                = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_LPUART0_CGC_1                = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_LPUART0_CGC_Enum;

/* ==============================================  PCC PCC_LPUART0 PR [31..31]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPUART0_PR                                                        */
  PCC_PCC_LPUART0_PR_0                 = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_LPUART0_PR_1                 = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_LPUART0_PR_Enum;

/* ======================================================  PCC_LPUART1  ====================================================== */
/* =============================================  PCC PCC_LPUART1 PCS [24..26]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPUART1_PCS                                                       */
  PCC_PCC_LPUART1_PCS_000              = 0,     /*!< 000 : Clock is off.                                                       */
  PCC_PCC_LPUART1_PCS_001              = 1,     /*!< 001 : Clock option 1                                                      */
  PCC_PCC_LPUART1_PCS_010              = 2,     /*!< 010 : Clock option 2                                                      */
  PCC_PCC_LPUART1_PCS_011              = 3,     /*!< 011 : Clock option 3                                                      */
  PCC_PCC_LPUART1_PCS_100              = 4,     /*!< 100 : Clock option 4                                                      */
  PCC_PCC_LPUART1_PCS_101              = 5,     /*!< 101 : Clock option 5                                                      */
  PCC_PCC_LPUART1_PCS_110              = 6,     /*!< 110 : Clock option 6                                                      */
  PCC_PCC_LPUART1_PCS_111              = 7,     /*!< 111 : Clock option 7                                                      */
} PCC_PCC_LPUART1_PCS_Enum;

/* =============================================  PCC PCC_LPUART1 CGC [30..30]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPUART1_CGC                                                       */
  PCC_PCC_LPUART1_CGC_0                = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_LPUART1_CGC_1                = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_LPUART1_CGC_Enum;

/* ==============================================  PCC PCC_LPUART1 PR [31..31]  ============================================== */
typedef enum {                                  /*!< PCC_PCC_LPUART1_PR                                                        */
  PCC_PCC_LPUART1_PR_0                 = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_LPUART1_PR_1                 = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_LPUART1_PR_Enum;

/* =======================================================  PCC_CMP0  ======================================================== */
/* ===============================================  PCC PCC_CMP0 CGC [30..30]  =============================================== */
typedef enum {                                  /*!< PCC_PCC_CMP0_CGC                                                          */
  PCC_PCC_CMP0_CGC_0                   = 0,     /*!< 0 : Clock disabled                                                        */
  PCC_PCC_CMP0_CGC_1                   = 1,     /*!< 1 : Clock enabled. The current clock selection and divider options
                                                     are locked.                                                               */
} PCC_PCC_CMP0_CGC_Enum;

/* ===============================================  PCC PCC_CMP0 PR [31..31]  ================================================ */
typedef enum {                                  /*!< PCC_PCC_CMP0_PR                                                           */
  PCC_PCC_CMP0_PR_0                    = 0,     /*!< 0 : Peripheral is not present.                                            */
  PCC_PCC_CMP0_PR_1                    = 1,     /*!< 1 : Peripheral is present.                                                */
} PCC_PCC_CMP0_PR_Enum;



/* =========================================================================================================================== */
/* ================                                          LPI2C0                                           ================ */
/* =========================================================================================================================== */

/* =====================================================  LPI2C0_VERID  ====================================================== */
/* ==========================================  LPI2C0 LPI2C0_VERID FEATURE [0..15]  ========================================== */
typedef enum {                                  /*!< LPI2C0_VERID_FEATURE                                                      */
  LPI2C0_VERID_FEATURE_0000000000000010 = 2,    /*!< 0000000000000010 : Master only with standard feature set.                 */
  LPI2C0_VERID_FEATURE_0000000000000011 = 3,    /*!< 0000000000000011 : Master and slave with standard feature set.            */
} LPI2C0_VERID_FEATURE_Enum;

/* =====================================================  LPI2C0_PARAM  ====================================================== */
/* ======================================================  LPI2C0_MCR  ======================================================= */
/* =============================================  LPI2C0 LPI2C0_MCR MEN [0..0]  ============================================== */
typedef enum {                                  /*!< LPI2C0_MCR_MEN                                                            */
  LPI2C0_MCR_MEN_0                     = 0,     /*!< 0 : Master logic is disabled.                                             */
  LPI2C0_MCR_MEN_1                     = 1,     /*!< 1 : Master logic is enabled.                                              */
} LPI2C0_MCR_MEN_Enum;

/* =============================================  LPI2C0 LPI2C0_MCR RST [1..1]  ============================================== */
typedef enum {                                  /*!< LPI2C0_MCR_RST                                                            */
  LPI2C0_MCR_RST_0                     = 0,     /*!< 0 : Master logic is not reset.                                            */
  LPI2C0_MCR_RST_1                     = 1,     /*!< 1 : Master logic is reset.                                                */
} LPI2C0_MCR_RST_Enum;

/* ============================================  LPI2C0 LPI2C0_MCR DOZEN [2..2]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MCR_DOZEN                                                          */
  LPI2C0_MCR_DOZEN_0                   = 0,     /*!< 0 : Master is enabled in Doze mode.                                       */
  LPI2C0_MCR_DOZEN_1                   = 1,     /*!< 1 : Master is disabled in Doze mode.                                      */
} LPI2C0_MCR_DOZEN_Enum;

/* ============================================  LPI2C0 LPI2C0_MCR DBGEN [3..3]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MCR_DBGEN                                                          */
  LPI2C0_MCR_DBGEN_0                   = 0,     /*!< 0 : Master is disabled in debug mode.                                     */
  LPI2C0_MCR_DBGEN_1                   = 1,     /*!< 1 : Master is enabled in debug mode.                                      */
} LPI2C0_MCR_DBGEN_Enum;

/* =============================================  LPI2C0 LPI2C0_MCR RTF [8..8]  ============================================== */
typedef enum {                                  /*!< LPI2C0_MCR_RTF                                                            */
  LPI2C0_MCR_RTF_0                     = 0,     /*!< 0 : No effect.                                                            */
  LPI2C0_MCR_RTF_1                     = 1,     /*!< 1 : Transmit FIFO is reset.                                               */
} LPI2C0_MCR_RTF_Enum;

/* =============================================  LPI2C0 LPI2C0_MCR RRF [9..9]  ============================================== */
typedef enum {                                  /*!< LPI2C0_MCR_RRF                                                            */
  LPI2C0_MCR_RRF_0                     = 0,     /*!< 0 : No effect.                                                            */
  LPI2C0_MCR_RRF_1                     = 1,     /*!< 1 : Receive FIFO is reset.                                                */
} LPI2C0_MCR_RRF_Enum;

/* ======================================================  LPI2C0_MSR  ======================================================= */
/* =============================================  LPI2C0 LPI2C0_MSR TDF [0..0]  ============================================== */
typedef enum {                                  /*!< LPI2C0_MSR_TDF                                                            */
  LPI2C0_MSR_TDF_0                     = 0,     /*!< 0 : Transmit data not requested.                                          */
  LPI2C0_MSR_TDF_1                     = 1,     /*!< 1 : Transmit data is requested.                                           */
} LPI2C0_MSR_TDF_Enum;

/* =============================================  LPI2C0 LPI2C0_MSR RDF [1..1]  ============================================== */
typedef enum {                                  /*!< LPI2C0_MSR_RDF                                                            */
  LPI2C0_MSR_RDF_0                     = 0,     /*!< 0 : Receive Data is not ready.                                            */
  LPI2C0_MSR_RDF_1                     = 1,     /*!< 1 : Receive data is ready.                                                */
} LPI2C0_MSR_RDF_Enum;

/* =============================================  LPI2C0 LPI2C0_MSR EPF [8..8]  ============================================== */
typedef enum {                                  /*!< LPI2C0_MSR_EPF                                                            */
  LPI2C0_MSR_EPF_0                     = 0,     /*!< 0 : Master has not generated a STOP or Repeated START condition.          */
  LPI2C0_MSR_EPF_1                     = 1,     /*!< 1 : Master has generated a STOP or Repeated START condition.              */
} LPI2C0_MSR_EPF_Enum;

/* =============================================  LPI2C0 LPI2C0_MSR SDF [9..9]  ============================================== */
typedef enum {                                  /*!< LPI2C0_MSR_SDF                                                            */
  LPI2C0_MSR_SDF_0                     = 0,     /*!< 0 : Master has not generated a STOP condition.                            */
  LPI2C0_MSR_SDF_1                     = 1,     /*!< 1 : Master has generated a STOP condition.                                */
} LPI2C0_MSR_SDF_Enum;

/* ============================================  LPI2C0 LPI2C0_MSR NDF [10..10]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MSR_NDF                                                            */
  LPI2C0_MSR_NDF_0                     = 0,     /*!< 0 : Unexpected NACK not detected.                                         */
  LPI2C0_MSR_NDF_1                     = 1,     /*!< 1 : Unexpected NACK was detected.                                         */
} LPI2C0_MSR_NDF_Enum;

/* ============================================  LPI2C0 LPI2C0_MSR ALF [11..11]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MSR_ALF                                                            */
  LPI2C0_MSR_ALF_0                     = 0,     /*!< 0 : Master has not lost arbitration.                                      */
  LPI2C0_MSR_ALF_1                     = 1,     /*!< 1 : Master has lost arbitration.                                          */
} LPI2C0_MSR_ALF_Enum;

/* ============================================  LPI2C0 LPI2C0_MSR FEF [12..12]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MSR_FEF                                                            */
  LPI2C0_MSR_FEF_0                     = 0,     /*!< 0 : No error.                                                             */
  LPI2C0_MSR_FEF_1                     = 1,     /*!< 1 : Master sending or receiving data without START condition.             */
} LPI2C0_MSR_FEF_Enum;

/* ============================================  LPI2C0 LPI2C0_MSR PLTF [13..13]  ============================================ */
typedef enum {                                  /*!< LPI2C0_MSR_PLTF                                                           */
  LPI2C0_MSR_PLTF_0                    = 0,     /*!< 0 : Pin low timeout has not occurred or is disabled.                      */
  LPI2C0_MSR_PLTF_1                    = 1,     /*!< 1 : Pin low timeout has occurred.                                         */
} LPI2C0_MSR_PLTF_Enum;

/* ============================================  LPI2C0 LPI2C0_MSR DMF [14..14]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MSR_DMF                                                            */
  LPI2C0_MSR_DMF_0                     = 0,     /*!< 0 : Have not received matching data.                                      */
  LPI2C0_MSR_DMF_1                     = 1,     /*!< 1 : Have received matching data.                                          */
} LPI2C0_MSR_DMF_Enum;

/* ============================================  LPI2C0 LPI2C0_MSR MBF [24..24]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MSR_MBF                                                            */
  LPI2C0_MSR_MBF_0                     = 0,     /*!< 0 : I2C Master is idle.                                                   */
  LPI2C0_MSR_MBF_1                     = 1,     /*!< 1 : I2C Master is busy.                                                   */
} LPI2C0_MSR_MBF_Enum;

/* ============================================  LPI2C0 LPI2C0_MSR BBF [25..25]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MSR_BBF                                                            */
  LPI2C0_MSR_BBF_0                     = 0,     /*!< 0 : I2C Bus is idle.                                                      */
  LPI2C0_MSR_BBF_1                     = 1,     /*!< 1 : I2C Bus is busy.                                                      */
} LPI2C0_MSR_BBF_Enum;

/* ======================================================  LPI2C0_MIER  ====================================================== */
/* ============================================  LPI2C0 LPI2C0_MIER TDIE [0..0]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MIER_TDIE                                                          */
  LPI2C0_MIER_TDIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_MIER_TDIE_1                   = 1,     /*!< 1 : Interrupt enabled                                                     */
} LPI2C0_MIER_TDIE_Enum;

/* ============================================  LPI2C0 LPI2C0_MIER RDIE [1..1]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MIER_RDIE                                                          */
  LPI2C0_MIER_RDIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_MIER_RDIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_MIER_RDIE_Enum;

/* ============================================  LPI2C0 LPI2C0_MIER EPIE [8..8]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MIER_EPIE                                                          */
  LPI2C0_MIER_EPIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_MIER_EPIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_MIER_EPIE_Enum;

/* ============================================  LPI2C0 LPI2C0_MIER SDIE [9..9]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MIER_SDIE                                                          */
  LPI2C0_MIER_SDIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_MIER_SDIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_MIER_SDIE_Enum;

/* ===========================================  LPI2C0 LPI2C0_MIER NDIE [10..10]  ============================================ */
typedef enum {                                  /*!< LPI2C0_MIER_NDIE                                                          */
  LPI2C0_MIER_NDIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_MIER_NDIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_MIER_NDIE_Enum;

/* ===========================================  LPI2C0 LPI2C0_MIER ALIE [11..11]  ============================================ */
typedef enum {                                  /*!< LPI2C0_MIER_ALIE                                                          */
  LPI2C0_MIER_ALIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_MIER_ALIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_MIER_ALIE_Enum;

/* ===========================================  LPI2C0 LPI2C0_MIER FEIE [12..12]  ============================================ */
typedef enum {                                  /*!< LPI2C0_MIER_FEIE                                                          */
  LPI2C0_MIER_FEIE_0                   = 0,     /*!< 0 : Interrupt enabled.                                                    */
  LPI2C0_MIER_FEIE_1                   = 1,     /*!< 1 : Interrupt disabled.                                                   */
} LPI2C0_MIER_FEIE_Enum;

/* ===========================================  LPI2C0 LPI2C0_MIER PLTIE [13..13]  =========================================== */
typedef enum {                                  /*!< LPI2C0_MIER_PLTIE                                                         */
  LPI2C0_MIER_PLTIE_0                  = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_MIER_PLTIE_1                  = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_MIER_PLTIE_Enum;

/* ===========================================  LPI2C0 LPI2C0_MIER DMIE [14..14]  ============================================ */
typedef enum {                                  /*!< LPI2C0_MIER_DMIE                                                          */
  LPI2C0_MIER_DMIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_MIER_DMIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_MIER_DMIE_Enum;

/* ======================================================  LPI2C0_MDER  ====================================================== */
/* ============================================  LPI2C0 LPI2C0_MDER TDDE [0..0]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MDER_TDDE                                                          */
  LPI2C0_MDER_TDDE_0                   = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPI2C0_MDER_TDDE_1                   = 1,     /*!< 1 : DMA request enabled                                                   */
} LPI2C0_MDER_TDDE_Enum;

/* ============================================  LPI2C0 LPI2C0_MDER RDDE [1..1]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MDER_RDDE                                                          */
  LPI2C0_MDER_RDDE_0                   = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPI2C0_MDER_RDDE_1                   = 1,     /*!< 1 : DMA request enabled.                                                  */
} LPI2C0_MDER_RDDE_Enum;

/* =====================================================  LPI2C0_MCFGR0  ===================================================== */
/* ===========================================  LPI2C0 LPI2C0_MCFGR0 HREN [0..0]  ============================================ */
typedef enum {                                  /*!< LPI2C0_MCFGR0_HREN                                                        */
  LPI2C0_MCFGR0_HREN_0                 = 0,     /*!< 0 : Host request input is disabled.                                       */
  LPI2C0_MCFGR0_HREN_1                 = 1,     /*!< 1 : Host request input is enabled.                                        */
} LPI2C0_MCFGR0_HREN_Enum;

/* ===========================================  LPI2C0 LPI2C0_MCFGR0 HRPOL [1..1]  =========================================== */
typedef enum {                                  /*!< LPI2C0_MCFGR0_HRPOL                                                       */
  LPI2C0_MCFGR0_HRPOL_0                = 0,     /*!< 0 : Active low.                                                           */
  LPI2C0_MCFGR0_HRPOL_1                = 1,     /*!< 1 : Active high.                                                          */
} LPI2C0_MCFGR0_HRPOL_Enum;

/* ===========================================  LPI2C0 LPI2C0_MCFGR0 HRSEL [2..2]  =========================================== */
typedef enum {                                  /*!< LPI2C0_MCFGR0_HRSEL                                                       */
  LPI2C0_MCFGR0_HRSEL_0                = 0,     /*!< 0 : Host request input is pin HREQ.                                       */
  LPI2C0_MCFGR0_HRSEL_1                = 1,     /*!< 1 : Host request input is input trigger.                                  */
} LPI2C0_MCFGR0_HRSEL_Enum;

/* ==========================================  LPI2C0 LPI2C0_MCFGR0 CIRFIFO [8..8]  ========================================== */
typedef enum {                                  /*!< LPI2C0_MCFGR0_CIRFIFO                                                     */
  LPI2C0_MCFGR0_CIRFIFO_0              = 0,     /*!< 0 : Circular FIFO is disabled.                                            */
  LPI2C0_MCFGR0_CIRFIFO_1              = 1,     /*!< 1 : Circular FIFO is enabled.                                             */
} LPI2C0_MCFGR0_CIRFIFO_Enum;

/* ===========================================  LPI2C0 LPI2C0_MCFGR0 RDMO [9..9]  ============================================ */
typedef enum {                                  /*!< LPI2C0_MCFGR0_RDMO                                                        */
  LPI2C0_MCFGR0_RDMO_0                 = 0,     /*!< 0 : Received data is stored in the receive FIFO as normal.                */
  LPI2C0_MCFGR0_RDMO_1                 = 1,     /*!< 1 : Received data is discarded unless the RMF is set.                     */
} LPI2C0_MCFGR0_RDMO_Enum;

/* =====================================================  LPI2C0_MCFGR1  ===================================================== */
/* =========================================  LPI2C0 LPI2C0_MCFGR1 PRESCALE [0..2]  ========================================== */
typedef enum {                                  /*!< LPI2C0_MCFGR1_PRESCALE                                                    */
  LPI2C0_MCFGR1_PRESCALE_000           = 0,     /*!< 000 : Divide by 1.                                                        */
  LPI2C0_MCFGR1_PRESCALE_001           = 1,     /*!< 001 : Divide by 2.                                                        */
  LPI2C0_MCFGR1_PRESCALE_010           = 2,     /*!< 010 : Divide by 4.                                                        */
  LPI2C0_MCFGR1_PRESCALE_011           = 3,     /*!< 011 : Divide by 8.                                                        */
  LPI2C0_MCFGR1_PRESCALE_100           = 4,     /*!< 100 : Divide by 16.                                                       */
  LPI2C0_MCFGR1_PRESCALE_101           = 5,     /*!< 101 : Divide by 32.                                                       */
  LPI2C0_MCFGR1_PRESCALE_110           = 6,     /*!< 110 : Divide by 64.                                                       */
  LPI2C0_MCFGR1_PRESCALE_111           = 7,     /*!< 111 : Divide by 128.                                                      */
} LPI2C0_MCFGR1_PRESCALE_Enum;

/* =========================================  LPI2C0 LPI2C0_MCFGR1 AUTOSTOP [8..8]  ========================================== */
typedef enum {                                  /*!< LPI2C0_MCFGR1_AUTOSTOP                                                    */
  LPI2C0_MCFGR1_AUTOSTOP_0             = 0,     /*!< 0 : No effect.                                                            */
  LPI2C0_MCFGR1_AUTOSTOP_1             = 1,     /*!< 1 : STOP condition is automatically generated whenever the transmit
                                                     FIFO is empty and LPI2C master is busy.                                   */
} LPI2C0_MCFGR1_AUTOSTOP_Enum;

/* ==========================================  LPI2C0 LPI2C0_MCFGR1 IGNACK [9..9]  =========================================== */
typedef enum {                                  /*!< LPI2C0_MCFGR1_IGNACK                                                      */
  LPI2C0_MCFGR1_IGNACK_0               = 0,     /*!< 0 : LPI2C Master will receive ACK and NACK normally.                      */
  LPI2C0_MCFGR1_IGNACK_1               = 1,     /*!< 1 : LPI2C Master will treat a received NACK as if it was an
                                                     ACK.                                                                      */
} LPI2C0_MCFGR1_IGNACK_Enum;

/* =========================================  LPI2C0 LPI2C0_MCFGR1 TIMECFG [10..10]  ========================================= */
typedef enum {                                  /*!< LPI2C0_MCFGR1_TIMECFG                                                     */
  LPI2C0_MCFGR1_TIMECFG_0              = 0,     /*!< 0 : Pin Low Timeout Flag will set if SCL is low for longer than
                                                     the configured timeout.                                                   */
  LPI2C0_MCFGR1_TIMECFG_1              = 1,     /*!< 1 : Pin Low Timeout Flag will set if either SCL or SDA is low
                                                     for longer than the configured timeout.                                   */
} LPI2C0_MCFGR1_TIMECFG_Enum;

/* =========================================  LPI2C0 LPI2C0_MCFGR1 MATCFG [16..18]  ========================================== */
typedef enum {                                  /*!< LPI2C0_MCFGR1_MATCFG                                                      */
  LPI2C0_MCFGR1_MATCFG_000             = 0,     /*!< 000 : Match disabled.                                                     */
  LPI2C0_MCFGR1_MATCFG_010             = 2,     /*!< 010 : Match enabled (1st data word equals MATCH0 OR MATCH1).              */
  LPI2C0_MCFGR1_MATCFG_011             = 3,     /*!< 011 : Match enabled (any data word equals MATCH0 OR MATCH1).              */
  LPI2C0_MCFGR1_MATCFG_100             = 4,     /*!< 100 : Match enabled (1st data word equals MATCH0 AND 2nd data
                                                     word equals MATCH1).                                                      */
  LPI2C0_MCFGR1_MATCFG_101             = 5,     /*!< 101 : Match enabled (any data word equals MATCH0 AND next data
                                                     word equals MATCH1).                                                      */
  LPI2C0_MCFGR1_MATCFG_110             = 6,     /*!< 110 : Match enabled (1st data word AND MATCH1 equals MATCH0
                                                     AND MATCH1).                                                              */
  LPI2C0_MCFGR1_MATCFG_111             = 7,     /*!< 111 : Match enabled (any data word AND MATCH1 equals MATCH0
                                                     AND MATCH1).                                                              */
} LPI2C0_MCFGR1_MATCFG_Enum;

/* =========================================  LPI2C0 LPI2C0_MCFGR1 PINCFG [24..26]  ========================================== */
typedef enum {                                  /*!< LPI2C0_MCFGR1_PINCFG                                                      */
  LPI2C0_MCFGR1_PINCFG_000             = 0,     /*!< 000 : LPI2C configured for 2-pin open drain mode.                         */
  LPI2C0_MCFGR1_PINCFG_001             = 1,     /*!< 001 : LPI2C configured for 2-pin output only mode (ultra-fast
                                                     mode).                                                                    */
  LPI2C0_MCFGR1_PINCFG_010             = 2,     /*!< 010 : LPI2C configured for 2-pin push-pull mode.                          */
  LPI2C0_MCFGR1_PINCFG_011             = 3,     /*!< 011 : LPI2C configured for 4-pin push-pull mode.                          */
  LPI2C0_MCFGR1_PINCFG_100             = 4,     /*!< 100 : LPI2C configured for 2-pin open drain mode with separate
                                                     LPI2C slave.                                                              */
  LPI2C0_MCFGR1_PINCFG_101             = 5,     /*!< 101 : LPI2C configured for 2-pin output only mode (ultra-fast
                                                     mode) with separate LPI2C slave.                                          */
  LPI2C0_MCFGR1_PINCFG_110             = 6,     /*!< 110 : LPI2C configured for 2-pin push-pull mode with separate
                                                     LPI2C slave.                                                              */
  LPI2C0_MCFGR1_PINCFG_111             = 7,     /*!< 111 : LPI2C configured for 4-pin push-pull mode (inverted outputs).       */
} LPI2C0_MCFGR1_PINCFG_Enum;

/* =====================================================  LPI2C0_MCFGR2  ===================================================== */
/* =====================================================  LPI2C0_MCFGR3  ===================================================== */
/* ======================================================  LPI2C0_MDMR  ====================================================== */
/* =====================================================  LPI2C0_MCCR0  ====================================================== */
/* =====================================================  LPI2C0_MCCR1  ====================================================== */
/* ======================================================  LPI2C0_MFCR  ====================================================== */
/* ======================================================  LPI2C0_MFSR  ====================================================== */
/* ======================================================  LPI2C0_MTDR  ====================================================== */
/* ============================================  LPI2C0 LPI2C0_MTDR CMD [8..10]  ============================================= */
typedef enum {                                  /*!< LPI2C0_MTDR_CMD                                                           */
  LPI2C0_MTDR_CMD_000                  = 0,     /*!< 000 : Transmit DATA[7:0].                                                 */
  LPI2C0_MTDR_CMD_001                  = 1,     /*!< 001 : Receive (DATA[7:0] + 1) bytes.                                      */
  LPI2C0_MTDR_CMD_010                  = 2,     /*!< 010 : Generate STOP condition.                                            */
  LPI2C0_MTDR_CMD_011                  = 3,     /*!< 011 : Receive and discard (DATA[7:0] + 1) bytes.                          */
  LPI2C0_MTDR_CMD_100                  = 4,     /*!< 100 : Generate (repeated) START and transmit address in DATA[7:0].        */
  LPI2C0_MTDR_CMD_101                  = 5,     /*!< 101 : Generate (repeated) START and transmit address in DATA[7:0].
                                                     This transfer expects a NACK to be returned.                              */
  LPI2C0_MTDR_CMD_110                  = 6,     /*!< 110 : Generate (repeated) START and transmit address in DATA[7:0]
                                                     using high speed mode.                                                    */
  LPI2C0_MTDR_CMD_111                  = 7,     /*!< 111 : Generate (repeated) START and transmit address in DATA[7:0]
                                                     using high speed mode. This transfer expects a NACK to
                                                     be returned.                                                              */
} LPI2C0_MTDR_CMD_Enum;

/* ======================================================  LPI2C0_MRDR  ====================================================== */
/* ==========================================  LPI2C0 LPI2C0_MRDR RXEMPTY [14..14]  ========================================== */
typedef enum {                                  /*!< LPI2C0_MRDR_RXEMPTY                                                       */
  LPI2C0_MRDR_RXEMPTY_0                = 0,     /*!< 0 : Receive FIFO is not empty.                                            */
  LPI2C0_MRDR_RXEMPTY_1                = 1,     /*!< 1 : Receive FIFO is empty.                                                */
} LPI2C0_MRDR_RXEMPTY_Enum;

/* ======================================================  LPI2C0_SCR  ======================================================= */
/* =============================================  LPI2C0 LPI2C0_SCR SEN [0..0]  ============================================== */
typedef enum {                                  /*!< LPI2C0_SCR_SEN                                                            */
  LPI2C0_SCR_SEN_0                     = 0,     /*!< 0 : Slave mode is disabled.                                               */
  LPI2C0_SCR_SEN_1                     = 1,     /*!< 1 : Slave mode is enabled.                                                */
} LPI2C0_SCR_SEN_Enum;

/* =============================================  LPI2C0 LPI2C0_SCR RST [1..1]  ============================================== */
typedef enum {                                  /*!< LPI2C0_SCR_RST                                                            */
  LPI2C0_SCR_RST_0                     = 0,     /*!< 0 : Slave logic is not reset.                                             */
  LPI2C0_SCR_RST_1                     = 1,     /*!< 1 : Slave logic is reset.                                                 */
} LPI2C0_SCR_RST_Enum;

/* ============================================  LPI2C0 LPI2C0_SCR FILTEN [4..4]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SCR_FILTEN                                                         */
  LPI2C0_SCR_FILTEN_0                  = 0,     /*!< 0 : Disable digital filter and output delay counter for slave
                                                     mode.                                                                     */
  LPI2C0_SCR_FILTEN_1                  = 1,     /*!< 1 : Enable digital filter and output delay counter for slave
                                                     mode.                                                                     */
} LPI2C0_SCR_FILTEN_Enum;

/* ============================================  LPI2C0 LPI2C0_SCR FILTDZ [5..5]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SCR_FILTDZ                                                         */
  LPI2C0_SCR_FILTDZ_0                  = 0,     /*!< 0 : Filter remains enabled in Doze mode.                                  */
  LPI2C0_SCR_FILTDZ_1                  = 1,     /*!< 1 : Filter is disabled in Doze mode.                                      */
} LPI2C0_SCR_FILTDZ_Enum;

/* =============================================  LPI2C0 LPI2C0_SCR RTF [8..8]  ============================================== */
typedef enum {                                  /*!< LPI2C0_SCR_RTF                                                            */
  LPI2C0_SCR_RTF_0                     = 0,     /*!< 0 : No effect                                                             */
  LPI2C0_SCR_RTF_1                     = 1,     /*!< 1 : Transmit Data Register is now empty                                   */
} LPI2C0_SCR_RTF_Enum;

/* =============================================  LPI2C0 LPI2C0_SCR RRF [9..9]  ============================================== */
typedef enum {                                  /*!< LPI2C0_SCR_RRF                                                            */
  LPI2C0_SCR_RRF_0                     = 0,     /*!< 0 : No effect                                                             */
  LPI2C0_SCR_RRF_1                     = 1,     /*!< 1 : Receive Data Register is now empty                                    */
} LPI2C0_SCR_RRF_Enum;

/* ======================================================  LPI2C0_SSR  ======================================================= */
/* =============================================  LPI2C0 LPI2C0_SSR TDF [0..0]  ============================================== */
typedef enum {                                  /*!< LPI2C0_SSR_TDF                                                            */
  LPI2C0_SSR_TDF_0                     = 0,     /*!< 0 : Transmit data not requested.                                          */
  LPI2C0_SSR_TDF_1                     = 1,     /*!< 1 : Transmit data is requested.                                           */
} LPI2C0_SSR_TDF_Enum;

/* =============================================  LPI2C0 LPI2C0_SSR RDF [1..1]  ============================================== */
typedef enum {                                  /*!< LPI2C0_SSR_RDF                                                            */
  LPI2C0_SSR_RDF_0                     = 0,     /*!< 0 : Receive Data is not ready.                                            */
  LPI2C0_SSR_RDF_1                     = 1,     /*!< 1 : Receive data is ready.                                                */
} LPI2C0_SSR_RDF_Enum;

/* =============================================  LPI2C0 LPI2C0_SSR AVF [2..2]  ============================================== */
typedef enum {                                  /*!< LPI2C0_SSR_AVF                                                            */
  LPI2C0_SSR_AVF_0                     = 0,     /*!< 0 : Address Status Register is not valid.                                 */
  LPI2C0_SSR_AVF_1                     = 1,     /*!< 1 : Address Status Register is valid.                                     */
} LPI2C0_SSR_AVF_Enum;

/* =============================================  LPI2C0 LPI2C0_SSR TAF [3..3]  ============================================== */
typedef enum {                                  /*!< LPI2C0_SSR_TAF                                                            */
  LPI2C0_SSR_TAF_0                     = 0,     /*!< 0 : Transmit ACK/NACK is not required.                                    */
  LPI2C0_SSR_TAF_1                     = 1,     /*!< 1 : Transmit ACK/NACK is required.                                        */
} LPI2C0_SSR_TAF_Enum;

/* =============================================  LPI2C0 LPI2C0_SSR RSF [8..8]  ============================================== */
typedef enum {                                  /*!< LPI2C0_SSR_RSF                                                            */
  LPI2C0_SSR_RSF_0                     = 0,     /*!< 0 : Slave has not detected a Repeated START condition.                    */
  LPI2C0_SSR_RSF_1                     = 1,     /*!< 1 : Slave has detected a Repeated START condition.                        */
} LPI2C0_SSR_RSF_Enum;

/* =============================================  LPI2C0 LPI2C0_SSR SDF [9..9]  ============================================== */
typedef enum {                                  /*!< LPI2C0_SSR_SDF                                                            */
  LPI2C0_SSR_SDF_0                     = 0,     /*!< 0 : Slave has not detected a STOP condition.                              */
  LPI2C0_SSR_SDF_1                     = 1,     /*!< 1 : Slave has detected a STOP condition.                                  */
} LPI2C0_SSR_SDF_Enum;

/* ============================================  LPI2C0 LPI2C0_SSR BEF [10..10]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SSR_BEF                                                            */
  LPI2C0_SSR_BEF_0                     = 0,     /*!< 0 : Slave has not detected a bit error.                                   */
  LPI2C0_SSR_BEF_1                     = 1,     /*!< 1 : Slave has detected a bit error.                                       */
} LPI2C0_SSR_BEF_Enum;

/* ============================================  LPI2C0 LPI2C0_SSR FEF [11..11]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SSR_FEF                                                            */
  LPI2C0_SSR_FEF_0                     = 0,     /*!< 0 : FIFO underflow or overflow not detected.                              */
  LPI2C0_SSR_FEF_1                     = 1,     /*!< 1 : FIFO underflow or overflow detected.                                  */
} LPI2C0_SSR_FEF_Enum;

/* ============================================  LPI2C0 LPI2C0_SSR AM0F [12..12]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SSR_AM0F                                                           */
  LPI2C0_SSR_AM0F_0                    = 0,     /*!< 0 : Have not received ADDR0 matching address.                             */
  LPI2C0_SSR_AM0F_1                    = 1,     /*!< 1 : Have received ADDR0 matching address.                                 */
} LPI2C0_SSR_AM0F_Enum;

/* ============================================  LPI2C0 LPI2C0_SSR AM1F [13..13]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SSR_AM1F                                                           */
  LPI2C0_SSR_AM1F_0                    = 0,     /*!< 0 : Have not received ADDR1 or ADDR0/ADDR1 range matching address.        */
  LPI2C0_SSR_AM1F_1                    = 1,     /*!< 1 : Have received ADDR1 or ADDR0/ADDR1 range matching address.            */
} LPI2C0_SSR_AM1F_Enum;

/* ============================================  LPI2C0 LPI2C0_SSR GCF [14..14]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SSR_GCF                                                            */
  LPI2C0_SSR_GCF_0                     = 0,     /*!< 0 : Slave has not detected the General Call Address or General
                                                     Call Address disabled.                                                    */
  LPI2C0_SSR_GCF_1                     = 1,     /*!< 1 : Slave has detected the General Call Address.                          */
} LPI2C0_SSR_GCF_Enum;

/* ============================================  LPI2C0 LPI2C0_SSR SARF [15..15]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SSR_SARF                                                           */
  LPI2C0_SSR_SARF_0                    = 0,     /*!< 0 : SMBus Alert Response disabled or not detected.                        */
  LPI2C0_SSR_SARF_1                    = 1,     /*!< 1 : SMBus Alert Response enabled and detected.                            */
} LPI2C0_SSR_SARF_Enum;

/* ============================================  LPI2C0 LPI2C0_SSR SBF [24..24]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SSR_SBF                                                            */
  LPI2C0_SSR_SBF_0                     = 0,     /*!< 0 : I2C Slave is idle.                                                    */
  LPI2C0_SSR_SBF_1                     = 1,     /*!< 1 : I2C Slave is busy.                                                    */
} LPI2C0_SSR_SBF_Enum;

/* ============================================  LPI2C0 LPI2C0_SSR BBF [25..25]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SSR_BBF                                                            */
  LPI2C0_SSR_BBF_0                     = 0,     /*!< 0 : I2C Bus is idle.                                                      */
  LPI2C0_SSR_BBF_1                     = 1,     /*!< 1 : I2C Bus is busy.                                                      */
} LPI2C0_SSR_BBF_Enum;

/* ======================================================  LPI2C0_SIER  ====================================================== */
/* ============================================  LPI2C0 LPI2C0_SIER TDIE [0..0]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SIER_TDIE                                                          */
  LPI2C0_SIER_TDIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_TDIE_1                   = 1,     /*!< 1 : Interrupt enabled                                                     */
} LPI2C0_SIER_TDIE_Enum;

/* ============================================  LPI2C0 LPI2C0_SIER RDIE [1..1]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SIER_RDIE                                                          */
  LPI2C0_SIER_RDIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_RDIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_SIER_RDIE_Enum;

/* ============================================  LPI2C0 LPI2C0_SIER AVIE [2..2]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SIER_AVIE                                                          */
  LPI2C0_SIER_AVIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_AVIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_SIER_AVIE_Enum;

/* ============================================  LPI2C0 LPI2C0_SIER TAIE [3..3]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SIER_TAIE                                                          */
  LPI2C0_SIER_TAIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_TAIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_SIER_TAIE_Enum;

/* ============================================  LPI2C0 LPI2C0_SIER RSIE [8..8]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SIER_RSIE                                                          */
  LPI2C0_SIER_RSIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_RSIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_SIER_RSIE_Enum;

/* ============================================  LPI2C0 LPI2C0_SIER SDIE [9..9]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SIER_SDIE                                                          */
  LPI2C0_SIER_SDIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_SDIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_SIER_SDIE_Enum;

/* ===========================================  LPI2C0 LPI2C0_SIER BEIE [10..10]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SIER_BEIE                                                          */
  LPI2C0_SIER_BEIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_BEIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_SIER_BEIE_Enum;

/* ===========================================  LPI2C0 LPI2C0_SIER FEIE [11..11]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SIER_FEIE                                                          */
  LPI2C0_SIER_FEIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_FEIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_SIER_FEIE_Enum;

/* ===========================================  LPI2C0 LPI2C0_SIER AM0IE [12..12]  =========================================== */
typedef enum {                                  /*!< LPI2C0_SIER_AM0IE                                                         */
  LPI2C0_SIER_AM0IE_0                  = 0,     /*!< 0 : Interrupt enabled.                                                    */
  LPI2C0_SIER_AM0IE_1                  = 1,     /*!< 1 : Interrupt disabled.                                                   */
} LPI2C0_SIER_AM0IE_Enum;

/* ===========================================  LPI2C0 LPI2C0_SIER AM1F [13..13]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SIER_AM1F                                                          */
  LPI2C0_SIER_AM1F_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_AM1F_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_SIER_AM1F_Enum;

/* ===========================================  LPI2C0 LPI2C0_SIER GCIE [14..14]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SIER_GCIE                                                          */
  LPI2C0_SIER_GCIE_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_GCIE_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_SIER_GCIE_Enum;

/* ===========================================  LPI2C0 LPI2C0_SIER SARIE [15..15]  =========================================== */
typedef enum {                                  /*!< LPI2C0_SIER_SARIE                                                         */
  LPI2C0_SIER_SARIE_0                  = 0,     /*!< 0 : Interrupt disabled.                                                   */
  LPI2C0_SIER_SARIE_1                  = 1,     /*!< 1 : Interrupt enabled.                                                    */
} LPI2C0_SIER_SARIE_Enum;

/* ======================================================  LPI2C0_SDER  ====================================================== */
/* ============================================  LPI2C0 LPI2C0_SDER TDDE [0..0]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SDER_TDDE                                                          */
  LPI2C0_SDER_TDDE_0                   = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPI2C0_SDER_TDDE_1                   = 1,     /*!< 1 : DMA request enabled                                                   */
} LPI2C0_SDER_TDDE_Enum;

/* ============================================  LPI2C0 LPI2C0_SDER RDDE [1..1]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SDER_RDDE                                                          */
  LPI2C0_SDER_RDDE_0                   = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPI2C0_SDER_RDDE_1                   = 1,     /*!< 1 : DMA request enabled.                                                  */
} LPI2C0_SDER_RDDE_Enum;

/* ============================================  LPI2C0 LPI2C0_SDER AVDE [2..2]  ============================================= */
typedef enum {                                  /*!< LPI2C0_SDER_AVDE                                                          */
  LPI2C0_SDER_AVDE_0                   = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPI2C0_SDER_AVDE_1                   = 1,     /*!< 1 : DMA request enabled.                                                  */
} LPI2C0_SDER_AVDE_Enum;

/* =====================================================  LPI2C0_SCFGR1  ===================================================== */
/* =========================================  LPI2C0 LPI2C0_SCFGR1 ADRSTALL [0..0]  ========================================== */
typedef enum {                                  /*!< LPI2C0_SCFGR1_ADRSTALL                                                    */
  LPI2C0_SCFGR1_ADRSTALL_0             = 0,     /*!< 0 : Clock stretching disabled.                                            */
  LPI2C0_SCFGR1_ADRSTALL_1             = 1,     /*!< 1 : Clock stretching enabled.                                             */
} LPI2C0_SCFGR1_ADRSTALL_Enum;

/* ==========================================  LPI2C0 LPI2C0_SCFGR1 RXSTALL [1..1]  ========================================== */
typedef enum {                                  /*!< LPI2C0_SCFGR1_RXSTALL                                                     */
  LPI2C0_SCFGR1_RXSTALL_0              = 0,     /*!< 0 : Clock stretching disabled.                                            */
  LPI2C0_SCFGR1_RXSTALL_1              = 1,     /*!< 1 : Clock stretching enabled.                                             */
} LPI2C0_SCFGR1_RXSTALL_Enum;

/* =========================================  LPI2C0 LPI2C0_SCFGR1 TXDSTALL [2..2]  ========================================== */
typedef enum {                                  /*!< LPI2C0_SCFGR1_TXDSTALL                                                    */
  LPI2C0_SCFGR1_TXDSTALL_0             = 0,     /*!< 0 : Clock stretching disabled.                                            */
  LPI2C0_SCFGR1_TXDSTALL_1             = 1,     /*!< 1 : Clock stretching enabled.                                             */
} LPI2C0_SCFGR1_TXDSTALL_Enum;

/* =========================================  LPI2C0 LPI2C0_SCFGR1 ACKSTALL [3..3]  ========================================== */
typedef enum {                                  /*!< LPI2C0_SCFGR1_ACKSTALL                                                    */
  LPI2C0_SCFGR1_ACKSTALL_0             = 0,     /*!< 0 : Clock stretching disabled.                                            */
  LPI2C0_SCFGR1_ACKSTALL_1             = 1,     /*!< 1 : Clock stretching enabled.                                             */
} LPI2C0_SCFGR1_ACKSTALL_Enum;

/* ===========================================  LPI2C0 LPI2C0_SCFGR1 GCEN [8..8]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SCFGR1_GCEN                                                        */
  LPI2C0_SCFGR1_GCEN_0                 = 0,     /*!< 0 : General Call address is disabled.                                     */
  LPI2C0_SCFGR1_GCEN_1                 = 1,     /*!< 1 : General call address is enabled.                                      */
} LPI2C0_SCFGR1_GCEN_Enum;

/* ===========================================  LPI2C0 LPI2C0_SCFGR1 SAEN [9..9]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SCFGR1_SAEN                                                        */
  LPI2C0_SCFGR1_SAEN_0                 = 0,     /*!< 0 : Disables match on SMBus Alert.                                        */
  LPI2C0_SCFGR1_SAEN_1                 = 1,     /*!< 1 : Enables match on SMBus Alert.                                         */
} LPI2C0_SCFGR1_SAEN_Enum;

/* ==========================================  LPI2C0 LPI2C0_SCFGR1 TXCFG [10..10]  ========================================== */
typedef enum {                                  /*!< LPI2C0_SCFGR1_TXCFG                                                       */
  LPI2C0_SCFGR1_TXCFG_0                = 0,     /*!< 0 : Transmit Data Flag will only assert during a slave-transmit
                                                     transfer when the transmit data register is empty.                        */
  LPI2C0_SCFGR1_TXCFG_1                = 1,     /*!< 1 : Transmit Data Flag will assert whenever the transmit data
                                                     register is empty.                                                        */
} LPI2C0_SCFGR1_TXCFG_Enum;

/* ==========================================  LPI2C0 LPI2C0_SCFGR1 RXCFG [11..11]  ========================================== */
typedef enum {                                  /*!< LPI2C0_SCFGR1_RXCFG                                                       */
  LPI2C0_SCFGR1_RXCFG_0                = 0,     /*!< 0 : Reading the receive data register will return receive data
                                                     and clear the receive data flag.                                          */
  LPI2C0_SCFGR1_RXCFG_1                = 1,     /*!< 1 : Reading the Receive Data register when the Address Valid
                                                     flag (SSR[AVF])is set, will return the Address Status register
                                                     and clear the Address Valid flag. Reading the Receive Data
                                                     register when the Address Valid flag is clear, will return
                                                     received data and clear the Receive Data flag (MSR[RDF]).                 */
} LPI2C0_SCFGR1_RXCFG_Enum;

/* =========================================  LPI2C0 LPI2C0_SCFGR1 IGNACK [12..12]  ========================================== */
typedef enum {                                  /*!< LPI2C0_SCFGR1_IGNACK                                                      */
  LPI2C0_SCFGR1_IGNACK_0               = 0,     /*!< 0 : Slave will end transfer when NACK detected.                           */
  LPI2C0_SCFGR1_IGNACK_1               = 1,     /*!< 1 : Slave will not end transfer when NACK detected.                       */
} LPI2C0_SCFGR1_IGNACK_Enum;

/* ==========================================  LPI2C0 LPI2C0_SCFGR1 HSMEN [13..13]  ========================================== */
typedef enum {                                  /*!< LPI2C0_SCFGR1_HSMEN                                                       */
  LPI2C0_SCFGR1_HSMEN_0                = 0,     /*!< 0 : Disables detection of Hs-mode master code.                            */
  LPI2C0_SCFGR1_HSMEN_1                = 1,     /*!< 1 : Enables detection of Hs-mode master code.                             */
} LPI2C0_SCFGR1_HSMEN_Enum;

/* =========================================  LPI2C0 LPI2C0_SCFGR1 ADDRCFG [16..18]  ========================================= */
typedef enum {                                  /*!< LPI2C0_SCFGR1_ADDRCFG                                                     */
  LPI2C0_SCFGR1_ADDRCFG_000            = 0,     /*!< 000 : Address match 0 (7-bit).                                            */
  LPI2C0_SCFGR1_ADDRCFG_001            = 1,     /*!< 001 : Address match 0 (10-bit).                                           */
  LPI2C0_SCFGR1_ADDRCFG_010            = 2,     /*!< 010 : Address match 0 (7-bit) or Address match 1 (7-bit).                 */
  LPI2C0_SCFGR1_ADDRCFG_011            = 3,     /*!< 011 : Address match 0 (10-bit) or Address match 1 (10-bit).               */
  LPI2C0_SCFGR1_ADDRCFG_100            = 4,     /*!< 100 : Address match 0 (7-bit) or Address match 1 (10-bit).                */
  LPI2C0_SCFGR1_ADDRCFG_101            = 5,     /*!< 101 : Address match 0 (10-bit) or Address match 1 (7-bit).                */
  LPI2C0_SCFGR1_ADDRCFG_110            = 6,     /*!< 110 : From Address match 0 (7-bit) to Address match 1 (7-bit).            */
  LPI2C0_SCFGR1_ADDRCFG_111            = 7,     /*!< 111 : From Address match 0 (10-bit) to Address match 1 (10-bit).          */
} LPI2C0_SCFGR1_ADDRCFG_Enum;

/* =====================================================  LPI2C0_SCFGR2  ===================================================== */
/* ======================================================  LPI2C0_SAMR  ====================================================== */
/* ======================================================  LPI2C0_SASR  ====================================================== */
/* ============================================  LPI2C0 LPI2C0_SASR ANV [14..14]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SASR_ANV                                                           */
  LPI2C0_SASR_ANV_0                    = 0,     /*!< 0 : RADDR is valid.                                                       */
  LPI2C0_SASR_ANV_1                    = 1,     /*!< 1 : RADDR is not valid.                                                   */
} LPI2C0_SASR_ANV_Enum;

/* ======================================================  LPI2C0_STAR  ====================================================== */
/* ===========================================  LPI2C0 LPI2C0_STAR TXNACK [0..0]  ============================================ */
typedef enum {                                  /*!< LPI2C0_STAR_TXNACK                                                        */
  LPI2C0_STAR_TXNACK_0                 = 0,     /*!< 0 : Transmit ACK for received word.                                       */
  LPI2C0_STAR_TXNACK_1                 = 1,     /*!< 1 : Transmit NACK for received word.                                      */
} LPI2C0_STAR_TXNACK_Enum;

/* ======================================================  LPI2C0_STDR  ====================================================== */
/* ======================================================  LPI2C0_SRDR  ====================================================== */
/* ==========================================  LPI2C0 LPI2C0_SRDR RXEMPTY [14..14]  ========================================== */
typedef enum {                                  /*!< LPI2C0_SRDR_RXEMPTY                                                       */
  LPI2C0_SRDR_RXEMPTY_0                = 0,     /*!< 0 : The Receive Data Register is not empty.                               */
  LPI2C0_SRDR_RXEMPTY_1                = 1,     /*!< 1 : The Receive Data Register is empty.                                   */
} LPI2C0_SRDR_RXEMPTY_Enum;

/* ============================================  LPI2C0 LPI2C0_SRDR SOF [15..15]  ============================================ */
typedef enum {                                  /*!< LPI2C0_SRDR_SOF                                                           */
  LPI2C0_SRDR_SOF_0                    = 0,     /*!< 0 : Indicates this is not the first data word since a (repeated)
                                                     START or STOP condition.                                                  */
  LPI2C0_SRDR_SOF_1                    = 1,     /*!< 1 : Indicates this is the first data word since a (repeated)
                                                     START or STOP condition.                                                  */
} LPI2C0_SRDR_SOF_Enum;



/* =========================================================================================================================== */
/* ================                                          LPUART0                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  LPUART0_VERID  ===================================================== */
/* =========================================  LPUART0 LPUART0_VERID FEATURE [0..15]  ========================================= */
typedef enum {                                  /*!< LPUART0_VERID_FEATURE                                                     */
  LPUART0_VERID_FEATURE_0000000000000001 = 1,   /*!< 0000000000000001 : Standard feature set.                                  */
  LPUART0_VERID_FEATURE_0000000000000011 = 3,   /*!< 0000000000000011 : Standard feature set with MODEM/IrDA support.          */
} LPUART0_VERID_FEATURE_Enum;

/* =====================================================  LPUART0_PARAM  ===================================================== */
/* ====================================================  LPUART0_GLOBAL  ===================================================== */
/* ===========================================  LPUART0 LPUART0_GLOBAL RST [1..1]  =========================================== */
typedef enum {                                  /*!< LPUART0_GLOBAL_RST                                                        */
  LPUART0_GLOBAL_RST_0                 = 0,     /*!< 0 : Module is not reset.                                                  */
  LPUART0_GLOBAL_RST_1                 = 1,     /*!< 1 : Module is reset.                                                      */
} LPUART0_GLOBAL_RST_Enum;

/* ====================================================  LPUART0_PINCFG  ===================================================== */
/* =========================================  LPUART0 LPUART0_PINCFG TRGSEL [0..1]  ========================================== */
typedef enum {                                  /*!< LPUART0_PINCFG_TRGSEL                                                     */
  LPUART0_PINCFG_TRGSEL_00             = 0,     /*!< 00 : Input trigger is disabled.                                           */
  LPUART0_PINCFG_TRGSEL_01             = 1,     /*!< 01 : Input trigger is used instead of RXD pin input.                      */
  LPUART0_PINCFG_TRGSEL_10             = 2,     /*!< 10 : Input trigger is used instead of CTS_B pin input.                    */
  LPUART0_PINCFG_TRGSEL_11             = 3,     /*!< 11 : Input trigger is used to modulate the TXD pin output. The
                                                     TXD pin output (after TXINV configuration) is ANDed with
                                                     the input trigger.                                                        */
} LPUART0_PINCFG_TRGSEL_Enum;

/* =====================================================  LPUART0_BAUD  ====================================================== */
/* ==========================================  LPUART0 LPUART0_BAUD SBNS [13..13]  =========================================== */
typedef enum {                                  /*!< LPUART0_BAUD_SBNS                                                         */
  LPUART0_BAUD_SBNS_0                  = 0,     /*!< 0 : One stop bit.                                                         */
  LPUART0_BAUD_SBNS_1                  = 1,     /*!< 1 : Two stop bits.                                                        */
} LPUART0_BAUD_SBNS_Enum;

/* =========================================  LPUART0 LPUART0_BAUD RXEDGIE [14..14]  ========================================= */
typedef enum {                                  /*!< LPUART0_BAUD_RXEDGIE                                                      */
  LPUART0_BAUD_RXEDGIE_0               = 0,     /*!< 0 : Hardware interrupts from LPUART_STAT[RXEDGIF] disabled.               */
  LPUART0_BAUD_RXEDGIE_1               = 1,     /*!< 1 : Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag
                                                     is 1.                                                                     */
} LPUART0_BAUD_RXEDGIE_Enum;

/* =========================================  LPUART0 LPUART0_BAUD LBKDIE [15..15]  ========================================== */
typedef enum {                                  /*!< LPUART0_BAUD_LBKDIE                                                       */
  LPUART0_BAUD_LBKDIE_0                = 0,     /*!< 0 : Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use
                                                     polling).                                                                 */
  LPUART0_BAUD_LBKDIE_1                = 1,     /*!< 1 : Hardware interrupt requested when LPUART_STAT[LBKDIF] flag
                                                     is 1.                                                                     */
} LPUART0_BAUD_LBKDIE_Enum;

/* ========================================  LPUART0 LPUART0_BAUD RESYNCDIS [16..16]  ======================================== */
typedef enum {                                  /*!< LPUART0_BAUD_RESYNCDIS                                                    */
  LPUART0_BAUD_RESYNCDIS_0             = 0,     /*!< 0 : Resynchronization during received data word is supported              */
  LPUART0_BAUD_RESYNCDIS_1             = 1,     /*!< 1 : Resynchronization during received data word is disabled               */
} LPUART0_BAUD_RESYNCDIS_Enum;

/* ========================================  LPUART0 LPUART0_BAUD BOTHEDGE [17..17]  ========================================= */
typedef enum {                                  /*!< LPUART0_BAUD_BOTHEDGE                                                     */
  LPUART0_BAUD_BOTHEDGE_0              = 0,     /*!< 0 : Receiver samples input data using the rising edge of the
                                                     baud rate clock.                                                          */
  LPUART0_BAUD_BOTHEDGE_1              = 1,     /*!< 1 : Receiver samples input data using the rising and falling
                                                     edge of the baud rate clock.                                              */
} LPUART0_BAUD_BOTHEDGE_Enum;

/* =========================================  LPUART0 LPUART0_BAUD MATCFG [18..19]  ========================================== */
typedef enum {                                  /*!< LPUART0_BAUD_MATCFG                                                       */
  LPUART0_BAUD_MATCFG_00               = 0,     /*!< 00 : Address Match Wakeup                                                 */
  LPUART0_BAUD_MATCFG_01               = 1,     /*!< 01 : Idle Match Wakeup                                                    */
  LPUART0_BAUD_MATCFG_10               = 2,     /*!< 10 : Match On and Match Off                                               */
} LPUART0_BAUD_MATCFG_Enum;

/* =========================================  LPUART0 LPUART0_BAUD RIDMAE [20..20]  ========================================== */
typedef enum {                                  /*!< LPUART0_BAUD_RIDMAE                                                       */
  LPUART0_BAUD_RIDMAE_0                = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPUART0_BAUD_RIDMAE_1                = 1,     /*!< 1 : DMA request enabled.                                                  */
} LPUART0_BAUD_RIDMAE_Enum;

/* ==========================================  LPUART0 LPUART0_BAUD RDMAE [21..21]  ========================================== */
typedef enum {                                  /*!< LPUART0_BAUD_RDMAE                                                        */
  LPUART0_BAUD_RDMAE_0                 = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPUART0_BAUD_RDMAE_1                 = 1,     /*!< 1 : DMA request enabled.                                                  */
} LPUART0_BAUD_RDMAE_Enum;

/* ==========================================  LPUART0 LPUART0_BAUD TDMAE [23..23]  ========================================== */
typedef enum {                                  /*!< LPUART0_BAUD_TDMAE                                                        */
  LPUART0_BAUD_TDMAE_0                 = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPUART0_BAUD_TDMAE_1                 = 1,     /*!< 1 : DMA request enabled.                                                  */
} LPUART0_BAUD_TDMAE_Enum;

/* ===========================================  LPUART0 LPUART0_BAUD OSR [24..28]  =========================================== */
typedef enum {                                  /*!< LPUART0_BAUD_OSR                                                          */
  LPUART0_BAUD_OSR_00000               = 0,     /*!< 00000 : Writing 0 to this field will result in an oversampling
                                                     ratio of 16                                                               */
  LPUART0_BAUD_OSR_00011               = 3,     /*!< 00011 : Oversampling ratio of 4, requires BOTHEDGE to be set.             */
  LPUART0_BAUD_OSR_00100               = 4,     /*!< 00100 : Oversampling ratio of 5, requires BOTHEDGE to be set.             */
  LPUART0_BAUD_OSR_00101               = 5,     /*!< 00101 : Oversampling ratio of 6, requires BOTHEDGE to be set.             */
  LPUART0_BAUD_OSR_00110               = 6,     /*!< 00110 : Oversampling ratio of 7, requires BOTHEDGE to be set.             */
  LPUART0_BAUD_OSR_00111               = 7,     /*!< 00111 : Oversampling ratio of 8.                                          */
  LPUART0_BAUD_OSR_01000               = 8,     /*!< 01000 : Oversampling ratio of 9.                                          */
  LPUART0_BAUD_OSR_01001               = 9,     /*!< 01001 : Oversampling ratio of 10.                                         */
  LPUART0_BAUD_OSR_01010               = 10,    /*!< 01010 : Oversampling ratio of 11.                                         */
  LPUART0_BAUD_OSR_01011               = 11,    /*!< 01011 : Oversampling ratio of 12.                                         */
  LPUART0_BAUD_OSR_01100               = 12,    /*!< 01100 : Oversampling ratio of 13.                                         */
  LPUART0_BAUD_OSR_01101               = 13,    /*!< 01101 : Oversampling ratio of 14.                                         */
  LPUART0_BAUD_OSR_01110               = 14,    /*!< 01110 : Oversampling ratio of 15.                                         */
  LPUART0_BAUD_OSR_01111               = 15,    /*!< 01111 : Oversampling ratio of 16.                                         */
  LPUART0_BAUD_OSR_10000               = 16,    /*!< 10000 : Oversampling ratio of 17.                                         */
  LPUART0_BAUD_OSR_10001               = 17,    /*!< 10001 : Oversampling ratio of 18.                                         */
  LPUART0_BAUD_OSR_10010               = 18,    /*!< 10010 : Oversampling ratio of 19.                                         */
  LPUART0_BAUD_OSR_10011               = 19,    /*!< 10011 : Oversampling ratio of 20.                                         */
  LPUART0_BAUD_OSR_10100               = 20,    /*!< 10100 : Oversampling ratio of 21.                                         */
  LPUART0_BAUD_OSR_10101               = 21,    /*!< 10101 : Oversampling ratio of 22.                                         */
  LPUART0_BAUD_OSR_10110               = 22,    /*!< 10110 : Oversampling ratio of 23.                                         */
  LPUART0_BAUD_OSR_10111               = 23,    /*!< 10111 : Oversampling ratio of 24.                                         */
  LPUART0_BAUD_OSR_11000               = 24,    /*!< 11000 : Oversampling ratio of 25.                                         */
  LPUART0_BAUD_OSR_11001               = 25,    /*!< 11001 : Oversampling ratio of 26.                                         */
  LPUART0_BAUD_OSR_11010               = 26,    /*!< 11010 : Oversampling ratio of 27.                                         */
  LPUART0_BAUD_OSR_11011               = 27,    /*!< 11011 : Oversampling ratio of 28.                                         */
  LPUART0_BAUD_OSR_11100               = 28,    /*!< 11100 : Oversampling ratio of 29.                                         */
  LPUART0_BAUD_OSR_11101               = 29,    /*!< 11101 : Oversampling ratio of 30.                                         */
  LPUART0_BAUD_OSR_11110               = 30,    /*!< 11110 : Oversampling ratio of 31.                                         */
  LPUART0_BAUD_OSR_11111               = 31,    /*!< 11111 : Oversampling ratio of 32.                                         */
} LPUART0_BAUD_OSR_Enum;

/* ===========================================  LPUART0 LPUART0_BAUD M10 [29..29]  =========================================== */
typedef enum {                                  /*!< LPUART0_BAUD_M10                                                          */
  LPUART0_BAUD_M10_0                   = 0,     /*!< 0 : Receiver and transmitter use 7-bit to 9-bit data characters.          */
  LPUART0_BAUD_M10_1                   = 1,     /*!< 1 : Receiver and transmitter use 10-bit data characters.                  */
} LPUART0_BAUD_M10_Enum;

/* ==========================================  LPUART0 LPUART0_BAUD MAEN2 [30..30]  ========================================== */
typedef enum {                                  /*!< LPUART0_BAUD_MAEN2                                                        */
  LPUART0_BAUD_MAEN2_0                 = 0,     /*!< 0 : Normal operation.                                                     */
  LPUART0_BAUD_MAEN2_1                 = 1,     /*!< 1 : Enables automatic address matching or data matching mode
                                                     for MATCH[MA2].                                                           */
} LPUART0_BAUD_MAEN2_Enum;

/* ==========================================  LPUART0 LPUART0_BAUD MAEN1 [31..31]  ========================================== */
typedef enum {                                  /*!< LPUART0_BAUD_MAEN1                                                        */
  LPUART0_BAUD_MAEN1_0                 = 0,     /*!< 0 : Normal operation.                                                     */
  LPUART0_BAUD_MAEN1_1                 = 1,     /*!< 1 : Enables automatic address matching or data matching mode
                                                     for MATCH[MA1].                                                           */
} LPUART0_BAUD_MAEN1_Enum;

/* =====================================================  LPUART0_STAT  ====================================================== */
/* ==========================================  LPUART0 LPUART0_STAT MA2F [14..14]  =========================================== */
typedef enum {                                  /*!< LPUART0_STAT_MA2F                                                         */
  LPUART0_STAT_MA2F_0                  = 0,     /*!< 0 : Received data is not equal to MA2                                     */
  LPUART0_STAT_MA2F_1                  = 1,     /*!< 1 : Received data is equal to MA2                                         */
} LPUART0_STAT_MA2F_Enum;

/* ==========================================  LPUART0 LPUART0_STAT MA1F [15..15]  =========================================== */
typedef enum {                                  /*!< LPUART0_STAT_MA1F                                                         */
  LPUART0_STAT_MA1F_0                  = 0,     /*!< 0 : Received data is not equal to MA1                                     */
  LPUART0_STAT_MA1F_1                  = 1,     /*!< 1 : Received data is equal to MA1                                         */
} LPUART0_STAT_MA1F_Enum;

/* ===========================================  LPUART0 LPUART0_STAT PF [16..16]  ============================================ */
typedef enum {                                  /*!< LPUART0_STAT_PF                                                           */
  LPUART0_STAT_PF_0                    = 0,     /*!< 0 : No parity error.                                                      */
  LPUART0_STAT_PF_1                    = 1,     /*!< 1 : Parity error.                                                         */
} LPUART0_STAT_PF_Enum;

/* ===========================================  LPUART0 LPUART0_STAT FE [17..17]  ============================================ */
typedef enum {                                  /*!< LPUART0_STAT_FE                                                           */
  LPUART0_STAT_FE_0                    = 0,     /*!< 0 : No framing error detected. This does not guarantee the framing
                                                     is correct.                                                               */
  LPUART0_STAT_FE_1                    = 1,     /*!< 1 : Framing error.                                                        */
} LPUART0_STAT_FE_Enum;

/* ===========================================  LPUART0 LPUART0_STAT NF [18..18]  ============================================ */
typedef enum {                                  /*!< LPUART0_STAT_NF                                                           */
  LPUART0_STAT_NF_0                    = 0,     /*!< 0 : No noise detected.                                                    */
  LPUART0_STAT_NF_1                    = 1,     /*!< 1 : Noise detected in the received character in LPUART_DATA.              */
} LPUART0_STAT_NF_Enum;

/* ===========================================  LPUART0 LPUART0_STAT OR [19..19]  ============================================ */
typedef enum {                                  /*!< LPUART0_STAT_OR                                                           */
  LPUART0_STAT_OR_0                    = 0,     /*!< 0 : No overrun.                                                           */
  LPUART0_STAT_OR_1                    = 1,     /*!< 1 : Receive overrun (new LPUART data lost).                               */
} LPUART0_STAT_OR_Enum;

/* ==========================================  LPUART0 LPUART0_STAT IDLE [20..20]  =========================================== */
typedef enum {                                  /*!< LPUART0_STAT_IDLE                                                         */
  LPUART0_STAT_IDLE_0                  = 0,     /*!< 0 : No idle line detected.                                                */
  LPUART0_STAT_IDLE_1                  = 1,     /*!< 1 : Idle line was detected.                                               */
} LPUART0_STAT_IDLE_Enum;

/* ==========================================  LPUART0 LPUART0_STAT RDRF [21..21]  =========================================== */
typedef enum {                                  /*!< LPUART0_STAT_RDRF                                                         */
  LPUART0_STAT_RDRF_0                  = 0,     /*!< 0 : Receive data buffer empty.                                            */
  LPUART0_STAT_RDRF_1                  = 1,     /*!< 1 : Receive data buffer full.                                             */
} LPUART0_STAT_RDRF_Enum;

/* ===========================================  LPUART0 LPUART0_STAT TC [22..22]  ============================================ */
typedef enum {                                  /*!< LPUART0_STAT_TC                                                           */
  LPUART0_STAT_TC_0                    = 0,     /*!< 0 : Transmitter active (sending data, a preamble, or a break).            */
  LPUART0_STAT_TC_1                    = 1,     /*!< 1 : Transmitter idle (transmission activity complete).                    */
} LPUART0_STAT_TC_Enum;

/* ==========================================  LPUART0 LPUART0_STAT TDRE [23..23]  =========================================== */
typedef enum {                                  /*!< LPUART0_STAT_TDRE                                                         */
  LPUART0_STAT_TDRE_0                  = 0,     /*!< 0 : Transmit data buffer full.                                            */
  LPUART0_STAT_TDRE_1                  = 1,     /*!< 1 : Transmit data buffer empty.                                           */
} LPUART0_STAT_TDRE_Enum;

/* ===========================================  LPUART0 LPUART0_STAT RAF [24..24]  =========================================== */
typedef enum {                                  /*!< LPUART0_STAT_RAF                                                          */
  LPUART0_STAT_RAF_0                   = 0,     /*!< 0 : LPUART receiver idle waiting for a start bit.                         */
  LPUART0_STAT_RAF_1                   = 1,     /*!< 1 : LPUART receiver active (RXD input not idle).                          */
} LPUART0_STAT_RAF_Enum;

/* ==========================================  LPUART0 LPUART0_STAT LBKDE [25..25]  ========================================== */
typedef enum {                                  /*!< LPUART0_STAT_LBKDE                                                        */
  LPUART0_STAT_LBKDE_0                 = 0,     /*!< 0 : LIN break detect is disabled, normal break character can
                                                     be detected.                                                              */
  LPUART0_STAT_LBKDE_1                 = 1,     /*!< 1 : LIN break detect is enabled. LIN break character is detected
                                                     at length of 11 bit times (if M = 0) or 12 (if M = 1) or
                                                     13 (M10 = 1).                                                             */
} LPUART0_STAT_LBKDE_Enum;

/* ==========================================  LPUART0 LPUART0_STAT BRK13 [26..26]  ========================================== */
typedef enum {                                  /*!< LPUART0_STAT_BRK13                                                        */
  LPUART0_STAT_BRK13_0                 = 0,     /*!< 0 : Break character is transmitted with length of 9 to 13 bit
                                                     times.                                                                    */
  LPUART0_STAT_BRK13_1                 = 1,     /*!< 1 : Break character is transmitted with length of 12 to 15 bit
                                                     times.                                                                    */
} LPUART0_STAT_BRK13_Enum;

/* ==========================================  LPUART0 LPUART0_STAT RWUID [27..27]  ========================================== */
typedef enum {                                  /*!< LPUART0_STAT_RWUID                                                        */
  LPUART0_STAT_RWUID_0                 = 0,     /*!< 0 : During receive standby state (RWU = 1), the IDLE bit does
                                                     not get set upon detection of an idle character. During
                                                     address match wakeup, the IDLE bit does not set when an
                                                     address does not match.                                                   */
  LPUART0_STAT_RWUID_1                 = 1,     /*!< 1 : During receive standby state (RWU = 1), the IDLE bit gets
                                                     set upon detection of an idle character. During address
                                                     match wakeup, the IDLE bit does set when an address does
                                                     not match.                                                                */
} LPUART0_STAT_RWUID_Enum;

/* ==========================================  LPUART0 LPUART0_STAT RXINV [28..28]  ========================================== */
typedef enum {                                  /*!< LPUART0_STAT_RXINV                                                        */
  LPUART0_STAT_RXINV_0                 = 0,     /*!< 0 : Receive data not inverted.                                            */
  LPUART0_STAT_RXINV_1                 = 1,     /*!< 1 : Receive data inverted.                                                */
} LPUART0_STAT_RXINV_Enum;

/* ==========================================  LPUART0 LPUART0_STAT MSBF [29..29]  =========================================== */
typedef enum {                                  /*!< LPUART0_STAT_MSBF                                                         */
  LPUART0_STAT_MSBF_0                  = 0,     /*!< 0 : LSB (bit0) is the first bit that is transmitted following
                                                     the start bit. Further, the first bit received after the
                                                     start bit is identified as bit0.                                          */
  LPUART0_STAT_MSBF_1                  = 1,     /*!< 1 : MSB (bit9, bit8, bit7 or bit6) is the first bit that is
                                                     transmitted following the start bit depending on the setting
                                                     of CTRL[M], CTRL[PE] and BAUD[M10]. Further, the first
                                                     bit received after the start bit is identified as bit9,
                                                     bit8, bit7 or bit6 depending on the setting of CTRL[M]
                                                     and CTRL[PE].                                                             */
} LPUART0_STAT_MSBF_Enum;

/* =========================================  LPUART0 LPUART0_STAT RXEDGIF [30..30]  ========================================= */
typedef enum {                                  /*!< LPUART0_STAT_RXEDGIF                                                      */
  LPUART0_STAT_RXEDGIF_0               = 0,     /*!< 0 : No active edge on the receive pin has occurred.                       */
  LPUART0_STAT_RXEDGIF_1               = 1,     /*!< 1 : An active edge on the receive pin has occurred.                       */
} LPUART0_STAT_RXEDGIF_Enum;

/* =========================================  LPUART0 LPUART0_STAT LBKDIF [31..31]  ========================================== */
typedef enum {                                  /*!< LPUART0_STAT_LBKDIF                                                       */
  LPUART0_STAT_LBKDIF_0                = 0,     /*!< 0 : No LIN break character has been detected.                             */
  LPUART0_STAT_LBKDIF_1                = 1,     /*!< 1 : LIN break character has been detected.                                */
} LPUART0_STAT_LBKDIF_Enum;

/* =====================================================  LPUART0_CTRL  ====================================================== */
/* ============================================  LPUART0 LPUART0_CTRL PT [0..0]  ============================================= */
typedef enum {                                  /*!< LPUART0_CTRL_PT                                                           */
  LPUART0_CTRL_PT_0                    = 0,     /*!< 0 : Even parity.                                                          */
  LPUART0_CTRL_PT_1                    = 1,     /*!< 1 : Odd parity.                                                           */
} LPUART0_CTRL_PT_Enum;

/* ============================================  LPUART0 LPUART0_CTRL PE [1..1]  ============================================= */
typedef enum {                                  /*!< LPUART0_CTRL_PE                                                           */
  LPUART0_CTRL_PE_0                    = 0,     /*!< 0 : No hardware parity generation or checking.                            */
  LPUART0_CTRL_PE_1                    = 1,     /*!< 1 : Parity enabled.                                                       */
} LPUART0_CTRL_PE_Enum;

/* ============================================  LPUART0 LPUART0_CTRL ILT [2..2]  ============================================ */
typedef enum {                                  /*!< LPUART0_CTRL_ILT                                                          */
  LPUART0_CTRL_ILT_0                   = 0,     /*!< 0 : Idle character bit count starts after start bit.                      */
  LPUART0_CTRL_ILT_1                   = 1,     /*!< 1 : Idle character bit count starts after stop bit.                       */
} LPUART0_CTRL_ILT_Enum;

/* ===========================================  LPUART0 LPUART0_CTRL WAKE [3..3]  ============================================ */
typedef enum {                                  /*!< LPUART0_CTRL_WAKE                                                         */
  LPUART0_CTRL_WAKE_0                  = 0,     /*!< 0 : Configures RWU for idle-line wakeup.                                  */
  LPUART0_CTRL_WAKE_1                  = 1,     /*!< 1 : Configures RWU with address-mark wakeup.                              */
} LPUART0_CTRL_WAKE_Enum;

/* =============================================  LPUART0 LPUART0_CTRL M [4..4]  ============================================= */
typedef enum {                                  /*!< LPUART0_CTRL_M                                                            */
  LPUART0_CTRL_M_0                     = 0,     /*!< 0 : Receiver and transmitter use 8-bit data characters.                   */
  LPUART0_CTRL_M_1                     = 1,     /*!< 1 : Receiver and transmitter use 9-bit data characters.                   */
} LPUART0_CTRL_M_Enum;

/* ===========================================  LPUART0 LPUART0_CTRL RSRC [5..5]  ============================================ */
typedef enum {                                  /*!< LPUART0_CTRL_RSRC                                                         */
  LPUART0_CTRL_RSRC_0                  = 0,     /*!< 0 : Provided LOOPS is set, RSRC is cleared, selects internal
                                                     loop back mode and the LPUART does not use the RXD pin.                   */
  LPUART0_CTRL_RSRC_1                  = 1,     /*!< 1 : Single-wire LPUART mode where the TXD pin is connected to
                                                     the transmitter output and receiver input.                                */
} LPUART0_CTRL_RSRC_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL DOZEEN [6..6]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_DOZEEN                                                       */
  LPUART0_CTRL_DOZEEN_0                = 0,     /*!< 0 : LPUART is enabled in Doze mode.                                       */
  LPUART0_CTRL_DOZEEN_1                = 1,     /*!< 1 : LPUART is disabled in Doze mode.                                      */
} LPUART0_CTRL_DOZEEN_Enum;

/* ===========================================  LPUART0 LPUART0_CTRL LOOPS [7..7]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_LOOPS                                                        */
  LPUART0_CTRL_LOOPS_0                 = 0,     /*!< 0 : Normal operation - RXD and TXD use separate pins.                     */
  LPUART0_CTRL_LOOPS_1                 = 1,     /*!< 1 : Loop mode or single-wire mode where transmitter outputs
                                                     are internally connected to receiver input (see RSRC bit).                */
} LPUART0_CTRL_LOOPS_Enum;

/* =========================================  LPUART0 LPUART0_CTRL IDLECFG [8..10]  ========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_IDLECFG                                                      */
  LPUART0_CTRL_IDLECFG_000             = 0,     /*!< 000 : 1 idle character                                                    */
  LPUART0_CTRL_IDLECFG_001             = 1,     /*!< 001 : 2 idle characters                                                   */
  LPUART0_CTRL_IDLECFG_010             = 2,     /*!< 010 : 4 idle characters                                                   */
  LPUART0_CTRL_IDLECFG_011             = 3,     /*!< 011 : 8 idle characters                                                   */
  LPUART0_CTRL_IDLECFG_100             = 4,     /*!< 100 : 16 idle characters                                                  */
  LPUART0_CTRL_IDLECFG_101             = 5,     /*!< 101 : 32 idle characters                                                  */
  LPUART0_CTRL_IDLECFG_110             = 6,     /*!< 110 : 64 idle characters                                                  */
  LPUART0_CTRL_IDLECFG_111             = 7,     /*!< 111 : 128 idle characters                                                 */
} LPUART0_CTRL_IDLECFG_Enum;

/* ===========================================  LPUART0 LPUART0_CTRL M7 [11..11]  ============================================ */
typedef enum {                                  /*!< LPUART0_CTRL_M7                                                           */
  LPUART0_CTRL_M7_0                    = 0,     /*!< 0 : Receiver and transmitter use 8-bit to 10-bit data characters.         */
  LPUART0_CTRL_M7_1                    = 1,     /*!< 1 : Receiver and transmitter use 7-bit data characters.                   */
} LPUART0_CTRL_M7_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL MA2IE [14..14]  ========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_MA2IE                                                        */
  LPUART0_CTRL_MA2IE_0                 = 0,     /*!< 0 : MA2F interrupt disabled                                               */
  LPUART0_CTRL_MA2IE_1                 = 1,     /*!< 1 : MA2F interrupt enabled                                                */
} LPUART0_CTRL_MA2IE_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL MA1IE [15..15]  ========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_MA1IE                                                        */
  LPUART0_CTRL_MA1IE_0                 = 0,     /*!< 0 : MA1F interrupt disabled                                               */
  LPUART0_CTRL_MA1IE_1                 = 1,     /*!< 1 : MA1F interrupt enabled                                                */
} LPUART0_CTRL_MA1IE_Enum;

/* ===========================================  LPUART0 LPUART0_CTRL SBK [16..16]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_SBK                                                          */
  LPUART0_CTRL_SBK_0                   = 0,     /*!< 0 : Normal transmitter operation.                                         */
  LPUART0_CTRL_SBK_1                   = 1,     /*!< 1 : Queue break character(s) to be sent.                                  */
} LPUART0_CTRL_SBK_Enum;

/* ===========================================  LPUART0 LPUART0_CTRL RWU [17..17]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_RWU                                                          */
  LPUART0_CTRL_RWU_0                   = 0,     /*!< 0 : Normal receiver operation.                                            */
  LPUART0_CTRL_RWU_1                   = 1,     /*!< 1 : LPUART receiver in standby waiting for wakeup condition.              */
} LPUART0_CTRL_RWU_Enum;

/* ===========================================  LPUART0 LPUART0_CTRL RE [18..18]  ============================================ */
typedef enum {                                  /*!< LPUART0_CTRL_RE                                                           */
  LPUART0_CTRL_RE_0                    = 0,     /*!< 0 : Receiver disabled.                                                    */
  LPUART0_CTRL_RE_1                    = 1,     /*!< 1 : Receiver enabled.                                                     */
} LPUART0_CTRL_RE_Enum;

/* ===========================================  LPUART0 LPUART0_CTRL TE [19..19]  ============================================ */
typedef enum {                                  /*!< LPUART0_CTRL_TE                                                           */
  LPUART0_CTRL_TE_0                    = 0,     /*!< 0 : Transmitter disabled.                                                 */
  LPUART0_CTRL_TE_1                    = 1,     /*!< 1 : Transmitter enabled.                                                  */
} LPUART0_CTRL_TE_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL ILIE [20..20]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_ILIE                                                         */
  LPUART0_CTRL_ILIE_0                  = 0,     /*!< 0 : Hardware interrupts from IDLE disabled; use polling.                  */
  LPUART0_CTRL_ILIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when IDLE flag is 1.                     */
} LPUART0_CTRL_ILIE_Enum;

/* ===========================================  LPUART0 LPUART0_CTRL RIE [21..21]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_RIE                                                          */
  LPUART0_CTRL_RIE_0                   = 0,     /*!< 0 : Hardware interrupts from RDRF disabled; use polling.                  */
  LPUART0_CTRL_RIE_1                   = 1,     /*!< 1 : Hardware interrupt requested when RDRF flag is 1.                     */
} LPUART0_CTRL_RIE_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL TCIE [22..22]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_TCIE                                                         */
  LPUART0_CTRL_TCIE_0                  = 0,     /*!< 0 : Hardware interrupts from TC disabled; use polling.                    */
  LPUART0_CTRL_TCIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when TC flag is 1.                       */
} LPUART0_CTRL_TCIE_Enum;

/* ===========================================  LPUART0 LPUART0_CTRL TIE [23..23]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_TIE                                                          */
  LPUART0_CTRL_TIE_0                   = 0,     /*!< 0 : Hardware interrupts from TDRE disabled; use polling.                  */
  LPUART0_CTRL_TIE_1                   = 1,     /*!< 1 : Hardware interrupt requested when TDRE flag is 1.                     */
} LPUART0_CTRL_TIE_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL PEIE [24..24]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_PEIE                                                         */
  LPUART0_CTRL_PEIE_0                  = 0,     /*!< 0 : PF interrupts disabled; use polling).                                 */
  LPUART0_CTRL_PEIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when PF is set.                          */
} LPUART0_CTRL_PEIE_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL FEIE [25..25]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_FEIE                                                         */
  LPUART0_CTRL_FEIE_0                  = 0,     /*!< 0 : FE interrupts disabled; use polling.                                  */
  LPUART0_CTRL_FEIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when FE is set.                          */
} LPUART0_CTRL_FEIE_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL NEIE [26..26]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_NEIE                                                         */
  LPUART0_CTRL_NEIE_0                  = 0,     /*!< 0 : NF interrupts disabled; use polling.                                  */
  LPUART0_CTRL_NEIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when NF is set.                          */
} LPUART0_CTRL_NEIE_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL ORIE [27..27]  =========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_ORIE                                                         */
  LPUART0_CTRL_ORIE_0                  = 0,     /*!< 0 : OR interrupts disabled; use polling.                                  */
  LPUART0_CTRL_ORIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when OR is set.                          */
} LPUART0_CTRL_ORIE_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL TXINV [28..28]  ========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_TXINV                                                        */
  LPUART0_CTRL_TXINV_0                 = 0,     /*!< 0 : Transmit data not inverted.                                           */
  LPUART0_CTRL_TXINV_1                 = 1,     /*!< 1 : Transmit data inverted.                                               */
} LPUART0_CTRL_TXINV_Enum;

/* ==========================================  LPUART0 LPUART0_CTRL TXDIR [29..29]  ========================================== */
typedef enum {                                  /*!< LPUART0_CTRL_TXDIR                                                        */
  LPUART0_CTRL_TXDIR_0                 = 0,     /*!< 0 : TXD pin is an input in single-wire mode.                              */
  LPUART0_CTRL_TXDIR_1                 = 1,     /*!< 1 : TXD pin is an output in single-wire mode.                             */
} LPUART0_CTRL_TXDIR_Enum;

/* =====================================================  LPUART0_DATA  ====================================================== */
/* =========================================  LPUART0 LPUART0_DATA IDLINE [11..11]  ========================================== */
typedef enum {                                  /*!< LPUART0_DATA_IDLINE                                                       */
  LPUART0_DATA_IDLINE_0                = 0,     /*!< 0 : Receiver was not idle before receiving this character.                */
  LPUART0_DATA_IDLINE_1                = 1,     /*!< 1 : Receiver was idle before receiving this character.                    */
} LPUART0_DATA_IDLINE_Enum;

/* =========================================  LPUART0 LPUART0_DATA RXEMPT [12..12]  ========================================== */
typedef enum {                                  /*!< LPUART0_DATA_RXEMPT                                                       */
  LPUART0_DATA_RXEMPT_0                = 0,     /*!< 0 : Receive buffer contains valid data.                                   */
  LPUART0_DATA_RXEMPT_1                = 1,     /*!< 1 : Receive buffer is empty, data returned on read is not valid.          */
} LPUART0_DATA_RXEMPT_Enum;

/* =========================================  LPUART0 LPUART0_DATA FRETSC [13..13]  ========================================== */
typedef enum {                                  /*!< LPUART0_DATA_FRETSC                                                       */
  LPUART0_DATA_FRETSC_0                = 0,     /*!< 0 : The dataword was received without a frame error on read,
                                                     or transmit a normal character on write.                                  */
  LPUART0_DATA_FRETSC_1                = 1,     /*!< 1 : The dataword was received with a frame error, or transmit
                                                     an idle or break character on transmit.                                   */
} LPUART0_DATA_FRETSC_Enum;

/* =========================================  LPUART0 LPUART0_DATA PARITYE [14..14]  ========================================= */
typedef enum {                                  /*!< LPUART0_DATA_PARITYE                                                      */
  LPUART0_DATA_PARITYE_0               = 0,     /*!< 0 : The dataword was received without a parity error.                     */
  LPUART0_DATA_PARITYE_1               = 1,     /*!< 1 : The dataword was received with a parity error.                        */
} LPUART0_DATA_PARITYE_Enum;

/* ==========================================  LPUART0 LPUART0_DATA NOISY [15..15]  ========================================== */
typedef enum {                                  /*!< LPUART0_DATA_NOISY                                                        */
  LPUART0_DATA_NOISY_0                 = 0,     /*!< 0 : The dataword was received without noise.                              */
  LPUART0_DATA_NOISY_1                 = 1,     /*!< 1 : The data was received with noise.                                     */
} LPUART0_DATA_NOISY_Enum;

/* =====================================================  LPUART0_MATCH  ===================================================== */
/* =====================================================  LPUART0_MODIR  ===================================================== */
/* ==========================================  LPUART0 LPUART0_MODIR TXCTSE [0..0]  ========================================== */
typedef enum {                                  /*!< LPUART0_MODIR_TXCTSE                                                      */
  LPUART0_MODIR_TXCTSE_0               = 0,     /*!< 0 : CTS has no effect on the transmitter.                                 */
  LPUART0_MODIR_TXCTSE_1               = 1,     /*!< 1 : Enables clear-to-send operation. The transmitter checks
                                                     the state of CTS each time it is ready to send a character.
                                                     If CTS is asserted, the character is sent. If CTS is deasserted,
                                                     the signal TXD remains in the mark state and transmission
                                                     is delayed until CTS is asserted. Changes in CTS as a character
                                                     is being sent do not affect its transmission.                             */
} LPUART0_MODIR_TXCTSE_Enum;

/* ==========================================  LPUART0 LPUART0_MODIR TXRTSE [1..1]  ========================================== */
typedef enum {                                  /*!< LPUART0_MODIR_TXRTSE                                                      */
  LPUART0_MODIR_TXRTSE_0               = 0,     /*!< 0 : The transmitter has no effect on RTS.                                 */
  LPUART0_MODIR_TXRTSE_1               = 1,     /*!< 1 : When a character is placed into an empty transmitter data
                                                     buffer , RTS asserts one bit time before the start bit
                                                     is transmitted. RTS deasserts one bit time after all characters
                                                     in the transmitter data buffer and shift register are completely
                                                     sent, including the last stop bit.                                        */
} LPUART0_MODIR_TXRTSE_Enum;

/* =========================================  LPUART0 LPUART0_MODIR TXRTSPOL [2..2]  ========================================= */
typedef enum {                                  /*!< LPUART0_MODIR_TXRTSPOL                                                    */
  LPUART0_MODIR_TXRTSPOL_0             = 0,     /*!< 0 : Transmitter RTS is active low.                                        */
  LPUART0_MODIR_TXRTSPOL_1             = 1,     /*!< 1 : Transmitter RTS is active high.                                       */
} LPUART0_MODIR_TXRTSPOL_Enum;

/* ==========================================  LPUART0 LPUART0_MODIR RXRTSE [3..3]  ========================================== */
typedef enum {                                  /*!< LPUART0_MODIR_RXRTSE                                                      */
  LPUART0_MODIR_RXRTSE_0               = 0,     /*!< 0 : The receiver has no effect on RTS.                                    */
} LPUART0_MODIR_RXRTSE_Enum;

/* ==========================================  LPUART0 LPUART0_MODIR TXCTSC [4..4]  ========================================== */
typedef enum {                                  /*!< LPUART0_MODIR_TXCTSC                                                      */
  LPUART0_MODIR_TXCTSC_0               = 0,     /*!< 0 : CTS input is sampled at the start of each character.                  */
  LPUART0_MODIR_TXCTSC_1               = 1,     /*!< 1 : CTS input is sampled when the transmitter is idle.                    */
} LPUART0_MODIR_TXCTSC_Enum;

/* =========================================  LPUART0 LPUART0_MODIR TXCTSSRC [5..5]  ========================================= */
typedef enum {                                  /*!< LPUART0_MODIR_TXCTSSRC                                                    */
  LPUART0_MODIR_TXCTSSRC_0             = 0,     /*!< 0 : CTS input is the CTS_B pin.                                           */
  LPUART0_MODIR_TXCTSSRC_1             = 1,     /*!< 1 : CTS input is the inverted Receiver Match result.                      */
} LPUART0_MODIR_TXCTSSRC_Enum;

/* ==========================================  LPUART0 LPUART0_MODIR TNP [16..17]  =========================================== */
typedef enum {                                  /*!< LPUART0_MODIR_TNP                                                         */
  LPUART0_MODIR_TNP_00                 = 0,     /*!< 00 : 1/OSR.                                                               */
  LPUART0_MODIR_TNP_01                 = 1,     /*!< 01 : 2/OSR.                                                               */
  LPUART0_MODIR_TNP_10                 = 2,     /*!< 10 : 3/OSR.                                                               */
  LPUART0_MODIR_TNP_11                 = 3,     /*!< 11 : 4/OSR.                                                               */
} LPUART0_MODIR_TNP_Enum;

/* ==========================================  LPUART0 LPUART0_MODIR IREN [18..18]  ========================================== */
typedef enum {                                  /*!< LPUART0_MODIR_IREN                                                        */
  LPUART0_MODIR_IREN_0                 = 0,     /*!< 0 : IR disabled.                                                          */
  LPUART0_MODIR_IREN_1                 = 1,     /*!< 1 : IR enabled.                                                           */
} LPUART0_MODIR_IREN_Enum;

/* =====================================================  LPUART0_FIFO  ====================================================== */
/* ========================================  LPUART0 LPUART0_FIFO RXFIFOSIZE [0..2]  ========================================= */
typedef enum {                                  /*!< LPUART0_FIFO_RXFIFOSIZE                                                   */
  LPUART0_FIFO_RXFIFOSIZE_000          = 0,     /*!< 000 : Receive FIFO/Buffer depth = 1 dataword.                             */
  LPUART0_FIFO_RXFIFOSIZE_001          = 1,     /*!< 001 : Receive FIFO/Buffer depth = 4 datawords.                            */
  LPUART0_FIFO_RXFIFOSIZE_010          = 2,     /*!< 010 : Receive FIFO/Buffer depth = 8 datawords.                            */
  LPUART0_FIFO_RXFIFOSIZE_011          = 3,     /*!< 011 : Receive FIFO/Buffer depth = 16 datawords.                           */
  LPUART0_FIFO_RXFIFOSIZE_100          = 4,     /*!< 100 : Receive FIFO/Buffer depth = 32 datawords.                           */
  LPUART0_FIFO_RXFIFOSIZE_101          = 5,     /*!< 101 : Receive FIFO/Buffer depth = 64 datawords.                           */
  LPUART0_FIFO_RXFIFOSIZE_110          = 6,     /*!< 110 : Receive FIFO/Buffer depth = 128 datawords.                          */
  LPUART0_FIFO_RXFIFOSIZE_111          = 7,     /*!< 111 : Receive FIFO/Buffer depth = 256 datawords.                          */
} LPUART0_FIFO_RXFIFOSIZE_Enum;

/* ===========================================  LPUART0 LPUART0_FIFO RXFE [3..3]  ============================================ */
typedef enum {                                  /*!< LPUART0_FIFO_RXFE                                                         */
  LPUART0_FIFO_RXFE_0                  = 0,     /*!< 0 : Receive FIFO is not enabled. Buffer is depth 1. (Legacy
                                                     support)                                                                  */
  LPUART0_FIFO_RXFE_1                  = 1,     /*!< 1 : Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.      */
} LPUART0_FIFO_RXFE_Enum;

/* ========================================  LPUART0 LPUART0_FIFO TXFIFOSIZE [4..6]  ========================================= */
typedef enum {                                  /*!< LPUART0_FIFO_TXFIFOSIZE                                                   */
  LPUART0_FIFO_TXFIFOSIZE_000          = 0,     /*!< 000 : Transmit FIFO/Buffer depth = 1 dataword.                            */
  LPUART0_FIFO_TXFIFOSIZE_001          = 1,     /*!< 001 : Transmit FIFO/Buffer depth = 4 datawords.                           */
  LPUART0_FIFO_TXFIFOSIZE_010          = 2,     /*!< 010 : Transmit FIFO/Buffer depth = 8 datawords.                           */
  LPUART0_FIFO_TXFIFOSIZE_011          = 3,     /*!< 011 : Transmit FIFO/Buffer depth = 16 datawords.                          */
  LPUART0_FIFO_TXFIFOSIZE_100          = 4,     /*!< 100 : Transmit FIFO/Buffer depth = 32 datawords.                          */
  LPUART0_FIFO_TXFIFOSIZE_101          = 5,     /*!< 101 : Transmit FIFO/Buffer depth = 64 datawords.                          */
  LPUART0_FIFO_TXFIFOSIZE_110          = 6,     /*!< 110 : Transmit FIFO/Buffer depth = 128 datawords.                         */
  LPUART0_FIFO_TXFIFOSIZE_111          = 7,     /*!< 111 : Transmit FIFO/Buffer depth = 256 datawords                          */
} LPUART0_FIFO_TXFIFOSIZE_Enum;

/* ===========================================  LPUART0 LPUART0_FIFO TXFE [7..7]  ============================================ */
typedef enum {                                  /*!< LPUART0_FIFO_TXFE                                                         */
  LPUART0_FIFO_TXFE_0                  = 0,     /*!< 0 : Transmit FIFO is not enabled. Buffer is depth 1. (Legacy
                                                     support).                                                                 */
  LPUART0_FIFO_TXFE_1                  = 1,     /*!< 1 : Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.    */
} LPUART0_FIFO_TXFE_Enum;

/* ===========================================  LPUART0 LPUART0_FIFO RXUFE [8..8]  =========================================== */
typedef enum {                                  /*!< LPUART0_FIFO_RXUFE                                                        */
  LPUART0_FIFO_RXUFE_0                 = 0,     /*!< 0 : RXUF flag does not generate an interrupt to the host.                 */
  LPUART0_FIFO_RXUFE_1                 = 1,     /*!< 1 : RXUF flag generates an interrupt to the host.                         */
} LPUART0_FIFO_RXUFE_Enum;

/* ===========================================  LPUART0 LPUART0_FIFO TXOFE [9..9]  =========================================== */
typedef enum {                                  /*!< LPUART0_FIFO_TXOFE                                                        */
  LPUART0_FIFO_TXOFE_0                 = 0,     /*!< 0 : TXOF flag does not generate an interrupt to the host.                 */
  LPUART0_FIFO_TXOFE_1                 = 1,     /*!< 1 : TXOF flag generates an interrupt to the host.                         */
} LPUART0_FIFO_TXOFE_Enum;

/* =========================================  LPUART0 LPUART0_FIFO RXIDEN [10..12]  ========================================== */
typedef enum {                                  /*!< LPUART0_FIFO_RXIDEN                                                       */
  LPUART0_FIFO_RXIDEN_000              = 0,     /*!< 000 : Disable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle.                                                         */
  LPUART0_FIFO_RXIDEN_001              = 1,     /*!< 001 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 1 character.                                         */
  LPUART0_FIFO_RXIDEN_010              = 2,     /*!< 010 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 2 characters.                                        */
  LPUART0_FIFO_RXIDEN_011              = 3,     /*!< 011 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 4 characters.                                        */
  LPUART0_FIFO_RXIDEN_100              = 4,     /*!< 100 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 8 characters.                                        */
  LPUART0_FIFO_RXIDEN_101              = 5,     /*!< 101 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 16 characters.                                       */
  LPUART0_FIFO_RXIDEN_110              = 6,     /*!< 110 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 32 characters.                                       */
  LPUART0_FIFO_RXIDEN_111              = 7,     /*!< 111 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 64 characters.                                       */
} LPUART0_FIFO_RXIDEN_Enum;

/* =========================================  LPUART0 LPUART0_FIFO RXFLUSH [14..14]  ========================================= */
typedef enum {                                  /*!< LPUART0_FIFO_RXFLUSH                                                      */
  LPUART0_FIFO_RXFLUSH_0               = 0,     /*!< 0 : No flush operation occurs.                                            */
  LPUART0_FIFO_RXFLUSH_1               = 1,     /*!< 1 : All data in the receive FIFO/buffer is cleared out.                   */
} LPUART0_FIFO_RXFLUSH_Enum;

/* =========================================  LPUART0 LPUART0_FIFO TXFLUSH [15..15]  ========================================= */
typedef enum {                                  /*!< LPUART0_FIFO_TXFLUSH                                                      */
  LPUART0_FIFO_TXFLUSH_0               = 0,     /*!< 0 : No flush operation occurs.                                            */
  LPUART0_FIFO_TXFLUSH_1               = 1,     /*!< 1 : All data in the transmit FIFO/Buffer is cleared out.                  */
} LPUART0_FIFO_TXFLUSH_Enum;

/* ==========================================  LPUART0 LPUART0_FIFO RXUF [16..16]  =========================================== */
typedef enum {                                  /*!< LPUART0_FIFO_RXUF                                                         */
  LPUART0_FIFO_RXUF_0                  = 0,     /*!< 0 : No receive buffer underflow has occurred since the last
                                                     time the flag was cleared.                                                */
  LPUART0_FIFO_RXUF_1                  = 1,     /*!< 1 : At least one receive buffer underflow has occurred since
                                                     the last time the flag was cleared.                                       */
} LPUART0_FIFO_RXUF_Enum;

/* ==========================================  LPUART0 LPUART0_FIFO TXOF [17..17]  =========================================== */
typedef enum {                                  /*!< LPUART0_FIFO_TXOF                                                         */
  LPUART0_FIFO_TXOF_0                  = 0,     /*!< 0 : No transmit buffer overflow has occurred since the last
                                                     time the flag was cleared.                                                */
  LPUART0_FIFO_TXOF_1                  = 1,     /*!< 1 : At least one transmit buffer overflow has occurred since
                                                     the last time the flag was cleared.                                       */
} LPUART0_FIFO_TXOF_Enum;

/* =========================================  LPUART0 LPUART0_FIFO RXEMPT [22..22]  ========================================== */
typedef enum {                                  /*!< LPUART0_FIFO_RXEMPT                                                       */
  LPUART0_FIFO_RXEMPT_0                = 0,     /*!< 0 : Receive buffer is not empty.                                          */
  LPUART0_FIFO_RXEMPT_1                = 1,     /*!< 1 : Receive buffer is empty.                                              */
} LPUART0_FIFO_RXEMPT_Enum;

/* =========================================  LPUART0 LPUART0_FIFO TXEMPT [23..23]  ========================================== */
typedef enum {                                  /*!< LPUART0_FIFO_TXEMPT                                                       */
  LPUART0_FIFO_TXEMPT_0                = 0,     /*!< 0 : Transmit buffer is not empty.                                         */
  LPUART0_FIFO_TXEMPT_1                = 1,     /*!< 1 : Transmit buffer is empty.                                             */
} LPUART0_FIFO_TXEMPT_Enum;

/* =====================================================  LPUART0_WATER  ===================================================== */


/* =========================================================================================================================== */
/* ================                                          LPUART1                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  LPUART1_VERID  ===================================================== */
/* =========================================  LPUART1 LPUART1_VERID FEATURE [0..15]  ========================================= */
typedef enum {                                  /*!< LPUART1_VERID_FEATURE                                                     */
  LPUART1_VERID_FEATURE_0000000000000001 = 1,   /*!< 0000000000000001 : Standard feature set.                                  */
  LPUART1_VERID_FEATURE_0000000000000011 = 3,   /*!< 0000000000000011 : Standard feature set with MODEM/IrDA support.          */
} LPUART1_VERID_FEATURE_Enum;

/* =====================================================  LPUART1_PARAM  ===================================================== */
/* ====================================================  LPUART1_GLOBAL  ===================================================== */
/* ===========================================  LPUART1 LPUART1_GLOBAL RST [1..1]  =========================================== */
typedef enum {                                  /*!< LPUART1_GLOBAL_RST                                                        */
  LPUART1_GLOBAL_RST_0                 = 0,     /*!< 0 : Module is not reset.                                                  */
  LPUART1_GLOBAL_RST_1                 = 1,     /*!< 1 : Module is reset.                                                      */
} LPUART1_GLOBAL_RST_Enum;

/* ====================================================  LPUART1_PINCFG  ===================================================== */
/* =========================================  LPUART1 LPUART1_PINCFG TRGSEL [0..1]  ========================================== */
typedef enum {                                  /*!< LPUART1_PINCFG_TRGSEL                                                     */
  LPUART1_PINCFG_TRGSEL_00             = 0,     /*!< 00 : Input trigger is disabled.                                           */
  LPUART1_PINCFG_TRGSEL_01             = 1,     /*!< 01 : Input trigger is used instead of RXD pin input.                      */
  LPUART1_PINCFG_TRGSEL_10             = 2,     /*!< 10 : Input trigger is used instead of CTS_B pin input.                    */
  LPUART1_PINCFG_TRGSEL_11             = 3,     /*!< 11 : Input trigger is used to modulate the TXD pin output. The
                                                     TXD pin output (after TXINV configuration) is ANDed with
                                                     the input trigger.                                                        */
} LPUART1_PINCFG_TRGSEL_Enum;

/* =====================================================  LPUART1_BAUD  ====================================================== */
/* ==========================================  LPUART1 LPUART1_BAUD SBNS [13..13]  =========================================== */
typedef enum {                                  /*!< LPUART1_BAUD_SBNS                                                         */
  LPUART1_BAUD_SBNS_0                  = 0,     /*!< 0 : One stop bit.                                                         */
  LPUART1_BAUD_SBNS_1                  = 1,     /*!< 1 : Two stop bits.                                                        */
} LPUART1_BAUD_SBNS_Enum;

/* =========================================  LPUART1 LPUART1_BAUD RXEDGIE [14..14]  ========================================= */
typedef enum {                                  /*!< LPUART1_BAUD_RXEDGIE                                                      */
  LPUART1_BAUD_RXEDGIE_0               = 0,     /*!< 0 : Hardware interrupts from LPUART_STAT[RXEDGIF] disabled.               */
  LPUART1_BAUD_RXEDGIE_1               = 1,     /*!< 1 : Hardware interrupt requested when LPUART_STAT[RXEDGIF] flag
                                                     is 1.                                                                     */
} LPUART1_BAUD_RXEDGIE_Enum;

/* =========================================  LPUART1 LPUART1_BAUD LBKDIE [15..15]  ========================================== */
typedef enum {                                  /*!< LPUART1_BAUD_LBKDIE                                                       */
  LPUART1_BAUD_LBKDIE_0                = 0,     /*!< 0 : Hardware interrupts from LPUART_STAT[LBKDIF] disabled (use
                                                     polling).                                                                 */
  LPUART1_BAUD_LBKDIE_1                = 1,     /*!< 1 : Hardware interrupt requested when LPUART_STAT[LBKDIF] flag
                                                     is 1.                                                                     */
} LPUART1_BAUD_LBKDIE_Enum;

/* ========================================  LPUART1 LPUART1_BAUD RESYNCDIS [16..16]  ======================================== */
typedef enum {                                  /*!< LPUART1_BAUD_RESYNCDIS                                                    */
  LPUART1_BAUD_RESYNCDIS_0             = 0,     /*!< 0 : Resynchronization during received data word is supported              */
  LPUART1_BAUD_RESYNCDIS_1             = 1,     /*!< 1 : Resynchronization during received data word is disabled               */
} LPUART1_BAUD_RESYNCDIS_Enum;

/* ========================================  LPUART1 LPUART1_BAUD BOTHEDGE [17..17]  ========================================= */
typedef enum {                                  /*!< LPUART1_BAUD_BOTHEDGE                                                     */
  LPUART1_BAUD_BOTHEDGE_0              = 0,     /*!< 0 : Receiver samples input data using the rising edge of the
                                                     baud rate clock.                                                          */
  LPUART1_BAUD_BOTHEDGE_1              = 1,     /*!< 1 : Receiver samples input data using the rising and falling
                                                     edge of the baud rate clock.                                              */
} LPUART1_BAUD_BOTHEDGE_Enum;

/* =========================================  LPUART1 LPUART1_BAUD MATCFG [18..19]  ========================================== */
typedef enum {                                  /*!< LPUART1_BAUD_MATCFG                                                       */
  LPUART1_BAUD_MATCFG_00               = 0,     /*!< 00 : Address Match Wakeup                                                 */
  LPUART1_BAUD_MATCFG_01               = 1,     /*!< 01 : Idle Match Wakeup                                                    */
  LPUART1_BAUD_MATCFG_10               = 2,     /*!< 10 : Match On and Match Off                                               */
} LPUART1_BAUD_MATCFG_Enum;

/* =========================================  LPUART1 LPUART1_BAUD RIDMAE [20..20]  ========================================== */
typedef enum {                                  /*!< LPUART1_BAUD_RIDMAE                                                       */
  LPUART1_BAUD_RIDMAE_0                = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPUART1_BAUD_RIDMAE_1                = 1,     /*!< 1 : DMA request enabled.                                                  */
} LPUART1_BAUD_RIDMAE_Enum;

/* ==========================================  LPUART1 LPUART1_BAUD RDMAE [21..21]  ========================================== */
typedef enum {                                  /*!< LPUART1_BAUD_RDMAE                                                        */
  LPUART1_BAUD_RDMAE_0                 = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPUART1_BAUD_RDMAE_1                 = 1,     /*!< 1 : DMA request enabled.                                                  */
} LPUART1_BAUD_RDMAE_Enum;

/* ==========================================  LPUART1 LPUART1_BAUD TDMAE [23..23]  ========================================== */
typedef enum {                                  /*!< LPUART1_BAUD_TDMAE                                                        */
  LPUART1_BAUD_TDMAE_0                 = 0,     /*!< 0 : DMA request disabled.                                                 */
  LPUART1_BAUD_TDMAE_1                 = 1,     /*!< 1 : DMA request enabled.                                                  */
} LPUART1_BAUD_TDMAE_Enum;

/* ===========================================  LPUART1 LPUART1_BAUD OSR [24..28]  =========================================== */
typedef enum {                                  /*!< LPUART1_BAUD_OSR                                                          */
  LPUART1_BAUD_OSR_00000               = 0,     /*!< 00000 : Writing 0 to this field will result in an oversampling
                                                     ratio of 16                                                               */
  LPUART1_BAUD_OSR_00011               = 3,     /*!< 00011 : Oversampling ratio of 4, requires BOTHEDGE to be set.             */
  LPUART1_BAUD_OSR_00100               = 4,     /*!< 00100 : Oversampling ratio of 5, requires BOTHEDGE to be set.             */
  LPUART1_BAUD_OSR_00101               = 5,     /*!< 00101 : Oversampling ratio of 6, requires BOTHEDGE to be set.             */
  LPUART1_BAUD_OSR_00110               = 6,     /*!< 00110 : Oversampling ratio of 7, requires BOTHEDGE to be set.             */
  LPUART1_BAUD_OSR_00111               = 7,     /*!< 00111 : Oversampling ratio of 8.                                          */
  LPUART1_BAUD_OSR_01000               = 8,     /*!< 01000 : Oversampling ratio of 9.                                          */
  LPUART1_BAUD_OSR_01001               = 9,     /*!< 01001 : Oversampling ratio of 10.                                         */
  LPUART1_BAUD_OSR_01010               = 10,    /*!< 01010 : Oversampling ratio of 11.                                         */
  LPUART1_BAUD_OSR_01011               = 11,    /*!< 01011 : Oversampling ratio of 12.                                         */
  LPUART1_BAUD_OSR_01100               = 12,    /*!< 01100 : Oversampling ratio of 13.                                         */
  LPUART1_BAUD_OSR_01101               = 13,    /*!< 01101 : Oversampling ratio of 14.                                         */
  LPUART1_BAUD_OSR_01110               = 14,    /*!< 01110 : Oversampling ratio of 15.                                         */
  LPUART1_BAUD_OSR_01111               = 15,    /*!< 01111 : Oversampling ratio of 16.                                         */
  LPUART1_BAUD_OSR_10000               = 16,    /*!< 10000 : Oversampling ratio of 17.                                         */
  LPUART1_BAUD_OSR_10001               = 17,    /*!< 10001 : Oversampling ratio of 18.                                         */
  LPUART1_BAUD_OSR_10010               = 18,    /*!< 10010 : Oversampling ratio of 19.                                         */
  LPUART1_BAUD_OSR_10011               = 19,    /*!< 10011 : Oversampling ratio of 20.                                         */
  LPUART1_BAUD_OSR_10100               = 20,    /*!< 10100 : Oversampling ratio of 21.                                         */
  LPUART1_BAUD_OSR_10101               = 21,    /*!< 10101 : Oversampling ratio of 22.                                         */
  LPUART1_BAUD_OSR_10110               = 22,    /*!< 10110 : Oversampling ratio of 23.                                         */
  LPUART1_BAUD_OSR_10111               = 23,    /*!< 10111 : Oversampling ratio of 24.                                         */
  LPUART1_BAUD_OSR_11000               = 24,    /*!< 11000 : Oversampling ratio of 25.                                         */
  LPUART1_BAUD_OSR_11001               = 25,    /*!< 11001 : Oversampling ratio of 26.                                         */
  LPUART1_BAUD_OSR_11010               = 26,    /*!< 11010 : Oversampling ratio of 27.                                         */
  LPUART1_BAUD_OSR_11011               = 27,    /*!< 11011 : Oversampling ratio of 28.                                         */
  LPUART1_BAUD_OSR_11100               = 28,    /*!< 11100 : Oversampling ratio of 29.                                         */
  LPUART1_BAUD_OSR_11101               = 29,    /*!< 11101 : Oversampling ratio of 30.                                         */
  LPUART1_BAUD_OSR_11110               = 30,    /*!< 11110 : Oversampling ratio of 31.                                         */
  LPUART1_BAUD_OSR_11111               = 31,    /*!< 11111 : Oversampling ratio of 32.                                         */
} LPUART1_BAUD_OSR_Enum;

/* ===========================================  LPUART1 LPUART1_BAUD M10 [29..29]  =========================================== */
typedef enum {                                  /*!< LPUART1_BAUD_M10                                                          */
  LPUART1_BAUD_M10_0                   = 0,     /*!< 0 : Receiver and transmitter use 7-bit to 9-bit data characters.          */
  LPUART1_BAUD_M10_1                   = 1,     /*!< 1 : Receiver and transmitter use 10-bit data characters.                  */
} LPUART1_BAUD_M10_Enum;

/* ==========================================  LPUART1 LPUART1_BAUD MAEN2 [30..30]  ========================================== */
typedef enum {                                  /*!< LPUART1_BAUD_MAEN2                                                        */
  LPUART1_BAUD_MAEN2_0                 = 0,     /*!< 0 : Normal operation.                                                     */
  LPUART1_BAUD_MAEN2_1                 = 1,     /*!< 1 : Enables automatic address matching or data matching mode
                                                     for MATCH[MA2].                                                           */
} LPUART1_BAUD_MAEN2_Enum;

/* ==========================================  LPUART1 LPUART1_BAUD MAEN1 [31..31]  ========================================== */
typedef enum {                                  /*!< LPUART1_BAUD_MAEN1                                                        */
  LPUART1_BAUD_MAEN1_0                 = 0,     /*!< 0 : Normal operation.                                                     */
  LPUART1_BAUD_MAEN1_1                 = 1,     /*!< 1 : Enables automatic address matching or data matching mode
                                                     for MATCH[MA1].                                                           */
} LPUART1_BAUD_MAEN1_Enum;

/* =====================================================  LPUART1_STAT  ====================================================== */
/* ==========================================  LPUART1 LPUART1_STAT MA2F [14..14]  =========================================== */
typedef enum {                                  /*!< LPUART1_STAT_MA2F                                                         */
  LPUART1_STAT_MA2F_0                  = 0,     /*!< 0 : Received data is not equal to MA2                                     */
  LPUART1_STAT_MA2F_1                  = 1,     /*!< 1 : Received data is equal to MA2                                         */
} LPUART1_STAT_MA2F_Enum;

/* ==========================================  LPUART1 LPUART1_STAT MA1F [15..15]  =========================================== */
typedef enum {                                  /*!< LPUART1_STAT_MA1F                                                         */
  LPUART1_STAT_MA1F_0                  = 0,     /*!< 0 : Received data is not equal to MA1                                     */
  LPUART1_STAT_MA1F_1                  = 1,     /*!< 1 : Received data is equal to MA1                                         */
} LPUART1_STAT_MA1F_Enum;

/* ===========================================  LPUART1 LPUART1_STAT PF [16..16]  ============================================ */
typedef enum {                                  /*!< LPUART1_STAT_PF                                                           */
  LPUART1_STAT_PF_0                    = 0,     /*!< 0 : No parity error.                                                      */
  LPUART1_STAT_PF_1                    = 1,     /*!< 1 : Parity error.                                                         */
} LPUART1_STAT_PF_Enum;

/* ===========================================  LPUART1 LPUART1_STAT FE [17..17]  ============================================ */
typedef enum {                                  /*!< LPUART1_STAT_FE                                                           */
  LPUART1_STAT_FE_0                    = 0,     /*!< 0 : No framing error detected. This does not guarantee the framing
                                                     is correct.                                                               */
  LPUART1_STAT_FE_1                    = 1,     /*!< 1 : Framing error.                                                        */
} LPUART1_STAT_FE_Enum;

/* ===========================================  LPUART1 LPUART1_STAT NF [18..18]  ============================================ */
typedef enum {                                  /*!< LPUART1_STAT_NF                                                           */
  LPUART1_STAT_NF_0                    = 0,     /*!< 0 : No noise detected.                                                    */
  LPUART1_STAT_NF_1                    = 1,     /*!< 1 : Noise detected in the received character in LPUART_DATA.              */
} LPUART1_STAT_NF_Enum;

/* ===========================================  LPUART1 LPUART1_STAT OR [19..19]  ============================================ */
typedef enum {                                  /*!< LPUART1_STAT_OR                                                           */
  LPUART1_STAT_OR_0                    = 0,     /*!< 0 : No overrun.                                                           */
  LPUART1_STAT_OR_1                    = 1,     /*!< 1 : Receive overrun (new LPUART data lost).                               */
} LPUART1_STAT_OR_Enum;

/* ==========================================  LPUART1 LPUART1_STAT IDLE [20..20]  =========================================== */
typedef enum {                                  /*!< LPUART1_STAT_IDLE                                                         */
  LPUART1_STAT_IDLE_0                  = 0,     /*!< 0 : No idle line detected.                                                */
  LPUART1_STAT_IDLE_1                  = 1,     /*!< 1 : Idle line was detected.                                               */
} LPUART1_STAT_IDLE_Enum;

/* ==========================================  LPUART1 LPUART1_STAT RDRF [21..21]  =========================================== */
typedef enum {                                  /*!< LPUART1_STAT_RDRF                                                         */
  LPUART1_STAT_RDRF_0                  = 0,     /*!< 0 : Receive data buffer empty.                                            */
  LPUART1_STAT_RDRF_1                  = 1,     /*!< 1 : Receive data buffer full.                                             */
} LPUART1_STAT_RDRF_Enum;

/* ===========================================  LPUART1 LPUART1_STAT TC [22..22]  ============================================ */
typedef enum {                                  /*!< LPUART1_STAT_TC                                                           */
  LPUART1_STAT_TC_0                    = 0,     /*!< 0 : Transmitter active (sending data, a preamble, or a break).            */
  LPUART1_STAT_TC_1                    = 1,     /*!< 1 : Transmitter idle (transmission activity complete).                    */
} LPUART1_STAT_TC_Enum;

/* ==========================================  LPUART1 LPUART1_STAT TDRE [23..23]  =========================================== */
typedef enum {                                  /*!< LPUART1_STAT_TDRE                                                         */
  LPUART1_STAT_TDRE_0                  = 0,     /*!< 0 : Transmit data buffer full.                                            */
  LPUART1_STAT_TDRE_1                  = 1,     /*!< 1 : Transmit data buffer empty.                                           */
} LPUART1_STAT_TDRE_Enum;

/* ===========================================  LPUART1 LPUART1_STAT RAF [24..24]  =========================================== */
typedef enum {                                  /*!< LPUART1_STAT_RAF                                                          */
  LPUART1_STAT_RAF_0                   = 0,     /*!< 0 : LPUART receiver idle waiting for a start bit.                         */
  LPUART1_STAT_RAF_1                   = 1,     /*!< 1 : LPUART receiver active (RXD input not idle).                          */
} LPUART1_STAT_RAF_Enum;

/* ==========================================  LPUART1 LPUART1_STAT LBKDE [25..25]  ========================================== */
typedef enum {                                  /*!< LPUART1_STAT_LBKDE                                                        */
  LPUART1_STAT_LBKDE_0                 = 0,     /*!< 0 : LIN break detect is disabled, normal break character can
                                                     be detected.                                                              */
  LPUART1_STAT_LBKDE_1                 = 1,     /*!< 1 : LIN break detect is enabled. LIN break character is detected
                                                     at length of 11 bit times (if M = 0) or 12 (if M = 1) or
                                                     13 (M10 = 1).                                                             */
} LPUART1_STAT_LBKDE_Enum;

/* ==========================================  LPUART1 LPUART1_STAT BRK13 [26..26]  ========================================== */
typedef enum {                                  /*!< LPUART1_STAT_BRK13                                                        */
  LPUART1_STAT_BRK13_0                 = 0,     /*!< 0 : Break character is transmitted with length of 9 to 13 bit
                                                     times.                                                                    */
  LPUART1_STAT_BRK13_1                 = 1,     /*!< 1 : Break character is transmitted with length of 12 to 15 bit
                                                     times.                                                                    */
} LPUART1_STAT_BRK13_Enum;

/* ==========================================  LPUART1 LPUART1_STAT RWUID [27..27]  ========================================== */
typedef enum {                                  /*!< LPUART1_STAT_RWUID                                                        */
  LPUART1_STAT_RWUID_0                 = 0,     /*!< 0 : During receive standby state (RWU = 1), the IDLE bit does
                                                     not get set upon detection of an idle character. During
                                                     address match wakeup, the IDLE bit does not set when an
                                                     address does not match.                                                   */
  LPUART1_STAT_RWUID_1                 = 1,     /*!< 1 : During receive standby state (RWU = 1), the IDLE bit gets
                                                     set upon detection of an idle character. During address
                                                     match wakeup, the IDLE bit does set when an address does
                                                     not match.                                                                */
} LPUART1_STAT_RWUID_Enum;

/* ==========================================  LPUART1 LPUART1_STAT RXINV [28..28]  ========================================== */
typedef enum {                                  /*!< LPUART1_STAT_RXINV                                                        */
  LPUART1_STAT_RXINV_0                 = 0,     /*!< 0 : Receive data not inverted.                                            */
  LPUART1_STAT_RXINV_1                 = 1,     /*!< 1 : Receive data inverted.                                                */
} LPUART1_STAT_RXINV_Enum;

/* ==========================================  LPUART1 LPUART1_STAT MSBF [29..29]  =========================================== */
typedef enum {                                  /*!< LPUART1_STAT_MSBF                                                         */
  LPUART1_STAT_MSBF_0                  = 0,     /*!< 0 : LSB (bit0) is the first bit that is transmitted following
                                                     the start bit. Further, the first bit received after the
                                                     start bit is identified as bit0.                                          */
  LPUART1_STAT_MSBF_1                  = 1,     /*!< 1 : MSB (bit9, bit8, bit7 or bit6) is the first bit that is
                                                     transmitted following the start bit depending on the setting
                                                     of CTRL[M], CTRL[PE] and BAUD[M10]. Further, the first
                                                     bit received after the start bit is identified as bit9,
                                                     bit8, bit7 or bit6 depending on the setting of CTRL[M]
                                                     and CTRL[PE].                                                             */
} LPUART1_STAT_MSBF_Enum;

/* =========================================  LPUART1 LPUART1_STAT RXEDGIF [30..30]  ========================================= */
typedef enum {                                  /*!< LPUART1_STAT_RXEDGIF                                                      */
  LPUART1_STAT_RXEDGIF_0               = 0,     /*!< 0 : No active edge on the receive pin has occurred.                       */
  LPUART1_STAT_RXEDGIF_1               = 1,     /*!< 1 : An active edge on the receive pin has occurred.                       */
} LPUART1_STAT_RXEDGIF_Enum;

/* =========================================  LPUART1 LPUART1_STAT LBKDIF [31..31]  ========================================== */
typedef enum {                                  /*!< LPUART1_STAT_LBKDIF                                                       */
  LPUART1_STAT_LBKDIF_0                = 0,     /*!< 0 : No LIN break character has been detected.                             */
  LPUART1_STAT_LBKDIF_1                = 1,     /*!< 1 : LIN break character has been detected.                                */
} LPUART1_STAT_LBKDIF_Enum;

/* =====================================================  LPUART1_CTRL  ====================================================== */
/* ============================================  LPUART1 LPUART1_CTRL PT [0..0]  ============================================= */
typedef enum {                                  /*!< LPUART1_CTRL_PT                                                           */
  LPUART1_CTRL_PT_0                    = 0,     /*!< 0 : Even parity.                                                          */
  LPUART1_CTRL_PT_1                    = 1,     /*!< 1 : Odd parity.                                                           */
} LPUART1_CTRL_PT_Enum;

/* ============================================  LPUART1 LPUART1_CTRL PE [1..1]  ============================================= */
typedef enum {                                  /*!< LPUART1_CTRL_PE                                                           */
  LPUART1_CTRL_PE_0                    = 0,     /*!< 0 : No hardware parity generation or checking.                            */
  LPUART1_CTRL_PE_1                    = 1,     /*!< 1 : Parity enabled.                                                       */
} LPUART1_CTRL_PE_Enum;

/* ============================================  LPUART1 LPUART1_CTRL ILT [2..2]  ============================================ */
typedef enum {                                  /*!< LPUART1_CTRL_ILT                                                          */
  LPUART1_CTRL_ILT_0                   = 0,     /*!< 0 : Idle character bit count starts after start bit.                      */
  LPUART1_CTRL_ILT_1                   = 1,     /*!< 1 : Idle character bit count starts after stop bit.                       */
} LPUART1_CTRL_ILT_Enum;

/* ===========================================  LPUART1 LPUART1_CTRL WAKE [3..3]  ============================================ */
typedef enum {                                  /*!< LPUART1_CTRL_WAKE                                                         */
  LPUART1_CTRL_WAKE_0                  = 0,     /*!< 0 : Configures RWU for idle-line wakeup.                                  */
  LPUART1_CTRL_WAKE_1                  = 1,     /*!< 1 : Configures RWU with address-mark wakeup.                              */
} LPUART1_CTRL_WAKE_Enum;

/* =============================================  LPUART1 LPUART1_CTRL M [4..4]  ============================================= */
typedef enum {                                  /*!< LPUART1_CTRL_M                                                            */
  LPUART1_CTRL_M_0                     = 0,     /*!< 0 : Receiver and transmitter use 8-bit data characters.                   */
  LPUART1_CTRL_M_1                     = 1,     /*!< 1 : Receiver and transmitter use 9-bit data characters.                   */
} LPUART1_CTRL_M_Enum;

/* ===========================================  LPUART1 LPUART1_CTRL RSRC [5..5]  ============================================ */
typedef enum {                                  /*!< LPUART1_CTRL_RSRC                                                         */
  LPUART1_CTRL_RSRC_0                  = 0,     /*!< 0 : Provided LOOPS is set, RSRC is cleared, selects internal
                                                     loop back mode and the LPUART does not use the RXD pin.                   */
  LPUART1_CTRL_RSRC_1                  = 1,     /*!< 1 : Single-wire LPUART mode where the TXD pin is connected to
                                                     the transmitter output and receiver input.                                */
} LPUART1_CTRL_RSRC_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL DOZEEN [6..6]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_DOZEEN                                                       */
  LPUART1_CTRL_DOZEEN_0                = 0,     /*!< 0 : LPUART is enabled in Doze mode.                                       */
  LPUART1_CTRL_DOZEEN_1                = 1,     /*!< 1 : LPUART is disabled in Doze mode.                                      */
} LPUART1_CTRL_DOZEEN_Enum;

/* ===========================================  LPUART1 LPUART1_CTRL LOOPS [7..7]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_LOOPS                                                        */
  LPUART1_CTRL_LOOPS_0                 = 0,     /*!< 0 : Normal operation - RXD and TXD use separate pins.                     */
  LPUART1_CTRL_LOOPS_1                 = 1,     /*!< 1 : Loop mode or single-wire mode where transmitter outputs
                                                     are internally connected to receiver input (see RSRC bit).                */
} LPUART1_CTRL_LOOPS_Enum;

/* =========================================  LPUART1 LPUART1_CTRL IDLECFG [8..10]  ========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_IDLECFG                                                      */
  LPUART1_CTRL_IDLECFG_000             = 0,     /*!< 000 : 1 idle character                                                    */
  LPUART1_CTRL_IDLECFG_001             = 1,     /*!< 001 : 2 idle characters                                                   */
  LPUART1_CTRL_IDLECFG_010             = 2,     /*!< 010 : 4 idle characters                                                   */
  LPUART1_CTRL_IDLECFG_011             = 3,     /*!< 011 : 8 idle characters                                                   */
  LPUART1_CTRL_IDLECFG_100             = 4,     /*!< 100 : 16 idle characters                                                  */
  LPUART1_CTRL_IDLECFG_101             = 5,     /*!< 101 : 32 idle characters                                                  */
  LPUART1_CTRL_IDLECFG_110             = 6,     /*!< 110 : 64 idle characters                                                  */
  LPUART1_CTRL_IDLECFG_111             = 7,     /*!< 111 : 128 idle characters                                                 */
} LPUART1_CTRL_IDLECFG_Enum;

/* ===========================================  LPUART1 LPUART1_CTRL M7 [11..11]  ============================================ */
typedef enum {                                  /*!< LPUART1_CTRL_M7                                                           */
  LPUART1_CTRL_M7_0                    = 0,     /*!< 0 : Receiver and transmitter use 8-bit to 10-bit data characters.         */
  LPUART1_CTRL_M7_1                    = 1,     /*!< 1 : Receiver and transmitter use 7-bit data characters.                   */
} LPUART1_CTRL_M7_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL MA2IE [14..14]  ========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_MA2IE                                                        */
  LPUART1_CTRL_MA2IE_0                 = 0,     /*!< 0 : MA2F interrupt disabled                                               */
  LPUART1_CTRL_MA2IE_1                 = 1,     /*!< 1 : MA2F interrupt enabled                                                */
} LPUART1_CTRL_MA2IE_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL MA1IE [15..15]  ========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_MA1IE                                                        */
  LPUART1_CTRL_MA1IE_0                 = 0,     /*!< 0 : MA1F interrupt disabled                                               */
  LPUART1_CTRL_MA1IE_1                 = 1,     /*!< 1 : MA1F interrupt enabled                                                */
} LPUART1_CTRL_MA1IE_Enum;

/* ===========================================  LPUART1 LPUART1_CTRL SBK [16..16]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_SBK                                                          */
  LPUART1_CTRL_SBK_0                   = 0,     /*!< 0 : Normal transmitter operation.                                         */
  LPUART1_CTRL_SBK_1                   = 1,     /*!< 1 : Queue break character(s) to be sent.                                  */
} LPUART1_CTRL_SBK_Enum;

/* ===========================================  LPUART1 LPUART1_CTRL RWU [17..17]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_RWU                                                          */
  LPUART1_CTRL_RWU_0                   = 0,     /*!< 0 : Normal receiver operation.                                            */
  LPUART1_CTRL_RWU_1                   = 1,     /*!< 1 : LPUART receiver in standby waiting for wakeup condition.              */
} LPUART1_CTRL_RWU_Enum;

/* ===========================================  LPUART1 LPUART1_CTRL RE [18..18]  ============================================ */
typedef enum {                                  /*!< LPUART1_CTRL_RE                                                           */
  LPUART1_CTRL_RE_0                    = 0,     /*!< 0 : Receiver disabled.                                                    */
  LPUART1_CTRL_RE_1                    = 1,     /*!< 1 : Receiver enabled.                                                     */
} LPUART1_CTRL_RE_Enum;

/* ===========================================  LPUART1 LPUART1_CTRL TE [19..19]  ============================================ */
typedef enum {                                  /*!< LPUART1_CTRL_TE                                                           */
  LPUART1_CTRL_TE_0                    = 0,     /*!< 0 : Transmitter disabled.                                                 */
  LPUART1_CTRL_TE_1                    = 1,     /*!< 1 : Transmitter enabled.                                                  */
} LPUART1_CTRL_TE_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL ILIE [20..20]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_ILIE                                                         */
  LPUART1_CTRL_ILIE_0                  = 0,     /*!< 0 : Hardware interrupts from IDLE disabled; use polling.                  */
  LPUART1_CTRL_ILIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when IDLE flag is 1.                     */
} LPUART1_CTRL_ILIE_Enum;

/* ===========================================  LPUART1 LPUART1_CTRL RIE [21..21]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_RIE                                                          */
  LPUART1_CTRL_RIE_0                   = 0,     /*!< 0 : Hardware interrupts from RDRF disabled; use polling.                  */
  LPUART1_CTRL_RIE_1                   = 1,     /*!< 1 : Hardware interrupt requested when RDRF flag is 1.                     */
} LPUART1_CTRL_RIE_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL TCIE [22..22]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_TCIE                                                         */
  LPUART1_CTRL_TCIE_0                  = 0,     /*!< 0 : Hardware interrupts from TC disabled; use polling.                    */
  LPUART1_CTRL_TCIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when TC flag is 1.                       */
} LPUART1_CTRL_TCIE_Enum;

/* ===========================================  LPUART1 LPUART1_CTRL TIE [23..23]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_TIE                                                          */
  LPUART1_CTRL_TIE_0                   = 0,     /*!< 0 : Hardware interrupts from TDRE disabled; use polling.                  */
  LPUART1_CTRL_TIE_1                   = 1,     /*!< 1 : Hardware interrupt requested when TDRE flag is 1.                     */
} LPUART1_CTRL_TIE_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL PEIE [24..24]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_PEIE                                                         */
  LPUART1_CTRL_PEIE_0                  = 0,     /*!< 0 : PF interrupts disabled; use polling).                                 */
  LPUART1_CTRL_PEIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when PF is set.                          */
} LPUART1_CTRL_PEIE_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL FEIE [25..25]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_FEIE                                                         */
  LPUART1_CTRL_FEIE_0                  = 0,     /*!< 0 : FE interrupts disabled; use polling.                                  */
  LPUART1_CTRL_FEIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when FE is set.                          */
} LPUART1_CTRL_FEIE_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL NEIE [26..26]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_NEIE                                                         */
  LPUART1_CTRL_NEIE_0                  = 0,     /*!< 0 : NF interrupts disabled; use polling.                                  */
  LPUART1_CTRL_NEIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when NF is set.                          */
} LPUART1_CTRL_NEIE_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL ORIE [27..27]  =========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_ORIE                                                         */
  LPUART1_CTRL_ORIE_0                  = 0,     /*!< 0 : OR interrupts disabled; use polling.                                  */
  LPUART1_CTRL_ORIE_1                  = 1,     /*!< 1 : Hardware interrupt requested when OR is set.                          */
} LPUART1_CTRL_ORIE_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL TXINV [28..28]  ========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_TXINV                                                        */
  LPUART1_CTRL_TXINV_0                 = 0,     /*!< 0 : Transmit data not inverted.                                           */
  LPUART1_CTRL_TXINV_1                 = 1,     /*!< 1 : Transmit data inverted.                                               */
} LPUART1_CTRL_TXINV_Enum;

/* ==========================================  LPUART1 LPUART1_CTRL TXDIR [29..29]  ========================================== */
typedef enum {                                  /*!< LPUART1_CTRL_TXDIR                                                        */
  LPUART1_CTRL_TXDIR_0                 = 0,     /*!< 0 : TXD pin is an input in single-wire mode.                              */
  LPUART1_CTRL_TXDIR_1                 = 1,     /*!< 1 : TXD pin is an output in single-wire mode.                             */
} LPUART1_CTRL_TXDIR_Enum;

/* =====================================================  LPUART1_DATA  ====================================================== */
/* =========================================  LPUART1 LPUART1_DATA IDLINE [11..11]  ========================================== */
typedef enum {                                  /*!< LPUART1_DATA_IDLINE                                                       */
  LPUART1_DATA_IDLINE_0                = 0,     /*!< 0 : Receiver was not idle before receiving this character.                */
  LPUART1_DATA_IDLINE_1                = 1,     /*!< 1 : Receiver was idle before receiving this character.                    */
} LPUART1_DATA_IDLINE_Enum;

/* =========================================  LPUART1 LPUART1_DATA RXEMPT [12..12]  ========================================== */
typedef enum {                                  /*!< LPUART1_DATA_RXEMPT                                                       */
  LPUART1_DATA_RXEMPT_0                = 0,     /*!< 0 : Receive buffer contains valid data.                                   */
  LPUART1_DATA_RXEMPT_1                = 1,     /*!< 1 : Receive buffer is empty, data returned on read is not valid.          */
} LPUART1_DATA_RXEMPT_Enum;

/* =========================================  LPUART1 LPUART1_DATA FRETSC [13..13]  ========================================== */
typedef enum {                                  /*!< LPUART1_DATA_FRETSC                                                       */
  LPUART1_DATA_FRETSC_0                = 0,     /*!< 0 : The dataword was received without a frame error on read,
                                                     or transmit a normal character on write.                                  */
  LPUART1_DATA_FRETSC_1                = 1,     /*!< 1 : The dataword was received with a frame error, or transmit
                                                     an idle or break character on transmit.                                   */
} LPUART1_DATA_FRETSC_Enum;

/* =========================================  LPUART1 LPUART1_DATA PARITYE [14..14]  ========================================= */
typedef enum {                                  /*!< LPUART1_DATA_PARITYE                                                      */
  LPUART1_DATA_PARITYE_0               = 0,     /*!< 0 : The dataword was received without a parity error.                     */
  LPUART1_DATA_PARITYE_1               = 1,     /*!< 1 : The dataword was received with a parity error.                        */
} LPUART1_DATA_PARITYE_Enum;

/* ==========================================  LPUART1 LPUART1_DATA NOISY [15..15]  ========================================== */
typedef enum {                                  /*!< LPUART1_DATA_NOISY                                                        */
  LPUART1_DATA_NOISY_0                 = 0,     /*!< 0 : The dataword was received without noise.                              */
  LPUART1_DATA_NOISY_1                 = 1,     /*!< 1 : The data was received with noise.                                     */
} LPUART1_DATA_NOISY_Enum;

/* =====================================================  LPUART1_MATCH  ===================================================== */
/* =====================================================  LPUART1_MODIR  ===================================================== */
/* ==========================================  LPUART1 LPUART1_MODIR TXCTSE [0..0]  ========================================== */
typedef enum {                                  /*!< LPUART1_MODIR_TXCTSE                                                      */
  LPUART1_MODIR_TXCTSE_0               = 0,     /*!< 0 : CTS has no effect on the transmitter.                                 */
  LPUART1_MODIR_TXCTSE_1               = 1,     /*!< 1 : Enables clear-to-send operation. The transmitter checks
                                                     the state of CTS each time it is ready to send a character.
                                                     If CTS is asserted, the character is sent. If CTS is deasserted,
                                                     the signal TXD remains in the mark state and transmission
                                                     is delayed until CTS is asserted. Changes in CTS as a character
                                                     is being sent do not affect its transmission.                             */
} LPUART1_MODIR_TXCTSE_Enum;

/* ==========================================  LPUART1 LPUART1_MODIR TXRTSE [1..1]  ========================================== */
typedef enum {                                  /*!< LPUART1_MODIR_TXRTSE                                                      */
  LPUART1_MODIR_TXRTSE_0               = 0,     /*!< 0 : The transmitter has no effect on RTS.                                 */
  LPUART1_MODIR_TXRTSE_1               = 1,     /*!< 1 : When a character is placed into an empty transmitter data
                                                     buffer , RTS asserts one bit time before the start bit
                                                     is transmitted. RTS deasserts one bit time after all characters
                                                     in the transmitter data buffer and shift register are completely
                                                     sent, including the last stop bit.                                        */
} LPUART1_MODIR_TXRTSE_Enum;

/* =========================================  LPUART1 LPUART1_MODIR TXRTSPOL [2..2]  ========================================= */
typedef enum {                                  /*!< LPUART1_MODIR_TXRTSPOL                                                    */
  LPUART1_MODIR_TXRTSPOL_0             = 0,     /*!< 0 : Transmitter RTS is active low.                                        */
  LPUART1_MODIR_TXRTSPOL_1             = 1,     /*!< 1 : Transmitter RTS is active high.                                       */
} LPUART1_MODIR_TXRTSPOL_Enum;

/* ==========================================  LPUART1 LPUART1_MODIR RXRTSE [3..3]  ========================================== */
typedef enum {                                  /*!< LPUART1_MODIR_RXRTSE                                                      */
  LPUART1_MODIR_RXRTSE_0               = 0,     /*!< 0 : The receiver has no effect on RTS.                                    */
} LPUART1_MODIR_RXRTSE_Enum;

/* ==========================================  LPUART1 LPUART1_MODIR TXCTSC [4..4]  ========================================== */
typedef enum {                                  /*!< LPUART1_MODIR_TXCTSC                                                      */
  LPUART1_MODIR_TXCTSC_0               = 0,     /*!< 0 : CTS input is sampled at the start of each character.                  */
  LPUART1_MODIR_TXCTSC_1               = 1,     /*!< 1 : CTS input is sampled when the transmitter is idle.                    */
} LPUART1_MODIR_TXCTSC_Enum;

/* =========================================  LPUART1 LPUART1_MODIR TXCTSSRC [5..5]  ========================================= */
typedef enum {                                  /*!< LPUART1_MODIR_TXCTSSRC                                                    */
  LPUART1_MODIR_TXCTSSRC_0             = 0,     /*!< 0 : CTS input is the CTS_B pin.                                           */
  LPUART1_MODIR_TXCTSSRC_1             = 1,     /*!< 1 : CTS input is the inverted Receiver Match result.                      */
} LPUART1_MODIR_TXCTSSRC_Enum;

/* ==========================================  LPUART1 LPUART1_MODIR TNP [16..17]  =========================================== */
typedef enum {                                  /*!< LPUART1_MODIR_TNP                                                         */
  LPUART1_MODIR_TNP_00                 = 0,     /*!< 00 : 1/OSR.                                                               */
  LPUART1_MODIR_TNP_01                 = 1,     /*!< 01 : 2/OSR.                                                               */
  LPUART1_MODIR_TNP_10                 = 2,     /*!< 10 : 3/OSR.                                                               */
  LPUART1_MODIR_TNP_11                 = 3,     /*!< 11 : 4/OSR.                                                               */
} LPUART1_MODIR_TNP_Enum;

/* ==========================================  LPUART1 LPUART1_MODIR IREN [18..18]  ========================================== */
typedef enum {                                  /*!< LPUART1_MODIR_IREN                                                        */
  LPUART1_MODIR_IREN_0                 = 0,     /*!< 0 : IR disabled.                                                          */
  LPUART1_MODIR_IREN_1                 = 1,     /*!< 1 : IR enabled.                                                           */
} LPUART1_MODIR_IREN_Enum;

/* =====================================================  LPUART1_FIFO  ====================================================== */
/* ========================================  LPUART1 LPUART1_FIFO RXFIFOSIZE [0..2]  ========================================= */
typedef enum {                                  /*!< LPUART1_FIFO_RXFIFOSIZE                                                   */
  LPUART1_FIFO_RXFIFOSIZE_000          = 0,     /*!< 000 : Receive FIFO/Buffer depth = 1 dataword.                             */
  LPUART1_FIFO_RXFIFOSIZE_001          = 1,     /*!< 001 : Receive FIFO/Buffer depth = 4 datawords.                            */
  LPUART1_FIFO_RXFIFOSIZE_010          = 2,     /*!< 010 : Receive FIFO/Buffer depth = 8 datawords.                            */
  LPUART1_FIFO_RXFIFOSIZE_011          = 3,     /*!< 011 : Receive FIFO/Buffer depth = 16 datawords.                           */
  LPUART1_FIFO_RXFIFOSIZE_100          = 4,     /*!< 100 : Receive FIFO/Buffer depth = 32 datawords.                           */
  LPUART1_FIFO_RXFIFOSIZE_101          = 5,     /*!< 101 : Receive FIFO/Buffer depth = 64 datawords.                           */
  LPUART1_FIFO_RXFIFOSIZE_110          = 6,     /*!< 110 : Receive FIFO/Buffer depth = 128 datawords.                          */
  LPUART1_FIFO_RXFIFOSIZE_111          = 7,     /*!< 111 : Receive FIFO/Buffer depth = 256 datawords.                          */
} LPUART1_FIFO_RXFIFOSIZE_Enum;

/* ===========================================  LPUART1 LPUART1_FIFO RXFE [3..3]  ============================================ */
typedef enum {                                  /*!< LPUART1_FIFO_RXFE                                                         */
  LPUART1_FIFO_RXFE_0                  = 0,     /*!< 0 : Receive FIFO is not enabled. Buffer is depth 1. (Legacy
                                                     support)                                                                  */
  LPUART1_FIFO_RXFE_1                  = 1,     /*!< 1 : Receive FIFO is enabled. Buffer is depth indicted by RXFIFOSIZE.      */
} LPUART1_FIFO_RXFE_Enum;

/* ========================================  LPUART1 LPUART1_FIFO TXFIFOSIZE [4..6]  ========================================= */
typedef enum {                                  /*!< LPUART1_FIFO_TXFIFOSIZE                                                   */
  LPUART1_FIFO_TXFIFOSIZE_000          = 0,     /*!< 000 : Transmit FIFO/Buffer depth = 1 dataword.                            */
  LPUART1_FIFO_TXFIFOSIZE_001          = 1,     /*!< 001 : Transmit FIFO/Buffer depth = 4 datawords.                           */
  LPUART1_FIFO_TXFIFOSIZE_010          = 2,     /*!< 010 : Transmit FIFO/Buffer depth = 8 datawords.                           */
  LPUART1_FIFO_TXFIFOSIZE_011          = 3,     /*!< 011 : Transmit FIFO/Buffer depth = 16 datawords.                          */
  LPUART1_FIFO_TXFIFOSIZE_100          = 4,     /*!< 100 : Transmit FIFO/Buffer depth = 32 datawords.                          */
  LPUART1_FIFO_TXFIFOSIZE_101          = 5,     /*!< 101 : Transmit FIFO/Buffer depth = 64 datawords.                          */
  LPUART1_FIFO_TXFIFOSIZE_110          = 6,     /*!< 110 : Transmit FIFO/Buffer depth = 128 datawords.                         */
  LPUART1_FIFO_TXFIFOSIZE_111          = 7,     /*!< 111 : Transmit FIFO/Buffer depth = 256 datawords                          */
} LPUART1_FIFO_TXFIFOSIZE_Enum;

/* ===========================================  LPUART1 LPUART1_FIFO TXFE [7..7]  ============================================ */
typedef enum {                                  /*!< LPUART1_FIFO_TXFE                                                         */
  LPUART1_FIFO_TXFE_0                  = 0,     /*!< 0 : Transmit FIFO is not enabled. Buffer is depth 1. (Legacy
                                                     support).                                                                 */
  LPUART1_FIFO_TXFE_1                  = 1,     /*!< 1 : Transmit FIFO is enabled. Buffer is depth indicated by TXFIFOSIZE.    */
} LPUART1_FIFO_TXFE_Enum;

/* ===========================================  LPUART1 LPUART1_FIFO RXUFE [8..8]  =========================================== */
typedef enum {                                  /*!< LPUART1_FIFO_RXUFE                                                        */
  LPUART1_FIFO_RXUFE_0                 = 0,     /*!< 0 : RXUF flag does not generate an interrupt to the host.                 */
  LPUART1_FIFO_RXUFE_1                 = 1,     /*!< 1 : RXUF flag generates an interrupt to the host.                         */
} LPUART1_FIFO_RXUFE_Enum;

/* ===========================================  LPUART1 LPUART1_FIFO TXOFE [9..9]  =========================================== */
typedef enum {                                  /*!< LPUART1_FIFO_TXOFE                                                        */
  LPUART1_FIFO_TXOFE_0                 = 0,     /*!< 0 : TXOF flag does not generate an interrupt to the host.                 */
  LPUART1_FIFO_TXOFE_1                 = 1,     /*!< 1 : TXOF flag generates an interrupt to the host.                         */
} LPUART1_FIFO_TXOFE_Enum;

/* =========================================  LPUART1 LPUART1_FIFO RXIDEN [10..12]  ========================================== */
typedef enum {                                  /*!< LPUART1_FIFO_RXIDEN                                                       */
  LPUART1_FIFO_RXIDEN_000              = 0,     /*!< 000 : Disable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle.                                                         */
  LPUART1_FIFO_RXIDEN_001              = 1,     /*!< 001 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 1 character.                                         */
  LPUART1_FIFO_RXIDEN_010              = 2,     /*!< 010 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 2 characters.                                        */
  LPUART1_FIFO_RXIDEN_011              = 3,     /*!< 011 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 4 characters.                                        */
  LPUART1_FIFO_RXIDEN_100              = 4,     /*!< 100 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 8 characters.                                        */
  LPUART1_FIFO_RXIDEN_101              = 5,     /*!< 101 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 16 characters.                                       */
  LPUART1_FIFO_RXIDEN_110              = 6,     /*!< 110 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 32 characters.                                       */
  LPUART1_FIFO_RXIDEN_111              = 7,     /*!< 111 : Enable RDRF assertion due to partially filled FIFO when
                                                     receiver is idle for 64 characters.                                       */
} LPUART1_FIFO_RXIDEN_Enum;

/* =========================================  LPUART1 LPUART1_FIFO RXFLUSH [14..14]  ========================================= */
typedef enum {                                  /*!< LPUART1_FIFO_RXFLUSH                                                      */
  LPUART1_FIFO_RXFLUSH_0               = 0,     /*!< 0 : No flush operation occurs.                                            */
  LPUART1_FIFO_RXFLUSH_1               = 1,     /*!< 1 : All data in the receive FIFO/buffer is cleared out.                   */
} LPUART1_FIFO_RXFLUSH_Enum;

/* =========================================  LPUART1 LPUART1_FIFO TXFLUSH [15..15]  ========================================= */
typedef enum {                                  /*!< LPUART1_FIFO_TXFLUSH                                                      */
  LPUART1_FIFO_TXFLUSH_0               = 0,     /*!< 0 : No flush operation occurs.                                            */
  LPUART1_FIFO_TXFLUSH_1               = 1,     /*!< 1 : All data in the transmit FIFO/Buffer is cleared out.                  */
} LPUART1_FIFO_TXFLUSH_Enum;

/* ==========================================  LPUART1 LPUART1_FIFO RXUF [16..16]  =========================================== */
typedef enum {                                  /*!< LPUART1_FIFO_RXUF                                                         */
  LPUART1_FIFO_RXUF_0                  = 0,     /*!< 0 : No receive buffer underflow has occurred since the last
                                                     time the flag was cleared.                                                */
  LPUART1_FIFO_RXUF_1                  = 1,     /*!< 1 : At least one receive buffer underflow has occurred since
                                                     the last time the flag was cleared.                                       */
} LPUART1_FIFO_RXUF_Enum;

/* ==========================================  LPUART1 LPUART1_FIFO TXOF [17..17]  =========================================== */
typedef enum {                                  /*!< LPUART1_FIFO_TXOF                                                         */
  LPUART1_FIFO_TXOF_0                  = 0,     /*!< 0 : No transmit buffer overflow has occurred since the last
                                                     time the flag was cleared.                                                */
  LPUART1_FIFO_TXOF_1                  = 1,     /*!< 1 : At least one transmit buffer overflow has occurred since
                                                     the last time the flag was cleared.                                       */
} LPUART1_FIFO_TXOF_Enum;

/* =========================================  LPUART1 LPUART1_FIFO RXEMPT [22..22]  ========================================== */
typedef enum {                                  /*!< LPUART1_FIFO_RXEMPT                                                       */
  LPUART1_FIFO_RXEMPT_0                = 0,     /*!< 0 : Receive buffer is not empty.                                          */
  LPUART1_FIFO_RXEMPT_1                = 1,     /*!< 1 : Receive buffer is empty.                                              */
} LPUART1_FIFO_RXEMPT_Enum;

/* =========================================  LPUART1 LPUART1_FIFO TXEMPT [23..23]  ========================================== */
typedef enum {                                  /*!< LPUART1_FIFO_TXEMPT                                                       */
  LPUART1_FIFO_TXEMPT_0                = 0,     /*!< 0 : Transmit buffer is not empty.                                         */
  LPUART1_FIFO_TXEMPT_1                = 1,     /*!< 1 : Transmit buffer is empty.                                             */
} LPUART1_FIFO_TXEMPT_Enum;

/* =====================================================  LPUART1_WATER  ===================================================== */


/* =========================================================================================================================== */
/* ================                                           CMP0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  CMP0_C0  ======================================================== */
/* ==============================================  CMP0 CMP0_C0 HYSTCTR [0..1]  ============================================== */
typedef enum {                                  /*!< CMP0_C0_HYSTCTR                                                           */
  CMP0_C0_HYSTCTR_00                   = 0,     /*!< 00 : The hard block output has level 0 hysteresis internally.             */
  CMP0_C0_HYSTCTR_01                   = 1,     /*!< 01 : The hard block output has level 1 hysteresis internally.             */
  CMP0_C0_HYSTCTR_10                   = 2,     /*!< 10 : The hard block output has level 2 hysteresis internally.             */
  CMP0_C0_HYSTCTR_11                   = 3,     /*!< 11 : The hard block output has level 3 hysteresis internally.             */
} CMP0_C0_HYSTCTR_Enum;

/* ==============================================  CMP0 CMP0_C0 OFFSET [2..2]  =============================================== */
typedef enum {                                  /*!< CMP0_C0_OFFSET                                                            */
  CMP0_C0_OFFSET_0                     = 0,     /*!< 0 : The comparator hard block output has level 0 offset internally.       */
  CMP0_C0_OFFSET_1                     = 1,     /*!< 1 : The comparator hard block output has level 1 offset internally.       */
} CMP0_C0_OFFSET_Enum;

/* ============================================  CMP0 CMP0_C0 FILTER_CNT [4..6]  ============================================= */
typedef enum {                                  /*!< CMP0_C0_FILTER_CNT                                                        */
  CMP0_C0_FILTER_CNT_000               = 0,     /*!< 000 : Filter is disabled. If SE = 1, then COUT is a logic zero
                                                     (this is not a legal state, and is not recommended). If
                                                     SE = 0, COUT = COUTA.                                                     */
  CMP0_C0_FILTER_CNT_001               = 1,     /*!< 001 : 1 consecutive sample must agree (comparator output is
                                                     simply sampled).                                                          */
  CMP0_C0_FILTER_CNT_010               = 2,     /*!< 010 : 2 consecutive samples must agree.                                   */
  CMP0_C0_FILTER_CNT_011               = 3,     /*!< 011 : 3 consecutive samples must agree.                                   */
  CMP0_C0_FILTER_CNT_100               = 4,     /*!< 100 : 4 consecutive samples must agree.                                   */
  CMP0_C0_FILTER_CNT_101               = 5,     /*!< 101 : 5 consecutive samples must agree.                                   */
  CMP0_C0_FILTER_CNT_110               = 6,     /*!< 110 : 6 consecutive samples must agree.                                   */
  CMP0_C0_FILTER_CNT_111               = 7,     /*!< 111 : 7 consecutive samples must agree.                                   */
} CMP0_C0_FILTER_CNT_Enum;

/* ================================================  CMP0 CMP0_C0 EN [8..8]  ================================================= */
typedef enum {                                  /*!< CMP0_C0_EN                                                                */
  CMP0_C0_EN_0                         = 0,     /*!< 0 : Analog Comparator is disabled.                                        */
  CMP0_C0_EN_1                         = 1,     /*!< 1 : Analog Comparator is enabled.                                         */
} CMP0_C0_EN_Enum;

/* ================================================  CMP0 CMP0_C0 OPE [9..9]  ================================================ */
typedef enum {                                  /*!< CMP0_C0_OPE                                                               */
  CMP0_C0_OPE_0                        = 0,     /*!< 0 : When OPE is 0, the comparator output (after window/filter
                                                     settings dependent on software configuration) is not available
                                                     to a packaged pin.                                                        */
  CMP0_C0_OPE_1                        = 1,     /*!< 1 : When OPE is 1, and if the software has configured the comparator
                                                     to own a packaged pin, the comparator is available in a
                                                     packaged pin.                                                             */
} CMP0_C0_OPE_Enum;

/* ===============================================  CMP0 CMP0_C0 COS [10..10]  =============================================== */
typedef enum {                                  /*!< CMP0_C0_COS                                                               */
  CMP0_C0_COS_0                        = 0,     /*!< 0 : Set CMPO to equal COUT (filtered comparator output).                  */
  CMP0_C0_COS_1                        = 1,     /*!< 1 : Set CMPO to equal COUTA (unfiltered comparator output).               */
} CMP0_C0_COS_Enum;

/* ==============================================  CMP0 CMP0_C0 INVT [11..11]  =============================================== */
typedef enum {                                  /*!< CMP0_C0_INVT                                                              */
  CMP0_C0_INVT_0                       = 0,     /*!< 0 : Does not invert the comparator output.                                */
  CMP0_C0_INVT_1                       = 1,     /*!< 1 : Inverts the comparator output.                                        */
} CMP0_C0_INVT_Enum;

/* ==============================================  CMP0 CMP0_C0 PMODE [12..12]  ============================================== */
typedef enum {                                  /*!< CMP0_C0_PMODE                                                             */
  CMP0_C0_PMODE_0                      = 0,     /*!< 0 : Low Speed (LS) comparison mode is selected.                           */
  CMP0_C0_PMODE_1                      = 1,     /*!< 1 : High Speed (HS) comparison mode is selected, in VLPx mode,
                                                     or Stop mode switched to Low Speed (LS) mode.                             */
} CMP0_C0_PMODE_Enum;

/* ===============================================  CMP0 CMP0_C0 WE [14..14]  ================================================ */
typedef enum {                                  /*!< CMP0_C0_WE                                                                */
  CMP0_C0_WE_0                         = 0,     /*!< 0 : Windowing mode is not selected.                                       */
  CMP0_C0_WE_1                         = 1,     /*!< 1 : Windowing mode is selected.                                           */
} CMP0_C0_WE_Enum;

/* ===============================================  CMP0 CMP0_C0 SE [15..15]  ================================================ */
typedef enum {                                  /*!< CMP0_C0_SE                                                                */
  CMP0_C0_SE_0                         = 0,     /*!< 0 : Sampling mode is not selected.                                        */
  CMP0_C0_SE_1                         = 1,     /*!< 1 : Sampling mode is selected.                                            */
} CMP0_C0_SE_Enum;

/* ===============================================  CMP0 CMP0_C0 CFF [25..25]  =============================================== */
typedef enum {                                  /*!< CMP0_C0_CFF                                                               */
  CMP0_C0_CFF_0                        = 0,     /*!< 0 : A falling edge has not been detected on COUT.                         */
  CMP0_C0_CFF_1                        = 1,     /*!< 1 : A falling edge on COUT has occurred.                                  */
} CMP0_C0_CFF_Enum;

/* ===============================================  CMP0 CMP0_C0 CFR [26..26]  =============================================== */
typedef enum {                                  /*!< CMP0_C0_CFR                                                               */
  CMP0_C0_CFR_0                        = 0,     /*!< 0 : A rising edge has not been detected on COUT.                          */
  CMP0_C0_CFR_1                        = 1,     /*!< 1 : A rising edge on COUT has occurred.                                   */
} CMP0_C0_CFR_Enum;

/* ===============================================  CMP0 CMP0_C0 IEF [27..27]  =============================================== */
typedef enum {                                  /*!< CMP0_C0_IEF                                                               */
  CMP0_C0_IEF_0                        = 0,     /*!< 0 : Interrupt is disabled.                                                */
  CMP0_C0_IEF_1                        = 1,     /*!< 1 : Interrupt is enabled.                                                 */
} CMP0_C0_IEF_Enum;

/* ===============================================  CMP0 CMP0_C0 IER [28..28]  =============================================== */
typedef enum {                                  /*!< CMP0_C0_IER                                                               */
  CMP0_C0_IER_0                        = 0,     /*!< 0 : Interrupt is disabled.                                                */
  CMP0_C0_IER_1                        = 1,     /*!< 1 : Interrupt is enabled.                                                 */
} CMP0_C0_IER_Enum;

/* ==============================================  CMP0 CMP0_C0 DMAEN [30..30]  ============================================== */
typedef enum {                                  /*!< CMP0_C0_DMAEN                                                             */
  CMP0_C0_DMAEN_0                      = 0,     /*!< 0 : DMA is disabled.                                                      */
  CMP0_C0_DMAEN_1                      = 1,     /*!< 1 : DMA is enabled.                                                       */
} CMP0_C0_DMAEN_Enum;

/* ========================================================  CMP0_C1  ======================================================== */
/* ===============================================  CMP0 CMP0_C1 MSEL [8..10]  =============================================== */
typedef enum {                                  /*!< CMP0_C1_MSEL                                                              */
  CMP0_C1_MSEL_000                     = 0,     /*!< 000 : IN0                                                                 */
  CMP0_C1_MSEL_001                     = 1,     /*!< 001 : IN1                                                                 */
  CMP0_C1_MSEL_010                     = 2,     /*!< 010 : IN2                                                                 */
  CMP0_C1_MSEL_011                     = 3,     /*!< 011 : IN3                                                                 */
  CMP0_C1_MSEL_100                     = 4,     /*!< 100 : IN4                                                                 */
  CMP0_C1_MSEL_101                     = 5,     /*!< 101 : IN5                                                                 */
  CMP0_C1_MSEL_110                     = 6,     /*!< 110 : IN6                                                                 */
  CMP0_C1_MSEL_111                     = 7,     /*!< 111 : IN7                                                                 */
} CMP0_C1_MSEL_Enum;

/* ==============================================  CMP0 CMP0_C1 PSEL [11..13]  =============================================== */
typedef enum {                                  /*!< CMP0_C1_PSEL                                                              */
  CMP0_C1_PSEL_000                     = 0,     /*!< 000 : IN0                                                                 */
  CMP0_C1_PSEL_001                     = 1,     /*!< 001 : IN1                                                                 */
  CMP0_C1_PSEL_010                     = 2,     /*!< 010 : IN2                                                                 */
  CMP0_C1_PSEL_011                     = 3,     /*!< 011 : IN3                                                                 */
  CMP0_C1_PSEL_100                     = 4,     /*!< 100 : IN4                                                                 */
  CMP0_C1_PSEL_101                     = 5,     /*!< 101 : IN5                                                                 */
  CMP0_C1_PSEL_110                     = 6,     /*!< 110 : IN6                                                                 */
  CMP0_C1_PSEL_111                     = 7,     /*!< 111 : IN7                                                                 */
} CMP0_C1_PSEL_Enum;

/* ==============================================  CMP0 CMP0_C1 VRSEL [14..14]  ============================================== */
typedef enum {                                  /*!< CMP0_C1_VRSEL                                                             */
  CMP0_C1_VRSEL_0                      = 0,     /*!< 0 : Vin1 is selected as resistor ladder network supply reference
                                                     Vin.                                                                      */
  CMP0_C1_VRSEL_1                      = 1,     /*!< 1 : Vin2 is selected as resistor ladder network supply reference
                                                     Vin.                                                                      */
} CMP0_C1_VRSEL_Enum;

/* ==============================================  CMP0 CMP0_C1 DACEN [15..15]  ============================================== */
typedef enum {                                  /*!< CMP0_C1_DACEN                                                             */
  CMP0_C1_DACEN_0                      = 0,     /*!< 0 : DAC is disabled.                                                      */
  CMP0_C1_DACEN_1                      = 1,     /*!< 1 : DAC is enabled.                                                       */
} CMP0_C1_DACEN_Enum;

/* =============================================  CMP0 CMP0_C1 INNSEL [24..25]  ============================================== */
typedef enum {                                  /*!< CMP0_C1_INNSEL                                                            */
  CMP0_C1_INNSEL_00                    = 0,     /*!< 00 : IN0, from the 8-bit DAC output                                       */
  CMP0_C1_INNSEL_01                    = 1,     /*!< 01 : IN1, from the analog 8-1 mux                                         */
} CMP0_C1_INNSEL_Enum;

/* =============================================  CMP0 CMP0_C1 INPSEL [27..28]  ============================================== */
typedef enum {                                  /*!< CMP0_C1_INPSEL                                                            */
  CMP0_C1_INPSEL_00                    = 0,     /*!< 00 : IN0, from the 8-bit DAC output                                       */
  CMP0_C1_INPSEL_01                    = 1,     /*!< 01 : IN1, from the analog 8-1 mux                                         */
} CMP0_C1_INPSEL_Enum;

/* ========================================================  CMP0_C2  ======================================================== */
/* =============================================  CMP0 CMP0_C2 INITMOD [8..13]  ============================================== */
typedef enum {                                  /*!< CMP0_C2_INITMOD                                                           */
  CMP0_C2_INITMOD_000000               = 0,     /*!< 000000 : The modulus is set to 64 (same with 111111).                     */
} CMP0_C2_INITMOD_Enum;

/* ==============================================  CMP0 CMP0_C2 NSAM [14..15]  =============================================== */
typedef enum {                                  /*!< CMP0_C2_NSAM                                                              */
  CMP0_C2_NSAM_00                      = 0,     /*!< 00 : The comparison result is sampled as soon as the active
                                                     channel is scanned in one round-robin clock.                              */
  CMP0_C2_NSAM_01                      = 1,     /*!< 01 : The sampling takes place 1 round-robin clock cycle after
                                                     the next cycle of the round-robin clock.                                  */
  CMP0_C2_NSAM_10                      = 2,     /*!< 10 : The sampling takes place 2 round-robin clock cycles after
                                                     the next cycle of the round-robin clock.                                  */
  CMP0_C2_NSAM_11                      = 3,     /*!< 11 : The sampling takes place 3 round-robin clock cycles after
                                                     the next cycle of the round-robin clock.                                  */
} CMP0_C2_NSAM_Enum;

/* =============================================  CMP0 CMP0_C2 FXMXCH [25..27]  ============================================== */
typedef enum {                                  /*!< CMP0_C2_FXMXCH                                                            */
  CMP0_C2_FXMXCH_000                   = 0,     /*!< 000 : Channel 0 is selected as the fixed reference input for
                                                     the fixed mux port.                                                       */
  CMP0_C2_FXMXCH_001                   = 1,     /*!< 001 : Channel 1 is selected as the fixed reference input for
                                                     the fixed mux port.                                                       */
  CMP0_C2_FXMXCH_010                   = 2,     /*!< 010 : Channel 2 is selected as the fixed reference input for
                                                     the fixed mux port.                                                       */
  CMP0_C2_FXMXCH_011                   = 3,     /*!< 011 : Channel 3 is selected as the fixed reference input for
                                                     the fixed mux port.                                                       */
  CMP0_C2_FXMXCH_100                   = 4,     /*!< 100 : Channel 4 is selected as the fixed reference input for
                                                     the fixed mux port.                                                       */
  CMP0_C2_FXMXCH_101                   = 5,     /*!< 101 : Channel 5 is selected as the fixed reference input for
                                                     the fixed mux port.                                                       */
  CMP0_C2_FXMXCH_110                   = 6,     /*!< 110 : Channel 6 is selected as the fixed reference input for
                                                     the fixed mux port.                                                       */
  CMP0_C2_FXMXCH_111                   = 7,     /*!< 111 : Channel 7 is selected as the fixed reference input for
                                                     the fixed mux port.                                                       */
} CMP0_C2_FXMXCH_Enum;

/* ==============================================  CMP0 CMP0_C2 FXMP [29..29]  =============================================== */
typedef enum {                                  /*!< CMP0_C2_FXMP                                                              */
  CMP0_C2_FXMP_0                       = 0,     /*!< 0 : The Plus port is fixed. Only the inputs to the Minus port
                                                     are swept in each round.                                                  */
  CMP0_C2_FXMP_1                       = 1,     /*!< 1 : The Minus port is fixed. Only the inputs to the Plus port
                                                     are swept in each round.                                                  */
} CMP0_C2_FXMP_Enum;

/* ==============================================  CMP0 CMP0_C2 RRIE [30..30]  =============================================== */
typedef enum {                                  /*!< CMP0_C2_RRIE                                                              */
  CMP0_C2_RRIE_0                       = 0,     /*!< 0 : The round-robin interrupt is disabled.                                */
  CMP0_C2_RRIE_1                       = 1,     /*!< 1 : The round-robin interrupt is enabled when a comparison result
                                                     changes from the last sample.                                             */
} CMP0_C2_RRIE_Enum;

/* ===============================================  CMP0 CMP0_C2 RRE [31..31]  =============================================== */
typedef enum {                                  /*!< CMP0_C2_RRE                                                               */
  CMP0_C2_RRE_0                        = 0,     /*!< 0 : Round-robin operation is disabled.                                    */
  CMP0_C2_RRE_1                        = 1,     /*!< 1 : Round-robin operation is enabled.                                     */
} CMP0_C2_RRE_Enum;



/* =========================================================================================================================== */
/* ================                                            PMC                                            ================ */
/* =========================================================================================================================== */

/* ======================================================  PMC_LVDSC1  ======================================================= */
/* ==============================================  PMC PMC_LVDSC1 LVDRE [4..4]  ============================================== */
typedef enum {                                  /*!< PMC_LVDSC1_LVDRE                                                          */
  PMC_LVDSC1_LVDRE_0                   = 0,     /*!< 0 : No system resets on low voltage detect events.                        */
} PMC_LVDSC1_LVDRE_Enum;

/* ==============================================  PMC PMC_LVDSC1 LVDIE [5..5]  ============================================== */
typedef enum {                                  /*!< PMC_LVDSC1_LVDIE                                                          */
  PMC_LVDSC1_LVDIE_0                   = 0,     /*!< 0 : Hardware interrupt disabled (use polling)                             */
  PMC_LVDSC1_LVDIE_1                   = 1,     /*!< 1 : Request a hardware interrupt when LVDF = 1                            */
} PMC_LVDSC1_LVDIE_Enum;

/* ==============================================  PMC PMC_LVDSC1 LVDF [7..7]  =============================================== */
typedef enum {                                  /*!< PMC_LVDSC1_LVDF                                                           */
  PMC_LVDSC1_LVDF_0                    = 0,     /*!< 0 : Low-voltage event not detected                                        */
  PMC_LVDSC1_LVDF_1                    = 1,     /*!< 1 : Low-voltage event detected                                            */
} PMC_LVDSC1_LVDF_Enum;

/* ======================================================  PMC_LVDSC2  ======================================================= */
/* ==============================================  PMC PMC_LVDSC2 LVWIE [5..5]  ============================================== */
typedef enum {                                  /*!< PMC_LVDSC2_LVWIE                                                          */
  PMC_LVDSC2_LVWIE_0                   = 0,     /*!< 0 : Hardware interrupt disabled (use polling)                             */
  PMC_LVDSC2_LVWIE_1                   = 1,     /*!< 1 : Request a hardware interrupt when LVWF=1                              */
} PMC_LVDSC2_LVWIE_Enum;

/* ==============================================  PMC PMC_LVDSC2 LVWF [7..7]  =============================================== */
typedef enum {                                  /*!< PMC_LVDSC2_LVWF                                                           */
  PMC_LVDSC2_LVWF_0                    = 0,     /*!< 0 : Low-voltage warning event not detected                                */
  PMC_LVDSC2_LVWF_1                    = 1,     /*!< 1 : Low-voltage warning event detected                                    */
} PMC_LVDSC2_LVWF_Enum;

/* =======================================================  PMC_REGSC  ======================================================= */
/* ==============================================  PMC PMC_REGSC BIASEN [0..0]  ============================================== */
typedef enum {                                  /*!< PMC_REGSC_BIASEN                                                          */
  PMC_REGSC_BIASEN_0                   = 0,     /*!< 0 : Biasing disabled, core logic can run in full performance              */
  PMC_REGSC_BIASEN_1                   = 1,     /*!< 1 : Biasing enabled, core logic is slower and there are restrictions
                                                     in allowed system clock speed (see Data Sheet for details)                */
} PMC_REGSC_BIASEN_Enum;

/* ============================================  PMC PMC_REGSC CLKBIASDIS [1..1]  ============================================ */
typedef enum {                                  /*!< PMC_REGSC_CLKBIASDIS                                                      */
  PMC_REGSC_CLKBIASDIS_0               = 0,     /*!< 0 : No effect                                                             */
  PMC_REGSC_CLKBIASDIS_1               = 1,     /*!< 1 : In VLPS mode, the bias currents and reference voltages for
                                                     the following clock modules are disabled: SIRC, FIRC, PLL.
                                                     (if available on device)                                                  */
} PMC_REGSC_CLKBIASDIS_Enum;

/* ==============================================  PMC PMC_REGSC REGFPM [2..2]  ============================================== */
typedef enum {                                  /*!< PMC_REGSC_REGFPM                                                          */
  PMC_REGSC_REGFPM_0                   = 0,     /*!< 0 : Regulator is in low power mode or transition to/from                  */
  PMC_REGSC_REGFPM_1                   = 1,     /*!< 1 : Regulator is in full performance mode                                 */
} PMC_REGSC_REGFPM_Enum;

/* =============================================  PMC PMC_REGSC LPOSTAT [6..6]  ============================================== */
typedef enum {                                  /*!< PMC_REGSC_LPOSTAT                                                         */
  PMC_REGSC_LPOSTAT_0                  = 0,     /*!< 0 : Low power oscillator in low phase                                     */
  PMC_REGSC_LPOSTAT_1                  = 1,     /*!< 1 : Low power oscillator in high phase                                    */
} PMC_REGSC_LPOSTAT_Enum;

/* ==============================================  PMC PMC_REGSC LPODIS [7..7]  ============================================== */
typedef enum {                                  /*!< PMC_REGSC_LPODIS                                                          */
  PMC_REGSC_LPODIS_0                   = 0,     /*!< 0 : Low power oscillator enabled                                          */
  PMC_REGSC_LPODIS_1                   = 1,     /*!< 1 : Low power oscillator disabled                                         */
} PMC_REGSC_LPODIS_Enum;

/* ======================================================  PMC_LPOTRIM  ====================================================== */


/* =========================================================================================================================== */
/* ================                                            SMC                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  SMC_VERID  ======================================================= */
/* =============================================  SMC SMC_VERID FEATURE [0..15]  ============================================= */
typedef enum {                                  /*!< SMC_VERID_FEATURE                                                         */
  SMC_VERID_FEATURE_0                  = 0,     /*!< 0 : Standard features implemented                                         */
} SMC_VERID_FEATURE_Enum;

/* =======================================================  SMC_PARAM  ======================================================= */
/* ==============================================  SMC SMC_PARAM EHSRUN [0..0]  ============================================== */
typedef enum {                                  /*!< SMC_PARAM_EHSRUN                                                          */
  SMC_PARAM_EHSRUN_0                   = 0,     /*!< 0 : The feature is not available.                                         */
  SMC_PARAM_EHSRUN_1                   = 1,     /*!< 1 : The feature is available.                                             */
} SMC_PARAM_EHSRUN_Enum;

/* ===============================================  SMC SMC_PARAM ELLS [3..3]  =============================================== */
typedef enum {                                  /*!< SMC_PARAM_ELLS                                                            */
  SMC_PARAM_ELLS_0                     = 0,     /*!< 0 : The feature is not available.                                         */
  SMC_PARAM_ELLS_1                     = 1,     /*!< 1 : The feature is available.                                             */
} SMC_PARAM_ELLS_Enum;

/* ==============================================  SMC SMC_PARAM ELLS2 [5..5]  =============================================== */
typedef enum {                                  /*!< SMC_PARAM_ELLS2                                                           */
  SMC_PARAM_ELLS2_0                    = 0,     /*!< 0 : The feature is not available.                                         */
  SMC_PARAM_ELLS2_1                    = 1,     /*!< 1 : The feature is available.                                             */
} SMC_PARAM_ELLS2_Enum;

/* ==============================================  SMC SMC_PARAM EVLLS0 [6..6]  ============================================== */
typedef enum {                                  /*!< SMC_PARAM_EVLLS0                                                          */
  SMC_PARAM_EVLLS0_0                   = 0,     /*!< 0 : The feature is not available.                                         */
  SMC_PARAM_EVLLS0_1                   = 1,     /*!< 1 : The feature is available.                                             */
} SMC_PARAM_EVLLS0_Enum;

/* ======================================================  SMC_PMPROT  ======================================================= */
/* ==============================================  SMC SMC_PMPROT AVLP [5..5]  =============================================== */
typedef enum {                                  /*!< SMC_PMPROT_AVLP                                                           */
  SMC_PMPROT_AVLP_0                    = 0,     /*!< 0 : VLPR and VLPS are not allowed.                                        */
  SMC_PMPROT_AVLP_1                    = 1,     /*!< 1 : VLPR and VLPS are allowed.                                            */
} SMC_PMPROT_AVLP_Enum;

/* ======================================================  SMC_PMCTRL  ======================================================= */
/* ==============================================  SMC SMC_PMCTRL STOPM [0..2]  ============================================== */
typedef enum {                                  /*!< SMC_PMCTRL_STOPM                                                          */
  SMC_PMCTRL_STOPM_000                 = 0,     /*!< 000 : Normal Stop (STOP)                                                  */
  SMC_PMCTRL_STOPM_010                 = 2,     /*!< 010 : Very-Low-Power Stop (VLPS)                                          */
  SMC_PMCTRL_STOPM_110                 = 6,     /*!< 110 : Reseved                                                             */
} SMC_PMCTRL_STOPM_Enum;

/* ==============================================  SMC SMC_PMCTRL VLPSA [3..3]  ============================================== */
typedef enum {                                  /*!< SMC_PMCTRL_VLPSA                                                          */
  SMC_PMCTRL_VLPSA_0                   = 0,     /*!< 0 : The previous stop mode entry was successful.                          */
  SMC_PMCTRL_VLPSA_1                   = 1,     /*!< 1 : The previous stop mode entry was aborted.                             */
} SMC_PMCTRL_VLPSA_Enum;

/* ==============================================  SMC SMC_PMCTRL RUNM [5..6]  =============================================== */
typedef enum {                                  /*!< SMC_PMCTRL_RUNM                                                           */
  SMC_PMCTRL_RUNM_00                   = 0,     /*!< 00 : Normal Run mode (RUN)                                                */
  SMC_PMCTRL_RUNM_10                   = 2,     /*!< 10 : Very-Low-Power Run mode (VLPR)                                       */
} SMC_PMCTRL_RUNM_Enum;

/* =====================================================  SMC_STOPCTRL  ====================================================== */
/* =============================================  SMC SMC_STOPCTRL STOPO [6..7]  ============================================= */
typedef enum {                                  /*!< SMC_STOPCTRL_STOPO                                                        */
  SMC_STOPCTRL_STOPO_01                = 1,     /*!< 01 : STOP1 - Stop with both system and bus clocks disabled                */
  SMC_STOPCTRL_STOPO_10                = 2,     /*!< 10 : STOP2 - Stop with system clock disabled and bus clock enabled        */
} SMC_STOPCTRL_STOPO_Enum;

/* ======================================================  SMC_PMSTAT  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            RCM                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  RCM_VERID  ======================================================= */
/* =============================================  RCM RCM_VERID FEATURE [0..15]  ============================================= */
typedef enum {                                  /*!< RCM_VERID_FEATURE                                                         */
  RCM_VERID_FEATURE_11                 = 3,     /*!< 11 : Standard feature set.                                                */
} RCM_VERID_FEATURE_Enum;

/* =======================================================  RCM_PARAM  ======================================================= */
/* =============================================  RCM RCM_PARAM EWAKEUP [0..0]  ============================================== */
typedef enum {                                  /*!< RCM_PARAM_EWAKEUP                                                         */
  RCM_PARAM_EWAKEUP_0                  = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_EWAKEUP_1                  = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_EWAKEUP_Enum;

/* ===============================================  RCM RCM_PARAM ELVD [1..1]  =============================================== */
typedef enum {                                  /*!< RCM_PARAM_ELVD                                                            */
  RCM_PARAM_ELVD_0                     = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_ELVD_1                     = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_ELVD_Enum;

/* ===============================================  RCM RCM_PARAM ELOC [2..2]  =============================================== */
typedef enum {                                  /*!< RCM_PARAM_ELOC                                                            */
  RCM_PARAM_ELOC_0                     = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_ELOC_1                     = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_ELOC_Enum;

/* ===============================================  RCM RCM_PARAM ELOL [3..3]  =============================================== */
typedef enum {                                  /*!< RCM_PARAM_ELOL                                                            */
  RCM_PARAM_ELOL_0                     = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_ELOL_1                     = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_ELOL_Enum;

/* =============================================  RCM RCM_PARAM ECMU_LOC [4..4]  ============================================= */
typedef enum {                                  /*!< RCM_PARAM_ECMU_LOC                                                        */
  RCM_PARAM_ECMU_LOC_0                 = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_ECMU_LOC_1                 = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_ECMU_LOC_Enum;

/* ==============================================  RCM RCM_PARAM EWDOG [5..5]  =============================================== */
typedef enum {                                  /*!< RCM_PARAM_EWDOG                                                           */
  RCM_PARAM_EWDOG_0                    = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_EWDOG_1                    = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_EWDOG_Enum;

/* ===============================================  RCM RCM_PARAM EPIN [6..6]  =============================================== */
typedef enum {                                  /*!< RCM_PARAM_EPIN                                                            */
  RCM_PARAM_EPIN_0                     = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_EPIN_1                     = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_EPIN_Enum;

/* ===============================================  RCM RCM_PARAM EPOR [7..7]  =============================================== */
typedef enum {                                  /*!< RCM_PARAM_EPOR                                                            */
  RCM_PARAM_EPOR_0                     = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_EPOR_1                     = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_EPOR_Enum;

/* ==============================================  RCM RCM_PARAM EJTAG [8..8]  =============================================== */
typedef enum {                                  /*!< RCM_PARAM_EJTAG                                                           */
  RCM_PARAM_EJTAG_0                    = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_EJTAG_1                    = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_EJTAG_Enum;

/* =============================================  RCM RCM_PARAM ELOCKUP [9..9]  ============================================== */
typedef enum {                                  /*!< RCM_PARAM_ELOCKUP                                                         */
  RCM_PARAM_ELOCKUP_0                  = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_ELOCKUP_1                  = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_ELOCKUP_Enum;

/* ==============================================  RCM RCM_PARAM ESW [10..10]  =============================================== */
typedef enum {                                  /*!< RCM_PARAM_ESW                                                             */
  RCM_PARAM_ESW_0                      = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_ESW_1                      = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_ESW_Enum;

/* ============================================  RCM RCM_PARAM EMDM_AP [11..11]  ============================================= */
typedef enum {                                  /*!< RCM_PARAM_EMDM_AP                                                         */
  RCM_PARAM_EMDM_AP_0                  = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_EMDM_AP_1                  = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_EMDM_AP_Enum;

/* ============================================  RCM RCM_PARAM ESACKERR [13..13]  ============================================ */
typedef enum {                                  /*!< RCM_PARAM_ESACKERR                                                        */
  RCM_PARAM_ESACKERR_0                 = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_ESACKERR_1                 = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_ESACKERR_Enum;

/* ============================================  RCM RCM_PARAM ETAMPER [15..15]  ============================================= */
typedef enum {                                  /*!< RCM_PARAM_ETAMPER                                                         */
  RCM_PARAM_ETAMPER_0                  = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_ETAMPER_1                  = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_ETAMPER_Enum;

/* =============================================  RCM RCM_PARAM ECORE1 [16..16]  ============================================= */
typedef enum {                                  /*!< RCM_PARAM_ECORE1                                                          */
  RCM_PARAM_ECORE1_0                   = 0,     /*!< 0 : The feature is not available.                                         */
  RCM_PARAM_ECORE1_1                   = 1,     /*!< 1 : The feature is available.                                             */
} RCM_PARAM_ECORE1_Enum;

/* ========================================================  RCM_SRS  ======================================================== */
/* ================================================  RCM RCM_SRS LVD [1..1]  ================================================= */
typedef enum {                                  /*!< RCM_SRS_LVD                                                               */
  RCM_SRS_LVD_0                        = 0,     /*!< 0 : Reset not caused by LVD trip, HVD trip or POR                         */
  RCM_SRS_LVD_1                        = 1,     /*!< 1 : Reset caused by LVD trip, HVD trip or POR                             */
} RCM_SRS_LVD_Enum;

/* ================================================  RCM RCM_SRS LOC [2..2]  ================================================= */
typedef enum {                                  /*!< RCM_SRS_LOC                                                               */
  RCM_SRS_LOC_0                        = 0,     /*!< 0 : Reset not caused by a loss of external clock.                         */
  RCM_SRS_LOC_1                        = 1,     /*!< 1 : Reset caused by a loss of external clock.                             */
} RCM_SRS_LOC_Enum;

/* ================================================  RCM RCM_SRS LOL [3..3]  ================================================= */
typedef enum {                                  /*!< RCM_SRS_LOL                                                               */
  RCM_SRS_LOL_0                        = 0,     /*!< 0 : Reset not caused by a loss of lock in the PLL/FLL                     */
  RCM_SRS_LOL_1                        = 1,     /*!< 1 : Reset caused by a loss of lock in the PLL/FLL                         */
} RCM_SRS_LOL_Enum;

/* ==============================================  RCM RCM_SRS CMU_LOC [4..4]  =============================================== */
typedef enum {                                  /*!< RCM_SRS_CMU_LOC                                                           */
  RCM_SRS_CMU_LOC_0                    = 0,     /*!< 0 : Reset not caused by the CMU loss-of-clock circuit.                    */
  RCM_SRS_CMU_LOC_1                    = 1,     /*!< 1 : Reset caused by the CMU loss-of-clock circuit.                        */
} RCM_SRS_CMU_LOC_Enum;

/* ================================================  RCM RCM_SRS WDOG [5..5]  ================================================ */
typedef enum {                                  /*!< RCM_SRS_WDOG                                                              */
  RCM_SRS_WDOG_0                       = 0,     /*!< 0 : Reset not caused by watchdog timeout                                  */
  RCM_SRS_WDOG_1                       = 1,     /*!< 1 : Reset caused by watchdog timeout                                      */
} RCM_SRS_WDOG_Enum;

/* ================================================  RCM RCM_SRS PIN [6..6]  ================================================= */
typedef enum {                                  /*!< RCM_SRS_PIN                                                               */
  RCM_SRS_PIN_0                        = 0,     /*!< 0 : Reset not caused by external reset pin                                */
  RCM_SRS_PIN_1                        = 1,     /*!< 1 : Reset caused by external reset pin                                    */
} RCM_SRS_PIN_Enum;

/* ================================================  RCM RCM_SRS POR [7..7]  ================================================= */
typedef enum {                                  /*!< RCM_SRS_POR                                                               */
  RCM_SRS_POR_0                        = 0,     /*!< 0 : Reset not caused by POR                                               */
  RCM_SRS_POR_1                        = 1,     /*!< 1 : Reset caused by POR                                                   */
} RCM_SRS_POR_Enum;

/* ================================================  RCM RCM_SRS JTAG [8..8]  ================================================ */
typedef enum {                                  /*!< RCM_SRS_JTAG                                                              */
  RCM_SRS_JTAG_0                       = 0,     /*!< 0 : Reset not caused by JTAG                                              */
  RCM_SRS_JTAG_1                       = 1,     /*!< 1 : Reset caused by JTAG                                                  */
} RCM_SRS_JTAG_Enum;

/* ===============================================  RCM RCM_SRS LOCKUP [9..9]  =============================================== */
typedef enum {                                  /*!< RCM_SRS_LOCKUP                                                            */
  RCM_SRS_LOCKUP_0                     = 0,     /*!< 0 : Reset not caused by core LOCKUP event                                 */
  RCM_SRS_LOCKUP_1                     = 1,     /*!< 1 : Reset caused by core LOCKUP event                                     */
} RCM_SRS_LOCKUP_Enum;

/* ================================================  RCM RCM_SRS SW [10..10]  ================================================ */
typedef enum {                                  /*!< RCM_SRS_SW                                                                */
  RCM_SRS_SW_0                         = 0,     /*!< 0 : Reset not caused by software setting of SYSRESETREQ bit               */
  RCM_SRS_SW_1                         = 1,     /*!< 1 : Reset caused by software setting of SYSRESETREQ bit                   */
} RCM_SRS_SW_Enum;

/* ==============================================  RCM RCM_SRS MDM_AP [11..11]  ============================================== */
typedef enum {                                  /*!< RCM_SRS_MDM_AP                                                            */
  RCM_SRS_MDM_AP_0                     = 0,     /*!< 0 : Reset was not caused by host debugger system setting of
                                                     the System Reset Request bit                                              */
  RCM_SRS_MDM_AP_1                     = 1,     /*!< 1 : Reset was caused by host debugger system setting of the
                                                     System Reset Request bit                                                  */
} RCM_SRS_MDM_AP_Enum;

/* =============================================  RCM RCM_SRS SACKERR [13..13]  ============================================== */
typedef enum {                                  /*!< RCM_SRS_SACKERR                                                           */
  RCM_SRS_SACKERR_0                    = 0,     /*!< 0 : Reset not caused by peripheral failure to acknowledge attempt
                                                     to enter stop mode                                                        */
  RCM_SRS_SACKERR_1                    = 1,     /*!< 1 : Reset caused by peripheral failure to acknowledge attempt
                                                     to enter stop mode                                                        */
} RCM_SRS_SACKERR_Enum;

/* ========================================================  RCM_RPC  ======================================================== */
/* =============================================  RCM RCM_RPC RSTFLTSRW [0..1]  ============================================== */
typedef enum {                                  /*!< RCM_RPC_RSTFLTSRW                                                         */
  RCM_RPC_RSTFLTSRW_00                 = 0,     /*!< 00 : All filtering disabled                                               */
  RCM_RPC_RSTFLTSRW_01                 = 1,     /*!< 01 : Bus clock filter enabled for normal operation                        */
  RCM_RPC_RSTFLTSRW_10                 = 2,     /*!< 10 : LPO clock filter enabled for normal operation                        */
} RCM_RPC_RSTFLTSRW_Enum;

/* ==============================================  RCM RCM_RPC RSTFLTSS [2..2]  ============================================== */
typedef enum {                                  /*!< RCM_RPC_RSTFLTSS                                                          */
  RCM_RPC_RSTFLTSS_0                   = 0,     /*!< 0 : All filtering disabled                                                */
  RCM_RPC_RSTFLTSS_1                   = 1,     /*!< 1 : LPO clock filter enabled                                              */
} RCM_RPC_RSTFLTSS_Enum;

/* =======================================================  RCM_SSRS  ======================================================== */
/* ===============================================  RCM RCM_SSRS SLVD [1..1]  ================================================ */
typedef enum {                                  /*!< RCM_SSRS_SLVD                                                             */
  RCM_SSRS_SLVD_0                      = 0,     /*!< 0 : Reset not caused by LVD trip or POR                                   */
  RCM_SSRS_SLVD_1                      = 1,     /*!< 1 : Reset caused by LVD trip or POR                                       */
} RCM_SSRS_SLVD_Enum;

/* ===============================================  RCM RCM_SSRS SLOC [2..2]  ================================================ */
typedef enum {                                  /*!< RCM_SSRS_SLOC                                                             */
  RCM_SSRS_SLOC_0                      = 0,     /*!< 0 : Reset not caused by a loss of external clock.                         */
  RCM_SSRS_SLOC_1                      = 1,     /*!< 1 : Reset caused by a loss of external clock.                             */
} RCM_SSRS_SLOC_Enum;

/* ===============================================  RCM RCM_SSRS SLOL [3..3]  ================================================ */
typedef enum {                                  /*!< RCM_SSRS_SLOL                                                             */
  RCM_SSRS_SLOL_0                      = 0,     /*!< 0 : Reset not caused by a loss of lock in the PLL/FLL                     */
  RCM_SSRS_SLOL_1                      = 1,     /*!< 1 : Reset caused by a loss of lock in the PLL/FLL                         */
} RCM_SSRS_SLOL_Enum;

/* =============================================  RCM RCM_SSRS SCMU_LOC [4..4]  ============================================== */
typedef enum {                                  /*!< RCM_SSRS_SCMU_LOC                                                         */
  RCM_SSRS_SCMU_LOC_0                  = 0,     /*!< 0 : Reset not caused by the CMU loss-of-clock circuit.                    */
  RCM_SSRS_SCMU_LOC_1                  = 1,     /*!< 1 : Reset caused by the CMU loss-of-clock circuit.                        */
} RCM_SSRS_SCMU_LOC_Enum;

/* ===============================================  RCM RCM_SSRS SWDOG [5..5]  =============================================== */
typedef enum {                                  /*!< RCM_SSRS_SWDOG                                                            */
  RCM_SSRS_SWDOG_0                     = 0,     /*!< 0 : Reset not caused by watchdog timeout                                  */
  RCM_SSRS_SWDOG_1                     = 1,     /*!< 1 : Reset caused by watchdog timeout                                      */
} RCM_SSRS_SWDOG_Enum;

/* ===============================================  RCM RCM_SSRS SPIN [6..6]  ================================================ */
typedef enum {                                  /*!< RCM_SSRS_SPIN                                                             */
  RCM_SSRS_SPIN_0                      = 0,     /*!< 0 : Reset not caused by external reset pin                                */
  RCM_SSRS_SPIN_1                      = 1,     /*!< 1 : Reset caused by external reset pin                                    */
} RCM_SSRS_SPIN_Enum;

/* ===============================================  RCM RCM_SSRS SPOR [7..7]  ================================================ */
typedef enum {                                  /*!< RCM_SSRS_SPOR                                                             */
  RCM_SSRS_SPOR_0                      = 0,     /*!< 0 : Reset not caused by POR                                               */
  RCM_SSRS_SPOR_1                      = 1,     /*!< 1 : Reset caused by POR                                                   */
} RCM_SSRS_SPOR_Enum;

/* ===============================================  RCM RCM_SSRS SJTAG [8..8]  =============================================== */
typedef enum {                                  /*!< RCM_SSRS_SJTAG                                                            */
  RCM_SSRS_SJTAG_0                     = 0,     /*!< 0 : Reset not caused by JTAG                                              */
  RCM_SSRS_SJTAG_1                     = 1,     /*!< 1 : Reset caused by JTAG                                                  */
} RCM_SSRS_SJTAG_Enum;

/* ==============================================  RCM RCM_SSRS SLOCKUP [9..9]  ============================================== */
typedef enum {                                  /*!< RCM_SSRS_SLOCKUP                                                          */
  RCM_SSRS_SLOCKUP_0                   = 0,     /*!< 0 : Reset not caused by core LOCKUP event                                 */
  RCM_SSRS_SLOCKUP_1                   = 1,     /*!< 1 : Reset caused by core LOCKUP event                                     */
} RCM_SSRS_SLOCKUP_Enum;

/* ===============================================  RCM RCM_SSRS SSW [10..10]  =============================================== */
typedef enum {                                  /*!< RCM_SSRS_SSW                                                              */
  RCM_SSRS_SSW_0                       = 0,     /*!< 0 : Reset not caused by software setting of SYSRESETREQ bit               */
  RCM_SSRS_SSW_1                       = 1,     /*!< 1 : Reset caused by software setting of SYSRESETREQ bit                   */
} RCM_SSRS_SSW_Enum;

/* =============================================  RCM RCM_SSRS SMDM_AP [11..11]  ============================================= */
typedef enum {                                  /*!< RCM_SSRS_SMDM_AP                                                          */
  RCM_SSRS_SMDM_AP_0                   = 0,     /*!< 0 : Reset was not caused by host debugger system setting of
                                                     the System Reset Request bit                                              */
  RCM_SSRS_SMDM_AP_1                   = 1,     /*!< 1 : Reset was caused by host debugger system setting of the
                                                     System Reset Request bit                                                  */
} RCM_SSRS_SMDM_AP_Enum;

/* ============================================  RCM RCM_SSRS SSACKERR [13..13]  ============================================= */
typedef enum {                                  /*!< RCM_SSRS_SSACKERR                                                         */
  RCM_SSRS_SSACKERR_0                  = 0,     /*!< 0 : Reset not caused by peripheral failure to acknowledge attempt
                                                     to enter stop mode                                                        */
  RCM_SSRS_SSACKERR_1                  = 1,     /*!< 1 : Reset caused by peripheral failure to acknowledge attempt
                                                     to enter stop mode                                                        */
} RCM_SSRS_SSACKERR_Enum;

/* =======================================================  RCM_SRIE  ======================================================== */
/* ===============================================  RCM RCM_SRIE DELAY [0..1]  =============================================== */
typedef enum {                                  /*!< RCM_SRIE_DELAY                                                            */
  RCM_SRIE_DELAY_00                    = 0,     /*!< 00 : 10 LPO cycles                                                        */
  RCM_SRIE_DELAY_01                    = 1,     /*!< 01 : 34 LPO cycles                                                        */
  RCM_SRIE_DELAY_10                    = 2,     /*!< 10 : 130 LPO cycles                                                       */
  RCM_SRIE_DELAY_11                    = 3,     /*!< 11 : 514 LPO cycles                                                       */
} RCM_SRIE_DELAY_Enum;

/* ================================================  RCM RCM_SRIE LOC [2..2]  ================================================ */
typedef enum {                                  /*!< RCM_SRIE_LOC                                                              */
  RCM_SRIE_LOC_0                       = 0,     /*!< 0 : Interrupt disabled.                                                   */
  RCM_SRIE_LOC_1                       = 1,     /*!< 1 : Interrupt enabled.                                                    */
} RCM_SRIE_LOC_Enum;

/* ================================================  RCM RCM_SRIE LOL [3..3]  ================================================ */
typedef enum {                                  /*!< RCM_SRIE_LOL                                                              */
  RCM_SRIE_LOL_0                       = 0,     /*!< 0 : Interrupt disabled.                                                   */
  RCM_SRIE_LOL_1                       = 1,     /*!< 1 : Interrupt enabled.                                                    */
} RCM_SRIE_LOL_Enum;

/* ==============================================  RCM RCM_SRIE CMU_LOC [4..4]  ============================================== */
typedef enum {                                  /*!< RCM_SRIE_CMU_LOC                                                          */
  RCM_SRIE_CMU_LOC_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  RCM_SRIE_CMU_LOC_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} RCM_SRIE_CMU_LOC_Enum;

/* ===============================================  RCM RCM_SRIE WDOG [5..5]  ================================================ */
typedef enum {                                  /*!< RCM_SRIE_WDOG                                                             */
  RCM_SRIE_WDOG_0                      = 0,     /*!< 0 : Interrupt disabled.                                                   */
  RCM_SRIE_WDOG_1                      = 1,     /*!< 1 : Interrupt enabled.                                                    */
} RCM_SRIE_WDOG_Enum;

/* ================================================  RCM RCM_SRIE PIN [6..6]  ================================================ */
typedef enum {                                  /*!< RCM_SRIE_PIN                                                              */
  RCM_SRIE_PIN_0                       = 0,     /*!< 0 : Reset not caused by external reset pin                                */
  RCM_SRIE_PIN_1                       = 1,     /*!< 1 : Reset caused by external reset pin                                    */
} RCM_SRIE_PIN_Enum;

/* ================================================  RCM RCM_SRIE GIE [7..7]  ================================================ */
typedef enum {                                  /*!< RCM_SRIE_GIE                                                              */
  RCM_SRIE_GIE_0                       = 0,     /*!< 0 : All interrupt sources disabled.                                       */
  RCM_SRIE_GIE_1                       = 1,     /*!< 1 : All interrupt sources enabled. Note that the individual
                                                     interrupt-enable bits still need to be set to generate
                                                     interrupts.                                                               */
} RCM_SRIE_GIE_Enum;

/* ===============================================  RCM RCM_SRIE JTAG [8..8]  ================================================ */
typedef enum {                                  /*!< RCM_SRIE_JTAG                                                             */
  RCM_SRIE_JTAG_0                      = 0,     /*!< 0 : Interrupt disabled.                                                   */
  RCM_SRIE_JTAG_1                      = 1,     /*!< 1 : Interrupt enabled.                                                    */
} RCM_SRIE_JTAG_Enum;

/* ==============================================  RCM RCM_SRIE LOCKUP [9..9]  =============================================== */
typedef enum {                                  /*!< RCM_SRIE_LOCKUP                                                           */
  RCM_SRIE_LOCKUP_0                    = 0,     /*!< 0 : Interrupt disabled.                                                   */
  RCM_SRIE_LOCKUP_1                    = 1,     /*!< 1 : Interrupt enabled.                                                    */
} RCM_SRIE_LOCKUP_Enum;

/* ===============================================  RCM RCM_SRIE SW [10..10]  ================================================ */
typedef enum {                                  /*!< RCM_SRIE_SW                                                               */
  RCM_SRIE_SW_0                        = 0,     /*!< 0 : Interrupt disabled.                                                   */
  RCM_SRIE_SW_1                        = 1,     /*!< 1 : Interrupt enabled.                                                    */
} RCM_SRIE_SW_Enum;

/* =============================================  RCM RCM_SRIE MDM_AP [11..11]  ============================================== */
typedef enum {                                  /*!< RCM_SRIE_MDM_AP                                                           */
  RCM_SRIE_MDM_AP_0                    = 0,     /*!< 0 : Interrupt disabled.                                                   */
  RCM_SRIE_MDM_AP_1                    = 1,     /*!< 1 : Interrupt enabled.                                                    */
} RCM_SRIE_MDM_AP_Enum;

/* =============================================  RCM RCM_SRIE SACKERR [13..13]  ============================================= */
typedef enum {                                  /*!< RCM_SRIE_SACKERR                                                          */
  RCM_SRIE_SACKERR_0                   = 0,     /*!< 0 : Interrupt disabled.                                                   */
  RCM_SRIE_SACKERR_1                   = 1,     /*!< 1 : Interrupt enabled.                                                    */
} RCM_SRIE_SACKERR_Enum;



/* =========================================================================================================================== */
/* ================                                            PTA                                            ================ */
/* =========================================================================================================================== */

/* ======================================================  GPIOA_PDOR  ======================================================= */
/* ======================================================  GPIOA_PSOR  ======================================================= */
/* ======================================================  GPIOA_PCOR  ======================================================= */
/* ======================================================  GPIOA_PTOR  ======================================================= */
/* ======================================================  GPIOA_PDIR  ======================================================= */
/* ======================================================  GPIOA_PDDR  ======================================================= */
/* ======================================================  GPIOA_PIDR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            PTB                                            ================ */
/* =========================================================================================================================== */

/* ======================================================  GPIOB_PDOR  ======================================================= */
/* ======================================================  GPIOB_PSOR  ======================================================= */
/* ======================================================  GPIOB_PCOR  ======================================================= */
/* ======================================================  GPIOB_PTOR  ======================================================= */
/* ======================================================  GPIOB_PDIR  ======================================================= */
/* ======================================================  GPIOB_PDDR  ======================================================= */
/* ======================================================  GPIOB_PIDR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            PTC                                            ================ */
/* =========================================================================================================================== */

/* ======================================================  GPIOC_PDOR  ======================================================= */
/* ======================================================  GPIOC_PSOR  ======================================================= */
/* ======================================================  GPIOC_PCOR  ======================================================= */
/* ======================================================  GPIOC_PTOR  ======================================================= */
/* ======================================================  GPIOC_PDIR  ======================================================= */
/* ======================================================  GPIOC_PDDR  ======================================================= */
/* ======================================================  GPIOC_PIDR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            PTD                                            ================ */
/* =========================================================================================================================== */

/* ======================================================  GPIOD_PDOR  ======================================================= */
/* ======================================================  GPIOD_PSOR  ======================================================= */
/* ======================================================  GPIOD_PCOR  ======================================================= */
/* ======================================================  GPIOD_PTOR  ======================================================= */
/* ======================================================  GPIOD_PDIR  ======================================================= */
/* ======================================================  GPIOD_PDDR  ======================================================= */
/* ======================================================  GPIOD_PIDR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            PTE                                            ================ */
/* =========================================================================================================================== */

/* ======================================================  GPIOE_PDOR  ======================================================= */
/* ======================================================  GPIOE_PSOR  ======================================================= */
/* ======================================================  GPIOE_PCOR  ======================================================= */
/* ======================================================  GPIOE_PTOR  ======================================================= */
/* ======================================================  GPIOE_PDIR  ======================================================= */
/* ======================================================  GPIOE_PDDR  ======================================================= */
/* ======================================================  GPIOE_PIDR  ======================================================= */


/* =========================================================================================================================== */
/* ================                                          S32_SCB                                          ================ */
/* =========================================================================================================================== */

/* =======================================================  SCB_ACTLR  ======================================================= */
/* =======================================================  SCB_CPUID  ======================================================= */
/* =======================================================  SCB_ICSR  ======================================================== */
/* =========================================  S32_SCB SCB_ICSR ISRPENDING [22..22]  ========================================== */
typedef enum {                                  /*!< S32_SCB_ICSR_ISRPENDING                                                   */
  S32_SCB_ICSR_ISRPENDING_0            = 0,     /*!< 0 : interrupt not pending                                                 */
  S32_SCB_ICSR_ISRPENDING_1            = 1,     /*!< 1 : interrupt pending                                                     */
} S32_SCB_ICSR_ISRPENDING_Enum;

/* ==========================================  S32_SCB SCB_ICSR PENDSTCLR [25..25]  ========================================== */
typedef enum {                                  /*!< S32_SCB_ICSR_PENDSTCLR                                                    */
  S32_SCB_ICSR_PENDSTCLR_0             = 0,     /*!< 0 : no effect                                                             */
  S32_SCB_ICSR_PENDSTCLR_1             = 1,     /*!< 1 : removes the pending state from the SysTick exception                  */
} S32_SCB_ICSR_PENDSTCLR_Enum;

/* ==========================================  S32_SCB SCB_ICSR PENDSTSET [26..26]  ========================================== */
typedef enum {                                  /*!< S32_SCB_ICSR_PENDSTSET                                                    */
  S32_SCB_ICSR_PENDSTSET_0             = 0,     /*!< 0 : write: no effect; read: SysTick exception is not pending              */
  S32_SCB_ICSR_PENDSTSET_1             = 1,     /*!< 1 : write: changes SysTick exception state to pending; read:
                                                     SysTick exception is pending                                              */
} S32_SCB_ICSR_PENDSTSET_Enum;

/* ==========================================  S32_SCB SCB_ICSR PENDSVCLR [27..27]  ========================================== */
typedef enum {                                  /*!< S32_SCB_ICSR_PENDSVCLR                                                    */
  S32_SCB_ICSR_PENDSVCLR_0             = 0,     /*!< 0 : no effect                                                             */
  S32_SCB_ICSR_PENDSVCLR_1             = 1,     /*!< 1 : removes the pending state from the PendSV exception                   */
} S32_SCB_ICSR_PENDSVCLR_Enum;

/* ==========================================  S32_SCB SCB_ICSR PENDSVSET [28..28]  ========================================== */
typedef enum {                                  /*!< S32_SCB_ICSR_PENDSVSET                                                    */
  S32_SCB_ICSR_PENDSVSET_0             = 0,     /*!< 0 : write: no effect; read: PendSV exception is not pending               */
  S32_SCB_ICSR_PENDSVSET_1             = 1,     /*!< 1 : write: changes PendSV exception state to pending; read:
                                                     PendSV exception is pending                                               */
} S32_SCB_ICSR_PENDSVSET_Enum;

/* =========================================  S32_SCB SCB_ICSR NMIPENDSET [31..31]  ========================================== */
typedef enum {                                  /*!< S32_SCB_ICSR_NMIPENDSET                                                   */
  S32_SCB_ICSR_NMIPENDSET_0            = 0,     /*!< 0 : write: no effect; read: NMI exception is not pending                  */
  S32_SCB_ICSR_NMIPENDSET_1            = 1,     /*!< 1 : write: changes NMI exception state to pending; read: NMI
                                                     exception is pending                                                      */
} S32_SCB_ICSR_NMIPENDSET_Enum;

/* =======================================================  SCB_VTOR  ======================================================== */
/* =======================================================  SCB_AIRCR  ======================================================= */
/* =========================================  S32_SCB SCB_AIRCR SYSRESETREQ [2..2]  ========================================== */
typedef enum {                                  /*!< S32_SCB_AIRCR_SYSRESETREQ                                                 */
  S32_SCB_AIRCR_SYSRESETREQ_0          = 0,     /*!< 0 : no system reset request                                               */
  S32_SCB_AIRCR_SYSRESETREQ_1          = 1,     /*!< 1 : asserts a signal to the outer system that requests a reset            */
} S32_SCB_AIRCR_SYSRESETREQ_Enum;

/* =========================================  S32_SCB SCB_AIRCR ENDIANNESS [15..15]  ========================================= */
typedef enum {                                  /*!< S32_SCB_AIRCR_ENDIANNESS                                                  */
  S32_SCB_AIRCR_ENDIANNESS_0           = 0,     /*!< 0 : Little-endian                                                         */
  S32_SCB_AIRCR_ENDIANNESS_1           = 1,     /*!< 1 : Big-endian                                                            */
} S32_SCB_AIRCR_ENDIANNESS_Enum;

/* ========================================================  SCB_SCR  ======================================================== */
/* ==========================================  S32_SCB SCB_SCR SLEEPONEXIT [1..1]  =========================================== */
typedef enum {                                  /*!< S32_SCB_SCR_SLEEPONEXIT                                                   */
  S32_SCB_SCR_SLEEPONEXIT_0            = 0,     /*!< 0 : o not sleep when returning to Thread mode                             */
  S32_SCB_SCR_SLEEPONEXIT_1            = 1,     /*!< 1 : enter sleep, or deep sleep, on return from an ISR                     */
} S32_SCB_SCR_SLEEPONEXIT_Enum;

/* ===========================================  S32_SCB SCB_SCR SLEEPDEEP [2..2]  ============================================ */
typedef enum {                                  /*!< S32_SCB_SCR_SLEEPDEEP                                                     */
  S32_SCB_SCR_SLEEPDEEP_0              = 0,     /*!< 0 : sleep                                                                 */
  S32_SCB_SCR_SLEEPDEEP_1              = 1,     /*!< 1 : deep sleep                                                            */
} S32_SCB_SCR_SLEEPDEEP_Enum;

/* ===========================================  S32_SCB SCB_SCR SEVONPEND [4..4]  ============================================ */
typedef enum {                                  /*!< S32_SCB_SCR_SEVONPEND                                                     */
  S32_SCB_SCR_SEVONPEND_0              = 0,     /*!< 0 : only enabled interrupts or events can wakeup the processor,
                                                     disabled interrupts are excluded                                          */
  S32_SCB_SCR_SEVONPEND_1              = 1,     /*!< 1 : enabled events and all interrupts, including disabled interrupts,
                                                     can wakeup the processor                                                  */
} S32_SCB_SCR_SEVONPEND_Enum;

/* ========================================================  SCB_CCR  ======================================================== */
/* =======================================================  SCB_SHPR2  ======================================================= */
/* =======================================================  SCB_SHPR3  ======================================================= */
/* =======================================================  SCB_SHCSR  ======================================================= */
/* ========================================  S32_SCB SCB_SHCSR SVCALLPENDED [15..15]  ======================================== */
typedef enum {                                  /*!< S32_SCB_SHCSR_SVCALLPENDED                                                */
  S32_SCB_SHCSR_SVCALLPENDED_0         = 0,     /*!< 0 : exception is not pending                                              */
  S32_SCB_SHCSR_SVCALLPENDED_1         = 1,     /*!< 1 : exception is pending                                                  */
} S32_SCB_SHCSR_SVCALLPENDED_Enum;

/* =======================================================  SCB_DFSR  ======================================================== */
/* ============================================  S32_SCB SCB_DFSR HALTED [0..0]  ============================================= */
typedef enum {                                  /*!< S32_SCB_DFSR_HALTED                                                       */
  S32_SCB_DFSR_HALTED_0                = 0,     /*!< 0 : No active halt request debug event                                    */
  S32_SCB_DFSR_HALTED_1                = 1,     /*!< 1 : Halt request debug event active                                       */
} S32_SCB_DFSR_HALTED_Enum;

/* =============================================  S32_SCB SCB_DFSR BKPT [1..1]  ============================================== */
typedef enum {                                  /*!< S32_SCB_DFSR_BKPT                                                         */
  S32_SCB_DFSR_BKPT_0                  = 0,     /*!< 0 : No current breakpoint debug event                                     */
  S32_SCB_DFSR_BKPT_1                  = 1,     /*!< 1 : At least one current breakpoint debug event                           */
} S32_SCB_DFSR_BKPT_Enum;

/* ============================================  S32_SCB SCB_DFSR DWTTRAP [2..2]  ============================================ */
typedef enum {                                  /*!< S32_SCB_DFSR_DWTTRAP                                                      */
  S32_SCB_DFSR_DWTTRAP_0               = 0,     /*!< 0 : No current debug events generated by the DWT                          */
  S32_SCB_DFSR_DWTTRAP_1               = 1,     /*!< 1 : At least one current debug event generated by the DWT                 */
} S32_SCB_DFSR_DWTTRAP_Enum;

/* ============================================  S32_SCB SCB_DFSR VCATCH [3..3]  ============================================= */
typedef enum {                                  /*!< S32_SCB_DFSR_VCATCH                                                       */
  S32_SCB_DFSR_VCATCH_0                = 0,     /*!< 0 : No Vector catch triggered                                             */
  S32_SCB_DFSR_VCATCH_1                = 1,     /*!< 1 : Vector catch triggered                                                */
} S32_SCB_DFSR_VCATCH_Enum;

/* ===========================================  S32_SCB SCB_DFSR EXTERNAL [4..4]  ============================================ */
typedef enum {                                  /*!< S32_SCB_DFSR_EXTERNAL                                                     */
  S32_SCB_DFSR_EXTERNAL_0              = 0,     /*!< 0 : No EDBGRQ debug event                                                 */
  S32_SCB_DFSR_EXTERNAL_1              = 1,     /*!< 1 : EDBGRQ debug event                                                    */
} S32_SCB_DFSR_EXTERNAL_Enum;



/* =========================================================================================================================== */
/* ================                                        S32_SysTick                                        ================ */
/* =========================================================================================================================== */

/* =======================================================  SYST_CSR  ======================================================== */
/* ==========================================  S32_SysTick SYST_CSR ENABLE [0..0]  =========================================== */
typedef enum {                                  /*!< S32_SysTick_CSR_ENABLE                                                    */
  S32_SysTick_CSR_ENABLE_0             = 0,     /*!< 0 : counter disabled                                                      */
  S32_SysTick_CSR_ENABLE_1             = 1,     /*!< 1 : counter enabled                                                       */
} S32_SysTick_CSR_ENABLE_Enum;

/* ==========================================  S32_SysTick SYST_CSR TICKINT [1..1]  ========================================== */
typedef enum {                                  /*!< S32_SysTick_CSR_TICKINT                                                   */
  S32_SysTick_CSR_TICKINT_0            = 0,     /*!< 0 : counting down to 0 does not assert the SysTick exception
                                                     request                                                                   */
  S32_SysTick_CSR_TICKINT_1            = 1,     /*!< 1 : counting down to 0 asserts the SysTick exception request              */
} S32_SysTick_CSR_TICKINT_Enum;

/* =========================================  S32_SysTick SYST_CSR CLKSOURCE [2..2]  ========================================= */
typedef enum {                                  /*!< S32_SysTick_CSR_CLKSOURCE                                                 */
  S32_SysTick_CSR_CLKSOURCE_0          = 0,     /*!< 0 : external clock                                                        */
  S32_SysTick_CSR_CLKSOURCE_1          = 1,     /*!< 1 : processor clock                                                       */
} S32_SysTick_CSR_CLKSOURCE_Enum;

/* =======================================================  SYST_RVR  ======================================================== */
/* =======================================================  SYST_CVR  ======================================================== */
/* ======================================================  SYST_CALIB  ======================================================= */
/* =========================================  S32_SysTick SYST_CALIB SKEW [30..30]  ========================================== */
typedef enum {                                  /*!< S32_SysTick_CALIB_SKEW                                                    */
  S32_SysTick_CALIB_SKEW_0             = 0,     /*!< 0 : TENMS value is exact                                                  */
  S32_SysTick_CALIB_SKEW_1             = 1,     /*!< 1 : TENMS value is inexact, or not given                                  */
} S32_SysTick_CALIB_SKEW_Enum;

/* =========================================  S32_SysTick SYST_CALIB NOREF [31..31]  ========================================= */
typedef enum {                                  /*!< S32_SysTick_CALIB_NOREF                                                   */
  S32_SysTick_CALIB_NOREF_0            = 0,     /*!< 0 : The reference clock is provided                                       */
  S32_SysTick_CALIB_NOREF_1            = 1,     /*!< 1 : The reference clock is not provided                                   */
} S32_SysTick_CALIB_NOREF_Enum;



/* =========================================================================================================================== */
/* ================                                         S32_NVIC                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  S32_NVIC_ISER  ===================================================== */
/* =====================================================  S32_NVIC_ICER  ===================================================== */
/* =====================================================  S32_NVIC_ISPR  ===================================================== */
/* =====================================================  S32_NVIC_ICPR  ===================================================== */
/* =====================================================  S32_NVIC_IPR0  ===================================================== */
/* =====================================================  S32_NVIC_IPR1  ===================================================== */
/* =====================================================  S32_NVIC_IPR2  ===================================================== */
/* =====================================================  S32_NVIC_IPR3  ===================================================== */
/* =====================================================  S32_NVIC_IPR4  ===================================================== */
/* =====================================================  S32_NVIC_IPR5  ===================================================== */
/* =====================================================  S32_NVIC_IPR6  ===================================================== */
/* =====================================================  S32_NVIC_IPR7  ===================================================== */


/* =========================================================================================================================== */
/* ================                                           LMEM                                            ================ */
/* =========================================================================================================================== */

/* ====================================================  LMEM_LMEM_PCCCR  ==================================================== */
/* ==========================================  LMEM LMEM_LMEM_PCCCR ENCACHE [0..0]  ========================================== */
typedef enum {                                  /*!< LMEM_LMEM_PCCCR_ENCACHE                                                   */
  LMEM_LMEM_PCCCR_ENCACHE_0            = 0,     /*!< 0 : Cache disabled                                                        */
  LMEM_LMEM_PCCCR_ENCACHE_1            = 1,     /*!< 1 : Cache enabled                                                         */
} LMEM_LMEM_PCCCR_ENCACHE_Enum;

/* ==========================================  LMEM LMEM_LMEM_PCCCR INVW0 [24..24]  ========================================== */
typedef enum {                                  /*!< LMEM_LMEM_PCCCR_INVW0                                                     */
  LMEM_LMEM_PCCCR_INVW0_0              = 0,     /*!< 0 : No operation                                                          */
  LMEM_LMEM_PCCCR_INVW0_1              = 1,     /*!< 1 : When setting the GO bit, invalidate all lines in way 0.               */
} LMEM_LMEM_PCCCR_INVW0_Enum;

/* =========================================  LMEM LMEM_LMEM_PCCCR PUSHW0 [25..25]  ========================================== */
typedef enum {                                  /*!< LMEM_LMEM_PCCCR_PUSHW0                                                    */
  LMEM_LMEM_PCCCR_PUSHW0_0             = 0,     /*!< 0 : No operation                                                          */
  LMEM_LMEM_PCCCR_PUSHW0_1             = 1,     /*!< 1 : When setting the GO bit, push all modified lines in way
                                                     0                                                                         */
} LMEM_LMEM_PCCCR_PUSHW0_Enum;

/* ==========================================  LMEM LMEM_LMEM_PCCCR INVW1 [26..26]  ========================================== */
typedef enum {                                  /*!< LMEM_LMEM_PCCCR_INVW1                                                     */
  LMEM_LMEM_PCCCR_INVW1_0              = 0,     /*!< 0 : No operation                                                          */
  LMEM_LMEM_PCCCR_INVW1_1              = 1,     /*!< 1 : When setting the GO bit, invalidate all lines in way 1                */
} LMEM_LMEM_PCCCR_INVW1_Enum;

/* =========================================  LMEM LMEM_LMEM_PCCCR PUSHW1 [27..27]  ========================================== */
typedef enum {                                  /*!< LMEM_LMEM_PCCCR_PUSHW1                                                    */
  LMEM_LMEM_PCCCR_PUSHW1_0             = 0,     /*!< 0 : No operation                                                          */
  LMEM_LMEM_PCCCR_PUSHW1_1             = 1,     /*!< 1 : When setting the GO bit, push all modified lines in way
                                                     1                                                                         */
} LMEM_LMEM_PCCCR_PUSHW1_Enum;

/* ===========================================  LMEM LMEM_LMEM_PCCCR GO [31..31]  ============================================ */
typedef enum {                                  /*!< LMEM_LMEM_PCCCR_GO                                                        */
  LMEM_LMEM_PCCCR_GO_0                 = 0,     /*!< 0 : Write: no effect. Read: no cache command active.                      */
  LMEM_LMEM_PCCCR_GO_1                 = 1,     /*!< 1 : Write: initiate command indicated by bits 27-24. Read: cache
                                                     command active.                                                           */
} LMEM_LMEM_PCCCR_GO_Enum;

/* ===================================================  LMEM_LMEM_PCCLCR  ==================================================== */
/* ===========================================  LMEM LMEM_LMEM_PCCLCR LGO [0..0]  ============================================ */
typedef enum {                                  /*!< LMEM_LMEM_PCCLCR_LGO                                                      */
  LMEM_LMEM_PCCLCR_LGO_0               = 0,     /*!< 0 : Write: no effect. Read: no line command active.                       */
  LMEM_LMEM_PCCLCR_LGO_1               = 1,     /*!< 1 : Write: initiate line command indicated by bits 27-24. Read:
                                                     line command active.                                                      */
} LMEM_LMEM_PCCLCR_LGO_Enum;

/* ==========================================  LMEM LMEM_LMEM_PCCLCR WSEL [14..14]  ========================================== */
typedef enum {                                  /*!< LMEM_LMEM_PCCLCR_WSEL                                                     */
  LMEM_LMEM_PCCLCR_WSEL_0              = 0,     /*!< 0 : Way 0                                                                 */
  LMEM_LMEM_PCCLCR_WSEL_1              = 1,     /*!< 1 : Way 1                                                                 */
} LMEM_LMEM_PCCLCR_WSEL_Enum;

/* =========================================  LMEM LMEM_LMEM_PCCLCR TDSEL [16..16]  ========================================== */
typedef enum {                                  /*!< LMEM_LMEM_PCCLCR_TDSEL                                                    */
  LMEM_LMEM_PCCLCR_TDSEL_0             = 0,     /*!< 0 : Data                                                                  */
  LMEM_LMEM_PCCLCR_TDSEL_1             = 1,     /*!< 1 : Tag                                                                   */
} LMEM_LMEM_PCCLCR_TDSEL_Enum;

/* ==========================================  LMEM LMEM_LMEM_PCCLCR LCMD [24..25]  ========================================== */
typedef enum {                                  /*!< LMEM_LMEM_PCCLCR_LCMD                                                     */
  LMEM_LMEM_PCCLCR_LCMD_00             = 0,     /*!< 00 : Search and read or write                                             */
  LMEM_LMEM_PCCLCR_LCMD_01             = 1,     /*!< 01 : Invalidate                                                           */
  LMEM_LMEM_PCCLCR_LCMD_10             = 2,     /*!< 10 : Push                                                                 */
  LMEM_LMEM_PCCLCR_LCMD_11             = 3,     /*!< 11 : Clear                                                                */
} LMEM_LMEM_PCCLCR_LCMD_Enum;

/* =========================================  LMEM LMEM_LMEM_PCCLCR LADSEL [26..26]  ========================================= */
typedef enum {                                  /*!< LMEM_LMEM_PCCLCR_LADSEL                                                   */
  LMEM_LMEM_PCCLCR_LADSEL_0            = 0,     /*!< 0 : Cache address                                                         */
  LMEM_LMEM_PCCLCR_LADSEL_1            = 1,     /*!< 1 : Physical address                                                      */
} LMEM_LMEM_PCCLCR_LADSEL_Enum;

/* ==========================================  LMEM LMEM_LMEM_PCCLCR LACC [27..27]  ========================================== */
typedef enum {                                  /*!< LMEM_LMEM_PCCLCR_LACC                                                     */
  LMEM_LMEM_PCCLCR_LACC_0              = 0,     /*!< 0 : Read                                                                  */
  LMEM_LMEM_PCCLCR_LACC_1              = 1,     /*!< 1 : Write                                                                 */
} LMEM_LMEM_PCCLCR_LACC_Enum;

/* ===================================================  LMEM_LMEM_PCCSAR  ==================================================== */
/* ===========================================  LMEM LMEM_LMEM_PCCSAR LGO [0..0]  ============================================ */
typedef enum {                                  /*!< LMEM_LMEM_PCCSAR_LGO                                                      */
  LMEM_LMEM_PCCSAR_LGO_0               = 0,     /*!< 0 : Write: no effect. Read: no line command active.                       */
  LMEM_LMEM_PCCSAR_LGO_1               = 1,     /*!< 1 : Write: initiate line command indicated by bits CLCR[27:24].
                                                     Read: line command active.                                                */
} LMEM_LMEM_PCCSAR_LGO_Enum;

/* ===================================================  LMEM_LMEM_PCCCVR  ==================================================== */
/* ======================================================  LMEM_PCCRMR  ====================================================== */
/* ==============================================  LMEM LMEM_PCCRMR R15 [0..1]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R15                                                           */
  LMEM_PCCRMR_R15_00                   = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R15_01                   = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R15_10                   = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R15_11                   = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R15_Enum;

/* ==============================================  LMEM LMEM_PCCRMR R14 [2..3]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R14                                                           */
  LMEM_PCCRMR_R14_00                   = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R14_01                   = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R14_10                   = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R14_11                   = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R14_Enum;

/* ==============================================  LMEM LMEM_PCCRMR R13 [4..5]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R13                                                           */
  LMEM_PCCRMR_R13_00                   = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R13_01                   = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R13_10                   = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R13_11                   = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R13_Enum;

/* ==============================================  LMEM LMEM_PCCRMR R12 [6..7]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R12                                                           */
  LMEM_PCCRMR_R12_00                   = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R12_01                   = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R12_10                   = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R12_11                   = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R12_Enum;

/* ==============================================  LMEM LMEM_PCCRMR R11 [8..9]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R11                                                           */
  LMEM_PCCRMR_R11_00                   = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R11_01                   = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R11_10                   = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R11_11                   = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R11_Enum;

/* =============================================  LMEM LMEM_PCCRMR R10 [10..11]  ============================================= */
typedef enum {                                  /*!< LMEM_PCCRMR_R10                                                           */
  LMEM_PCCRMR_R10_00                   = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R10_01                   = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R10_10                   = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R10_11                   = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R10_Enum;

/* =============================================  LMEM LMEM_PCCRMR R9 [12..13]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R9                                                            */
  LMEM_PCCRMR_R9_00                    = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R9_01                    = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R9_10                    = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R9_11                    = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R9_Enum;

/* =============================================  LMEM LMEM_PCCRMR R8 [14..15]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R8                                                            */
  LMEM_PCCRMR_R8_00                    = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R8_01                    = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R8_10                    = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R8_11                    = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R8_Enum;

/* =============================================  LMEM LMEM_PCCRMR R7 [16..17]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R7                                                            */
  LMEM_PCCRMR_R7_00                    = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R7_01                    = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R7_10                    = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R7_11                    = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R7_Enum;

/* =============================================  LMEM LMEM_PCCRMR R6 [18..19]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R6                                                            */
  LMEM_PCCRMR_R6_00                    = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R6_01                    = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R6_10                    = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R6_11                    = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R6_Enum;

/* =============================================  LMEM LMEM_PCCRMR R5 [20..21]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R5                                                            */
  LMEM_PCCRMR_R5_00                    = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R5_01                    = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R5_10                    = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R5_11                    = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R5_Enum;

/* =============================================  LMEM LMEM_PCCRMR R4 [22..23]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R4                                                            */
  LMEM_PCCRMR_R4_00                    = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R4_01                    = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R4_10                    = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R4_11                    = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R4_Enum;

/* =============================================  LMEM LMEM_PCCRMR R3 [24..25]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R3                                                            */
  LMEM_PCCRMR_R3_00                    = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R3_01                    = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R3_10                    = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R3_11                    = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R3_Enum;

/* =============================================  LMEM LMEM_PCCRMR R2 [26..27]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R2                                                            */
  LMEM_PCCRMR_R2_00                    = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R2_01                    = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R2_10                    = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R2_11                    = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R2_Enum;

/* =============================================  LMEM LMEM_PCCRMR R1 [28..29]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R1                                                            */
  LMEM_PCCRMR_R1_00                    = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R1_01                    = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R1_10                    = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R1_11                    = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R1_Enum;

/* =============================================  LMEM LMEM_PCCRMR R0 [30..31]  ============================================== */
typedef enum {                                  /*!< LMEM_PCCRMR_R0                                                            */
  LMEM_PCCRMR_R0_00                    = 0,     /*!< 00 : Non-cacheable                                                        */
  LMEM_PCCRMR_R0_01                    = 1,     /*!< 01 : Non-cacheable                                                        */
  LMEM_PCCRMR_R0_10                    = 2,     /*!< 10 : Write-through                                                        */
  LMEM_PCCRMR_R0_11                    = 3,     /*!< 11 : Write-back                                                           */
} LMEM_PCCRMR_R0_Enum;



/* =========================================================================================================================== */
/* ================                                          MTB_DWT                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  MTB_DWT_CTRL  ====================================================== */
/* =====================================================  MTB_DWT_COMP0  ===================================================== */
/* =====================================================  MTB_DWT_COMP1  ===================================================== */
/* =====================================================  MTB_DWT_MASK0  ===================================================== */
/* =====================================================  MTB_DWT_MASK1  ===================================================== */
/* =====================================================  MTB_DWT_FCT0  ====================================================== */
/* =========================================  MTB_DWT MTB_DWT_FCT0 FUNCTION [0..3]  ========================================== */
typedef enum {                                  /*!< MTB_DWT_FCT0_FUNCTION                                                     */
  MTB_DWT_FCT0_FUNCTION_0000           = 0,     /*!< 0000 : Disabled.                                                          */
  MTB_DWT_FCT0_FUNCTION_0100           = 4,     /*!< 0100 : Instruction fetch.                                                 */
  MTB_DWT_FCT0_FUNCTION_0101           = 5,     /*!< 0101 : Data operand read.                                                 */
  MTB_DWT_FCT0_FUNCTION_0110           = 6,     /*!< 0110 : Data operand write.                                                */
  MTB_DWT_FCT0_FUNCTION_0111           = 7,     /*!< 0111 : Data operand (read + write).                                       */
} MTB_DWT_FCT0_FUNCTION_Enum;

/* ========================================  MTB_DWT MTB_DWT_FCT0 DATAVMATCH [8..8]  ========================================= */
typedef enum {                                  /*!< MTB_DWT_FCT0_DATAVMATCH                                                   */
  MTB_DWT_FCT0_DATAVMATCH_0            = 0,     /*!< 0 : Perform address comparison.                                           */
  MTB_DWT_FCT0_DATAVMATCH_1            = 1,     /*!< 1 : Perform data value comparison.                                        */
} MTB_DWT_FCT0_DATAVMATCH_Enum;

/* ========================================  MTB_DWT MTB_DWT_FCT0 DATAVSIZE [10..11]  ======================================== */
typedef enum {                                  /*!< MTB_DWT_FCT0_DATAVSIZE                                                    */
  MTB_DWT_FCT0_DATAVSIZE_00            = 0,     /*!< 00 : Byte.                                                                */
  MTB_DWT_FCT0_DATAVSIZE_01            = 1,     /*!< 01 : Halfword.                                                            */
  MTB_DWT_FCT0_DATAVSIZE_10            = 2,     /*!< 10 : Word.                                                                */
  MTB_DWT_FCT0_DATAVSIZE_11            = 3,     /*!< 11 : Reserved. Any attempts to use this value results in UNPREDICTABLE
                                                     behavior.                                                                 */
} MTB_DWT_FCT0_DATAVSIZE_Enum;

/* =========================================  MTB_DWT MTB_DWT_FCT0 MATCHED [24..24]  ========================================= */
typedef enum {                                  /*!< MTB_DWT_FCT0_MATCHED                                                      */
  MTB_DWT_FCT0_MATCHED_0               = 0,     /*!< 0 : No match.                                                             */
  MTB_DWT_FCT0_MATCHED_1               = 1,     /*!< 1 : Match occurred.                                                       */
} MTB_DWT_FCT0_MATCHED_Enum;

/* =====================================================  MTB_DWT_FCT1  ====================================================== */
/* =========================================  MTB_DWT MTB_DWT_FCT1 FUNCTION [0..3]  ========================================== */
typedef enum {                                  /*!< MTB_DWT_FCT1_FUNCTION                                                     */
  MTB_DWT_FCT1_FUNCTION_0000           = 0,     /*!< 0000 : Disabled.                                                          */
  MTB_DWT_FCT1_FUNCTION_0100           = 4,     /*!< 0100 : Instruction fetch.                                                 */
  MTB_DWT_FCT1_FUNCTION_0101           = 5,     /*!< 0101 : Data operand read.                                                 */
  MTB_DWT_FCT1_FUNCTION_0110           = 6,     /*!< 0110 : Data operand write.                                                */
  MTB_DWT_FCT1_FUNCTION_0111           = 7,     /*!< 0111 : Data operand (read + write).                                       */
} MTB_DWT_FCT1_FUNCTION_Enum;

/* =========================================  MTB_DWT MTB_DWT_FCT1 MATCHED [24..24]  ========================================= */
typedef enum {                                  /*!< MTB_DWT_FCT1_MATCHED                                                      */
  MTB_DWT_FCT1_MATCHED_0               = 0,     /*!< 0 : No match.                                                             */
  MTB_DWT_FCT1_MATCHED_1               = 1,     /*!< 1 : Match occurred.                                                       */
} MTB_DWT_FCT1_MATCHED_Enum;

/* ====================================================  MTB_DWT_TBCTRL  ===================================================== */
/* =========================================  MTB_DWT MTB_DWT_TBCTRL ACOMP0 [0..0]  ========================================== */
typedef enum {                                  /*!< MTB_DWT_TBCTRL_ACOMP0                                                     */
  MTB_DWT_TBCTRL_ACOMP0_0              = 0,     /*!< 0 : Trigger TSTOP based on the assertion of MTBDWT_FCT0[MATCHED].         */
  MTB_DWT_TBCTRL_ACOMP0_1              = 1,     /*!< 1 : Trigger TSTART based on the assertion of MTBDWT_FCT0[MATCHED].        */
} MTB_DWT_TBCTRL_ACOMP0_Enum;

/* =========================================  MTB_DWT MTB_DWT_TBCTRL ACOMP1 [1..1]  ========================================== */
typedef enum {                                  /*!< MTB_DWT_TBCTRL_ACOMP1                                                     */
  MTB_DWT_TBCTRL_ACOMP1_0              = 0,     /*!< 0 : Trigger TSTOP based on the assertion of MTBDWT_FCT1[MATCHED].         */
  MTB_DWT_TBCTRL_ACOMP1_1              = 1,     /*!< 1 : Trigger TSTART based on the assertion of MTBDWT_FCT1[MATCHED].        */
} MTB_DWT_TBCTRL_ACOMP1_Enum;

/* ===================================================  MTB_DWT_DEVICECFG  =================================================== */
/* ==================================================  MTB_DWT_DEVICETYPID  ================================================== */
/* ===================================================  MTB_DWT_PERIPHID4  =================================================== */
/* ===================================================  MTB_DWT_PERIPHID5  =================================================== */
/* ===================================================  MTB_DWT_PERIPHID6  =================================================== */
/* ===================================================  MTB_DWT_PERIPHID7  =================================================== */
/* ===================================================  MTB_DWT_PERIPHID0  =================================================== */
/* ===================================================  MTB_DWT_PERIPHID1  =================================================== */
/* ===================================================  MTB_DWT_PERIPHID2  =================================================== */
/* ===================================================  MTB_DWT_PERIPHID3  =================================================== */
/* ====================================================  MTB_DWT_COMPID0  ==================================================== */
/* ====================================================  MTB_DWT_COMPID1  ==================================================== */
/* ====================================================  MTB_DWT_COMPID2  ==================================================== */
/* ====================================================  MTB_DWT_COMPID3  ==================================================== */


/* =========================================================================================================================== */
/* ================                                            MCM                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  MCM_PLASC  ======================================================= */
/* ===============================================  MCM MCM_PLASC ASC [0..7]  ================================================ */
typedef enum {                                  /*!< MCM_PLASC_ASC                                                             */
  MCM_PLASC_ASC_0                      = 0,     /*!< 0 : A bus slave connection to AXBS input port n is absent                 */
  MCM_PLASC_ASC_1                      = 1,     /*!< 1 : A bus slave connection to AXBS input port n is present                */
} MCM_PLASC_ASC_Enum;

/* =======================================================  MCM_PLAMC  ======================================================= */
/* ===============================================  MCM MCM_PLAMC AMC [0..7]  ================================================ */
typedef enum {                                  /*!< MCM_PLAMC_AMC                                                             */
  MCM_PLAMC_AMC_0                      = 0,     /*!< 0 : A bus master connection to AXBS input port n is absent                */
  MCM_PLAMC_AMC_1                      = 1,     /*!< 1 : A bus master connection to AXBS input port n is present               */
} MCM_PLAMC_AMC_Enum;

/* =======================================================  MCM_CPCR  ======================================================== */
/* ============================================  MCM MCM_CPCR HLT_FSM_ST [0..1]  ============================================= */
typedef enum {                                  /*!< MCM_CPCR_HLT_FSM_ST                                                       */
  MCM_CPCR_HLT_FSM_ST_00               = 0,     /*!< 00 : Waiting for request                                                  */
  MCM_CPCR_HLT_FSM_ST_01               = 1,     /*!< 01 : Waiting for platform idle                                            */
  MCM_CPCR_HLT_FSM_ST_11               = 3,     /*!< 11 : Platform stalled                                                     */
  MCM_CPCR_HLT_FSM_ST_10               = 2,     /*!< 10 : Unused state                                                         */
} MCM_CPCR_HLT_FSM_ST_Enum;

/* ===========================================  MCM MCM_CPCR AXBS_HLT_REQ [2..2]  ============================================ */
typedef enum {                                  /*!< MCM_CPCR_AXBS_HLT_REQ                                                     */
  MCM_CPCR_AXBS_HLT_REQ_0              = 0,     /*!< 0 : AXBS is not receiving halt request                                    */
  MCM_CPCR_AXBS_HLT_REQ_1              = 1,     /*!< 1 : AXBS is receiving halt request                                        */
} MCM_CPCR_AXBS_HLT_REQ_Enum;

/* =============================================  MCM MCM_CPCR AXBS_HLTD [3..3]  ============================================= */
typedef enum {                                  /*!< MCM_CPCR_AXBS_HLTD                                                        */
  MCM_CPCR_AXBS_HLTD_0                 = 0,     /*!< 0 : AXBS is not currently halted                                          */
  MCM_CPCR_AXBS_HLTD_1                 = 1,     /*!< 1 : AXBS is currently halted                                              */
} MCM_CPCR_AXBS_HLTD_Enum;

/* ============================================  MCM MCM_CPCR FMC_PF_IDLE [4..4]  ============================================ */
typedef enum {                                  /*!< MCM_CPCR_FMC_PF_IDLE                                                      */
  MCM_CPCR_FMC_PF_IDLE_0               = 0,     /*!< 0 : FMC program flash is not idle                                         */
  MCM_CPCR_FMC_PF_IDLE_1               = 1,     /*!< 1 : FMC program flash is currently idle                                   */
} MCM_CPCR_FMC_PF_IDLE_Enum;

/* ===========================================  MCM MCM_CPCR PBRIDGE_IDLE [6..6]  ============================================ */
typedef enum {                                  /*!< MCM_CPCR_PBRIDGE_IDLE                                                     */
  MCM_CPCR_PBRIDGE_IDLE_0              = 0,     /*!< 0 : PBRIDGE is not idle                                                   */
  MCM_CPCR_PBRIDGE_IDLE_1              = 1,     /*!< 1 : PBRIDGE is currently idle                                             */
} MCM_CPCR_PBRIDGE_IDLE_Enum;

/* ===============================================  MCM MCM_CPCR CBRR [9..9]  ================================================ */
typedef enum {                                  /*!< MCM_CPCR_CBRR                                                             */
  MCM_CPCR_CBRR_0                      = 0,     /*!< 0 : Fixed-priority arbitration                                            */
  MCM_CPCR_CBRR_1                      = 1,     /*!< 1 : Round-robin arbitration                                               */
} MCM_CPCR_CBRR_Enum;

/* ========================================================  MCM_PID  ======================================================== */
/* ========================================================  MCM_CPO  ======================================================== */
/* ===============================================  MCM MCM_CPO CPOREQ [0..0]  =============================================== */
typedef enum {                                  /*!< MCM_CPO_CPOREQ                                                            */
  MCM_CPO_CPOREQ_0                     = 0,     /*!< 0 : Request is cleared.                                                   */
  MCM_CPO_CPOREQ_1                     = 1,     /*!< 1 : Request Compute Operation.                                            */
} MCM_CPO_CPOREQ_Enum;

/* ===============================================  MCM MCM_CPO CPOACK [1..1]  =============================================== */
typedef enum {                                  /*!< MCM_CPO_CPOACK                                                            */
  MCM_CPO_CPOACK_0                     = 0,     /*!< 0 : Compute operation entry has not completed or compute operation
                                                     exit has completed.                                                       */
  MCM_CPO_CPOACK_1                     = 1,     /*!< 1 : Compute operation entry has completed or compute operation
                                                     exit has not completed.                                                   */
} MCM_CPO_CPOACK_Enum;

/* ===============================================  MCM MCM_CPO CPOWOI [2..2]  =============================================== */
typedef enum {                                  /*!< MCM_CPO_CPOWOI                                                            */
  MCM_CPO_CPOWOI_0                     = 0,     /*!< 0 : No effect.                                                            */
  MCM_CPO_CPOWOI_1                     = 1,     /*!< 1 : When set, the CPOREQ is cleared on any interrupt or exception
                                                     vector fetch.                                                             */
} MCM_CPO_CPOWOI_Enum;

/* =======================================================  MCM_LMDR0  ======================================================= */
/* ===============================================  MCM MCM_LMDR0 MT [13..15]  =============================================== */
typedef enum {                                  /*!< MCM_LMDR0_MT                                                              */
  MCM_LMDR0_MT_000                     = 0,     /*!< 000 : SRAM_L                                                              */
  MCM_LMDR0_MT_001                     = 1,     /*!< 001 : SRAM_U                                                              */
} MCM_LMDR0_MT_Enum;

/* ==============================================  MCM MCM_LMDR0 DPW [17..19]  =============================================== */
typedef enum {                                  /*!< MCM_LMDR0_DPW                                                             */
  MCM_LMDR0_DPW_010                    = 2,     /*!< 010 : LMEMn 32-bits wide                                                  */
  MCM_LMDR0_DPW_011                    = 3,     /*!< 011 : LMEMn 64-bits wide                                                  */
} MCM_LMDR0_DPW_Enum;

/* ===============================================  MCM MCM_LMDR0 WY [20..23]  =============================================== */
typedef enum {                                  /*!< MCM_LMDR0_WY                                                              */
  MCM_LMDR0_WY_0000                    = 0,     /*!< 0000 : No Cache                                                           */
  MCM_LMDR0_WY_0010                    = 2,     /*!< 0010 : 2-Way Set Associative                                              */
  MCM_LMDR0_WY_0100                    = 4,     /*!< 0100 : 4-Way Set Associative                                              */
} MCM_LMDR0_WY_Enum;

/* ==============================================  MCM MCM_LMDR0 LMSZ [24..27]  ============================================== */
typedef enum {                                  /*!< MCM_LMDR0_LMSZ                                                            */
  MCM_LMDR0_LMSZ_0000                  = 0,     /*!< 0000 : no LMEMn (0 KB)                                                    */
  MCM_LMDR0_LMSZ_0001                  = 1,     /*!< 0001 : 1 KB LMEMn                                                         */
  MCM_LMDR0_LMSZ_0010                  = 2,     /*!< 0010 : 2 KB LMEMn                                                         */
  MCM_LMDR0_LMSZ_0011                  = 3,     /*!< 0011 : 4 KB LMEMn                                                         */
  MCM_LMDR0_LMSZ_0100                  = 4,     /*!< 0100 : 8 KB LMEMn                                                         */
  MCM_LMDR0_LMSZ_0101                  = 5,     /*!< 0101 : 16 KB LMEMn                                                        */
  MCM_LMDR0_LMSZ_0110                  = 6,     /*!< 0110 : 32 KB LMEMn                                                        */
  MCM_LMDR0_LMSZ_0111                  = 7,     /*!< 0111 : 64 KB LMEMn                                                        */
  MCM_LMDR0_LMSZ_1000                  = 8,     /*!< 1000 : 128 KB LMEMn                                                       */
  MCM_LMDR0_LMSZ_1001                  = 9,     /*!< 1001 : 256 KB LMEMn                                                       */
  MCM_LMDR0_LMSZ_1010                  = 10,    /*!< 1010 : 512 KB LMEMn                                                       */
  MCM_LMDR0_LMSZ_1011                  = 11,    /*!< 1011 : 1024 KB LMEMn                                                      */
  MCM_LMDR0_LMSZ_1100                  = 12,    /*!< 1100 : 2048 KB LMEMn                                                      */
  MCM_LMDR0_LMSZ_1101                  = 13,    /*!< 1101 : 4096 KB LMEMn                                                      */
  MCM_LMDR0_LMSZ_1110                  = 14,    /*!< 1110 : 8192 KB LMEMn                                                      */
  MCM_LMDR0_LMSZ_1111                  = 15,    /*!< 1111 : 16384 KB LMEMn                                                     */
} MCM_LMDR0_LMSZ_Enum;

/* =============================================  MCM MCM_LMDR0 LMSZH [28..28]  ============================================== */
typedef enum {                                  /*!< MCM_LMDR0_LMSZH                                                           */
  MCM_LMDR0_LMSZH_0                    = 0,     /*!< 0 : LMEMn is a power-of-2 capacity.                                       */
  MCM_LMDR0_LMSZH_1                    = 1,     /*!< 1 : LMEMn is not a power-of-2, with a capacity is 0.75 * LMSZ.            */
} MCM_LMDR0_LMSZH_Enum;

/* ===============================================  MCM MCM_LMDR0 V [31..31]  ================================================ */
typedef enum {                                  /*!< MCM_LMDR0_V                                                               */
  MCM_LMDR0_V_0                        = 0,     /*!< 0 : LMEMn is not present.                                                 */
  MCM_LMDR0_V_1                        = 1,     /*!< 1 : LMEMn is present.                                                     */
} MCM_LMDR0_V_Enum;

/* =======================================================  MCM_LMDR1  ======================================================= */
/* ===============================================  MCM MCM_LMDR1 MT [13..15]  =============================================== */
typedef enum {                                  /*!< MCM_LMDR1_MT                                                              */
  MCM_LMDR1_MT_000                     = 0,     /*!< 000 : SRAM_L                                                              */
  MCM_LMDR1_MT_001                     = 1,     /*!< 001 : SRAM_U                                                              */
} MCM_LMDR1_MT_Enum;

/* ==============================================  MCM MCM_LMDR1 DPW [17..19]  =============================================== */
typedef enum {                                  /*!< MCM_LMDR1_DPW                                                             */
  MCM_LMDR1_DPW_010                    = 2,     /*!< 010 : LMEMn 32-bits wide                                                  */
  MCM_LMDR1_DPW_011                    = 3,     /*!< 011 : LMEMn 64-bits wide                                                  */
} MCM_LMDR1_DPW_Enum;

/* ===============================================  MCM MCM_LMDR1 WY [20..23]  =============================================== */
typedef enum {                                  /*!< MCM_LMDR1_WY                                                              */
  MCM_LMDR1_WY_0000                    = 0,     /*!< 0000 : No Cache                                                           */
  MCM_LMDR1_WY_0010                    = 2,     /*!< 0010 : 2-Way Set Associative                                              */
  MCM_LMDR1_WY_0100                    = 4,     /*!< 0100 : 4-Way Set Associative                                              */
} MCM_LMDR1_WY_Enum;

/* ==============================================  MCM MCM_LMDR1 LMSZ [24..27]  ============================================== */
typedef enum {                                  /*!< MCM_LMDR1_LMSZ                                                            */
  MCM_LMDR1_LMSZ_0000                  = 0,     /*!< 0000 : no LMEMn (0 KB)                                                    */
  MCM_LMDR1_LMSZ_0001                  = 1,     /*!< 0001 : 1 KB LMEMn                                                         */
  MCM_LMDR1_LMSZ_0010                  = 2,     /*!< 0010 : 2 KB LMEMn                                                         */
  MCM_LMDR1_LMSZ_0011                  = 3,     /*!< 0011 : 4 KB LMEMn                                                         */
  MCM_LMDR1_LMSZ_0100                  = 4,     /*!< 0100 : 8 KB LMEMn                                                         */
  MCM_LMDR1_LMSZ_0101                  = 5,     /*!< 0101 : 16 KB LMEMn                                                        */
  MCM_LMDR1_LMSZ_0110                  = 6,     /*!< 0110 : 32 KB LMEMn                                                        */
  MCM_LMDR1_LMSZ_0111                  = 7,     /*!< 0111 : 64 KB LMEMn                                                        */
  MCM_LMDR1_LMSZ_1000                  = 8,     /*!< 1000 : 128 KB LMEMn                                                       */
  MCM_LMDR1_LMSZ_1001                  = 9,     /*!< 1001 : 256 KB LMEMn                                                       */
  MCM_LMDR1_LMSZ_1010                  = 10,    /*!< 1010 : 512 KB LMEMn                                                       */
  MCM_LMDR1_LMSZ_1011                  = 11,    /*!< 1011 : 1024 KB LMEMn                                                      */
  MCM_LMDR1_LMSZ_1100                  = 12,    /*!< 1100 : 2048 KB LMEMn                                                      */
  MCM_LMDR1_LMSZ_1101                  = 13,    /*!< 1101 : 4096 KB LMEMn                                                      */
  MCM_LMDR1_LMSZ_1110                  = 14,    /*!< 1110 : 8192 KB LMEMn                                                      */
  MCM_LMDR1_LMSZ_1111                  = 15,    /*!< 1111 : 16384 KB LMEMn                                                     */
} MCM_LMDR1_LMSZ_Enum;

/* =============================================  MCM MCM_LMDR1 LMSZH [28..28]  ============================================== */
typedef enum {                                  /*!< MCM_LMDR1_LMSZH                                                           */
  MCM_LMDR1_LMSZH_0                    = 0,     /*!< 0 : LMEMn is a power-of-2 capacity.                                       */
  MCM_LMDR1_LMSZH_1                    = 1,     /*!< 1 : LMEMn is not a power-of-2, with a capacity is 0.75 * LMSZ.            */
} MCM_LMDR1_LMSZH_Enum;

/* ===============================================  MCM MCM_LMDR1 V [31..31]  ================================================ */
typedef enum {                                  /*!< MCM_LMDR1_V                                                               */
  MCM_LMDR1_V_0                        = 0,     /*!< 0 : LMEMn is not present.                                                 */
  MCM_LMDR1_V_1                        = 1,     /*!< 1 : LMEMn is present.                                                     */
} MCM_LMDR1_V_Enum;

/* ======================================================  MCM_LMPECR  ======================================================= */
/* ======================================================  MCM_LMPEIR  ======================================================= */
/* ============================================  MCM MCM_LMPEIR PEELOC [24..28]  ============================================= */
typedef enum {                                  /*!< MCM_LMPEIR_PEELOC                                                         */
  MCM_LMPEIR_PEELOC_00                 = 0,     /*!< 00 : Non-correctable ECC event from SRAM_L                                */
  MCM_LMPEIR_PEELOC_01                 = 1,     /*!< 01 : Non-correctable ECC event from SRAM_U                                */
} MCM_LMPEIR_PEELOC_Enum;

/* =======================================================  MCM_LMFAR  ======================================================= */
/* ======================================================  MCM_LMFATR  ======================================================= */
/* =============================================  MCM MCM_LMFATR PEFSIZE [4..6]  ============================================= */
typedef enum {                                  /*!< MCM_LMFATR_PEFSIZE                                                        */
  MCM_LMFATR_PEFSIZE_000               = 0,     /*!< 000 : 8-bit access                                                        */
  MCM_LMFATR_PEFSIZE_001               = 1,     /*!< 001 : 16-bit access                                                       */
  MCM_LMFATR_PEFSIZE_010               = 2,     /*!< 010 : 32-bit access                                                       */
  MCM_LMFATR_PEFSIZE_011               = 3,     /*!< 011 : 64-bit access                                                       */
} MCM_LMFATR_PEFSIZE_Enum;

/* ======================================================  MCM_LMFDHR  ======================================================= */
/* ======================================================  MCM_LMFDLR  ======================================================= */

/** @} */ /* End of group EnumValue_peripherals */


#ifdef __cplusplus
}
#endif

#endif /* S32K116_H */


/** @} */ /* End of group S32K116 */

/** @} */ /* End of group NXP */
